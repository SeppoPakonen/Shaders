{"ver": "0.1", "info": {"id": "tdtSDn", "date": "1571809620", "viewed": 159, "name": "OctreeTreeRayCasting", "username": "JohnShadow", "description": "A method to ray cast octrees, basically a limit sum.", "likes": 1, "published": 1, "flags": 0, "tags": ["octree"], "requires": ["imagebuf"]}, "renderpass": [{"inputs": [], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "struct Ray\n{\n\tvec3 o, d;\n};\nstruct AABB\n{\n\tvec3 max, min;\n};\nstruct RayHit\n{\n    float dist;\n    vec3 norm;\n    vec3 color;\n};\nAABB worldbox = AABB(vec3(-1.0, -1.0, -1.0), vec3(1.0, 1.0, 1.0));\nfloat depth = 10.0; // this will be 2^(n + 1)\nfloat rayAABB(Ray ray, AABB aabb, float tmin, float tmax) {\n    vec3 invD = 1.0/ray.d;\n\tvec3 t0s = (aabb.min - ray.o) * invD;\n  \tvec3 t1s = (aabb.max - ray.o) * invD;\n    \n  \tvec3 tsmaller = min(t0s, t1s);\n\tvec3 tbigger  = max(t0s, t1s);\n\n\ttmin = max(tmin, max(tsmaller[0], max(tsmaller[1], tsmaller[2])));\n\ttmax = min(tmax, min(tbigger[0], min(tbigger[1], tbigger[2])));\n\treturn (tmin < tmax) ? tmin : 0.0;\n}\nbool inradius(vec3 x)\n{\n    float n = depth; //max(abs(sin(iTime * 1./depth)) * depth, 3.0);\n    if(dot(x, x) < 1.0)\n        return true;\n    return false;\n}\nvec3 raycast(vec3 pos, vec3 dir)\n{\n\tfloat np = pow(2.0, depth);\n\tpos *= np;\n    float inp = pow(2.0, -depth);\n\tfor(float i = 0.0; i < np; ++i)\n\t{\n\t\tvec3 aprox = (pos + dir * 3.46410161514 * i);\n        aprox = ceil(aprox) * inp;;\n\t\tif(inradius(aprox))\n\t\t\treturn aprox;\n\t}\n\treturn vec3(0.0);\n}\nRayHit march(Ray ray)\n{\n\tfloat dist = rayAABB(ray, worldbox, 0.0, 1e20);\n\t//if(dist == 0.0)\n\t//\treturn RayHit(0.0, vec3(0), vec3(0));\n\tvec3 start = (ray.o) + ray.d * (floor(dist));\n\tvec3 pos = raycast(start, ray.d);\n\treturn RayHit(dist = length(pos), normalize(pos), vec3(1.0,1.0,1.0));\n}\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 viewDir = rayDirection(60.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(4.0*sin(iTime), 2.0 * cos(iTime), cos(iTime)*4.0);\n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    vec3 normal, color;\n    \n    // Time varying pixel color\n    Ray ray = Ray(eye, worldDir);\n    RayHit hit = march(ray);\n    float ldot = max(dot(hit.norm, vec3(0.70710, 0, 0.70710)), 0.3);\n    if(hit.dist != 0.0)\n        color = hit.color * ldot * hit.norm;\n\t\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "name": "Image", "description": "", "type": "image"}]}