{"ver":"0.1","info":{"id":"llcfDM","date":"1541261288","viewed":222,"name":"Sonic 3D","username":"shau","description":"Sonic","likes":12,"published":1,"flags":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define R iResolution.xy\n#define EPS .001\n#define FAR 15.\n#define T iTime\n#define PI 3.141592\n\n#define BLUE 1.\n#define EYE 2.\n#define SKIN 3.\n#define BLACK 4.\n#define RED 5.\n#define WHITE 6.\n#define GOLD 7.\n#define FLOOR 8.\n#define MOUTH 9.\n\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\n//distance functions from IQ\n//http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;    \n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xy) - t.x, p.z);\n    return length(q) - t.y;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa, ba) / dot(ba, ba), 0., 1.);\n    return length(pa - ba * h) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\n\nfloat sdEllipsoid(vec3 p, vec3 r) {\n    return (length(p / r) - 1.) * min(min(r.x, r.y), r.z);\n}\n\nfloat sdRoundCone(vec3 p, float r1, float r2, float h){\n    \n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdConeSection(vec3 p, float h, float r1, float r2) {\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5 * (r1 - r2) / h;\n    float d2 = max(sqrt(dot(p.xz, p.xz) * (1.0 - si * si)) + q * si - r2, q);\n    return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) {\n\tfloat h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n\treturn mix(a, b, h) + k * h * (1.0 - h);\n}\n\nvec2 nearest(vec2 a, vec2 b) {\n    return mix(a, b, step(b.x, a.x));    \n}\n\n//A useful little function from IQ\n//http://www.iquilezles.org/www/articles/functions/functions.htm\nfloat almostIdentity(float x, float m, float n) {\n    if (x > m) return x;\n    float a = 2.0 * n - m;\n    float b = 2.0 * m - 3.0 * n;\n    float t = x / m;\n    return (a * t + b) * t * t + n;\n}\n\n//model\n\nvec2 dfHead(vec3 p) {\n \n    p.xz *= rot(0.7);\n    p.yz *= rot(-0.2);\n    \n    vec3 q = p;\n    \n    //mouth\n    float skin = sdEllipsoid(p - vec3(0., -0.4, 0.4), vec3(0.62, 0.58, 0.58));\n    skin = smax(skin, -sdCapsule(p - vec3(0., 0.16 , 0.), \n                                       vec3(-1., 0.14, 0.82), \n                                       vec3(1., 0.14, 0.82), 0.87), 0.1);\n    q.y -= q.x * q.x * 0.8;\n    skin = max(skin, -sdBox(q - vec3(-0.06, -0.8, 0.), vec3(0.24, 0.028, 1.0))); \n    skin = max(skin, -sdCapsule(p - vec3(-0.24, -0.76, 0.), vec3(0., 0., 0.6), vec3(0., 0., 0.9), 0.04));\n    \n    //float mouth = max(skin, sdBox(q - vec3(-0.06, -0.8, 0.), vec3(0.24, 0.015, 1.0))); \n    float mouth = max(sdEllipsoid(p - vec3(0., -0.4, 0.4), vec3(0.61, 0.57, 0.57)),\n                      sdBox(q - vec3(-0.06, -0.8, 0.), vec3(0.24, 0.018, 1.0)));\n    //head and spikes\n    float head = sdSphere(p, 1.);\n    q = p; //top spike\n    q.y += q.z * q.z * 0.5;\n    q.yz *= rot(-0.6);\n\thead = smin(head, sdConeSection(q - vec3(0., 1.6, 0.3), 0.9, 0.4, 0.02), 0.2);\n    q = p; //middle spike\n    q.y += q.z * q.z * 0.2;\n    q.yz *= rot(-1.2);\n\thead = smin(head, sdConeSection(q - vec3(0., 1.4, 0.1), 0.7, 0.5, 0.02), 0.2);\n    q = p; //lower spike\n    q.y += q.z * q.z * 0.3;\n    q.yz *= rot(-2.2);\n\thead = smin(head, sdConeSection(q - vec3(0., 1.3, 0.1), 0.5, 0.4, 0.02), 0.2);\n    q = p; //side spikes\n    q.x = abs(q.x);\n    q.y += q.x * q.x * 0.2;\n    q.xz *= rot(1.);\n    q.yz *= rot(-1.7);\n\thead = smin(head, sdConeSection(q - vec3(0., 1.4, 0.1), 0.6, 0.5, 0.02), 0.2);\n        \n    q = p; //iris\n    q.x = abs(q.x);\n    q.xy *= rot(-0.1);\n    float black = sdEllipsoid(q - vec3(0.18, -0.26, .9), vec3(0.1, 0.2, 0.08));\n    q.xy *= rot(-0.5); //ear\n    float ear = sdRoundCone(q - vec3(0., 0.7, 0.4), 0.4, 0.1, 0.7);\n    ear = max(ear, -sdRoundCone(q - vec3(0., 0.7, 0.6), 0.4, 0.1, 0.7));\n    skin = min(skin, sdRoundCone(q - vec3(0., 0.7, 0.4), 0.3, 0.1, 0.6)); //inner ear\n    skin = max(skin, -sdRoundCone(q - vec3(0., 0.7, 0.61), 0.4, 0.1, 0.72)); \n    head = smin(head, ear, 0.04);\n    q.xy *= rot(0.1); //eyes\n    head = smin(head, sdEllipsoid(q - vec3(0.26, 0., 0.82), //eyebrow\n                                  vec3(0.32, 0.46, 0.32)), 0.1);\n    head = smax(head, -sdEllipsoid(q - vec3(0.28, 0., 0.8), //eye cut out\n                                   vec3(0.32, 0.46, 0.33)), 0.06);\n    float eye = sdSphere(p, 0.97); //eye ball\n    black = min(black, sdSphere(p - vec3(0., -0.56, 0.98), 0.1)); //nose\n    \n    vec2 near = nearest(vec2(head, BLUE), vec2(eye, EYE));\n    near = nearest(near, vec2(skin, SKIN));\n    near = nearest(near, vec2(mouth, MOUTH));\n\treturn nearest(near, vec2(black, BLACK));\n}\n\nvec2 dfBody(vec3 p) {\n    \n    vec3 q = p;\n    q.xz *= rot(0.4);\n    q.yz *= rot(-0.3);\n    q.xy *= rot(0.2);\n    \n    float a = sdEllipsoid(q - vec3(0., -1.9, 0.), vec3(0.7, 1., 0.6)); //body\n    a = smin(a, sdSphere(q - vec3(-0.3, -1.16, 0.), 0.18), 0.1); //shoulders\n    a = smin(a, sdSphere(q - vec3(0.3, -1.16, 0.), 0.18), 0.1); //shoulders\n    float b = sdEllipsoid(q - vec3(0., -1.9, 0.1), vec3(0.6, 0.8, 0.6)); //belly   \n    a = smin(a, sdCapsule(p, vec3(-0.3, -2.4, 0.8), vec3(-1.0, -5.6, 1.2), 0.22), 0.16); //left leg\n    a = smin(a, sdCapsule(p, vec3(0.5, -2.4, 1.0), vec3(0.8, -3.5, 1.3), 0.22), 0.16); //right leg\n    a = smin(a, sdCapsule(p, vec3(0.8, -3.5, 1.3), vec3(1.0, -5.6, 1.3), 0.22), 0.06); //right leg    \n    q.y -= q.z * q.z * 0.2; //tail\n\ta = smin(a, sdConeSection(vec3(q.x, (q.z + 1.) * -1., q.y + 2.4), 0.5, 0.2, 0.02), 0.1);\n    \n    return nearest(vec2(a, BLUE), vec2(b, SKIN));\n}\n\nvec2 dfShoe(vec3 p, float lr, float a) {\n    \n    p.xz *= rot(a);\n    \n    vec3 q = p; //buckle\n    q.xy *= rot(1.0 * lr); //buckle\n    float b = sdBox(q - vec3(0.5 * lr, -0.2, 0.6), vec3(0.05, 0.2, 0.2)); //buckle\n    b = max(b, -sdBox(q - vec3(0.5 * lr, -0.2, 0.6), vec3(0.1, 0.1, 0.1))); //buckle\n    p.x = abs(p.x); //red upper\n    p.x = almostIdentity(p.x, .18, 0.08);\n    float r = sdEllipsoid(p - vec3(-0.06, 0., 0.), vec3(0.6, 0.4, 1.4)); //red upper\n    r = max(r, -sdBox(p - vec3(0., 0., -1.), vec3(1., 1., 1.))); //red upper\n    r = min(r, sdSphere(p - vec3(-0.06, 0., 0.), 0.6)); //red upper\n    r = max(r, -sdBox(p - vec3(0., -1., 0.), vec3(1.))); //red upper\n    float w = sdEllipsoid(p - vec3(-0.06, 0., 0.), vec3(0.62, 0.42, 1.42)); //white sole\n    w = max(w, -sdBox(p - vec3(0., 0., -1.), vec3(1., 1., 1.))); //white sole\n    w = min(w, sdSphere(p - vec3(-0.06, 0., 0.), 0.62)); //white sole\n    w = max(w, -sdBox(p - vec3(0., 1., 0.), vec3(2., 1., 2.))); //white sole\n    float ws = sdEllipsoid(p - vec3(-0.06, 0., 0.), vec3(0.62, 0.42, 1.42)); //white stripe :)\n    q = p; //white stripe :)\n    q.yz *= rot(0.4); //white stripe :)\n    ws = max(ws, -sdBox(q - vec3(0., 0., -0.7), vec3(1., 1., 1.))); //white stripe :)\n    ws = max(ws, -sdBox(q - vec3(0., 0., 1.7), vec3(1., 1., 1.))); //white stripe :)\n    w = min(w, ws); //put it all together\n    w = max(w, -sdBox(p - vec3(0., -1.1, 0.), vec3(2., 1., 2.)));\n    w = min(w, sdTorus(p.xzy - vec3(0., 0., 0.5), vec2(0.4, 0.1))); //boot hoops\n    w = min(w, sdTorus(p.xzy - vec3(0., 0., 0.7), vec2(0.4, 0.1))); //boot hoops\n    \n    vec2 near = nearest(vec2(r, RED), vec2(w, WHITE));\n    near = nearest(near, vec2(b, GOLD));\n    return near;\n} \n\nvec2 dfGloves(vec3 p) {\n    \n    vec3 q = p - vec3(-1.6, -1.1, 0.7); //left glove\n    float lg = sdTorus(q.xzy - vec3(0., 0., 0.04), vec2(0.2, 0.08)); //cuff\n    lg = min(lg, sdTorus(q.xzy - vec3(0., 0., 0.2), vec2(0.2, 0.08))); //cuff\n    lg = min(lg, sdEllipsoid(q - vec3(0., 0.5, 0.0), vec3(0.34, 0.34, 0.16))); //back\n    lg = smin(lg, sdCapsule(q, vec3(0.4, 0.75, 0.2), vec3(0.24, 0.5, 0.), 0.12), 0.03); //thumb\n    lg = smin(lg, sdCapsule(q, vec3(-0.30, 0.65, 0.14), vec3(-0.26, 0.65, 0.05), 0.1), 0.03); //smooth pinkie joint\n    lg = smin(lg, sdRoundCone(q - vec3(0.18, 0.6, 0.), 0.1, 0.12, 0.7), 0.02); //index finger\n    lg = min(lg, sdCapsule(q, vec3(0.07, 0.5, 0.2), vec3(0., 0.75, 0.15), 0.1)); //2nd finger\n    lg = min(lg, sdCapsule(q, vec3(0., 0.75, 0.15), vec3(0., 0.75, 0.02), 0.1)); //2nd finger\n    lg = min(lg, sdCapsule(q, vec3(-0.09, 0.5, 0.2), vec3(-0.17, 0.70, 0.2), 0.1)); //3rd finger\n    lg = min(lg, sdCapsule(q, vec3(-0.17, 0.70, 0.2), vec3(-0.17, 0.70, 0.05), 0.1)); //3rd finger\n    lg = min(lg, sdCapsule(q, vec3(-0.23, 0.5, 0.2), vec3(-0.30, 0.65, 0.14), 0.1)); //pinkie\n    \n    q = p - vec3(1.3, -1.7, 0.5);//right glove\n    q.xz *= rot(-0.4);\n    q.xy *= rot(0.7);\n    float rg = sdTorus(q.zyx - vec3(0., 0., -0.04), vec2(0.2, 0.08)); //cuff\n    rg = min(rg, sdTorus(q.zyx - vec3(0., 0., -0.2), vec2(0.2, 0.08))); //cuff\n    rg = min(rg, sdEllipsoid(q - vec3(-0.5, 0., 0.), vec3(0.34, 0.16, 0.34))); //back\n    rg = smin(rg, sdCapsule(q, vec3(-0.75, 0., -0.4), vec3(-0.5, 0., -0.24), 0.12), 0.03); //thumb\n    rg = smin(rg, sdCapsule(q, vec3(-0.75, -0.15, -0.17), vec3(-0.73, 0.0, -0.15), 0.1), 0.05); //smooth 1st finger\n    rg = smin(rg, sdCapsule(q, vec3(-0.65, -0.14, 0.3), vec3(-0.65, -0.05, 0.24), 0.1), 0.05); //smooth pinkie joint\n    rg = min(rg, sdCapsule(q, vec3(-0.5, -0.2, 0.23), vec3(-0.65, -0.14, 0.3), 0.1)); //pinkie\n    rg = min(rg, sdCapsule(q, vec3(-0.5, -0.2, 0.09), vec3(-0.7, -0.20, 0.17), 0.1)); //3rd finger\n    rg = min(rg, sdCapsule(q, vec3(-0.7, -0.20, 0.17), vec3(-0.7, -0.05, 0.17), 0.1)); //3rd finger\n    rg = min(rg, sdCapsule(q, vec3(-0.5, -0.2, -0.17), vec3(-0.75, -0.15, -0.17), 0.1)); //1st finger\n    rg = min(rg, sdCapsule(q, vec3(-0.5, -0.2, -0.07), vec3(-0.78, -0.16, 0.), 0.1)); //2nd finger\n    rg = min(rg, sdCapsule(q, vec3(-0.78, -0.16, 0.), vec3(-0.75, -0.02, 0.0), 0.1)); //2nd finger\n\n    return vec2(min(lg, rg), WHITE);\n}\n\nvec2 dfArms(vec3 p) {\n    float a = sdCapsule(p, vec3(-0.2, -1.2, 0.3), vec3(-1.4, -1.8, 0.7), 0.15); //left arm\n    a = min(a, sdCapsule(p, vec3(-1.4, -1.8, 0.7), vec3(-1.6, -1., 0.7), 0.15)); //left arm\n    a = min(a,sdCapsule(p, vec3(0.4, -1.06, 0.56), vec3(1.5, -1.3, 0.), 0.15)); //right arm\n    a = min(a, sdCapsule(p, vec3(1.5, -1.3, 0.), vec3(1.3, -1.74, 0.5), 0.15)); //right arm\n    return vec2(a, SKIN);\n}\n\nvec2 map(vec3 p) {\n    vec2 near = nearest(dfHead(p - vec3(0., 0., 0.4)), dfBody(p));\n    near = nearest(near, dfArms(p));\n    near = nearest(near, dfShoe(p - vec3(1.0, -6.0, 1.3), 1.0, 0.0));\n    near = nearest(near, dfShoe(p - vec3(-0.96, -6.0, 1.16), -1.0, 0.6));\n    near = nearest(near, vec2(p.y + 6.14, FLOOR));\n    return nearest(near, dfGloves(p));\n}\n\n//tetrahedral normal - IQ\nvec3 normal(vec3 p) {  \n    vec2 e = vec2(-1., 1.) * EPS;   \n\treturn normalize(e.yxx * map(p + e.yxx).x + e.xxy * map(p + e.xxy).x + \n\t\t\t\t\t e.xyx * map(p + e.xyx).x + e.yyy * map(p + e.yyy).x);   \n}\n\n//noise and environment mapping from Terrain Lattice by Shane\nfloat n3D(vec3 p) {    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); \n    p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p * p * (3. - 2. * p);\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\nvec3 envMap(vec3 p){    \n    p *= 2.;\n    p.xz += T * .5;\n    float n3D2 = n3D(p * 2.);\n    float c = n3D(p) * .57 + n3D2 * .28 + n3D(p * 4.) * .15;\n    c = smoothstep(0.5, 1., c);    \n    p = vec3(c * .8, c * .9, c);\n    return mix(p.zxy, p, n3D2 * .34 + .665);\n}\n\n//IQ - http://www.iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm\nfloat AO(vec3 p, vec3 n) {\n    float ra = 0., w = 1., d = 0.;\n    for (float i = 1.; i < 5.; i += 1.){\n        d = i / 5.;\n        ra += w * (d - map(p + n * d).x);\n        w *= .5;\n    }\n    return 1. - clamp(ra, 0., 1.);\n}\n\n//http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf\nvec2 relaxedMarch(vec3 ro, vec3 rd) {\n\n    float om = 1.3; //omega\n    float t = EPS;\n    float ce = FAR; //candidate error\n    float ct = EPS; //candidate t\n    float pr = 0.0; //previous radius\n    float sl = 0.0; //step length\n    const float PR = EPS; //pixel radiud\n    float fs = map(ro).x < 0.0 ? -1.0 : 1.0; //sign\n    \n    float id = 0.0;\n\n    for (int i = 0; i < 100; ++i) {\n        vec2 si = map(ro + rd * t);\n        float sr = fs * si.x; //signed radius\n        float r = abs(sr); //radius\n        bool fail = om > 1.0 && (r + pr) < sl;\n        if (fail) {\n            sl -= om * sl;\n            om = 1.0;\n        } else {\n            sl = sr * om;\n        }\n        pr = r;\n        float err = r / t;\n        if (!fail && err < ce) {\n            ct = t;\n            ce = err;\n        }\n        if (!fail && err < PR || t > FAR) {\n            id = si.y;\n            break;\n        }\n        t += sl;\n    }\n\n    if (t > FAR || ce > PR) ct = FAR;\n\n    return vec2(ct, id);\n}\n\n/*\n//interesting for comparison\nvec2 march(vec3 ro, vec3 rd) {\n    \n    float t = 0., id = 0.;\n    \n    for (int i = 0; i < 128; i++) {\n        vec2 si = map(ro + rd * t);\n        if (si.x < EPS || t > FAR) {\n            id = si.y;\n            break;\n        }\n        t += si.x * 0.6;\n    }\n    \n    return vec2(t, id);\n}\n//*/\n\nvec3 render(vec3 ro, vec3 rd) {\n\n    vec3 pc = vec3(0.), \n         lp = vec3(-5, 6, 2);\n\n    //interesting for comparison\n    //for both perforrmance and ray penetration into scene\n    //vec2 si = march(ro, rd);\n    vec2 si = relaxedMarch(ro, rd);\n    \n    float t = si.x;\n    float id = si.y;\n    \n    if (t > 0. && t < FAR) {\n        vec3 p = ro + rd * t;\n        vec3 ld = normalize(lp - p);\n        vec3 n = normal(p);\n        float dif = max(dot(ld, n), 0.2);\n        float sp = pow(max(dot(reflect(ld, n), rd), 0.), 8.);\n        float ao = AO(p, n);\n        vec3 env = envMap(reflect(rd, n)) * 2.;\n        \n        vec3 sc = vec3(0., 0., 1.);\n        if (id == 1.) {\n            //blue\n            pc = vec3(0., 0., 1.) * ao * dif\n                 + vec3(0.05) * sp;\n        } else if (id == 2.) {\n            //eyes\n            pc = vec3(1.) * ao    \n                 + vec3(0.4, 0.4, 1.) * 0.24 * env;    \n        } else if (id == 3.) {\n            //skin\n            pc = vec3(1., 0.5, 0.5) * ao * dif    \n                 + vec3(0.05) * sp;\n        } else if (id == 4.) {\n            //black\n            sp = pow(max(dot(reflect(ld, n), -rd), 0.), 32.);\n            pc = vec3(.01) + vec3(1.) * sp\n                 + vec3(0.05) * env;    \n        } else if (id == 5.) {\n            //red\n            pc = vec3(1., 0., 0.) * ao * dif    \n                 + vec3(0.05) * sp;\n        } else if (id == 6.) {\n            //white\n            pc = vec3(1.) * ao * dif    \n                 + vec3(0.2) * sp;\n        } else if (id == 7.) {\n            //gold\n            pc = vec3(1., 1., 0.) * ao * 0.5\n                 + vec3(1., 1., 0.) * env * 2.;    \n        } else if (id == 8.) {\n            //floor\n            float lt = length(vec2(0., 1.4) - p.xz);\n            lt = 1. / (1. + lt * lt * .6);                  \n            pc = mix(vec3(1), vec3(0.2), lt) * max(ao, 0.8);\n        }\n    } else {\n        pc = vec3(1.);    \n    }\n    \n    return sqrt(clamp(pc, 0.0, 1.0));\n}\n\nvoid camera(vec2 U, inout vec3 ro, inout vec3 rd) {\n    \n    const float fo = 1.4;\n\n    vec2 uv = (U - R * .5) / R.y;\n    \n    vec3 la = vec3(0, -2.8, 0);\n    ro = vec3(0, -2. + sin(T * 0.07), 7. + sin(T * 0.05)); \n    \n    ro.xz *= rot(sin(T * -.1) * 0.8);\n    \n    vec3 fwd = normalize(la - ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x)); \n\n    rd = normalize(fwd + 1.4 * uv.x * rgt + 1.4 * uv.y * cross(fwd, rgt));\n}\n\nvoid mainImage(out vec4 C, vec2 U) {    \n    vec3 ro, rd;\n    camera(U, ro, rd);\n    C = vec4(render(ro, rd), 1.);\n}","name":"Image","description":"","type":"image"}]}