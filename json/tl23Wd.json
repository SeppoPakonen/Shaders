{"ver":"0.1","info":{"id":"tl23Wd","date":"1561902818","viewed":364,"name":"Stranded","username":"jackdavenport","description":"Gaze upon the moon you are stranded on. For controls see Image or press the i button on phone.\n\nThis shader is designed to be used in VR, so I recommend downloading the Shadertoy app on a smartphone and using a Google Cardboard to view this shader in VR.","likes":1,"published":3,"flags":49,"tags":[]},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Stranded by jackdavenport\n// Created 2019\n// All code is free to use with credit :)\n//\n// Mobile/VR Controls\n// Turn head: Look around\n// Press screen: Move\n//\n// PC Controls\n// WASD/Arrow Keys: Move\n// Spacebar: Jump\n// Shift: Sprint\n// R: Jump to random position\n\nvec3 screen(vec3 a, vec3 b) {\n    return 1. - (1. - a) * (1. - b);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 base = texture(iChannel0, uv).xyz;\n    vec3 bloom = texture(iChannel1, uv).xyz;\n    \n    fragColor.xyz = screen(base, bloom);\n    fragColor.w   = 1.;\n}\n\nvoid mainVR(out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd) {\n    mainImage(fragColor, fragCoord);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Stranded by jackdavenport\n// Created 2019\n// All code is free to use with credit :)\n\n//----------------------------------------------------------------------------------------------\nvec4 loadValue( in ivec2 re )\n{\n    return texelFetch( iChannel0, re, 0 );\n}\nvoid storeValue( in ivec2 re, in vec4 va, inout vec4 fragColor, in ivec2 p )\n{\n    fragColor = (p==re) ? va : fragColor;\n}\nvoid storeValue( in ivec4 re, in vec4 va, inout vec4 fragColor, in ivec2 p )\n{\n    fragColor = ( p.x>=re.x && p.y>=re.y && p.x<=re.z && p.y<=re.w ) ? va : fragColor;\n}\n//----------------------------------------------------------------------------------------------\n#define KEY_W 87.5\n#define KEY_A 65.5\n#define KEY_S 83.5\n#define KEY_D 68.5\n#define KEY_R 82.5\n#define KEY_UP 38.5\n#define KEY_DOWN 40.5\n#define KEY_LEFT 37.5\n#define KEY_RIGHT 39.5\n#define KEY_SPACE 32.5\n#define KEY_SHIFT 16.5\nfloat getKey(float key) {\n\treturn texture(iChannel1, vec2(key,0.)/256.).x;   \n}\n//----------------------------------------------------------------------------------------------\nfloat hash(in float entropy)\n{\n    return fract(sin(entropy*821.91)*951.51);\n}\n//----------------------------------------------------------------------------------------------\n\nconst ivec2 addr_playerPosRot = ivec2(0,0);\nconst ivec2 addr_mouseDelta   = ivec2(1,0);\nconst ivec2 addr_playerVel    = ivec2(2,0);\n\n#define PI 3.14159265359\n#define HALF_PI 1.57079632679\n\n#define MOVE_SPEED .001  // move speed (in radians/sec)\n#define LOOK_SPEED PI    // look speed (radians)\n#define BOOST_AMNT 3.    // amount to sprint by\n#define JUMP_FORCE 2.5   // force to jump by (m/s)\n#define GRAVITY -1.62    // actual gravity of the moon (m/s)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // load old values\n    ivec2 fragPos = ivec2(fragCoord - .5);\n    vec4 playerPosRot = loadValue(addr_playerPosRot);\n    vec2 mouseDelta   = loadValue(addr_mouseDelta).xy;\n    vec2 playerVel    = loadValue(addr_playerVel).xy;\n    \n    // player movement\n    if(iFrame == 0) {\n    \tplayerPosRot.x = PI * .5;\n    \tplayerPosRot.z = PI * .5;\n        playerPosRot.y = 0.;\n        playerPosRot.w = 0.;\n    } else {\n        float sinY = sin(playerPosRot.y); \n    \tfloat cosY = cos(playerPosRot.y);\n        float sinY90 = sin(playerPosRot.y+HALF_PI);\n        float cosY90 = cos(playerPosRot.y+HALF_PI);\n        \n        // wasd keys\n        float fwd = getKey(KEY_W) - getKey(KEY_S);\n        float str = getKey(KEY_D) - getKey(KEY_A);\n        // arrow keys\n        fwd += getKey(KEY_UP) - getKey(KEY_DOWN);\n        str += getKey(KEY_RIGHT) - getKey(KEY_LEFT);\n        // move player\n        float moveSpeed = MOVE_SPEED * iTimeDelta * mix(1.,BOOST_AMNT,getKey(KEY_SHIFT));\n        playerPosRot.z += cosY * moveSpeed * fwd;\n        playerPosRot.x -= sinY * moveSpeed * fwd;\n        playerPosRot.z += cosY90 * moveSpeed * str;\n        playerPosRot.x -= sinY90 * moveSpeed * str;\n        \n        // player rotation\n        if(iMouse.z > 0.) {\n            float mx = iMouse.x / iResolution.x;\n            if(mouseDelta.x < 1.) {\n                mouseDelta = vec2(1.,mx);\n            }\n            float del = mx - mouseDelta.y;\n            playerPosRot.y += del * LOOK_SPEED;\n            mouseDelta.y = mx;\n        } else {\n            mouseDelta.x = 0.;\n        }\n        \n        // jumping\n        if(getKey(KEY_SPACE) > 0.) {\n            playerVel.y = JUMP_FORCE;\n        } else if(abs(playerVel.y) > .005) {\n            playerPosRot.w = max(0., playerPosRot.w + playerVel.y * iTimeDelta);\n            playerVel.y = playerVel.y + GRAVITY * iTimeDelta;\n        }\n        \n        // random position\n        if(getKey(KEY_R) > 0.) {\n            playerPosRot.x = hash(iTime) * PI * 2.;\n            playerPosRot.z = hash(iTime) * PI;\n        }\n    }\n    \n    // write out values\n    storeValue(addr_playerPosRot, playerPosRot, fragColor, fragPos);\n    storeValue(addr_mouseDelta, vec4(mouseDelta,0.,0.), fragColor, fragPos);\n    storeValue(addr_playerVel, vec4(playerVel,0.,0.), fragColor, fragPos);\n}\n\nvoid mainVR(out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd) {\n    // load old values\n    ivec2 fragPos = ivec2(fragCoord - .5);\n    vec4 playerPosRot = loadValue(addr_playerPosRot);\n    vec2 playerVel    = loadValue(addr_playerVel).xy;\n    \n    // player movement\n    if(iFrame == 0) {\n        playerPosRot.x = PI * .5;\n    \tplayerPosRot.z = PI * .5;\n        playerPosRot.y = 0.;\n        playerPosRot.w = 0.;\n    } else {\n        playerPosRot.z += 0.005 * iTimeDelta;\n    }\n    \n    // write out values\n    storeValue(addr_playerPosRot, playerPosRot, fragColor, fragPos);\n    storeValue(addr_playerVel, vec4(playerVel,0.,0.), fragColor, fragPos);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Stranded by jackdavenport\n// Created 2019\n// All code is free to use with credit :)\n\n#define MAX_ITER 300\n#define MIN_DIST .001\n#define MAX_DIST 3000.\n\n#define PI 3.14159265359\n#define HALF_PI 1.57079632679\n#define TWO_PI 6.28318530718\n\n#define saturate(x) clamp(x,0.,1.)\n#define rgb(r,g,b) (vec3(r,g,b)*.00392156862)\n\n//----------config----------//\n//#define FAST_NORMALS // better performance, but lighting might look off\n\n//--------------------------//\n\nconst float moonSize = 1000.;\nconst vec3 moonPos = vec3(0.,-moonSize,0.);\nconst vec3 sunDir = normalize(vec3(30.,17.5,45.));\nconst vec3 ambLight = vec3(0.1);\n\n//----------------------------------------------------------------------------------------------\nstruct Material {\n    vec3 albedo;\n    vec3 specular;\n    float shine;\n    vec3 emission;\n};\n//----------------------------------------------------------------------------------------------\nvec4 loadValue( in ivec2 re )\n{\n    return texelFetch( iChannel0, re, 0 );\n}\n//----------------------------------------------------------------------------------------------\nconst ivec2 addr_playerPosRot = ivec2(0,0);\n//----------------------------------------------------------------------------------------------\n\nfloat hash(in float entropy)\n{\n    return fract(sin(entropy*821.91)*951.51);\n}\n\nfloat hash3(in vec3 entropy)\n{\n    return hash(dot(entropy,vec3(3.7,721.5,3.91)) + 0.5);\n}\n\nfloat noise(in vec3 p)\n{\n    vec3 ipos = floor(p);\n    vec3 fpos = fract(p);\n    \n    float a = hash3(ipos + vec3(0, 0, 0));\n    float b = hash3(ipos + vec3(1, 0, 0));\n    float c = hash3(ipos + vec3(0, 1, 0));\n    float d = hash3(ipos + vec3(1, 1, 0));\n    \n    float e = hash3(ipos + vec3(0, 0, 1));\n    float f = hash3(ipos + vec3(1, 0, 1));\n    float g = hash3(ipos + vec3(0, 1, 1));\n    float h = hash3(ipos + vec3(1, 1, 1));\n    \n    vec3 t = smoothstep(0., 1., fpos);\n    \n    return mix(mix(mix(a, b, t.x), mix(c, d, t.x), t.y),\n               mix(mix(e, f, t.x), mix(g, h, t.x), t.y),\n               t.z);\n}\n\nfloat fbm(in vec3 p, in float amp, in float freq)\n{\n    float res = 0.;\n    for (int i = 0; i < 5; ++i)\n    {\n        res += amp*noise(freq*p);\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return res;\n}\nfloat fbm(in vec3 p) {\n    return fbm(p, .75, 2.75);\n}\n//---------------------------------------------------------------------------------------\n// 3d texture sampler by reinder (thanks!)\n// Source: https://www.shadertoy.com/view/4dj3Dw\nvec4 tex3D( in vec3 pos, in vec3 normal, sampler2D sampler )\n{\n\treturn \ttexture( sampler, pos.yz )*abs(normal.x)+ \n\t\t\ttexture( sampler, pos.xz )*abs(normal.y)+ \n\t\t\ttexture( sampler, pos.xy )*abs(normal.z);\n}\n//---------------------------------------------------------------------------------------\n\nvec2 rot2D(vec2 p, float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c,s,-s,c) * p;\n}\n\nvec2 dstMin(vec2 a, float bd, float bid) {\n    if(a.x < bd) { return a; }\n    return vec2(bd, bid);\n}\n\nfloat getMoonHeight(vec3 p) {\n    float amp = .5 + 2. * fbm(p*20., .4, 1.);\n    float freq = 2. + 1. * fbm(p*10., .2, 1.);\n    return fbm(p*50., amp, freq) * 2.5;\n}\n\nvec2 dstScene(vec3 p) {\n    vec2 dst = vec2(MAX_DIST,-1.);\n    // moon\n    vec3 moonNorm  = normalize(p - moonPos);\n    float moonSurf = getMoonHeight(moonNorm);\n    dst = dstMin(dst, length(p-moonPos)-moonSize-moonSurf, 0.);\n    // earth\n    dst = dstMin(dst, length(p-vec3(0.,500.,-1500.))-300., 1.);\n    // end scene\n    return dst;\n}\n\nvec2 raymarch(vec3 ro, vec3 rd, float t) {\n    float id = -1.;\n    for(int i = 0; i < MAX_ITER; i++) {\n        vec2 scn = dstScene(ro+rd*t);\n        if(scn.x < MIN_DIST*t || t > MAX_DIST) {\n            id = scn.y;\n            break;\n        }\n        t += scn.x * .5;\n    }\n    return vec2(t,id);\n}\n\nvec3 calcNormal(vec3 p, float t) {\n#ifndef FAST_NORMALS\n    vec2 e = vec2(.001*t,0.);\n    vec3 n = vec3(dstScene(p+e.xyy).x-dstScene(p-e.xyy).x,\n                  dstScene(p+e.yxy).x-dstScene(p-e.yxy).x,\n                  dstScene(p+e.yyx).x-dstScene(p-e.yyx).x);\n    return normalize(n);\n#else\n    return normalize(-cross(dFdy(p),dFdx(p)));\n#endif\n}\n\nvec3 getSky(vec3 dir) {\n    float stars = 0.;\n    stars += smoothstep(.95, 1., tex3D((dir-vec3(2.,0.,0.))*5., dir, iChannel1).x);\n    stars += smoothstep(.85, 1., tex3D(dir*5., dir, iChannel1).x);\n    stars = saturate(pow(stars, 10.)) * 2.;\n    return vec3(stars);\n}\n\n// Thanks iq!\n// Source: https://www.shadertoy.com/view/MdX3Rr\nfloat softshadow(in vec3 ro, in vec3 rd, in float maxt)\n{\n    float res = 1.0;\n    float t = 0.001;\n\tfor( int i=0; i<80; i++ )\n\t{\n\t    vec3  p = ro + t*rd;\n        float h = dstScene(p).x;\n\t\tres = min( res, 16.0*h/t );\n\t\tt += h;\n\t\tif( res<0.001 ||p.y > maxt) break;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n\nvoid material(inout Material mat, in vec3 p, in vec3 n, in vec3 rd, in float ndotl, in vec2 t);\nvoid camera(inout vec3 ro, inout vec3 rd, in bool vr);\n\nvec3 shade(vec3 ro, vec3 rd) {\n    vec3 col = getSky(rd);\n    \n    // emulate refraction through the visor\n    float tHelmet = .005;\n    vec3 hp = ro + rd * tHelmet;\n    vec3 hn = normalize(ro - hp);\n    vec3 hr = normalize(refract(rd, hn, 1.25));\n    \n    vec2 t = raymarch(hp, hr, 0.);\n    if(t.x < MAX_DIST && t.y > -1.) {\n        vec3 p = ro+rd*t.x;\n        vec3 n = calcNormal(p,t.x);\n        vec3 r = normalize(reflect(rd,n));\n        \n        float ndotl = max(dot(n,sunDir),0.);\n        float rdotl = max(dot(r,sunDir),0.);\n        float shdw  = 1.;\n        \n        if(t.x < 500.) { // only draw shadows at short distance to save performance\n            shdw = softshadow(p,sunDir,1000.);\n        }\n        \n        Material mat;\n        material(mat, p, n, rd, ndotl, t);\n        col = ambLight +\n            mat.albedo * ndotl * shdw +\n            mat.specular * pow(rdotl, mat.shine) * shdw +\n            max(vec3(0.),mat.emission);\n    }\n    \n    // add visor artefacts\n    hr = normalize(reflect(rd,hn));\n    float shdw = softshadow(hp,sunDir,100.);\n    // visor specular\n    col += pow(max(dot(hr,sunDir),0.),70.) * shdw;\n    // visor dust/dirt\n    col += pow(fbm(hn*1.),3.) * (.2 + .3 * shdw);\n    \n    //col = sqrt(col);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // calculate ray direction for this pixel\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    vec3 ro = vec3(0.,0.,0.);\n    vec3 rd = vec3(uv.x,-1.,uv.y);\n    \n    // apply camera transform\n    camera(ro, rd, false);\n    \n    // calculate the pixel colour\n    fragColor.xyz = shade(ro, normalize(rd));\n    fragColor.w   = 1.;\n}\n\nvoid mainVR(out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd) {\n    // apply camera transform on top of VR ray\n    camera(ro, rd, true);\n    \n    // calculate the pixel colour\n    fragColor.xyz = shade(ro, normalize(rd));\n    fragColor.w   = 1.;\n}\n\nvec3 rotPitchYaw(vec3 p, float pitch, float yaw) {\n    float s = sin(yaw), c = cos(yaw);\n    mat3 rx = mat3(1,0,0,0,c,-s,0,s,c);\n    s = sin(pitch); c = cos(pitch);\n    mat3 ry = mat3(c,0,s,0,1,0,-s,0,c);\n    return rx * ry * p;\n}\n\nvoid camera(inout vec3 ro, inout vec3 rd, in bool vr) {\n    // calculate ray origin\n    vec4 playerPos = loadValue(addr_playerPosRot).xzyw;\n    vec3 off = moonSize * vec3(cos(playerPos.x) * sin(playerPos.y),\n                               sin(playerPos.x) * sin(playerPos.y),\n                               cos(playerPos.y));\n    vec3 nor = normalize(off);\n    ro = moonPos + off + nor * (getMoonHeight(nor) + .4 + playerPos.w);\n    \n    // orient camera to planet surface\n    vec3 u = normalize(cross(nor, vec3(0.,0.,1.)));\n    vec3 v = normalize(cross(u, nor));\n    rd = normalize(mat3(u,v,nor) * rd);\n    \n    // rotate camera (only if not VR)\n    if(!vr) {\n    \tfloat my = (2. * iMouse.y / iResolution.y) - 1.;\n    \tif(iMouse.x < 0. && iMouse.y < 0.) {\n        \tmy = 0.;\n    \t}\n    \trd = rotPitchYaw(rd, playerPos.z, my * PI);\n    }\n}\n\nvoid material(inout Material mat, in vec3 p, in vec3 n, in vec3 rd, in float ndotl, in vec2 t) {\n    if(t.y == 0.) { // lunar surface\n        float rand = fbm(p * 1.5) * .8 + fbm(p, 1., 3.) * .2;\n        vec3 surf = mix(rgb(255, 252, 240),rgb(191, 191, 191),rand) * (1. - .6 * fbm(p*.05));\n        mat.albedo = surf;\n        mat.specular = vec3(.1);\n        mat.shine = 20.;\n        mat.emission = vec3(0.);\n    } else if(t.y == 1.) { // earth\n        // calculate UVs for planet\n        vec2 uv = asin(n.xy) / PI + .5;\n        uv.x += iTime * .005;\n        // calculate land mass\n        float val = saturate(pow(texture(iChannel2, uv*2.).x, 1.5));\n        val = saturate(pow(smoothstep(val,0.,.3), .7)*3.);\n        // calculate lights\n        float lights = pow(texture(iChannel1,uv*.5).x,3.);\n        // calculate terrain colour\n        vec3 surfCol = mix(rgb(210,105,30),rgb(111, 201, 91),fbm(n*5.));\n        vec3 surf = mix(surfCol,rgb(0,105,148),val);\n        // fake atmospheric scattering\n        float fres = saturate(1.-pow(max(0.,-dot(n,rd)),.1));\n        vec3 atmo = rgb(130, 220, 237) * fres;\n        // output to material\n        mat.albedo = surf;\n        mat.specular = vec3(.2+.8*val);\n        mat.shine = 30. + 15. * val;\n        mat.emission = (rgb(255, 222, 171) * lights * (1.-val) * pow(1.-ndotl,15.)) + atmo;\n    } else { // default material\n        mat.albedo = vec3(1.,0.,1.);\n        mat.specular = vec3(0.);\n        mat.shine = 0.;\n        mat.emission = vec3(0.);\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Stranded by jackdavenport\n// Created 2019\n// All code is free to use with credit :)\n\nconst float BLUR_SIZE = 2.5;\nconst float BLOOM_THRESHOLD = 1.;\n    \nfloat sampleHDR(vec2 uv) {\n    return max(0., texture(iChannel0, uv).x - BLOOM_THRESHOLD);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float total = 0.;\n    \n    // do horizontal blur\n    float size = BLUR_SIZE / iResolution.x;\n    total += sampleHDR(uv-vec2(5.*size,0.)) * 0.000003;\n    total += sampleHDR(uv-vec2(4.*size,0.)) * 0.000229;\n    total += sampleHDR(uv-vec2(3.*size,0.)) * 0.005977;\n    total += sampleHDR(uv-vec2(2.*size,0.)) * 0.060598;\n    total += sampleHDR(uv-vec2(1.*size,0.)) * 0.24173;\n    total += sampleHDR(uv) * 0.382925;\n    total += sampleHDR(uv+vec2(1.*size,0.)) * 0.24173;\n    total += sampleHDR(uv+vec2(2.*size,0.)) * 0.060598;\n    total += sampleHDR(uv+vec2(3.*size,0.)) * 0.005977;\n    total += sampleHDR(uv+vec2(4.*size,0.)) * 0.000229;\n    total += sampleHDR(uv-vec2(5.*size,0.)) * 0.000003;\n    \n    fragColor = vec4(total,total,total,1.);\n}\n\nvoid mainVR(out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd) {\n    // pass to normal function, it does the same thing\n    mainImage(fragColor, fragCoord);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Stranded by jackdavenport\n// Created 2019\n// All code is free to use with credit :)\n\nconst float BLUR_SIZE = 2.5;\n    \nfloat sampleHDR(vec2 uv) {\n    return texture(iChannel0, uv).x;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float total = 0.;\n    \n    // do vertical blur\n    float size = BLUR_SIZE / iResolution.x;\n    total += sampleHDR(uv-vec2(0.,5.*size)) * 0.000003;\n    total += sampleHDR(uv-vec2(0.,4.*size)) * 0.000229;\n    total += sampleHDR(uv-vec2(0.,3.*size)) * 0.005977;\n    total += sampleHDR(uv-vec2(0.,2.*size)) * 0.060598;\n    total += sampleHDR(uv-vec2(0.,1.*size)) * 0.24173;\n    total += sampleHDR(uv) * 0.382925;\n    total += sampleHDR(uv+vec2(0.,1.*size)) * 0.24173;\n    total += sampleHDR(uv+vec2(0.,2.*size)) * 0.060598;\n    total += sampleHDR(uv+vec2(0.,3.*size)) * 0.005977;\n    total += sampleHDR(uv+vec2(0.,4.*size)) * 0.000229;\n    total += sampleHDR(uv-vec2(0.,5.*size)) * 0.000003;\n    \n    fragColor = vec4(total,total,total,1.);\n}\n\nvoid mainVR(out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd) {\n    // pass to normal function, it does the same thing\n    mainImage(fragColor, fragCoord);\n}","name":"Buffer D","description":"","type":"buffer"}]}