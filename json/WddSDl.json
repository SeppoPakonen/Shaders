{"ver":"0.1","info":{"id":"WddSDl","date":"1577646496","viewed":117,"name":"Atmosphere: Na\u00efve ","username":"alro","description":"Na\u00efve ray marched atmoshpere rendering based on the work by Nishinta and examples online. Pause and look around using mouse.","likes":3,"published":1,"flags":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Based on:\n//http://nishitalab.org/user/nis/cdrom/sig93_nis.pdf\n//\"Physically Based Sky, Atmosphere and Cloud Rendering in Frostbite\", S. Hillaire\n//https://www.shadertoy.com/view/wlBXWK\n//https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky/simulating-colors-of-the-sky\n//https://www.alanzucconi.com/2017/10/10/atmospheric-scattering-1/\n\n//Distance of camera to planet (e.g. 0.0 for ground level, 5.0 for distant view)\n//In units of planetary radius\n#define CAMERA_DISTANCE 0.0\n\n#define PI 3.1415\n\n//Measurements for Earth seen in literature\n#define PLANET_RADIUS 6371e3\n#define ATMOSPHERE_THICKNESS 100e3\n#define ATMOSPHERE_RADIUS float(PLANET_RADIUS + ATMOSPHERE_THICKNESS)\n\n#define MAX_DIST ATMOSPHERE_THICKNESS * 10\n\n#define WITH_OZONE\n\n#ifdef WITH_OZONE\n//From \"Physically Based Sky...\"\n#define BETA_RAYLEIGH vec3(vec3(5.47e-6, 1.28e-5, 3.12e-5) + vec3(3.426, 8.298, 0.356) * 0.06 * 1e-5)\n\n#else\n\n//https://www.shadertoy.com/view/wlBXWK uses vec3(5.5e-6, 13.0e-6, 22.4e-6) which looks better\n#define BETA_RAYLEIGH vec3(5.47e-6, 1.28e-5, 3.12e-5)\n\n#endif\n\n#define BETA_MIE 2.1e-6\n#define SCALE_HEIGHT_RAYLEIGH float(0.085 * ATMOSPHERE_THICKNESS)\n#define SCALE_HEIGHT_MIE float(0.012 * ATMOSPHERE_THICKNESS)\n\n#define STEPS_PRIMARY 32\n#define STEPS_LIGHT 8\n\n\n//https://www.geertarien.com/blog/2017/07/30/breakdown-of-the-lookAt-function-in-OpenGL/\nmat3 lookAt(vec3 camera, vec3 targetDir, vec3 up){\n  vec3 zaxis = normalize(targetDir);    \n  vec3 xaxis = normalize(cross(zaxis, up));\n  vec3 yaxis = cross(xaxis, zaxis);\n\n  return mat3(xaxis, yaxis, -zaxis);\n}\n\nvec3 rayDirection(float fieldOfView, vec2 fragCoord) {\n    vec2 xy = fragCoord - iResolution.xy / 2.0;\n    float z = (0.5 * iResolution.y) / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n//Return the near and far intersections of an infinite ray and a sphere. \n//Assumes sphere at origin. No intersection if result.x > result.y\nvec2 sphereIntersect(vec3 start, vec3 dir, float radius){\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(dir, start);\n    float c = dot(start, start) - (radius * radius);\n    float d = (b*b) - 4.0*a*c;\n    if (d < 0.0){\n    \treturn vec2(1e5, -1e5);\n    }\n    return vec2((-b - sqrt(d))/(2.0*a), (-b + sqrt(d))/(2.0*a));\n}\n\n//Surface colour for planet\nvec3 renderPlanet(vec3 cameraPos, vec3 rayDir, vec3 lightDir, vec2 rayPlanetIntersect){\n    \n    float diff = dot(normalize(cameraPos + normalize(rayDir) * rayPlanetIntersect.x), lightDir); \n    if(diff < 0.0){\n    \treturn vec3(0.0);\n    }\n    //Planet is lit with diffuse grey\n    return diff * vec3(0.2, 0.2, 0.2);\n}\n\n//Return colour of the atmosphere or black, if the ray points to space\nvec3 getSkyColour(vec3 cameraPos, vec3 rayDir, float maxDist, vec3 lightDir){\n\tvec3 col = vec3(0);\n    \n    vec2 rayAtmosphereIntersect = sphereIntersect(cameraPos, rayDir, ATMOSPHERE_RADIUS);\n    vec2 rayPlanetIntersect = sphereIntersect(cameraPos, rayDir, PLANET_RADIUS);  \n    \n    //Does the ray point into the atmosphere and the planet\n    bool hitsAtmosphere = (rayAtmosphereIntersect.x <= rayAtmosphereIntersect.y) && rayAtmosphereIntersect.x > 0.0;  \n    bool hitsPlanet = (rayPlanetIntersect.x <= rayPlanetIntersect.y) && rayPlanetIntersect.x > 0.0;\n    \n    //Is the camera inside the atmosphere\n    bool inAtmosphere = length(cameraPos) < ATMOSPHERE_RADIUS;\n    \n    //If the ray hits the atmosphere or if the camera is in the atmosphere\n    if(hitsAtmosphere || inAtmosphere){\n\n        //The start and end points of the ray \n    \tfloat start;\n    \tfloat end;\n        \n    \tif(inAtmosphere){\n            //In the atmosphere, the ray starts at the camera\n    \t\tstart = 0.0;\n   \t \t}else{\n            //In space, the ray starts at the near intersection with the atmosphere \n    \t\tstart = rayAtmosphereIntersect.x;\n    \t}\n        \n        //The ray ends at either the near intersection with the planet \n        //or the far intersection with the atmosphere\n        if(hitsPlanet){ \n     \t\tend = rayPlanetIntersect.x;\n     \t}else{\t\n    \t\tend = rayAtmosphereIntersect.y;\n        }\n    \n        //Get the length of each segment\n    \tfloat rayLength = end - start;\n    \tfloat stepSize = rayLength / float(STEPS_PRIMARY);\n    \n        //Total Rayleigh and Mie scattering. SUM(attn * rho(h))ds\n    \tvec3 totalRayleigh = vec3(0.0);\n    \tvec3 totalMie = vec3(0.0);\n        \n        //Total Rayleigh and Mie optical depth. D(PA)+D(CP)\n        float opticalDepthRayleigh = 0.0;\n        float opticalDepthMie = 0.0;\n        \n        //Density rho(h) at sample point\n        float densityRayleigh = 0.0;\n        float densityMie = 0.0;\n        \n        vec3 startPos = cameraPos + rayDir * start;\n        \n        //Step along the ray from start to end and accumulate the total optical depth. \n        //By collecting the densities along the ray, and the light rays to the sample points, \n        //we find how much material the light has travelled through to reach the camera.\n        for(int i = 0; i < STEPS_PRIMARY; i++){\n            \n            //Get position along ray. This is the middle point of the current segment\n            vec3 pos_i = startPos + rayDir * (float(i) * stepSize + 0.5 * stepSize);\n            \n            //Get height of point above surface\n            float height_i = length(pos_i) - PLANET_RADIUS;\n            \n            //Density at point\n           \tdensityRayleigh = exp(-height_i / SCALE_HEIGHT_RAYLEIGH) * stepSize;\n            densityMie = exp(-height_i / SCALE_HEIGHT_MIE) * stepSize;\n            \n            //Accumulate total optical depth\n            opticalDepthRayleigh += densityRayleigh;\n            opticalDepthMie += densityMie;\n            \n            //Find the ray to light\n            float stepSizeLight = sphereIntersect(pos_i, lightDir, ATMOSPHERE_RADIUS).y / float(STEPS_LIGHT);\n    \t\t \n            //Total Rayleigh and Mie optical depth for light ray\n        \tfloat opticalDepthRayleighLight = 0.0;\n        \tfloat opticalDepthMieLight = 0.0;\n            \n            //To discard contributions from points too far in the shadow of the planet,\n\t  \t\t//test the light ray against collision with a sphere 95% of the planet size.\n\t  \t\t//Testing with the actual planet size leads to band artifacts at sunset.\n\t  \t\tvec2 lightRayPlanetIntersect = sphereIntersect(pos_i, lightDir, PLANET_RADIUS * 0.95);  \n\t  \t\tbool hitsPlanetLight = (lightRayPlanetIntersect.x <= lightRayPlanetIntersect.y) && lightRayPlanetIntersect.x > 0.0;\n\n\t  \t\tif(!hitsPlanetLight){\n\t    \t\t//Travel from sample point towards the light, stopping at where it enters the atmosphere\n\t    \t\tfor(int j = 0; j < STEPS_LIGHT; j++){\n\n\t      \t\t//Get position along ray. This is the middle point of the current light segment\n\t      \t\tvec3 pos_j = pos_i + lightDir * (float(j) * stepSizeLight + 0.5 * stepSizeLight);\n\t\t\n\t      \t\t//Get height of point above surface\n\t      \t\tfloat height_j = max(0.0, length(pos_j) - PLANET_RADIUS);\n\n\t      \t\t//Add density at point to light total\n\t     \t\topticalDepthRayleighLight += exp(-height_j / SCALE_HEIGHT_RAYLEIGH) * stepSizeLight;\n\t     \t\topticalDepthMieLight += exp(-height_j / SCALE_HEIGHT_MIE) * stepSizeLight;\n\t   \t\t}\n\n\t    \tvec3 attenuation = exp(-(BETA_RAYLEIGH * (opticalDepthRayleigh + opticalDepthRayleighLight) + (BETA_MIE * (opticalDepthMie + opticalDepthMieLight))));\n\t    \t//Accumulate total scattering\n\t    \ttotalRayleigh += densityRayleigh * attenuation;\n\t    \ttotalMie += densityMie * attenuation;\n\t  \t\t}\n\n\t\t}\n\n\t\t//Stop Mie scattering from shining through the planet\n\t\tif(hitsPlanet){\n\t\t  totalMie = vec3(0.0);\n\t\t}\n    \n        float mu = dot(rayDir, lightDir);\n    \tfloat mumu = mu * mu;\n    \tfloat phaseRayleigh = 3.0 / 50.2654824574 * (1.0 + mumu);\n        float g = 0.999;\n        float gg = g * g;\n    \tfloat phaseMie = 3.0 / (25.1327412287) * ((1.0 - gg) * (mumu + 1.0)) / (pow(1.0 + gg - 2.0 * mu * g, 1.5) * (2.0 + gg));\n\n        col = phaseRayleigh * BETA_RAYLEIGH * totalRayleigh + phaseMie * BETA_MIE * totalMie;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    \n    //Get the default direction of the ray (along the negative z direction)\n    vec3 rayDir = rayDirection(45.0, fragCoord);\n    vec4 mouse = (iMouse / iResolution.xyxy) * 2.0 - 1.0;\n    if(iMouse.xy == vec2(0.0)){\n\t\tmouse.x += 1.0;\n        mouse.y += 1.1;\n    }\n    \n    float time = iTime * 0.25;\n    \n    //----------------- Define a camera -----------------\n   \n    vec3 cameraPos = vec3(0.0, PLANET_RADIUS + 1.0, PLANET_RADIUS * CAMERA_DISTANCE);\n    \n    vec3 sunDirection = normalize(vec3(0.0, sin(time), -cos(time)));\n    \n    vec3 targetDir = vec3(sin(mouse.x), mouse.y, -cos(mouse.x));\n    \n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    //---------------------------------------------------\n    \n    //Get the view matrix from the camera orientation\n    mat3 viewMatrix = lookAt(cameraPos, targetDir, up);\n    \n    //Transform the ray to point in the correct direction\n    rayDir = normalize(viewMatrix * rayDir);\n    \n   \tvec2 rayPlanetIntersect = sphereIntersect(cameraPos, rayDir, PLANET_RADIUS);\n    \n    vec3 col;\n    \n    if((rayPlanetIntersect.x <= rayPlanetIntersect.y) && rayPlanetIntersect.x > 0.0){\n    \tcol = renderPlanet(cameraPos, rayDir, sunDirection, rayPlanetIntersect);\n    }\n    \n    col += 40.0*getSkyColour(cameraPos, rayDir, 1e12, sunDirection);\n    \n    //Tone mapping\n    col = 1.0 - exp(-col);\n    //Gamma correction 1.0/2.2 = 0.4545...\n    col = pow(col, vec3(0.4545));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}