{"ver": "0.1", "info": {"id": "wtS3Wh", "date": "1559308317", "viewed": 129, "name": "Embellished Rotation pattern", "username": "Yusef28", "description": "Another Pattern", "likes": 7, "published": 1, "flags": 0, "tags": ["basic"], "requires": ["texture", "imagebuf", "texturebuf"]}, "renderpass": [{"inputs": [{"id": "XdX3Rn", "filepath": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "type": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "4dXGzn", "filepath": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "type": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "Xsf3Rr", "filepath": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "type": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "#define PI 3.14159265358979323846\n#define scale 4.\n\nfloat rnd (vec2 p)\n{\n return fract(sin(dot(p ,vec2(12.9898, 75.233)))*43563.234);   \n}\n\nmat2 rot(float a )\n{\n return mat2(cos(a), -sin(a), sin(a), cos(a) );    \n}\n\nvec2 tilerot (vec2 p)\n    \n{\n    //From the book of shaders https://thebookofshaders.com/10/\n    vec2 ipos = floor(p*scale);   \n     //-0.5 to get -0.5 to 0.5 for rotation\n    vec2 fpos = fract(p*scale)-0.5; \n    float index = rnd(ipos);\n        \n    if(index >= 0.75){ p = fpos*rot(PI/2.);}\n    else if (index >= 0.50){ p = fpos*rot(-PI/2.);}\n    else if (index >= 0.25){ p = fpos*rot(PI);}\n    else p = fpos;//<---need this!\n   \n //+0.5 to reverse the earlier process so you for 0.- 1 again\n return p+0.5;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //resolution correction \n    uv.x*=iResolution.x/iResolution.y;\n    \n   /// uv+=iTime/16.;  //to move the pattern\n    uv = tilerot(uv);\n    \n    //textures\n    vec3 tx0 = vec3(texture(iChannel0, uv));\n    vec3 tx1 = vec3(texture(iChannel1, uv));\n    vec3 tx2 = vec3(texture(iChannel2, uv));\n    \n    //moving light aroud the gold borders\n    vec3 gold = vec3(202., 165., 55.)/255.-abs(sin(uv.x*4.+iTime))/2.;\n    //initial color will be the greyish background\n    vec3 col = vec3(0.)+tx1.x/5.;\n    \n    float circ = length(vec2(uv.x+0.1, uv.y-0.5));\n    \n    //the shape of the red circle\n    float redC = 1.0-step(0.5,circ );\n    \n    //coloring the red circle\n    col = mix(col, vec3(1.0,0.,0.)*tx0.x, redC);\n\t//sq += step(0.5, abs(sin(dot(uv, vec2(0., 0.5))*28.)));\n    \n    //the shape of the gold borders\n    float sq = step(0.98, uv.x)+step(uv.x, 0.02)\n        \t\t+step(0.98, uv.y)+step(uv.y, 0.02);\n    \n    //coloring the gold borders\n    col = mix(col, gold+tx2.x/3., min(sq, 1.));\n    \n    //the gold ring around the red circles\n    float ring =  smoothstep(0.5, 0.5+0.009, circ) -  \n        smoothstep(0.55, 0.55+0.009, circ);\n    \n    //makes the bend in the metal like the straight gold  borders have\n    float ring2 =  smoothstep(0.5, 0.5+0.009, circ) -  \n        smoothstep(0.525, 0.525+0.009, circ);\n    \n    //adding the two rings together with color\n    col = mix(col, gold, ring+ring2);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "name": "Image", "description": "", "type": "image"}]}