{"ver":"0.1","info":{"id":"ldSfDt","date":"1502721866","viewed":230,"name":"Pixel grid matching blur","username":"MartyMcFly","description":"different approach to blur kernel generation for DoF. Mostly a proof-of-concept for myself, maybe I'll port this over to a postprocess injector like ENBSeries or ReShade to try it out in realtime.","likes":3,"published":1,"flags":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nDoF blur discs often have moire patterns because their \nblur kernel doesn't align with pixel grid. \nThis filter here matches the blur kernel with the pixel grid \nand skips samples outside the blur radius. For static width\nblur probably the dumbest possible way to setup a blur kernel\nbut for variable-width blur like DoF, this may even work out,\nespecially because it looks a lot better than regular blur.\n*/\n\n\n/*ideas for improvement:\n\n   -using sample offsets that make use of bilinear filter\n   -approx. costy trigonometry\n   -figure out why algorithm needs reciprocal radius parametrization for hexagon (?)\n*/\n\n//#define SHOWGRID //display the blur grid instead\n\n#define VERTICES 6.0\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 PixelSize = 1.0 / iResolution.xy;\n\tvec2 texcoord = fragCoord.xy * PixelSize.xy;\n    \n    #define PI 3.141592653589\n    \n    float maxradius = 20.0;\n    \n    vec4 color = vec4(0.0);\n\t\n    for(float x = -maxradius; x<=maxradius; x+= 1.0f)\n    {\n    \tfor(float y = -maxradius; y<=maxradius; y+= 1.0f) \n        {\n            vec2 offset = vec2(x,y);\n    \t\tfloat angle = atan(y,x); // + shape rotation angle\n    \t\tfloat radius = sqrt(dot(offset,offset));\n            \n            //radius *= somedepthoffieldcoc in 0-1 range\n \n            float paraPoly = cos(angle - (2.0*PI*floor((PI + VERTICES*angle)/(2.0*PI)))/VERTICES)/cos(PI/VERTICES);\n            float sdfPoly = paraPoly * radius - maxradius;\n               \n    \t\tif(sdfPoly < 0.0)\n    \t\t{\n                float egdeFalloff = smoothstep(0.0,-1.0,sdfPoly);\n                #ifndef SHOWGRID\n        \t\tvec4 tap = texture(iChannel0,texcoord.xy + PixelSize.xy * offset.xy);\n                //intentional gamma-incorrect blur to make the shape stand out.\n \t\t\t\ttap = pow(tap,vec4(8.0)); \n                tap.w = 1.0;\n                color += tap * egdeFalloff;\n                #else                \n                color += max(0.0,1.0 - 100.0*length(vec2(1.0,iResolution.y/iResolution.x)\n                     *(texcoord.xy * 2.0 - 1.0) - offset.xy * 0.5 / maxradius))* egdeFalloff;\n                #endif\n    \t\t}           \n        }\n    }\n    #ifndef SHOWGRID\n    color.rgb /= color.www;\n    color.rgb = pow(color.rgb,vec3(1.0/8.0));\n    #endif\n    fragColor = vec4(color.rgb,1.0);\n    \n    \n}","name":"Image","description":"","type":"image"}]}