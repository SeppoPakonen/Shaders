{"ver":"0.1","info":{"id":"3sffzj","date":"1588673137","viewed":2048,"name":"VOLUMETRIC CLOUD","username":"alro","description":"Use mouse to look around.","likes":45,"published":1,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nEDIT: \tReduced sample step count and introduced blue noise dithering as in \n\t\thttps://www.shadertoy.com/view/3dlfWs\n\nEDIT 2:\tChanged scattering and absorption to depend on wavelength for a coloured cloud. Added \n\t\textinction factor to light ray calculation.\n        \nEDIT 3: Better multiple scattering approximation based on \n        https://twitter.com/FewesW/status/1364617191652524032\n        http://magnuswrenninge.com/wp-content/uploads/2010/03/Wrenninge-OzTheGreatAndVolumetric.pdf\n\nVolumetric cloud shader based on:\n\nhttps://www.guerrilla-games.com/read/the-real-time-volumetric-cloudscapes-of-horizon-zero-dawn\nhttps://www.guerrilla-games.com/read/nubis-realtime-volumetric-cloudscapes-in-a-nutshell\nhttps://media.contentapi.ea.com/content/dam/eacom/frostbite/files/s2016-pbs-frostbite-sky-clouds-new.pdf\nhttp://www.diva-portal.org/smash/get/diva2:1223894/FULLTEXT01.pdf\n\nhttps://www.shadertoy.com/view/XlBSRz\nhttps://www.shadertoy.com/view/4dSBDt\n\nBuffer A: Perlin-Worley noise atlas\nBuffer B: Camera and resolution change tracking\nBuffer C: Cloud map heightfield of three hemispheres\n\nWe ray march a density field and calculate the attenuation of light that reaches the camera.\nThe cloud shape is defined by a cloud map in Buffer C. The base shape is carved using a \nPerlin-Worley noise which has both fluffy plumes and an interconnecting structure. The noise\nis generated once in Buffer A based on the example listed at the top. The noise is stored in a \ntexture atlas of tiles with halo cells that allow for interpolation. Data is stored in \nduplicate and offset using the red and green channels so that we can get the values above \nand below any 3D point using a single texture read.\n\nThe lighting theory is presented in the sources above. Light attenuation uses the Beer-Lambert\nlaw, the phase function is a two-lobed Henyey-Greenstein function and we include the powder \neffect discussed in the original HZD presentation.\n\nTaking fewer raymarching steps leads to better performance but also banding artefacts. We use \nblue noise to offset the initial sample position along the ray each frame. This dithering gets\nrid of the banding and gives a more uniform look. As blue noise is only blue in space, not \ntime, we follow the example by @demofox and add the golden ratio to the offset to get a low \ndiscrepancy sequence in time.\n\nTODO:\tDynamic atlas size.\n\n*/\n\n//------- Uncomment for fewer ray marching steps and better performance\n//#define FAST\n\n#ifdef FAST\n\t#define STEPS_PRIMARY 16\n#else\n\t#define STEPS_PRIMARY 32\n#endif\n\n#define STEPS_LIGHT 10\n\n\n//------- Uncomment for coloured cloud\n//#define COLOUR_SCATTERING\n\n//------- Uncomment to move the sun\n//#define ANIMATE_SUN\n\n//------- Uncomment for coloured light\n//#define COLOUR_LIGHT\n\n//------- Offset the sample point by blue noise every frame to get rid of banding\n#define DITHERING\nconst float goldenRatio = 1.61803398875;\n\n//For size of AABB\n#define CLOUD_EXTENT 100.0\n\nconst vec3 skyColour = 0.6 * vec3(0.09, 0.33, 0.81);\n\n//Scattering and absorption coefficients\n#ifdef COLOUR_SCATTERING\nconst vec3 sigmaS = vec3(0.5, 1.0, 1.0);\n#else\nconst vec3 sigmaS = vec3(1);\n#endif\nconst vec3 sigmaA = vec3(0.0);\n\n//Extinction coefficient.\nconst vec3 sigmaE = max(sigmaS + sigmaA, vec3(1e-6));\n\nconst float power = 200.0;\nconst float densityMultiplier = 0.65;\n\nconst float shapeSize = 0.35;\nconst float detailSize = 0.9;\n\nconst float shapeStrength = 0.5;\nconst float detailStrength = 0.25;\n\nconst float cloudStart = 0.0;\nconst float cloudEnd = CLOUD_EXTENT;\n\nconst vec3 minCorner = vec3(-CLOUD_EXTENT, cloudStart, -CLOUD_EXTENT);\nconst vec3 maxCorner = vec3(CLOUD_EXTENT, cloudEnd, CLOUD_EXTENT);\n\nvec3 rayDirection(float fieldOfView, vec2 fragCoord) {\n    vec2 xy = fragCoord - iResolution.xy / 2.0;\n    float z = (0.5 * iResolution.y) / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n//https://www.geertarien.com/blog/2017/07/30/breakdown-of-the-lookAt-function-in-OpenGL/\nmat3 lookAt(vec3 camera, vec3 targetDir, vec3 up){\n  vec3 zaxis = normalize(targetDir);    \n  vec3 xaxis = normalize(cross(zaxis, up));\n  vec3 yaxis = cross(xaxis, zaxis);\n\n  return mat3(xaxis, yaxis, -zaxis);\n}\n\n//Darken sky when looking up.\nvec3 getSkyColour(vec3 rayDir){\n    return mix(skyColour, 0.5*skyColour, rayDir.y);\n}\n\n//Return the near and far intersections of an infinite ray and a sphere. \n//Assumes sphere at origin. No intersection if result.x > result.y\nvec2 sphereIntersections(vec3 start, vec3 dir, float radius){\n\tfloat a = dot(dir, dir);\n\tfloat b = 2.0 * dot(dir, start);\n    float c = dot(start, start) - (radius * radius);\n\tfloat d = (b*b) - 4.0*a*c;\n\tif (d < 0.0){\n        return vec2(1e5, -1e5);\n\t}\n\treturn vec2((-b - sqrt(d))/(2.0*a), (-b + sqrt(d))/(2.0*a));\n}\n\n//https://gist.github.com/DomNomNom/46bb1ce47f68d255fd5d\n//Compute the near and far intersections using the slab method.\n//No intersection if tNear > tFar.\nvec2 intersectAABB(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {\n    vec3 tMin = (boxMin - rayOrigin) / rayDir;\n    vec3 tMax = (boxMax - rayOrigin) / rayDir;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    return vec2(tNear, tFar);\n}\n\nbool insideAABB(vec3 p){\n    float eps = 1e-4;\n\treturn  (p.x > minCorner.x-eps) && (p.y > minCorner.y-eps) && (p.z > minCorner.z-eps) && \n\t\t\t(p.x < maxCorner.x+eps) && (p.y < maxCorner.y+eps) && (p.z < maxCorner.z+eps);\n}\n\nbool getCloudIntersection(vec3 org, vec3 dir, out float distToStart, out float totalDistance){\n\tvec2 intersections = intersectAABB(org, dir, minCorner, maxCorner);\n\t\n    if(insideAABB(org)){\n        intersections.x = 1e-4;\n    }\n    \n    distToStart = intersections.x;\n    totalDistance = intersections.y - intersections.x;\n    return intersections.x > 0.0 && (intersections.x < intersections.y);\n}\n\n\nfloat getPerlinWorleyNoise(vec3 pos){\n    //The cloud shape texture is an atlas of 6*6 tiles (36). \n    //Each tile is 32*32 with a 1 pixel wide boundary.\n    //Per tile:\t\t32 + 2 = 34.\n    //Atlas width:\t6 * 34 = 204.\n    //The rest of the texture is black.\n    //The 3D texture the atlas represents has dimensions 32 * 32 * 36.\n    //The green channel is the data of the red channel shifted by one tile.\n    //(tex.g is the data one level above tex.r). \n    //To get the necessary data only requires a single texture fetch.\n    const float dataWidth = 204.0;\n    const float tileRows = 6.0;\n    const vec3 atlasDimensions = vec3(32.0, 32.0, 36.0);\n\n    //Change from Y being height to Z being height.\n    vec3 p = pos.xzy;\n\n    //Pixel coordinates of point in the 3D data.\n    vec3 coord = vec3(mod(p, atlasDimensions));\n    float f = fract(coord.z);  \n    float level = floor(coord.z);\n    float tileY = floor(level/tileRows); \n    float tileX = level - tileY * tileRows;\n\n    //The data coordinates are offset by the x and y tile, the two boundary cells \n    //between each tile pair and the initial boundary cell on the first row/column.\n    vec2 offset = atlasDimensions.x * vec2(tileX, tileY) + 2.0 * vec2(tileX, tileY) + 1.0;\n    vec2 pixel = coord.xy + offset;\n    vec2 data = texture(iChannel0, mod(pixel, dataWidth)/iChannelResolution[0].xy).xy;\n    return mix(data.x, data.y, f);\n}\n\n//Read cloud map.\nfloat getCloudMap(vec3 p){\n    vec2 uv = 0.5+0.5*(p.xz/(1.8*CLOUD_EXTENT));\n    return texture(iChannel2, uv).x;\n}\n\nfloat clouds(vec3 p, out float cloudHeight, bool sampleNoise){\n    if(!insideAABB(p)){\n    \treturn 0.0;\n    }\n\n    cloudHeight = saturate((p.y - cloudStart)/(cloudEnd-cloudStart));\n    float cloud = getCloudMap(p);\n\n    //If there are no clouds, exit early.\n    if(cloud <= 0.0){\n      return 0.0;\n    }\n\n    //Sample texture which determines how high clouds reach.\n    float height = pow(cloud, 0.75);\n    \n    //Round the bottom and top of the clouds. From \"Real-time rendering of volumetric clouds\". \n    cloud *= saturate(remap(cloudHeight, 0.0, 0.175, 0.25, 1.0))\n             * saturate(remap(cloudHeight, 0.75*height, height, 1.0, 0.0));\n\n    //Animate main shape.\n    p += vec3(2.0*iTime);\n    \n    //Get main shape noise, invert and scale it.\n    float shape = 1.0-getPerlinWorleyNoise(shapeSize * p);\n    shape *= shapeStrength;\n\n    //Carve away density from cloud based on noise.\n    cloud = saturate(remap(cloud, shape, 1.0, 0.0, 1.0));\n\n    //Early exit from empty space\n    if(cloud <= 0.0){\n      return 0.0;    \n    }\n    \n    //Animate details.\n    p += vec3(4.0*iTime, 0.0, iTime);\n    \n    float detail = getPerlinWorleyNoise(detailSize*p);\n    //Invert detail noise to subtract from the main shape.\n    //Leave the value at the bottom of the cloud to introduce wispy shapes there.\n\tdetail = mix(detail, 1.0-detail, saturate(cloudHeight * 10.0));\n\tdetail *= detailStrength;\n    \n\t//Carve away detail based on the noise\n\tcloud = saturate(remap(cloud, detail, 1.0, 0.0, 1.0));\n    return densityMultiplier * cloud;\n}\n\nfloat HenyeyGreenstein(float g, float costh){\n\treturn (1.0/(4.0 * 3.1415))  * ((1.0 - g * g) / pow(1.0 + g*g - 2.0*g*costh, 1.5));\n}\n\n//https://twitter.com/FewesW/status/1364629939568451587/photo/1\nvec3 multipleOctaves(float extinction, float mu, float stepL){\n\n    vec3 luminance = vec3(0);\n    const float octaves = 4.0;\n    \n    //Attenuation\n    float a = 1.0;\n    //Contribution\n    float b = 1.0;\n    //Phase attenuation\n    float c = 1.0;\n    \n    float phase;\n    \n    for(float i = 0.0; i < octaves; i++){\n        //Two-lobed HG\n        phase = mix(HenyeyGreenstein(-0.1*c, mu), HenyeyGreenstein(0.3*c, mu), 0.7);\n        luminance += b * phase * exp(-stepL * extinction * sigmaE * a);\n        //Lower is brighter\n        a *= 0.2;\n        //Higher is brighter\n        b *= 0.5;\n        c *= 0.5;\n    }\n    return luminance;\n}\n\n//Get the amount of light that reaches a sample point.\nvec3 lightRay(vec3 org, vec3 p, float phaseFunction, float mu, vec3 sunDirection){\n\n\tfloat lightRayDistance = CLOUD_EXTENT*0.75;\n    float distToStart = 0.0;\n    \n    getCloudIntersection(p, sunDirection, distToStart, lightRayDistance);\n        \n    float stepL = lightRayDistance/float(STEPS_LIGHT);\n\n\tfloat lightRayDensity = 0.0;\n    \n    float cloudHeight = 0.0;\n\n\t//Collect total density along light ray.\n\tfor(int j = 0; j < STEPS_LIGHT; j++){\n\t\n\t\tbool sampleDetail = true;\n\t\tif(lightRayDensity > 0.3){\n\t\t\tsampleDetail = false;\n\t\t}\n        \n\t\tlightRayDensity += clouds(p + sunDirection * float(j) * stepL, cloudHeight, sampleDetail);\n\t}\n    \n\tvec3 beersLaw = multipleOctaves(lightRayDensity, mu, stepL);\n\t\n    //Return product of Beer's law and powder effect depending on the \n    //view direction angle with the light direction.\n\treturn mix(beersLaw * 2.0 * (1.0-(exp(-stepL*lightRayDensity*2.0*sigmaE))), beersLaw, 0.5+0.5*mu);\n}\n\n//Get the colour along the main view ray.\nvec3 mainRay(vec3 org, vec3 dir, vec3 sunDirection, \n             out vec3 totalTransmittance, float mu, vec3 sunLightColour, float offset){\n    \n\t//Variable to track transmittance along view ray. \n    //Assume clear sky and attenuate light when encountering clouds.\n\ttotalTransmittance = vec3(1.0);\n\n\t//Default to black.\n\tvec3 colour = vec3(0.0);\n    \n    //The distance at which to start ray marching.\n    float distToStart = 0.0;\n    \n    //The length of the intersection.\n    float totalDistance = 0.0;\n\n    //Determine if ray intersects bounding volume.\n\t//Set ray parameters in the cloud layer.\n\tbool renderClouds = getCloudIntersection(org, dir, distToStart, totalDistance);\n\n\tif(!renderClouds){\n\t\treturn colour;\n    }\n\n\t//Sampling step size.\n    float stepS = totalDistance / float(STEPS_PRIMARY); \n    \n    //Offset the starting point by blue noise.\n    distToStart += stepS * offset;\n    \n    //Track distance to sample point.\n    float dist = distToStart;\n\n    //Initialise sampling point.\n    vec3 p = org + dist * dir;\n    \n    //Combine backward and forward scattering to have details in all directions.\n\tfloat phaseFunction = mix(HenyeyGreenstein(-0.3, mu), HenyeyGreenstein(0.3, mu), 0.7);\n    \n    vec3 sunLight = sunLightColour * power;\n\n\tfor(int i = 0; i < STEPS_PRIMARY; i++){\n\n        //Normalised height for shaping and ambient lighting weighting.\n        float cloudHeight;\n\n        //Get density and cloud height at sample point\n        float density = clouds(p, cloudHeight, true);\n\n        vec3 sampleSigmaS = sigmaS * density;\n        vec3 sampleSigmaE = sigmaE * density;\n\n        //If there is a cloud at the sample point.\n        if(density > 0.0 ){\n\n            //Constant lighting factor based on the height of the sample point.\n            vec3 ambient = sunLightColour * mix((0.2), (0.8), cloudHeight);\n\n            //Amount of sunlight that reaches the sample point through the cloud \n            //is the combination of ambient light and attenuated direct light.\n            vec3 luminance = 0.1 * ambient +\n               \tsunLight * phaseFunction * lightRay(org, p, phaseFunction, mu, sunDirection);\n\n            //Scale light contribution by density of the cloud.\n            luminance *= sampleSigmaS;\n\n            //Beer-Lambert.\n            vec3 transmittance = exp(-sampleSigmaE * stepS);\n\n            //Better energy conserving integration\n            //\"From Physically based sky, atmosphere and cloud rendering in Frostbite\" 5.6\n            //by Sebastian Hillaire.\n            colour += \n                totalTransmittance * (luminance - luminance * transmittance) / sampleSigmaE; \n\n            //Attenuate the amount of light that reaches the camera.\n            totalTransmittance *= transmittance;  \n\n            //If ray combined transmittance is close to 0, nothing beyond this sample \n            //point is visible, so break early.\n            if(length(totalTransmittance) <= 0.001){\n                totalTransmittance = vec3(0.0);\n                break;\n            }\n        }\n\n        dist += stepS;\n\n\t\t//Step along ray.\n\t\tp = org + dir * dist;\n\t}\n\n\treturn colour;\n}\n\nfloat getGlow(float dist, float radius, float intensity){\n    dist = max(dist, 1e-6);\n\treturn pow(radius/dist, intensity);\t\n}\n\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x){\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    //Get the default direction of the ray (along the negative Z direction)\n    vec3 rayDir = rayDirection(55.0, fragCoord);\n   \n    //----------------- Define a camera -----------------\n    \n    vec3 cameraPos = texelFetch(iChannel1, ivec2(0.5, 1.5), 0).xyz;\n\t\n    vec3 targetDir = -cameraPos + vec3(-10.0, cloudStart + 0.5 * (cloudEnd-cloudStart), -5.0);\n    \n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    //Get the view matrix from the camera orientation\n    mat3 viewMatrix = lookAt(cameraPos, targetDir, up);\n    \n    //Transform the ray to point in the correct direction\n    rayDir = normalize(viewMatrix * rayDir);\n    \n    //---------------------------------------------------\n\n    #ifdef COLOUR_LIGHT\n\t\tvec3 sunLightColour = 0.5 + 0.5 * cos(iTime+vec3(0,2,4));\n\t#else\n\t\tvec3 sunLightColour = vec3(1.0);\n\t#endif\n    \n    //azimuth\n\tfloat sunLocation = 1.0;\n\t//0: horizon, 1: zenith\n\tfloat sunHeight = 0.6;\n    \n\t#ifdef ANIMATE_SUN\n    \tsunLocation = iTime * 0.3;\n\t#endif\n    \n    vec3 sunDirection = normalize(vec3(cos(sunLocation), sunHeight, sin(sunLocation)));\n    \n    vec3 background = getSkyColour(rayDir);\n\n    float mu = 0.5+0.5*dot(rayDir, sunDirection);\n    background += sunLightColour * getGlow(1.0-mu, 0.00015, 0.9);\n   \n\tvec3 totalTransmittance = vec3(1.0);\n    \n    float offset = 0.0;\n    \n    #ifdef DITHERING\n    //Sometimes the blue noise texture is not immediately loaded into iChannel3\n    //leading to jitters.\n    if(iChannelResolution[3].xy == vec2(1024)){\n        //From https://blog.demofox.org/2020/05/10/ray-marching-fog-with-blue-noise/\n        //Get blue noise for the fragment.\n        float blueNoise = texture(iChannel3, fragCoord / 1024.0).r;\n\n    \t//Blue noise texture is blue in space but animating it leads to white noise in time.\n        //Adding golden ratio to a number yields a low discrepancy sequence (apparently),\n    \t//making the offset of each pixel more blue in time (use fract() for modulo 1).\n        //https://blog.demofox.org/2017/10/31/animating-noise-for-integration-over-time/\n        offset = fract(blueNoise + float(iFrame%32) * goldenRatio);\n    }\n    #endif\n\n    float exposure = 0.5;\n    vec3 colour = exposure * mainRay(cameraPos, rayDir, sunDirection, \n                                     totalTransmittance, dot(rayDir, sunDirection), sunLightColour, offset); \n\n    colour += background * totalTransmittance;\n   \n    //Tonemapping\n    colour = ACESFilm(colour);\n\n    //Gamma correction 1.0/2.2 = 0.4545...\n    colour = pow(colour, vec3(0.4545));\n    \n    //Output to screen\n    fragColor = vec4(colour, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Create a Perlin-Worley texture atlas for cloud shape carving.\n//Runs only once in the first frame.\n//Based on https://github.com/sebh/TileableVolumeNoise/blob/master/main.cpp\n\n//The atlas is a 6*6 grid of 32*32 tiles with a single layer of halo cells around each tile. \n\n//TODO: Assumes a size of at least 204*204. Make it work with any reasonable resolution.\n\n#define TILES 1.0\n#define NUM_CELLS 2.0\n\n#define PERLIN_WORLEY 0\n#define WORLEY 1\n\nvec4 taylorInvSqrt(vec4 r){\n\treturn 1.79284291400159-0.85373472095314*r;\n}\n\nvec4 mod289(vec4 x){\n    return x-floor(x*(1.0/289.0))*289.0;\n}\n\nvec4 permute(vec4 x){\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 fade(vec4 t){\n\treturn (t * t * t) * (t * (t * vec4(6) - vec4(15)) + vec4(10));\n}\n\n//From https://github.com/g-truc/glm/blob/master/glm/gtc/noise.inl\n//Classic Perlin noise, periodic version\nfloat glmPerlin(vec4 Position, vec4 rep){\n  vec4 Pi0 = mod(floor(Position), rep); // Integer part modulo rep\n  vec4 Pi1 = mod(Pi0 + float(1), rep); // Integer part + 1 mod rep\n  vec4 Pf0 = fract(Position); // Fractional part for interpolation\n  vec4 Pf1 = Pf0 - float(1); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.y, Pi0.y, Pi1.y, Pi1.y);\n  vec4 iz0 = vec4(Pi0.z);\n  vec4 iz1 = vec4(Pi1.z);\n  vec4 iw0 = vec4(Pi0.w);\n  vec4 iw1 = vec4(Pi1.w);\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n  vec4 ixy00 = permute(ixy0 + iw0);\n  vec4 ixy01 = permute(ixy0 + iw1);\n  vec4 ixy10 = permute(ixy1 + iw0);\n  vec4 ixy11 = permute(ixy1 + iw1);\n\n  vec4 gx00 = ixy00 / float(7);\n  vec4 gy00 = floor(gx00) / float(7);\n  vec4 gz00 = floor(gy00) / float(6);\n  gx00 = fract(gx00) - float(0.5);\n  gy00 = fract(gy00) - float(0.5);\n  gz00 = fract(gz00) - float(0.5);\n  vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n  vec4 sw00 = step(gw00, vec4(0));\n  gx00 -= sw00 * (step(float(0), gx00) - float(0.5));\n  gy00 -= sw00 * (step(float(0), gy00) - float(0.5));\n\n  vec4 gx01 = ixy01 / float(7);\n  vec4 gy01 = floor(gx01) / float(7);\n  vec4 gz01 = floor(gy01) / float(6);\n  gx01 = fract(gx01) - float(0.5);\n  gy01 = fract(gy01) - float(0.5);\n  gz01 = fract(gz01) - float(0.5);\n  vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n  vec4 sw01 = step(gw01, vec4(0.0));\n  gx01 -= sw01 * (step(float(0), gx01) - float(0.5));\n  gy01 -= sw01 * (step(float(0), gy01) - float(0.5));\n\n  vec4 gx10 = ixy10 / float(7);\n  vec4 gy10 = floor(gx10) / float(7);\n  vec4 gz10 = floor(gy10) / float(6);\n  gx10 = fract(gx10) - float(0.5);\n  gy10 = fract(gy10) - float(0.5);\n  gz10 = fract(gz10) - float(0.5);\n  vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n  vec4 sw10 = step(gw10, vec4(0.0));\n  gx10 -= sw10 * (step(float(0), gx10) - float(0.5));\n  gy10 -= sw10 * (step(float(0), gy10) - float(0.5));\n\n  vec4 gx11 = ixy11 / float(7);\n  vec4 gy11 = floor(gx11) / float(7);\n  vec4 gz11 = floor(gy11) / float(6);\n  gx11 = fract(gx11) - float(0.5);\n  gy11 = fract(gy11) - float(0.5);\n  gz11 = fract(gz11) - float(0.5);\n  vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n  vec4 sw11 = step(gw11, vec4(float(0)));\n  gx11 -= sw11 * (step(float(0), gx11) - float(0.5));\n  gy11 -= sw11 * (step(float(0), gy11) - float(0.5));\n\n  vec4 g0000 = vec4(gx00.x, gy00.x, gz00.x, gw00.x);\n  vec4 g1000 = vec4(gx00.y, gy00.y, gz00.y, gw00.y);\n  vec4 g0100 = vec4(gx00.z, gy00.z, gz00.z, gw00.z);\n  vec4 g1100 = vec4(gx00.w, gy00.w, gz00.w, gw00.w);\n  vec4 g0010 = vec4(gx10.x, gy10.x, gz10.x, gw10.x);\n  vec4 g1010 = vec4(gx10.y, gy10.y, gz10.y, gw10.y);\n  vec4 g0110 = vec4(gx10.z, gy10.z, gz10.z, gw10.z);\n  vec4 g1110 = vec4(gx10.w, gy10.w, gz10.w, gw10.w);\n  vec4 g0001 = vec4(gx01.x, gy01.x, gz01.x, gw01.x);\n  vec4 g1001 = vec4(gx01.y, gy01.y, gz01.y, gw01.y);\n  vec4 g0101 = vec4(gx01.z, gy01.z, gz01.z, gw01.z);\n  vec4 g1101 = vec4(gx01.w, gy01.w, gz01.w, gw01.w);\n  vec4 g0011 = vec4(gx11.x, gy11.x, gz11.x, gw11.x);\n  vec4 g1011 = vec4(gx11.y, gy11.y, gz11.y, gw11.y);\n  vec4 g0111 = vec4(gx11.z, gy11.z, gz11.z, gw11.z);\n  vec4 g1111 = vec4(gx11.w, gy11.w, gz11.w, gw11.w);\n\n  vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), \n                                   dot(g1100, g1100)));\n  g0000 *= norm00.x;\n  g0100 *= norm00.y;\n  g1000 *= norm00.z;\n  g1100 *= norm00.w;\n\n  vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), \n                                   dot(g1101, g1101)));\n  g0001 *= norm01.x;\n  g0101 *= norm01.y;\n  g1001 *= norm01.z;\n  g1101 *= norm01.w;\n\n  vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), \n                                   dot(g1110, g1110)));\n  g0010 *= norm10.x;\n  g0110 *= norm10.y;\n  g1010 *= norm10.z;\n  g1110 *= norm10.w;\n\n  vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), \n                                   dot(g1111, g1111)));\n  g0011 *= norm11.x;\n  g0111 *= norm11.y;\n  g1011 *= norm11.z;\n  g1111 *= norm11.w;\n\n  float n0000 = dot(g0000, Pf0);\n  float n1000 = dot(g1000, vec4(Pf1.x, Pf0.y, Pf0.z, Pf0.w));\n  float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.z, Pf0.w));\n  float n1100 = dot(g1100, vec4(Pf1.x, Pf1.y, Pf0.z, Pf0.w));\n  float n0010 = dot(g0010, vec4(Pf0.x, Pf0.y, Pf1.z, Pf0.w));\n  float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n  float n0110 = dot(g0110, vec4(Pf0.x, Pf1.y, Pf1.z, Pf0.w));\n  float n1110 = dot(g1110, vec4(Pf1.x, Pf1.y, Pf1.z, Pf0.w));\n  float n0001 = dot(g0001, vec4(Pf0.x, Pf0.y, Pf0.z, Pf1.w));\n  float n1001 = dot(g1001, vec4(Pf1.x, Pf0.y, Pf0.z, Pf1.w));\n  float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n  float n1101 = dot(g1101, vec4(Pf1.x, Pf1.y, Pf0.z, Pf1.w));\n  float n0011 = dot(g0011, vec4(Pf0.x, Pf0.y, Pf1.z, Pf1.w));\n  float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.z, Pf1.w));\n  float n0111 = dot(g0111, vec4(Pf0.x, Pf1.y, Pf1.z, Pf1.w));\n  float n1111 = dot(g1111, Pf1);\n\n  vec4 fade_xyzw = fade(Pf0);\n  vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), \n                  vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n  vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), \n                  vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n  vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n  vec2 n_yzw = mix(vec2(n_zw.x, n_zw.y), vec2(n_zw.z, n_zw.w), fade_xyzw.y);\n  float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n  return float(2.2) * n_xyzw;\n}\n\nfloat getPerlinNoise(vec3 pos, float frequency){\n\t//Noise frequency factor between octave.\n\tconst float octaveFrequencyFactor = 2.0;\n\n\t//Compute the sum for each octave.\n\tfloat sum = 0.0;\n\tfloat weightSum = 0.0;\n\tfloat weight = 1.0;\n\tfor(int oct = 0; oct < 3; oct++){\n\n        vec3 p = pos * frequency;\n        //Hillaire says that the 3D version of tileable perlin noise in GLM is broken.\n        //Use 4D noise with w component set to 0 as in example code.\n        float val = 0.5 + 0.5 * glmPerlin(vec4(p, 0.0), vec4(frequency));\n        sum += val * weight;\n        weightSum += weight;\n\n        weight *= 0.5;\n        frequency *= octaveFrequencyFactor;\n\t}\n\n    float noise = (sum / weightSum);\n\tnoise = saturate(noise);\n\treturn noise;\n}\n\nfloat hash(float n){\n\treturn fract(sin(n) * 43758.5453);\n}\n\n//From Shadertoy somewhere but not sure where originally.\nfloat noise(in vec3 x){\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\n\tf = f*f*(3.0 - 2.0 * f);\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\treturn mix(\n\tmix(\n       \tmix(hash(n + 0.0), hash(n + 1.0), f.x),\n\t\tmix(hash(n + 57.0), hash(n + 58.0), f.x),\n\t\tf.y),\n\tmix(\n\t\tmix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\tmix(hash(n + 170.0), hash(n + 171.0), f.x),\n\t\tf.y),\n\tf.z);\n}\n\n\nfloat worley(vec3 pos, float numCells){\n\tvec3 p = pos * numCells;\n\tfloat d = 1.0e10;\n\tfor (int x = -1; x <= 1; x++){\n\t\tfor (int y = -1; y <= 1; y++){\n\t\t\tfor (int z = -1; z <= 1; z++){\n                vec3 tp = floor(p) + vec3(x, y, z);\n                tp = p - tp - noise(mod(tp, numCells / TILES));\n                d = min(d, dot(tp, tp));\n            }\n        }\n    }\n\treturn 1.0 - clamp(d, 0.0, 1.0);\n}\n\n//Return the 3D coordinate corresponding to the 2D atlas uv coordinate.\nvec3 get3Dfrom2D(vec2 uv, float tileRows){\n    vec2 tile = floor(uv);\n    float z = floor(tileRows * tile.y + tile.x);\n    return vec3(fract(uv), z);\n}\n\nfloat getTextureForPoint(vec3 p, int type){\n\tfloat res;\n    if(type == PERLIN_WORLEY){\n        \n        //Perlin-Worley.\n        const float frequency = 8.0;\n        float perlinNoise = getPerlinNoise(p, frequency);\n        res = perlinNoise;\n\n        //Special weights from example code.\n        float worley0 = worley(p, NUM_CELLS*2.0);\n        float worley1 = worley(p, NUM_CELLS*8.0);\n        float worley2 = worley(p, NUM_CELLS*14.0);\n\n        float worleyFBM = worley0 * 0.625 + worley1 * 0.25 + worley2 * 0.125;\n        res = remap(perlinNoise, 0.0, 1.0, worleyFBM, 1.0);\n        \n\t}else{\n\n        //Worley\n        float worley0 = worley(p, NUM_CELLS);\n        float worley1 = worley(p, NUM_CELLS*2.0);\n        float worley2 = worley(p, NUM_CELLS*4.0);\n        float worley3 = worley(p, NUM_CELLS*8.0);\n\n        float FBM0 = worley0 * 0.625 + worley1 * 0.25 + worley2 * 0.125;\n\t\tfloat FBM1 = worley1 * 0.625 + worley2 * 0.25 + worley3 * 0.125;\n\t\tfloat FBM2 = worley2 * 0.75 + worley3 * 0.25;\n\n        res = FBM0 * 0.625 + FBM1 * 0.25 + FBM2 * 0.125;\n\t}\n    \n\treturn res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    if(iFrame < 1 || length(texelFetch(iChannel0, ivec2(0), 0).rgba) == 0.0){\n        vec3 col = vec3(0);\n        //32 with 1 pixel on either side.\n        float tileSize = 34.0;\n        float padWidth = 1.0;\n        float coreSize = tileSize - 2.0 * padWidth;\n        float tileRows = 6.0;\n        float tileCount = tileRows * tileRows;\n        vec2 tile = floor((fragCoord.xy - 0.5) / tileSize);\n\n        bool padCell = false;\n        if(mod(fragCoord.x, tileSize) == 0.5 || mod(fragCoord.x, tileSize) == tileSize - 0.5){\n            padCell = true;\n        }\n        if(mod(fragCoord.y, tileSize) == 0.5 || mod(fragCoord.y, tileSize) == tileSize - 0.5){\n            padCell = true;\n        }\n\n        bool startPadX = false;\n        bool endPadX = false;\n        bool startPadY = false;\n        bool endPadY = false;\n        if(fragCoord.x == tile.x * tileSize + 0.5){\n            startPadX = true;\n        }\n        if(fragCoord.y == tile.y * tileSize + 0.5){\n            startPadY = true;\n        }\n        if(fragCoord.x == (tile.x + 1.0) * tileSize - 0.5){\n            endPadX = true;\n        }\n        if(fragCoord.y == (tile.y + 1.0) * tileSize - 0.5){\n            endPadY = true;\n        }\n        vec2 padding = vec2(2.0 * padWidth) * tile;\n        vec2 pixel;\n        vec2 uv;\n        \n        if(!padCell){\n            pixel = fragCoord.xy - padWidth - padding;\n            uv = vec2(pixel.xy/coreSize);\n        }else{\n            pixel = fragCoord.xy - padWidth - padding;\n            if(startPadX){\n                pixel.x += coreSize;\t\n            }\n            if(startPadY){\n                pixel.y += coreSize;\t\n            }\n            if(endPadX){\n                pixel.x -= coreSize;\t\n            }\n            if(endPadY){\n                pixel.y -= coreSize;\t\n            }\n            uv = vec2(pixel.xy/coreSize);\n        }\n        \n        vec3 p_ = get3Dfrom2D(uv, tileRows);\n        vec3 p = p_;\n        p.z /= (tileRows*tileRows);\n\n        //Get Perlin-Worley noise for level l\n        float worleyPerlinNoise = getTextureForPoint(p, PERLIN_WORLEY);\n\n        //Get Worley noise for level l\n        float worleyNoise = getTextureForPoint(p, WORLEY);\n        col.r = saturate(remap(worleyPerlinNoise, worleyNoise, 1.0, 0.0, 1.0));\n\n        p_ = mod(p_ + 1.0, tileRows * tileRows);\n        p = p_;\n        p.z /= (tileRows*tileRows);\n\n        //Get Perlin-Worley noise for level l+1\n        worleyPerlinNoise = getTextureForPoint(p, PERLIN_WORLEY);\n\n        //Get Worley noise for level l+1\n        worleyNoise = getTextureForPoint(p, WORLEY);\n        col.g = saturate(remap(worleyPerlinNoise, worleyNoise, 1.0, 0.0, 1.0));\n\n        //Unused cells\n        if(gl_FragCoord.x > tileRows * tileSize || gl_FragCoord.y > tileRows * tileSize){\n            col = vec3(0);\n        }\n        \n    \tfragColor = vec4(col,1.0);\n        \n    }else{\n        \n    \tfragColor = texelFetch(iChannel0, ivec2(fragCoord - 0.5), 0).rgba;\n        \n    }\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Track mouse movement and resolution change between frames and set camera position.\n\n#define PI 3.14159\n#define EPS 1e-4\n#define CAMERA_DIST 180.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    //Work with just the first four pixels.\n    if((fragCoord.x == 0.5) && (fragCoord.y < 4.0)){\n        \n        vec4 oldMouse = texelFetch(iChannel0, ivec2(0.5), 0).xyzw;\n        vec4 mouse = (iMouse / iResolution.xyxy); \n        vec4 newMouse = vec4(0);\n\n        float mouseDownLastFrame = texelFetch(iChannel0, ivec2(0.5, 3.5), 0).x;\n        \n        //If mouse button is down and was down last frame\n        if(iMouse.z > 0.0 && mouseDownLastFrame > 0.0){\n            \n            //Difference between mouse position last frame and now.\n            vec2 mouseMove = mouse.xy-oldMouse.zw;\n            newMouse = vec4(oldMouse.xy + vec2(5.0, 3.0)*mouseMove, mouse.xy);\n            \n        }else{\n            newMouse = vec4(oldMouse.xy, mouse.xy);\n        }\n        newMouse.x = mod(newMouse.x, 2.0*PI);\n        newMouse.y = min(0.99, max(-0.99, newMouse.y));\n\n        //Store mouse data in the first pixel of Buffer B.\n        if(fragCoord == vec2(0.5, 0.5)){\n            ///Set value at first frames\n            if(iFrame < 5){\n                newMouse = vec4(-1.9, 0.2, 0.0, 0.0);\n            }\n            fragColor = vec4(newMouse);\n        }\n\n        //Store camera position in the second pixel of Buffer B.\n        if(fragCoord == vec2(0.5, 1.5)){\n            //Set camera position from mouse information.\n            vec3 cameraPos = vec3(-10.0, 0.0, -5.0) + CAMERA_DIST * vec3(sin(newMouse.x), -sin(newMouse.y), -cos(newMouse.x));\n            fragColor = vec4(cameraPos, 1.0);\n        }\n        \n        //Store resolution change data in the third pixel of Buffer B.\n        if(fragCoord == vec2(0.5, 2.5)){\n            float resolutionChangeFlag = 0.0;\n            //The resolution last frame.\n            vec2 oldResolution = texelFetch(iChannel0, ivec2(0.5, 2.5), 0).yz;\n            \n            if(iResolution.xy != oldResolution){\n            \tresolutionChangeFlag = 1.0;\n            }\n            \n        \tfragColor = vec4(resolutionChangeFlag, iResolution.xy, 1.0);\n        }\n           \n        //Store whether the mouse button is down in the fourth pixel of Buffer A\n        if(fragCoord == vec2(0.5, 3.5)){\n            if(iMouse.z > 0.0){\n            \tfragColor = vec4(vec3(1.0), 1.0);\n            }else{\n            \tfragColor = vec4(vec3(0.0), 1.0);\n            }\n        }\n        \n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float saturate(float x){\n\treturn clamp(x, 0.0, 1.0);\n}\n\nfloat remap(float x, float low1, float high1, float low2, float high2){\n\treturn low2 + (x - low1) * (high2 - low2) / (high1 - low1);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//Simple cloud map to define where clouds occur.\n\nfloat circularOut(float t) {\n  return sqrt((2.0 - t) * t);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    bool resolutionChanged = (texelFetch(iChannel0, ivec2(0.5, 2.5), 0).x == 1.0);\n    \n    //Draw map at the first frame or when the resolution has changed.\n    if(iFrame < 1 || resolutionChanged){\n    \tvec2 uv = fragCoord/iResolution.xy;\n        uv -= 0.5;\n\n        //Three overlapping circles.\n        uv *= 5.0;\n        float dist = circularOut(max(0.0, 1.0-length(uv)));\n        uv *= 1.2;\n        dist = max(dist, 0.8*circularOut(max(0.0, 1.0-length(uv+0.65))));\n        uv *= 1.3;\n        dist = max(dist, 0.75*circularOut(max(0.0, 1.0-length(uv-0.75))));\n\n        vec3 col = vec3(dist);\n\n        fragColor = vec4(col,1.0);\n    }else{\n        //Reuse data in buffer.\n    \tfragColor = texelFetch(iChannel1, ivec2(fragCoord - 0.5), 0).rgba;;\n    }\n}","name":"Buffer C","description":"","type":"buffer"}]}