{"ver":"0.1","info":{"id":"XtycD1","date":"1535958713","viewed":2252,"name":"Leizex (made in 2008)","username":"iq","description":"\"Leizex\", a procedural graphics I made in 2008, as my 3rd ever SDF raymarched image (I was still investigating the technique). I copy+pasted the 10 years old code, which was C++ at the time, adjusted it a bit for GLSL and just worked!","likes":51,"published":3,"flags":32,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by inigo quilez - iq/2008/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// This is \"Leizex\", a procedural graphics I made in 2008, which was my 3rd ever\n// raymarched image (I was still investigating and learning the technique).\n//\n// I just copy pasted the code, which run in C++ at the time, into GLSL and it pretty\n// much worked out of the box! It's glad to see that after 10 years my code hasn't\n// changed that much really, in cluding vaiable names!\n//\n// Link to the original piece: https://iquilezles.org/prods/index.htm#leizex\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tivec2 p = ivec2(fragCoord);\n    \n    // blur (could be optimized by maing it separable and HW interpolated in-between samples)\n    vec3 col = vec3(0.0);\n    for( int m=-4; m<=4; m++ )\n    for( int n=-4; n<=4; n++ )\n    {\n        vec2 uv = (fragCoord + vec2(float(m),float(n)) )/iResolution.xy;\n        col += textureLod(iChannel0, uv, 0.0 ).xyz;\n    }\n    col /= 81.0;\n\n\n    // mix (blur only on borders)\n    float x = fragCoord.x/iResolution.x;\n    float f = clamp( 4.0*abs(x-0.5)-1.0, 0.0, 1.0 );\n    vec3 ori = texelFetch( iChannel0, p, 0 ).xyz;\n    col = mix( ori, col, 0.25 + 0.75*f );\n\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by inigo quilez - iq/2008/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// This is \"Leizex\", a procedural graphics I made in 2008, which was my 3rd ever\n// raymarched image (I was still investigating and learning the technique).\n//\n// I just copy pasted the code, which run in C++ at the time, into GLSL and it pretty\n// much worked out of the box! It's glad to see that after 10 years my code hasn't\n// changed that much really, in cluding vaiable names!\n//\n// Link to the original piece: https://iquilezles.org/prods/index.htm#leizex\n\n\nfloat hash( int n )\n{\n\tn = (n << 13) ^ n;\n    n = (n * (n * n * 15731 + 789221) + 1376312589) & 0x7fffffff;\n    return float(n)/2147483647.0;\n}\n\n\n// value noise\nfloat noise3f( in vec3 p, in int sem )\n{\n    ivec3 i = ivec3( floor(p) );\n    vec3  f = p - vec3(i);\n\n    // quintic smoothstep\n    vec3 w = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    int n = i.x + i.y * 57 + 113*i.z + sem;\n\n\treturn 1.0 - 2.0*mix(mix(mix(hash(n+(0+57*0+113*0)),\n                                 hash(n+(1+57*0+113*0)),w.x),\n                             mix(hash(n+(0+57*1+113*0)),\n                                 hash(n+(1+57*1+113*0)),w.x),w.y),\n                         mix(mix(hash(n+(0+57*0+113*1)),\n                                 hash(n+(1+57*0+113*1)),w.x),\n                             mix(hash(n+(0+57*1+113*1)),\n                                 hash(n+(1+57*1+113*1)),w.x),w.y),w.z);\n}\n\nfloat fbm( in vec3 p )\n{\n    return 0.5000*noise3f( p*1.0, 0 ) + \n           0.2500*noise3f( p*2.0, 0 ) + \n           0.1250*noise3f( p*4.0, 0 ) +\n           0.0625*noise3f( p*8.0, 0 );\n}\n\nvec2 celular( in vec3 p )\n{\n    ivec3 q = ivec3( floor(p) );\n    vec3  f = p - vec3(q);\n\n\tvec2 dmin = vec2( 2.0 );\n\n\tfor( int k=-1; k<=1; k++ )\n\tfor( int j=-1; j<=1; j++ )\n\tfor( int i=-1; i<=1; i++ )\n\t{\n\t\tint nn = (q.x+i) + 57*(q.y+j) + 113*(q.z+k);\n        vec3 di = vec3( float(i) + hash(nn     ),\n\t\t                float(j) + hash(nn+1217),\n\t\t                float(k) + hash(nn+2513) ) - f;\n\t\tfloat d2 = dot(di,di);\n\n        if( d2<dmin.x )\n        {\n            dmin.y = dmin.x;\n            dmin.x = d2;\n        }\n        else if( d2<dmin.y )\n        {\n            dmin.y = d2;\n        }\n\t}\n    \n    return 0.25*sqrt(dmin);\n}\n\n\nfloat map( in vec3 pos, out float occ )\n{\n    pos.yz -= 1.0;\n    \n    vec3 dd = fract(1024.0+pos) - 0.5;\n\tfloat dis = length(dd) - 0.09;\n\n\tfloat disp = noise3f( 4.0*pos, 0 );\n\tdis += 0.8*disp;\n\tocc = clamp(-1.5*disp, 0.0, 1.0);\n\n    if( dis<0.25 )\n    {\n\tvec2 cel = celular( 16.0*pos );\n\tfloat disp2 = clamp(cel.y - cel.x, 0.0, 1.0);\n\tdis -= 1.0*disp2;\n\tocc *= clamp(disp2*12.0,0.0,1.0);\n    }\n\n    return dis;\n}\n\n#define ZERO (min(iFrame,0))\n\nvec3 calcNormal( in vec3 pos )\n{\n    float kk;\n    float eps = 0.0002;\n#if 0    \n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*map( pos + e.xyy, kk ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, kk ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, kk ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, kk ) );\n\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 nor = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        nor += e*map(pos+eps*e, kk);\n    }\n    return normalize(nor);\n#endif    \n}\n\n\nfloat cast_ray( in vec3 ro, in vec3 rd, const float mindist, const float maxdist, out float matInfo )\n{\n    float t = mindist;\n    for( int i=0; i<256; i++ )\n    {\n        vec3 p = ro + t*rd;\n        float h = map( p, matInfo );\n        if( abs(h)<(0.005*t) || t>maxdist ) break;\n        t += h*0.1;\n    }\n    \n    if( t>maxdist ) t=-1.0;\n    \n\treturn t;\n}\n\n\nfloat bump( in vec3 pos )\n{\n\treturn fbm( 256.0*pos );\n}\n\nvec3 addbump( in vec3 xnor, float bumpa, in vec3 pos)\n{\n    const float ke = 0.0005;\n\n\tfloat kk =        bump( pos );\n    vec3 gra = vec3(  bump( pos+vec3(ke,0.0,0.0))-kk,\n                      bump( pos+vec3(0.0,ke,0.0))-kk,\n                      bump( pos+vec3(0.0,0.0,ke))-kk );\n\n    return normalize(xnor + bumpa*gra);\n}\n\nconst vec3 lig = vec3( 0.8, 0.5, -0.1 );\nvec3 shade( in vec3 pos, in vec3 nor, in vec3 ro, in vec3 rd, float dis, in float occ )\n{\n    // material\n    float f = 1.0 + 0.5*fbm(96.0*pos);\n    vec3 mate = vec3(f);\n\n    // bump\n    vec3 xnor = addbump( nor, 1.0, 0.25*pos );\n\n    // lighting\n    vec3 rgb = vec3(0.0);\n    rgb += mate*vec3(0.50,0.55,0.60)*occ;\n    rgb += mate*vec3(0.6,0.5,0.3)*3.0*occ*clamp(dot( xnor, lig ), 0.0, 1.0);\n\n    // fog extintion\n\trgb /= (1.0+dis);\n    // fog inscattering\n\trgb += vec3(0.53,0.57,0.50)*2.0*(1.0 - exp2(-0.25*dis));\n\n\treturn rgb;\n}\n\nvec3 colorCorrect( in vec3 rgb, in vec2 px )\n{\n    // grade\n    rgb = clamp( (rgb-0.1)*vec3(1.5,1.7,1.5)*1.1, 0.0, 1.0 );\n\n\t// vigneting\n    float v = px.x/iResolution.x;\n\trgb *= 0.5 + 2.0*v*(1.0-v);\n    \n    return rgb;\n}\n\n// ===========================================================================\n\nmat3 setCamera( in vec3 ro, in vec3 rt, in vec3 ru )\n{\n\tvec3 cw = normalize(rt-ro);\n\tvec3 cu = normalize( cross(cw,ru) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, -cw );\n}\n\nvoid generateRay(out vec3 rayDir, out vec3 rayPos, in vec2 px )\n{\n    vec2 s = (-iResolution.xy+2.0*px)/iResolution.y;\n    \n\n    // barrel distort\n\tfloat r2 = s.x*s.x*0.32 + s.y*s.y;\n\ts *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n    \n    // set camera position and orientation\n#if 0\n         rayPos = vec3( -0.1564345, 1.0938345,  0.0123116 );\n\tvec3 rayTar = vec3( -0.0408938, 0.4444526,  1.0619653 );\n\tvec3 rayUp  = vec3(  0.0,       0.9999299, -0.0118397 );\n#else\n    float time = 0.5 + iTime*0.5;\n    time = 0.5 - (iTime-10.0);\n\n    vec3 rayTar = vec3( 0.0, 0.5, 1.0 );\n\trayPos = rayTar - vec3(1.0,-0.75,1.0)*cos(6.2831853*time/20.0 + vec3(-1.5708,0.5,0.0));\n\trayTar += 0.075*vec3(noise3f(vec3(2.0*iTime,0.0,0.5),0),\n\t                     noise3f(vec3(2.0*iTime,0.1,0.4),7),\n\t                     noise3f(vec3(2.0*iTime,0.2,0.3),9));\n\tfloat roll = 0.1*noise3f(vec3(2.0*time,0.0,0.0),13);\n\tvec3 rayUp = vec3( 0.0, cos(roll), sin(roll) );\n#endif\n        \n    // compute camera matrix\n    mat3 mat = setCamera( rayPos, rayTar, rayUp );\n\n    // create ray direction\n    rayDir = normalize( mat * vec3( -s.x, s.y, -1.0 ) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // genearete ray\n    vec3 rd, ro; generateRay( rd, ro, fragCoord );\n\n    // ray march scene\n    vec3 col = vec3(0.0);\n    \n\tfloat matInfo;\n\tfloat t = cast_ray( ro, rd, 0.01, 15.0, matInfo );\n    if( t>0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n        col = shade( pos, nor, ro, rd, t, matInfo );\n    }\n    \n    // color grade\n\tcol = colorCorrect( col, fragCoord );\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}