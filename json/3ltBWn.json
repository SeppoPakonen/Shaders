{"ver": "0.1", "info": {"id": "3ltBWn", "date": "1612537123", "viewed": 174, "name": "Planetary Atmospheric Scattering", "username": "gelami", "description": "A basic planetary atmosphere with only Rayleigh scattering\nSingle loop, no inner loop\n\nNot physically based, just wanted to make a simple atmosphere\n", "likes": 5, "published": 3, "flags": 0, "usePreview": 0, "tags": [], "requires": ["texture", "imagebuf", "texturebuf"]}, "renderpass": [{"inputs": [{"id": "4sfGRn", "filepath": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "type": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "\n// Planetary Atmospheric Scattering - gelami\n// https://www.shadertoy.com/view/3ltBWn\n\n/**\n * \n * A basic planetary atmosphere with only Rayleigh scattering\n * Single loop, no inner loop\n *\n * Not physically based, just wanted to make a simple atmosphere\n * \n */\n\n#define bruh\n\n// Constants\n\n#define ZOOM 1.\n#define MAX_STEPS 5\n\n#if 0\n#define SCATTERING_COEFF vec3(0.106622, 0.324442, 0.683013)\n#else\n#define SCATTERING_COEFF (vec3(5.5e-2, 13.0e-2, 22.4e-2) * 2. )\n#endif\n\n#define PLANET_RADIUS 6.\n#define ATMOSPHERE_RADIUS 7.\n\n#define PLANET_POS vec3(0, 0, 0)\n\n#define DENSITY_SCALE 4.\n#define SCATTERING_STR 1.\n#define LIGHT_SCALE 1.\n\n#define SUN_COLOR vec3(1., .9, .65)\n\n// Toggles\n\n#define SUN_ROTATION\n#define PLANET_ROTATION\n\n//#define SKY_DOME\n\n// Common Constants\n#define EPS .001\n\n#define PI acos(-1.)\n#define TAU PI*2.\n\n#if HW_PERFORMANCE==0\n  #define AA 1\n#else\n  #define AA 2\n#endif\n\n\nvec2 raySphere( vec3 ro, vec3 rd, float r ) {\n\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - r*r;\n    float h = b*b  - c;\n    \n    if (h < 0.) return vec2(1000);\n    \n    h = sqrt(h);\n    return vec2(-b-h, -b+h);\n}\n\nmat2 rot2D( float a ) {\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nmat3 rot3D( vec3 a ) {\n    return mat3( cos(a.z)*cos(a.y), sin(a.z)*cos(a.y), -sin(a.y),\n             cos(a.z)*sin(a.y)*sin(a.x)-sin(a.z)*cos(a.x), sin(a.z)*sin(a.y)*sin(a.x)+cos(a.z)*cos(a.x), cos(a.y)*sin(a.x),\n             cos(a.z)*sin(a.y)*cos(a.x)+sin(a.z)*sin(a.x), sin(a.z)*sin(a.y)*cos(a.x)-cos(a.z)*sin(a.x), cos(a.y)*cos(a.x) );\n}\n\nvec2 equirectangularProjection( vec3 p ) {\n    return vec2(atan(p.y, p.x) / -TAU + .5, atan(p.z, length(p.xy)) / PI + .5);\n}\n\nvec3 getPlanetTexture( vec2 uv ) {\n    return texture(iChannel0, uv).rgb;\n}\n\nvec3 getPlanetTriplanarTexture( vec3 p, vec3 n, float s) {\n    vec3 xy = texture(iChannel0, p.xy).rgb;\n    vec3 yz = texture(iChannel0, p.yz).rgb;\n    vec3 xz = texture(iChannel0, p.xz).rgb;\n    \n    vec3 d = pow(abs(n), vec3(s));\n    d /= dot(d, vec3(1));\n    \n    return xy * d.z + yz * d.x + xz * d.y;\n}\n\nmat3 getCameraMatrix( in vec3 ro, in vec3 la, in float r) {\n\n    vec3 cw = normalize(la - ro);\n    vec3 cu = cross(cw, vec3(sin(r), 0, cos(r)));\n    vec3 cv = cross(cu, cw);\n    \n    return mat3(cu, cv, cw);\n}\n\nvec3 getSkyDomeDirection( in vec3 p ) {\n    \n    float z2 = p.x * p.x + p.y * p.y;\n    float phi = atan(p.y, p.x);\n    float theta = acos(1.0 - z2);\n    return vec3(\n        sin(theta) * cos(phi),\n        sin(theta) * sin(phi),\n        cos(theta));\n}\n\nfloat henyeyGreenstein( float cosTheta, float g ) {\n    float gg = g*g;\n    return (1. - gg) / (pow(1. + gg - g*2. * cosTheta, 1.5));\n}\n\nfloat getDensity( vec3 p ) {\n    \n    float d = (length(p) - PLANET_RADIUS) * 1. / (ATMOSPHERE_RADIUS - PLANET_RADIUS);\n    return exp(-max(d, .0001) * DENSITY_SCALE);\n}\n\n#define ZERO (min(iFrame, 0))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec3 totalCol = vec3(0);\n    \n  #if AA > 1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n    \n    vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n\n    vec2 p = (fragCoord.xy+o - .5 * iResolution.xy) / iResolution.y;\n  #else\n    vec2 p = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n  #endif\n  \n    vec4 mouse = iMouse / iResolution.xyxy;\n\n  #ifndef SKY_DOME\n    vec3 rayPos = vec3(2, -16, 1);\n    vec3 lookAtPos = vec3(0, 0, 0);\n  #else\n    vec3 rayPos = vec3(0, 0, PLANET_RADIUS + .001);\n    vec3 lookAtPos = vec3(0, 0, PLANET_RADIUS + 1.);\n  #endif    \n    \n    vec3 sunDir = normalize(vec3(.5, 1, .4));\n    \n    sunDir.yz *= rot2D(-mouse.y * TAU + PI);\n    sunDir.xy *= rot2D(mouse.x * TAU - PI);\n    \n  #ifdef SUN_ROTATION\n    sunDir.xy *= rot2D(iTime * .3);\n  #endif\n  \n  #ifdef PLANET_ROTATION\n    rayPos.xy *= rot2D(iTime * .4);\n  #endif\n    \n    mat3 camMat = getCameraMatrix(rayPos, lookAtPos, 0.);\n  #ifndef SKY_DOME\n    vec3 rayDir = normalize(camMat * vec3(p, ZOOM));\n  #else\n    vec3 rayDir = getSkyDomeDirection(vec3(p * 2.2, ZOOM));\n  #endif\n  \n    \n    vec3 planetPos = PLANET_POS;\n    \n    // Intersect planet and atmosphere\n    vec2 planetDist = raySphere(rayPos - planetPos, rayDir, PLANET_RADIUS);\n    vec2 atmospDist = raySphere(rayPos - planetPos, rayDir, ATMOSPHERE_RADIUS);\n    \n    planetDist = planetDist.x < 0. ? vec2(1000.) : planetDist;\n    \n    atmospDist.x = max(atmospDist.x, 0.);\n    \n    float planetMask = step(planetDist.x, 999.);\n    \n    vec3 plPos = rayPos + rayDir * planetDist.x - planetPos;\n    vec3 planetNormal = normalize(plPos);\n    vec3 planetTangent = cross(planetNormal, vec3(1, 0, 0));\n    vec2 planetUV = equirectangularProjection(plPos);\n    \n    // Planet texture and bump\n    vec3 planetTex = getPlanetTexture(planetUV);\n    \n    float planetTexH = dot(planetTex, vec3(1));\n    float planetTexHx = dot(getPlanetTexture(planetUV + vec2(EPS, 0)), vec3(1));\n    float planetTexHy = dot(getPlanetTexture(planetUV + vec2(0, EPS)), vec3(1));\n    \n    vec3 planetBump = vec3(planetTexHx, planetTexHy, 2.) - vec3(vec2(planetTexH), 0);\n    \n    mat3 planetTBN = mat3(planetTangent, cross(planetTangent, planetNormal), planetNormal);\n    \n    //vec3 bn = vec3(dot(dFdx(planetTexture), vec3(1)),\n    //               dot(dFdy(planetTexture), vec3(1)), 2.);\n    \n    planetNormal = normalize(planetTBN * planetBump);\n    \n    // Atmosphere\n    float atmospDepth = min(planetDist.x, atmospDist.y) - atmospDist.x;\n    float stepSize = atmospDepth / float(MAX_STEPS);\n    \n    vec3 pos = rayPos + rayDir * atmospDist.x - planetPos;\n    \n    float totalViewOD = 0.;\n    float totalLightOD = 0.;\n    \n    vec3 totalScatteredLight = vec3(0);\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        \n        pos += rayDir * stepSize;\n        \n        vec2 atmospDist = raySphere(pos, sunDir, ATMOSPHERE_RADIUS);\n        \n        float density = getDensity(pos);\n        \n        // Old derivative using forward differences\n        //float densityEps = getDensity(normalize(pos) * EPS + pos);\n        //float densityDeriv = (densityEps - density) * (1. / EPS);\n        \n        // Analytical derivative\n        float densityDeriv = -density * DENSITY_SCALE / (ATMOSPHERE_RADIUS - PLANET_RADIUS);\n        \n        float opticalDepthLight = -0.5 * density / (exp(-atmospDist.y) * densityDeriv * DENSITY_SCALE);\n        opticalDepthLight = max(opticalDepthLight, 0.);\n        \n        float opticalDepthView = density * stepSize;\n        \n        totalViewOD += opticalDepthView;\n        totalLightOD += opticalDepthLight;\n        \n        vec3 scatteredLight = (totalViewOD + opticalDepthLight) * SCATTERING_COEFF;\n        \n        totalScatteredLight += exp(-scatteredLight * SCATTERING_STR * LIGHT_SCALE) * opticalDepthView;\n    }\n    \n    float cosTheta = dot(sunDir, rayDir);\n    \n    float rayleighPhase = henyeyGreenstein(cosTheta, 0.);\n    \n    totalScatteredLight *= SCATTERING_COEFF * rayleighPhase * SUN_COLOR;\n    \n    vec3 opDepthScatter = exp(-totalViewOD * SCATTERING_COEFF * 6.);\n    \n    // Sun disk\n    vec3 sunDisk = smoothstep(.9998, 1., cosTheta) * SUN_COLOR * 5. * opDepthScatter * (1.-planetMask);\n    sunDisk += pow(max(cosTheta, 0.), 2e2) * SUN_COLOR * .5 * (1.-planetMask);\n \n    // Planet color\n    float planetDiffuse = max(dot(planetNormal, sunDir), 0.);\n    float planetSpecular = pow(max(dot(normalize(sunDir - rayDir), planetNormal), 0.), 16.) * .8;\n    \n    vec3 planetCol = vec3(.7, .45, .4) * opDepthScatter * planetMask;\n    planetCol *= mix(planetTex, vec3(1), .5);\n    planetCol *= planetDiffuse + planetSpecular;\n    \n    vec3 col = vec3(0);\n    \n    col = vec3(totalScatteredLight);\n    \n    col += sunDisk;\n    col += planetCol;\n\n    //col = pow(col, vec3(.4545));\n  \n  #ifdef SKY_DOME\n    col *= step(0., rayDir.z);\n  #endif\n  \n    totalCol += col;\n    \n  #if AA > 1\n    }\n    totalCol /= float(AA*AA);\n  #endif\n    \n    fragColor = vec4(totalCol, 1);\n}", "name": "Image", "description": "", "type": "image"}]}