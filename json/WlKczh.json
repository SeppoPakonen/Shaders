{"ver":"0.1","info":{"id":"WlKczh","date":"1625149293","viewed":674,"name":"Heavy Light Denoising","username":"Mathis","description":"Denoised indirect diffuse, glossy reflections and soft shadows glued together with simple TAA.\nWASD to move, mouse to look and n,m to rotate the sun.\n\nThe noise texture takes some time to load.","likes":30,"published":1,"flags":48,"usePreview":1,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nInspired by nvidia ReSTIR GI using screen space information.\nSSGI and SSR can be disabled by commenting the \"defines\" in the Common tab.\n\n\nTechnical:\n    Indirect diffuse: It uses screen space data for multiple bounce lighting.\n    Ray traced reflections: Combines screen space data and ray traced lighting. No temporal accumulation.\n    Ray traced shadows: No temporal accumulation.\n    TAA: Super simple, uses reprojection and neighbour clamping. No motion vectors are used.\n    Denoising: 3 different denoisers have been created.\n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv=fragCoord*IRES;\n    vec3 Color=texture(iChannel0,(uv*HRES+vec2(HRES.x,0.))*IRES).xyz;\n    \n    //DEBUG\n        //Color=Read3(texture(iChannel1,uv).x).xyz; //1 spp reflections\n            //Color=texture(iChannel1).zzz; //1 spp shadows\n            //Color=texture(iChannel3,uv).xyz; //Accumulated diffuse\n        //Color=Read3(texture(iChannel0,uv).y).xyz; //Normals\n        //Color=texture(iChannel3,uv).xyz; //Buffer D\n    \n    //Output\n    fragColor=vec4(pow(Color,vec3(0.45)),1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Settings\nconst float FOV=0.7; //In radians\nconst float NGIRaysAcc=24.; //Number of accumulated diffuse rays\n//Enable screen space sampling -> multiple diffuse bounces\n#define SSGI\n//Enable screen space sampling -> secondary rays in reflections\n#define SSR\n\n//Constants\nconst float ALPHA=1./NGIRaysAcc;\nconst float SunCR=0.01;\nconst float Coeff_Z=12.;\nconst float Coeff_L=4.;\nconst vec3 SkyColor=vec3(0.3,0.7,1.)*0.5;\nconst vec3 SunColor=vec3(1.,0.9,0.7)*1.5;\nconst float PI=3.14159265;\nconst float HPI=PI*0.5;\nconst float IPI=1./PI;\nconst float I09=1./0.9;\nconst float I16=1./16.;\nconst float I32=1./32.;\nconst float I64=1./64.;\nconst float I255=1./255.;\nconst float I1024 = 1./1024.;\nconst vec2 eps=vec2(0.003,0.);\nconst float CFOV=tan(FOV);\nconst vec2 TAAOff[16]=vec2[16](vec2(-0.4,0.4),vec2(0.4),vec2(-0.4),vec2(0.4,-0.4),\n                            vec2(0.,0.2),vec2(0.,-0.2),vec2(0.2,0.),vec2(-0.2,0.),\n                            vec2(-0.3,0.3),vec2(0.3),vec2(-0.3),vec2(0.3,-0.3),\n                            vec2(0.,0.1),vec2(0.,-0.1),vec2(0.1,0.),vec2(-0.1,0.));\nvec2 TaaOffset(int fr) { return TAAOff[int(mod(float(fr),16.))]; } //Homemade TAA-offsets\n#define InvAF ((0.5/CFOV)*vec2(iResolution.y/iResolution.x,1.))\n#define HRES (floor(iResolution.xy*0.5))\n#define RES (HRES*2.)\n#define IRES 1./iResolution.xy\n#define IHRES 2./iResolution.xy\n#define ASPECT vec2(iResolution.x/iResolution.y,1.)\n\n//Structs\nstruct RayHit { float D; vec3 N; vec3 C; float R; float G; };\nstruct DF { float D; vec3 C; float R; float G; };\n\nfloat Box2(vec2 p, vec2 b) {\n    vec2 d=abs(p-b*0.5)-b*0.5;\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\nfloat BoxC2(vec2 p, vec2 b) {\n    vec2 d=abs(p)-b;\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\n\n\n//****************Math****************\nmat3 TBN(vec3 N) {\n    vec3 Nb,Nt;\n    if (abs(N.y)>0.999) {\n        Nb=vec3(1.,0.,0.);\n        Nt=vec3(0.,0.,1.);\n    } else {\n    \tNb=normalize(cross(N,vec3(0.,1.,0.)));\n    \tNt=normalize(cross(Nb,N));\n    }\n    return mat3(Nb.x,Nt.x,N.x,Nb.y,Nt.y,N.y,Nb.z,Nt.z,N.z);\n}\n\nvec3 TBN(vec3 N, out vec3 O) {\n    O=normalize(cross(N,vec3(0.001,1.,0.)));\n    return normalize(cross(O,N));\n}\n\nvec3 URandSample(vec2 v) {\n    float z=v.x*2.-1.;\n    float rxy=sqrt(1.-z*z);\n    float phi=v.y*2.*PI;\n    return vec3(rxy*cos(phi), rxy*sin(phi), z);\n}\n\nvec3 RandSample(vec2 v) {\n    float theta=sqrt(v.x);\n    float phi=2.*3.14159*v.y;\n    float x=theta*cos(phi);\n    float z=theta*sin(phi);\n    return vec3(x,z,sqrt(max(0.,1.-v.x)));\n}\n\nfloat Write3(vec3 v) {\n    return floor(v.x*1000.)*0.001+floor(1000.*v.y)+floor(1000.*v.z)*1000.;\n}\nvec3 Read3(float v) {\n    float vx=fract(v);\n    return vec3(vx,fract((v-vx)*0.001),floor(v*0.001)*0.001);\n}\n\nfloat Write2(vec2 a) {\n    return a.x+floor(a.y*255.);\n}\n\nvec2 Read2(float a) {\n    float tmp_fl=floor(a);\n    return vec2((a-tmp_fl),tmp_fl*I255);\n}\n\n\n\n//****************Intersection functions****************\nfloat boxfar(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax) {\n    vec3 tMin=(bmin-origin)*dir;\n    vec3 tMax=(bmax-origin)*dir;\n    vec3 t2=max(tMin,tMax);\n    return min(min(t2.x,t2.y),t2.z);\n}\n\nfloat boxfar2(vec2 origin, vec2 dir, vec2 bmin, vec2 bmax) {\n    vec2 tMin=(bmin-origin)*dir;\n    vec2 tMax=(bmax-origin)*dir;\n    vec2 t2=max(tMin,tMax);\n    return min(t2.x,t2.y);\n}\n\nbool box(vec3 origin, vec3 dir, vec3 bmin, vec3 bsize, out vec2 bb) {\n    vec3 tMin=(bmin-origin)*dir;\n    vec3 tMax=(bmin+bsize-origin)*dir;\n    vec3 t1=min(tMin,tMax);\n    vec3 t2=max(tMin,tMax);\n    bb=vec2(max(max(t1.x,t1.y),t1.z),min(min(t2.x,t2.y),t2.z));\n    return ((bb.x>0. && bb.x<bb.y) || (bb.x<0. && bb.y>0.));\n}\n\nbool bvh(vec3 origin, vec3 dir, vec3 bmin, vec3 bsize, float CD, float FAR, out vec2 bb, inout float i) {\n    vec3 tMin=(bmin-origin)*dir;\n    vec3 tMax=(bmin+bsize-origin)*dir;\n    vec3 t1=min(tMin,tMax);\n    vec3 t2=max(tMin,tMax);\n    bb=vec2(max(max(t1.x,t1.y),t1.z),min(min(t2.x,t2.y),t2.z));\n    bool bbool=((bb.x>0. && bb.x<min(FAR,min(CD,bb.y))) || (bb.x<0. && bb.y>0.));\n    i+=float(bbool);\n    return bbool;\n}\n\n\n\n//****************Denoising functions****************\nfloat WeightVar(float deltaZ, float dotN, vec3 deltaL, float L_div_inv) {\n    return max(0.001,dotN)*min(exp(-(deltaZ*deltaZ)*Coeff_Z),1.)\n        \t*min(exp(-dot(deltaL,deltaL)*L_div_inv),1.);\n}\n\nfloat Weight(float deltaZ, float dotN) {\n    return max(0.001,dotN)*min(exp(-(deltaZ*deltaZ)*64.),1.);\n}\n\nvec4 _DenoiseGI(vec2 uv, vec2 aUV, vec2 lUV, vec2 UVoff, vec3 CVP, vec3 CN, vec3 CVN, sampler2D ta, sampler2D tl,\n            vec2 ires, vec2 hres, vec2 asfov, vec3 L0, float LCoeff) {\n    //Denoiser help function\n    vec4 a0=texture(ta,(aUV+UVoff)*ires);\n    vec4 a1=texture(ta,(aUV-UVoff)*ires);\n    vec4 L=vec4(0.); vec3 SP,L1;\n    if (a0.w<9990. && Box2(uv+UVoff,hres)<-0.5) {\n        vec4 l0=texture(tl,(lUV+UVoff)*ires);\n        SP=normalize(vec3(((uv+UVoff)*ires*4.-1.)*asfov,1.))*a0.w;\n        L1=l0.xyz;\n        //L+=vec4(L1,1.)*WeightVar(dot(SP-CVP,CVN),dot(CN,Read3(a0.y)*2.-1.),L1-L0,LCoeff);\n        L+=vec4(L1,1.)*Weight(dot(SP-CVP,CVN),dot(CN,Read3(a0.y)*2.-1.));\n    }\n    if (a1.w<9990. && Box2(uv-UVoff,hres)<-0.5) {\n        vec4 l1=texture(tl,(lUV-UVoff)*ires);\n        SP=normalize(vec3(((uv-UVoff)*ires*4.-1.)*asfov,1.))*a1.w;\n        L1=l1.xyz;\n        //L+=vec4(L1,1.)*WeightVar(dot(SP-CVP,CVN),dot(CN,Read3(a1.y)*2.-1.),L1-L0,LCoeff);\n        L+=vec4(L1,1.)*Weight(dot(SP-CVP,CVN),dot(CN,Read3(a1.y)*2.-1.));\n    }\n    return L;\n}\n\nvec3 DenoiseGI(vec2 uv, vec2 aUV, vec2 lUV, sampler2D attr, sampler2D light, float radie,\n                vec3 CVP, vec3 CN, vec3 CVN, vec2 ires, vec2 hres, vec2 asfov) {\n    //Diffuse denoiser\n    vec4 L0=texture(light,lUV*ires);\n    //Variance\n    vec2 Moments=Read3(L0.w).xy*16.;\n    float Variance=abs(Moments.y-Moments.x*Moments.x);\n    float LCoeff=1.; ///(Coeff_L*pow(4.*sqrt(Variance),radius)+0.0001);\n    float radius=min(radie,sqrt(Variance/(PI*0.1)));\n        radius=min(radie,sqrt((4096./(Read3(L0.w).z*64.))/PI));\n    \n    //Wavelet\n    vec3 LL0=L0.xyz;\n    vec4 Accum=vec4(LL0*0.2,0.2);\n    Accum+=(_DenoiseGI(uv,aUV,lUV,vec2(radius,0.),CVP,CN,CVN,attr,light,ires,hres,asfov,LL0,LCoeff)+\n            _DenoiseGI(uv,aUV,lUV,vec2(0.,radius),CVP,CN,CVN,attr,light,ires,hres,asfov,LL0,LCoeff)+\n            _DenoiseGI(uv,aUV,lUV,vec2(radius*0.707),CVP,CN,CVN,attr,light,ires,hres,asfov,LL0,LCoeff)+\n            _DenoiseGI(uv,aUV,lUV,vec2(radius,-radius)*0.707,CVP,CN,CVN,attr,light,ires,hres,asfov,LL0,LCoeff)\n            )*0.1;\n    //Output\n    return vec3(Accum.xyz/Accum.w);\n}\n\nvec3 _DenoiseSHAD(vec2 uv, vec2 lUV, vec2 aUV, vec2 UVoff, vec3 CVP,\n            vec3 CN, vec3 CVN, sampler2D ta, sampler2D tl, vec2 ires, vec2 hres, vec2 asfov) {\n    //Denoiser help function\n    vec4 l0=texture(tl,(lUV+UVoff)*ires);\n    vec4 a0=texture(ta,(aUV+UVoff)*ires);\n    vec4 l1=texture(tl,(lUV-UVoff)*ires);\n    vec4 a1=texture(ta,(aUV-UVoff)*ires);\n    vec3 L=vec3(0.); vec3 SP;\n    if (a0.w<9990. && Box2(uv+UVoff,hres)<-0.5) {\n        SP=normalize(vec3(((uv+UVoff)*ires*4.-1.)*asfov,1.))*a0.w;\n    \tL+=vec3(l0.zw,1.)*Weight(dot(SP-CVP,CVN),dot(CN,Read3(a0.y)*2.-1.));\n    }\n    if (a1.w<9990. && BoxC2(uv-UVoff,hres)<-0.5) {\n        SP=normalize(vec3(((uv-UVoff)*ires*4.-1.)*asfov,1.))*a1.w;\n    \tL+=vec3(l1.zw,1.)*Weight(dot(SP-CVP,CVN),dot(CN,Read3(a1.y)*2.-1.));\n    }\n    return L;\n}\n\n\nvec2 DenoiseSHAD(vec2 uv, vec2 lUV, vec2 aUV,  sampler2D attr, sampler2D light, float radius, vec3 CVP, vec3 CN, vec3 CVN,\n            vec2 ires, vec2 hres, vec2 asfov) {\n    //R denoiser\n    vec4 L0=texture(light,lUV*ires);\n    vec3 Accum=vec3(L0.zw*0.2,0.2);\n    Accum+=(_DenoiseSHAD(uv,lUV,aUV,vec2(radius,0.),CVP,CN,CVN,attr,light,ires,hres,asfov)+\n            _DenoiseSHAD(uv,lUV,aUV,vec2(0.,radius),CVP,CN,CVN,attr,light,ires,hres,asfov)+\n            _DenoiseSHAD(uv,lUV,aUV,vec2(radius*0.707),CVP,CN,CVN,attr,light,ires,hres,asfov)+\n            _DenoiseSHAD(uv,lUV,aUV,vec2(radius,-radius)*0.707,CVP,CN,CVN,attr,light,ires,hres,asfov)\n            )*0.1;\n    //Output\n    return Accum.xy/Accum.z;\n}\n\nvec4 _DenoiseREF(vec2 uv, vec2 lUV, vec2 aUV, vec2 UVoff, vec3 CVP,\n            vec3 CN, vec3 CVN, sampler2D ta, sampler2D tl, vec2 ires, vec2 hres, vec2 asfov) {\n    //Denoiser help function\n    vec4 l0=texture(tl,(lUV+UVoff)*ires);\n    vec4 a0=texture(ta,(aUV+UVoff)*ires);\n    vec4 l1=texture(tl,(lUV-UVoff)*ires);\n    vec4 a1=texture(ta,(aUV-UVoff)*ires);\n    vec4 L=vec4(0.); vec3 SP;\n    if (a0.w<9990. && Box2(uv+UVoff,hres)<-0.5) {\n        SP=normalize(vec3(((uv+UVoff)*ires*4.-1.)*asfov,1.))*a0.w;\n    \tL+=vec4(Read3(l0.x),1.)*Weight(dot(SP-CVP,CVN),dot(CN,Read3(a0.y)*2.-1.));\n    }\n    if (a1.w<9990. && Box2(uv-UVoff,hres)<-0.5) {\n        SP=normalize(vec3(((uv-UVoff)*ires*4.-1.)*asfov,1.))*a1.w;\n    \tL+=vec4(Read3(l1.x),1.)*Weight(dot(SP-CVP,CVN),dot(CN,Read3(a1.y)*2.-1.));\n    }\n    return L;\n}\n\n\nvec3 DenoiseREF(vec2 uv, vec2 lUV, vec2 aUV, sampler2D attr, sampler2D light, float radius, vec3 CVP, vec3 CN, vec3 CVN,\n            vec2 ires, vec2 hres, vec2 asfov) {\n    //RGB denoiser\n    vec4 L0=texture(light,lUV*ires);\n    vec4 Accum=vec4(Read3(L0.x)*0.2,0.2);\n    Accum+=(_DenoiseREF(uv,lUV,aUV,vec2(radius,0.),CVP,CN,CVN,attr,light,ires,hres,asfov)+\n            _DenoiseREF(uv,lUV,aUV,vec2(0.,radius),CVP,CN,CVN,attr,light,ires,hres,asfov)+\n            _DenoiseREF(uv,lUV,aUV,vec2(radius*0.707),CVP,CN,CVN,attr,light,ires,hres,asfov)+\n            _DenoiseREF(uv,lUV,aUV,vec2(radius,-radius)*0.707,CVP,CN,CVN,attr,light,ires,hres,asfov)\n            )*0.1;\n    //Output\n    return Accum.xyz/Accum.w;\n}\n\n//****************LPV****************\nvec3 LPV_Sample(vec3 p, vec3 d, vec4 Cxp, vec4 Cxn, vec4 Cyp, vec4 Cyn, vec4 Czp, vec4 Czn) {\n    vec3 Sqd=d*d;\n    float InterpW=((d.x<0.)?Cxn.w:Cxp.w)*Sqd.x+((d.y<0.)?Cyn.w:Cyp.w)*Sqd.y+((d.z<0.)?Czn.w:Czp.w)*Sqd.z;\n    vec3 InterpL=((d.x<0.)?Cxn.xyz:Cxp.xyz)*Sqd.x+((d.y<0.)?Cyn.xyz:Cyp.xyz)*Sqd.y\n                +((d.z<0.)?Czn.xyz:Czp.xyz)*Sqd.z;\n    return InterpL/(InterpW+0.001);\n}\n\nvec3 LPV_DoubleSample(vec3 p, vec3 d, vec4 Cxp, vec4 Cxn, vec4 Cyp, vec4 Cyn, vec4 Czp, vec4 Czn) {\n    vec3 Sqd=d*d;\n    vec3 ILP=Cxp.xyz*Sqd.x+Cyp.xyz*Sqd.y+Czp.xyz*Sqd.z;\n    vec3 ILN=Cxn.xyz*Sqd.x+Cyn.xyz*Sqd.y+Czn.xyz*Sqd.z;\n    return ILP/(Cxp.w*Sqd.x+Cyp.w*Sqd.y+Czp.w*Sqd.z+0.001)+\n            ILN/(Cxn.w*Sqd.x+Cyn.w*Sqd.y+Czn.w*Sqd.z+0.001);\n}\n\n\n\n//****************SDF****************\nbool DFBox(vec3 p, vec3 b, float cd) {\n    vec3 d=abs(p-b*0.5)-b*0.5;\n    return (min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.))<cd);\n}\n\nfloat DFBox(vec3 p, vec3 b) {\n    vec3 d=abs(p-b*0.5)-b*0.5;\n    return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\n}\n\nfloat DFBoxC(vec3 p, vec3 b) {\n    vec3 d=abs(p)-b;\n    return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\n}\n\nvec2 DFRotate(vec2 p, float ang) {\n    float c=cos(ang), s=sin(ang);\n    return vec2(p.x*c-p.y*s,p.x*s+p.y*c);\n}\n\nvec2 DFRepeat(vec2 p, float n) {\n    float ang=2.*3.14159/n;\n    float sector=floor(atan(p.x,p.y)/ang+0.5);\n    p=DFRotate(p,sector*ang);\n    return p;\n}\n\nvec2 DFRepeat(vec2 p, float n, float a) {\n    float ang=2.*3.14159/n;\n    float sector=floor((atan(p.x,p.y)+a)/ang+0.5);\n    p=DFRotate(p,sector*ang-a);\n    return p;\n}\n\nfloat DFPlane(vec3 p, vec3 n, float offs) {\n\treturn dot(p,n)-offs;\n}\n\nfloat DFLine(vec3 p, vec3 a, vec3 b) {\n    vec3 ba=b-a;\n    float k=dot(p-a,ba)/dot(ba,ba);\n    return length((a+clamp(k,0.,1.)*(b-a))-p);\n}\n\nfloat DFSMIN(float a, float b, float k) {\n    float h=clamp(0.5+0.5*(b-a)/k,0.,1.);\n    return mix(b,a,h)-k*h*(1.-h);\n}\n\nvoid DFMIN(inout DF df, DF a) {\n    if (a.D<=df.D) df=a;\n}\n\nvoid DFMAX(inout DF df, DF a) {\n    if (a.D>=df.D) df=a;\n}\n\nDF SDF(vec3 p, float Time) {\n    DF df=DF(DFBox(p-vec3(0.,-1.,0.),vec3(64.,1.,64.)),vec3(1.),1.,0.);\n    vec3 rp,RP;\n    if (DFBox(p-vec3(10.,0.,0.),vec3(10.,10.,10.),df.D)) { //Room\n        //Box med roterande emissive\n        rp=p-vec3(20.,9.5,5.); rp.xz=DFRepeat(rp.xz,20.);\n        float LineD=DFLine(p,vec3(20.,-10.,5.),vec3(20.,20.,5.))-4.7;\n        DFMIN(df,DF(max(max(max(max(DFLine(p,vec3(20.,-10.,5.),vec3(20.,20.,5.))-4.9,p.y-10.),-p.y+9.),\n                    -LineD),\n                    -DFBoxC(rp-vec3(0.,0.,4.),vec3(0.5,0.4,2.)))\n                    ,vec3(1.),1.,0.)); //Windows\n        DFMIN(df,DF(max(max(DFBox(p-vec3(10.,5.,0.),vec3(10.,4.1,10.)),-LineD),\n                    -DFBox(p-vec3(10.2,5.,0.2),vec3(12.,4.,9.6))),vec3(1.),1.,0.)); //Walls\n        DFMIN(df,DF(DFBox(p-vec3(10.,4.,0.),vec3(10.,1.,10.)),vec3(1.),0.35,0.1)); //Floor\n        DFMIN(df,DF(DFBox(p-vec3(19.8,5.,0.),vec3(0.2,5.,10.)),vec3(1.),1.,0.)); //Wall where sun falls\n        DFMIN(df,DF(max(DFBox(p-vec3(10.,9.9,0.),vec3(10.,0.1,10.)),LineD),vec3(0.3,1.,0.3),1.,0.)); //Roof\n    }\n    if (DFBox(p-vec3(10.,5.,0.),vec3(5.,5.,10.),df.D)) { //Wall with rings\n        df.D=max(df.D,-DFBox(p-vec3(12.,6.,0.2),vec3(2.,8.,2.)));\n        df.D=max(df.D,-DFBox(p-vec3(12.,6.,5.),vec3(2.,8.,4.)));\n        if (DFBox(p-vec3(10.,5.,6.),vec3(4.,3.,0.5),df.D)) { //First room\n            DFMIN(df,DF(DFBox(p-vec3(10.,5.,6.),vec3(4.,3.,0.1)),vec3(1.),1.,0.)); //Wall where sun falls\n            rp=p-vec3(10.,5.,6.1); rp.xy=clamp(rp.xy,vec2(0.),vec2(4.,3.)); rp.xy=fract(rp.xy*2.)*0.5;\n            DFMIN(df,DF(max(max(max(DFLine(rp,vec3(0.25,0.25,0.),vec3(0.25,0.25,0.5))-0.22,rp.z-0.15),-rp.z),\n                        -DFLine(rp,vec3(0.25,0.25,0.),vec3(0.25,0.25,0.5))+0.15),vec3(1.),1.,0.));\n        }\n    }\n    if (DFBox(p-vec3(16.,5.,5.),vec3(2.),df.D)) { //Boxes\n        RP=p-vec3(16.,5.,5.);\n        DFMIN(df,DF(DFBox(RP-vec3(0.6,0.,0.6),vec3(0.8,1.2,0.8)),vec3(1.,0.1,0.1),1.,0.)); //Bix middle\n            DFMIN(df,DF(DFBox(RP-vec3(1.2,0.,1.2),vec3(0.6,0.6,0.6)),vec3(1.),1.,0.));\n            DFMIN(df,DF(DFBox(RP-vec3(0.5,0.,0.9),vec3(0.7,0.8,0.7)),vec3(1.,1.,0.5),1.,0.));\n    }\n    if (DFBox(p-vec3(10.,5.,6.5),vec3(3.),df.D)) { //Spheres and emissive\n        RP=p-vec3(10.,5.,6.5);\n        DFMIN(df,DF(length(RP-vec3(1.,0.7,1.))-0.7,vec3(1.,0.,0.),1.,0.)); //Red\n            DFMIN(df,DF(length(RP-vec3(2.3,0.5,1.1))-0.5,vec3(1.),0.,0.)); //Reflective\n            DFMIN(df,DF(DFLine(RP,vec3(0.5,0.3,2.3),vec3(0.5,1.2,2.3))-0.3,vec3(1.),1.75,0.)); //Emissive\n    }\n    if (DFBox(p-vec3(10.,5.,1.),vec3(1.,3.,3.),df.D)) { //Emissive red ring\n        DFMIN(df,DF(max(max(max(DFLine(p,vec3(10.,6.5,2.5),vec3(14.,6.5,2.5))-1.5,p.x-10.4),-p.x+10.1),\n                    -DFLine(p,vec3(10.,6.5,2.5),vec3(14.,6.5,2.5))+1.),vec3(1.,0.1,0.1),1.75,0.));\n    }\n    //Return\n    return df;\n}\n\nvec3 Gradient(vec3 RP, float Time) {\n    return -normalize(vec3(SDF(RP-eps.xyy,Time).D-SDF(RP+eps.xyy,Time).D,\n                            SDF(RP-eps.yxy,Time).D-SDF(RP+eps.yxy,Time).D,\n                            SDF(RP-eps.yyx,Time).D-SDF(RP+eps.yyx,Time).D));\n}\n\nRayHit TraceBVH(vec3 p, vec3 d, float FAR, float Time, out float ii) {\n    DF t; float dist=0.; vec3 RP=p; RayHit R; ii=0.;\n    for (int i=0; i<256; i++) {\n        if (dist>FAR) break;\n        RP=p+d*dist;\n        t=SDF(RP,Time);\n        if (t.D<eps.x) {\n\t\t\tR.D=dist+t.D;\n            RP=p+d*R.D;\n            R.N=Gradient(RP,Time);\n            R.C=t.C;\n            R.G=t.G;\n            R.R=t.R;\n            return R;\n        }\n        dist=dist+t.D;\n    }\n    return RayHit(10000.,vec3(0.),vec3(0.),0.,0.);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Storage, G-Buffer, TAA\n\nvec2 ProjectUV(vec3 p, vec3 LP, vec3 LD, vec3 LT, vec3 LB) {\n\tvec3 CVPos=p-LP;\n    vec3 LVPos=vec3(dot(CVPos,LT),dot(CVPos,LB),dot(CVPos,LD));\n    return (LVPos.xy/LVPos.z)*InvAF+0.5;\n}\n\nvoid ComputePosition(inout vec3 Color, vec3 Eye) {\n    float Speed=iTimeDelta*2.;\n        if (texelFetch(iChannel1,ivec2(32,0),0).x>0.) Speed=20.*iTimeDelta;\n    if (texelFetch(iChannel1,ivec2(87,0),0).x>0.) Color.xyz+=Eye*Speed; //W\n    if (texelFetch(iChannel1,ivec2(83,0),0).x>0.) Color.xyz-=Eye*Speed; //S\n    vec3 Tan=normalize(cross(vec3(Eye.x,0.,Eye.z),vec3(0.,1.,0.)));\n    if (texelFetch(iChannel1,ivec2(65,0),0).x>0.) Color.xyz-=Tan*Speed; //A\n    if (texelFetch(iChannel1,ivec2(68,0),0).x>0.) Color.xyz+=Tan*Speed; //D\n}\n\nvoid ComputePosition(inout vec4 Color) {\n    float Speed=iTimeDelta*2.;\n        if (texelFetch(iChannel1,ivec2(32,0),0).x>0.) Speed=20.*iTimeDelta;\n    vec3 Eye=texture(iChannel0,vec2(2.5,0.5)*IRES).xyz;\n    if (texelFetch(iChannel1,ivec2(87,0),0).x>0.) Color.xyz+=Eye*Speed; //W\n    if (texelFetch(iChannel1,ivec2(83,0),0).x>0.) Color.xyz-=Eye*Speed; //S\n    vec3 Tan=normalize(cross(vec3(Eye.x,0.,Eye.z),vec3(0.,1.,0.)));\n    if (texelFetch(iChannel1,ivec2(65,0),0).x>0.) Color.xyz-=Tan*Speed; //A\n    if (texelFetch(iChannel1,ivec2(68,0),0).x>0.) Color.xyz+=Tan*Speed; //D\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Color=texture(iChannel0,fragCoord.xy/iResolution.xy);\n    vec2 fragFloor=floor(fragCoord);\n    if (iFrame==0) { //Initialization\n        Color=vec4(0.);\n        if (fragCoord.x<10. && fragCoord.y<1.) { //Store vars\n            if (fragCoord.x<1.) Color=vec4(0.,0.,0.,0.); //Mouse\n            else if (fragCoord.x<2.) Color=vec4(0.,3.7,0.,0.); //Player Eye (Angles)\n            else if (fragCoord.x<3.) Color=vec4(0.,0.,0.,1.); //Player Eye (Vector)\n            else if (fragCoord.x<4.) Color=vec4(19.,6.75,9.,1.); //Player Pos\n            else if (fragCoord.x<5.) Color=vec4(0.707,-3.1,0.,0.); //Sun angles\n            else if (fragCoord.x<6.) Color=vec4(0.,0.,0.,0.); //Sun direction\n        }\n    } else { //Update\n\t\tif (fragCoord.x<16. && fragCoord.y<1.) { //Update vars\n            if (fragCoord.x<1.) { //Mouse\n                if (iMouse.z>0.) { //B\u00f6rjat klicka\n                    if (Color.w==0.) {\n                    \tColor.w=1.;\n                    \tColor.xy=iMouse.zw;\n                    }\n                } else Color.w=0.;\n            } else if (fragCoord.x<2.) { //Player Eye (Angles)\n                vec4 LMouse=texture(iChannel0,vec2(0.5,0.5)*IRES);\n                if (LMouse.w==0.)  Color.zw=Color.xy;\n                if (LMouse.w==1.) {\n                \t//Y led\n                \tColor.x=Color.z+(iMouse.y-LMouse.y)*0.01;\n                \tColor.x=clamp(Color.x,-2.8*0.5,2.8*0.5);\n                \t//X led\n                \tColor.y=Color.w-(iMouse.x-LMouse.x)*0.02;\n               \t\tColor.y=mod(Color.y,3.1415926*2.);\n                }\n            } else if (fragCoord.x<3.) { //Player Eye (Vector)\n                vec3 Angles=texture(iChannel0,vec2(1.5,0.5)*IRES).xyz;\n                Color.xyz=normalize(vec3(cos(Angles.x)*sin(Angles.y),\n                  \t\t\t   \t\t\tsin(Angles.x),\n                  \t\t\t   \t\t\tcos(Angles.x)*cos(Angles.y)));\n            } else if (fragCoord.x<4.) { //Player Pos\n                ComputePosition(Color);\n            } else if (fragCoord.x<5.) { //Sun angle\n                if (texelFetch(iChannel1,ivec2(77,0),0).x>0.) Color.y+=0.02;\n                if (texelFetch(iChannel1,ivec2(78,0),0).x>0.) Color.y-=0.02;\n                Color.z=Color.y; //Sunangle last frame\n            } else if (fragCoord.x<6.) { //Sun direction\n                vec2 Angles=texture(iChannel0,vec2(4.5,0.5)*IRES).xy;\n                Color=vec4(normalize(vec3(cos(Angles.y)*cos(Angles.x)\n                \t,sin(Angles.x),sin(Angles.y)*cos(Angles.x))),1.);\n            } else if (fragCoord.x<7.) { //Last frame dir\n                Color=texture(iChannel0,vec2(2.5,0.5)*IRES);\n            } else if (fragCoord.x<8.) { //Last frame position\n                Color=texture(iChannel0,vec2(3.5,0.5)*IRES);\n            } else if (fragCoord.x<9.) { //Last last frame dir\n                Color=texture(iChannel0,vec2(6.5,0.5)*IRES);\n            } else if (fragCoord.x<10.) { //Last last frame position\n                Color=texture(iChannel0,vec2(7.5,0.5)*IRES);\n            } else if (fragCoord.x<11.) { //Last last frame dir\n                Color=texture(iChannel0,vec2(8.5,0.5)*IRES);\n            } else if (fragCoord.x<12.) { //Last last frame position\n                Color=texture(iChannel0,vec2(9.5,0.5)*IRES);\n            }\n        } else if (Box2(fragCoord-vec2(0.,HRES.y),HRES)<0.) {\n            //Copy G-Buffer\n            Color=texture(iChannel0,(fragCoord+vec2(HRES.x,0.))*IRES);\n        } else if (Box2(fragCoord-HRES,HRES)<0.) {\n            //G-Buffer\n            vec2 uv=fragCoord*2.-iResolution.xy;\n            vec3 Pos=texture(iChannel0,vec2(3.5,0.5)*IRES).xyz;\n            mat3 MM=TBN(texture(iChannel0,vec2(2.5,0.5)*IRES).xyz);\n            vec3 Dir=normalize(vec3(((uv+TaaOffset(iFrame)*2.)*IRES*2.-1.)*(ASPECT*CFOV),1.)*MM);\n            float Iter; RayHit HIT=TraceBVH(Pos,Dir,512.,iTime,Iter);\n            if (HIT.D<9999.) {\n                Color=vec4(Write3(HIT.C*0.9),Write3(HIT.N*0.9*0.5+0.5),Write2(vec2(HIT.R,HIT.G)*0.5),HIT.D);\n                    //Color.xyz=vec3(1./(1.+Iter)); //Iterations\n            } else {\n                Color=vec4(0.,0.,0.,10000.);\n            }\n        } else if (Box2(fragCoord-vec2(HRES.x,0.),HRES)<0.) {\n            //TAA\n            vec4 Attr=texture(iChannel2,fragCoord*IRES);\n            vec3 Pos=texture(iChannel0,vec2(9.5,0.5)*IRES).xyz;\n            vec3 Eye=texture(iChannel0,vec2(8.5,0.5)*IRES).xyz;\n            vec3 Dir=normalize(vec3(((fragCoord-vec2(iResolution.x*0.5,0.))*IRES*4.-1.)\n                                *(ASPECT*CFOV),1.)*TBN(Eye));\n            vec3 PixelP=Pos+Dir*Attr.w;\n            vec3 NewLight=Attr.xyz+texture(iChannel2,(fragCoord-vec2(HRES.x,0.))*IRES).xyz;\n            //Backprojecting\n            vec3 LLPos=texture(iChannel0,vec2(11.5,0.5)*IRES).xyz;\n            vec3 LLEye=texture(iChannel0,vec2(10.5,0.5)*IRES).xyz;\n            vec3 LLTan=normalize(cross(LLEye,vec3(0.,1.,0.)));\n            vec3 LLBit=normalize(cross(LLTan,LLEye));\n            vec2 Luv=ProjectUV(PixelP,LLPos,LLEye,LLTan,LLBit);\n            if (Box2(Luv,vec2(1.))<0.) {\n                vec2 TLuv=Luv*HRES+vec2(HRES.x,0.);\n                vec4 OldLight=texture(iChannel0,\n                              vec2(max(HRES.x+0.5,TLuv.x),min(HRES.y-0.5,TLuv.y))*IRES);\n                //3x3 neighbour clamping\n                vec3 CMin,CMax,CSample; CMin=vec3(100.); CMax=vec3(-100.);\n                vec2 CCUV=fragCoord; vec2 CCSUV;\n                for (float x=-1.; x<2.; x++) {\n                    for (float y=-1.; y<2.; y++) {\n                        CCSUV=clamp(CCUV+vec2(x,y),vec2(HRES.x+0.5,0.5),\n                                        vec2(RES.x-0.5,HRES.y-0.5));\n                        CSample=texture(iChannel2,CCSUV*IRES).xyz+texture(iChannel2,(CCSUV-vec2(HRES.x,0.))*IRES).xyz;\n                        CMin=min(CMin,CSample);\n                        CMax=max(CMax,CSample);\n                    }\n                }\n                OldLight.xyz=clamp(OldLight.xyz,CMin,CMax);\n                //TAA\n                Color=vec4(mix(OldLight.xyz,NewLight,max(I255,1./(OldLight.w+1.))),OldLight.w+1.);\n            } else {\n                Color=vec4(NewLight,1.);\n            }\n        }\n    }\n    fragColor=Color;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":3,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Ray tracing: GI, reflections and shadows, sunshafts and second denoising pass\n\nvec2 ProjectUV(vec3 p, vec3 LP, vec3 LD, vec3 LT, vec3 LB) {\n\tvec3 CVPos=p-LP;\n    vec3 LVPos=vec3(dot(CVPos,LT),dot(CVPos,LB),dot(CVPos,LD));\n    return (LVPos.xy/LVPos.z)*InvAF+0.5;\n}\n\nvec3 ComputeLight(vec3 P, vec3 D, vec3 N, vec2 rand, float iTime, mat3 MM, vec3 Pos, vec3 Eye) {\n    float Iter; vec3 Sample,LHITP; vec3 Color=vec3(0.);\n    //Diffuse\n    vec3 SunVec=texture(iChannel0,vec2(5.5,0.5)*IRES).xyz;\n    Sample=RandSample(rand)*TBN(N);\n    RayHit LHIT=TraceBVH(P,Sample,128.,iTime,Iter);\n    if (LHIT.D<9990.) {\n        if (LHIT.R>1.5)\n            //Emissive\n            Color=LHIT.C;\n        else {\n            #ifdef SSGI\n            //Screen space indirect light\n            vec3 SSPos=texture(iChannel0,vec2(9.5,0.5)*IRES).xyz;\n            vec3 SSEye=texture(iChannel0,vec2(8.5,0.5)*IRES).xyz;\n            vec3 SSTan=normalize(cross(SSEye,vec3(0.,1.,0.)));\n            vec3 SSBit=normalize(cross(SSTan,SSEye));\n            vec2 SSuv=ProjectUV(P+Sample*LHIT.D,SSPos,SSEye,SSTan,SSBit);\n            vec3 SSDir=normalize(vec3((SSuv*2.-1.)*(ASPECT*CFOV),1.)*MM);\n            vec4 SSAttr=texture(iChannel0,(SSuv*HRES+vec2(0.,HRES.y))*IRES);\n            if (Box2(SSuv*HRES,HRES)<0.\n            && dot(LHIT.N,Read3(SSAttr.y)*2.-1.)>0.707\n            && abs(dot(P+Sample*LHIT.D-(Pos+SSDir*SSAttr.w),LHIT.N))<0.1\n            && dot(P+Sample*LHIT.D-Pos,Eye)>0.) {\n                Color+=texture(iChannel1,(SSuv*HRES+vec2(0.,HRES.y))*IRES).xyz;\n            }\n            #endif\n            //Direct Light\n            float LDot=dot(SunVec,LHIT.N);\n            if (LDot>0.) {\n                LHITP=P+Sample*LHIT.D;\n                Sample=normalize(RandSample(rand)*TBN(SunVec)*SunCR+SunVec);\n                RayHit SunHIT=TraceBVH(LHITP+LHIT.N*0.05,Sample,128.,iTime,Iter);\n                if (SunHIT.D>9900.)\n                    Color.xyz+=SunColor*LDot;\n                \n            }\n            Color.xyz*=LHIT.C*LHIT.R;\n        }\n    } else Color.xyz=(1.-0.5*Sample.y)*SkyColor;\n    //Return\n    return Color;\n}\n\nvec3 LinearSample0(vec2 uv, out float coeff, out vec3 Moments, vec3 CN) {\n    vec4 Attr=texture(iChannel0,(uv+vec2(0.,HRES.y))*IRES);\n    if (Attr.w>9999. || Box2(uv,HRES)>0.) {coeff=0.001; Moments=vec3(0.); return vec3(0.); }\n    coeff=max(0.001,dot(CN,(Read3(Attr.y)*2.-1.)*I09));\n    vec4 Light=texture(iChannel1,(uv+vec2(0.,HRES.y))*IRES);\n    Moments=Read3(Light.w)*coeff;\n    return Light.xyz*coeff;\n}\n\nvec3 LinearSample(vec2 uv, vec3 CN, out vec3 Moments) {\n    float c0,c1,c2,c3; vec3 m0,m1,m2,m3;\n    vec2 fuv=floor(uv*HRES-0.499)+0.5;\n    vec3 C0=LinearSample0(fuv,c0,m0,CN);\n    vec3 C1=LinearSample0(fuv+vec2(1.,0.),c1,m1,CN);\n    vec3 C2=LinearSample0(fuv+vec2(0.,1.),c2,m2,CN);\n    vec3 C3=LinearSample0(fuv+vec2(1.),c3,m3,CN);\n    vec2 fruv=fract(uv*HRES-0.499);\n    float mc=mix(mix(c0,c1,fruv.x),mix(c2,c3,fruv.x),fruv.y)+0.01;\n    Moments=mix(mix(m0,m1,fruv.x),mix(m2,m3,fruv.x),fruv.y)/mc;\n    return mix(mix(C0,C1,fruv.x),mix(C2,C3,fruv.x),fruv.y)/mc;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Color=vec4(0.);\n    if (fragCoord.x>HRES.x && fragCoord.x<RES.x) {\n        if (fragCoord.y>HRES.y && fragCoord.y<RES.y) {\n            //Glossy reflections\n            Color=vec4(0.);\n            vec2 uv=fragCoord.xy*2.-iResolution.xy;\n            vec3 SunDir=texture(iChannel0,vec2(5.5,0.5)*IRES).xyz;\n            vec3 Pos=texture(iChannel0,vec2(7.5,0.5)*IRES).xyz;\n            vec3 Eye=texture(iChannel0,vec2(6.5,0.5)*IRES).xyz;\n            mat3 MM=TBN(Eye);\n            vec3 Dir=normalize(vec3(((uv+TaaOffset(iFrame)*2.)*IRES*2.-1.)*(ASPECT*CFOV),1.)*MM);\n            vec4 Attr=texture(iChannel0,fragCoord*IRES);\n            vec2 ARG=Read2(Attr.z)*2.;\n            if (Attr.w<9990.) {\n                vec3 HITP=Pos+Dir*Attr.w;\n                vec3 HITN=Gradient(HITP,iTime);\n                vec4 RefShad=vec4(0.,0.,0.,0.); //Reflection light + shadow occlusion\n                float RefLen=10100.;\n                float ShadLen=10100.;\n                vec3 Light=vec3(0.);\n                if (ARG.x<0.95 || true) { //Pga att undvika svart runt diffusa kanter pga denoising\n                    //REFLECTIONS\n                    vec3 RefDir=reflect(Dir,HITN);\n                    RefDir=normalize(RandSample(texture(iChannel3,uv*8.*I1024).xy)\n                                    *TBN(RefDir)*ARG.y+RefDir);\n                    if (dot(RefDir,HITN)<0.) RefDir=reflect(RefDir,HITN);\n                    float Iter; RayHit RHIT=TraceBVH(HITP+HITN*0.05,RefDir,10000.,iTime,Iter);\n                    if (RHIT.D<9990.) {\n                        if (RHIT.R>1.5)\n                            //Emissive\n                            RefShad.xyz=RHIT.C;\n                        else {\n                            bool SSBool=false;\n                            #ifdef SSR\n                            //Screen space reprojection\n                            vec3 SSPos=texture(iChannel0,vec2(9.5,0.5)*IRES).xyz;\n                            vec3 SSEye=texture(iChannel0,vec2(8.5,0.5)*IRES).xyz;\n                            vec3 SSTan=normalize(cross(SSEye,vec3(0.,1.,0.)));\n                            vec3 SSBit=normalize(cross(SSTan,SSEye));\n                            vec2 SSuv=ProjectUV(HITP+HITN*0.05+RefDir*RHIT.D,SSPos,SSEye,SSTan,SSBit);\n                            vec3 SSDir=normalize(vec3((SSuv*2.-1.)*(ASPECT*CFOV),1.)*MM);\n                            vec4 SSAttr=texture(iChannel0,(SSuv*HRES+vec2(0.,HRES.y))*IRES);\n                            vec3 RRP=HITP+HITN*0.05+RefDir*RHIT.D;\n                            if (Box2(SSuv*HRES,HRES)<0.\n                            && dot(RHIT.N,Read3(SSAttr.y)*2.-1.)>0.707\n                            && abs(dot(RRP-(Pos+SSDir*SSAttr.w),RHIT.N))<0.5\n                            && dot(RRP-Pos,Eye)>0.) {\n                                SSBool=true;\n                                RefShad.xyz=texture(iChannel1,(SSuv*HRES)*IRES).xyz+\n                                            SunColor*(max(0.,dot(RHIT.N,SunDir))\n                                            *texture(iChannel2,(SSuv*HRES+vec2(HRES.x,0.))*IRES).z);\n                                RefShad.xyz*=RHIT.C;\n                            }\n                            #endif\n                            if (SSBool==false && dot(RHIT.N,SunDir)>0.) {\n                                //Diffuse\n                                RayHit SunHIT=TraceBVH(HITP+HITN*0.03+RefDir*RHIT.D+RHIT.N*0.05,\n                                                        SunDir,10000.,iTime,Iter);\n                                if (SunHIT.D>9900.)\n                                    RefShad.xyz=SunColor*RHIT.C*dot(RHIT.N,SunDir);\n                            }\n                        }\n                        RefLen=RHIT.D;\n                    } else\n                        //Sky\n                        RefShad.xyz=SkyColor*(1.-0.5*RefDir.y);\n                }\n                //SOFT SHADOWS\n                if (dot(SunDir,HITN)>0.) {\n                    vec3 RefDir=normalize(RandSample(texture(iChannel3,uv*16.*I1024).xy)\n                                            *TBN(SunDir)*SunCR+SunDir);\n                    float Iter; RayHit RHIT=TraceBVH(HITP+HITN*0.03,RefDir,10000.,iTime,Iter);\n                    ShadLen=RHIT.D;\n                    if (RHIT.D>9990.) {\n                        RefShad.w=1.;\n                    }\n                }\n                //RETURN\n                Color=vec4(Write3(min(RefShad.xyz*0.9,0.9)),RefLen,RefShad.w,ShadLen);\n            } else\n                Color=vec4(Write3(vec3(0.)),0.,0.,10000.);\n        } else {\n            //Denoising pass 3 (Shadows and reflections)\n            vec2 uv=fragCoord-vec2(HRES.x,0.);\n            vec2 lUV=fragCoord+vec2(0.,HRES.y);\n            vec2 aUV=uv+vec2(0.,HRES.y);\n            vec4 CAttr=texture(iChannel0,aUV*IRES);\n            vec4 CTex=texture(iChannel2,lUV*IRES);\n            float CR=Read2(CAttr.z).y*2.;\n            //World to view space attributes\n            vec3 Eye=texture(iChannel0,vec2(8.5,0.5)*IRES).xyz;\n            vec3 VDir=normalize(vec3((uv*IRES*4.-1.)*(ASPECT*CFOV),1.));\n            vec3 Tan; vec3 Bit=TBN(Eye,Tan);\n            vec3 HITVP=VDir*CAttr.w;\n            vec3 HITN=Read3(CAttr.y)*2.-1.;\n            vec3 HITVN=vec3(dot(HITN,Tan),dot(HITN,Bit),dot(HITN,Eye));\n            //Projected cone radius\n            vec3 VBit=normalize(cross(VDir,vec3(0.,1.,0.)));\n            vec3 Proj_d1=(CTex.y+CAttr.w)*VDir+CR*CTex.y*VBit;\n            vec3 Proj_d2=(CTex.y+CAttr.w)*VDir-CR*CTex.y*VBit;\n            //REFLECTIONS\n            float Proj_r=abs(((Proj_d1.x/Proj_d1.z-Proj_d2.x/Proj_d2.z)/(CFOV*ASPECT.x))*0.125*iResolution.x);\n            vec3 DREF=DenoiseREF(uv,lUV,aUV,iChannel0,iChannel2,min(Proj_r,4.),HITVP,HITN,HITVN,IRES,HRES,CFOV*ASPECT);\n            //SHADOWS\n            Proj_d1=vec3(CTex.w*SunCR,0.,CAttr.w);\n            Proj_d2=vec3(-CTex.w*SunCR,0.,CAttr.w);\n            Proj_r=abs(((Proj_d1.x/Proj_d1.z-Proj_d2.x/Proj_d2.z)/(CFOV*ASPECT.x))*0.125*iResolution.x);\n            vec2 DSHAD=DenoiseSHAD(uv,lUV,aUV,iChannel0,iChannel2,min(Proj_r,4.),HITVP,HITN,HITVN,IRES,HRES,CFOV*ASPECT);\n            //OUTPUT\n            Color=vec4(Write3(min(DREF.xyz,vec3(0.9))),CTex.y,DSHAD);\n        }\n    } else {\n        if (fragCoord.y>HRES.y && fragCoord.y<RES.y) {\n            //Diffuse GI tracing and accumulation\n            vec2 uv=fragCoord*2.-vec2(0.,iResolution.y);\n            vec3 Pos=texture(iChannel0,vec2(7.5,0.5)*IRES).xyz;\n            vec3 Eye=texture(iChannel0,vec2(6.5,0.5)*IRES).xyz;\n            mat3 MM=TBN(Eye);\n            vec3 Dir=normalize(vec3(((uv+TaaOffset(iFrame)*2.)*IRES*2.-1.)*(ASPECT*CFOV),1.)*MM);\n            vec4 Attr=texture(iChannel0,uv*IRES*0.5+0.5);\n            if (Attr.w<9999. && iFrame>2) {\n                vec2 ARG=Read2(Attr.z)*2.;\n                if (ARG.x<1.5) {\n                    vec3 HITP=Pos+Dir*Attr.w;\n                    vec3 HITN=(Read3(Attr.y)*2.-1.)*I09;\n                    float modframe=mod(float(iFrame),NGIRaysAcc);\n                    vec2 rand=texture(iChannel3,(fragCoord+modframe*vec2(35.253,57.171))*I1024).xy;\n                    vec3 Light=ComputeLight(HITP+HITN*0.05,Dir,HITN,rand,iTime,MM,Pos,Eye);\n                    //Accumulation\n                    float NSamples=1.;\n                    vec2 MixedMoments=vec2(0.99,0.);\n                    vec3 LLPos=texture(iChannel0,vec2(9.5,0.5)*IRES).xyz;\n                    vec3 LLEye=texture(iChannel0,vec2(8.5,0.5)*IRES).xyz;\n                    vec3 LLTan=normalize(cross(LLEye,vec3(0.,1.,0.)));\n                    vec3 LLBit=normalize(cross(LLTan,LLEye));\n                    //Reprojection\n                    vec2 Luv=ProjectUV(HITP,LLPos,LLEye,LLTan,LLBit);\n                    vec4 LLA=texture(iChannel0,Luv*0.5+vec2(0.,0.5));\n                    vec3 LLPP=LLPos+normalize(vec3((Luv*2.-1.)*(ASPECT*CFOV),1.)*TBN(LLEye))*LLA.w;\n                    if (BoxC2(Luv-0.5,vec2(0.5))>0. || abs(dot(LLPP-HITP,HITN))>0.5*sqrt(Attr.w)) {\n                        //Invalid pixel\n                    } else if (iFrame>0) {\n                        //Valid pixel\n                        vec3 AccumMoments;\n                        vec3 AccumLight=LinearSample(Luv,HITN,AccumMoments);\n                        NSamples=min(NGIRaysAcc,AccumMoments.z*64.+1.);\n                        if (NSamples>3.) {\n                            //Stable temporal variance\n                            float Lum=dot(Light.xyz,vec3(0.299,0.587,0.114));\n                            MixedMoments=AccumMoments.xy*(1.-ALPHA)+vec2(Lum,Lum*Lum)*ALPHA;\n                        }\n                        MixedMoments=clamp(MixedMoments*0.99,vec2(0.),vec2(0.99));\n                        Light=mix(AccumLight,Light,max(1./NSamples,ALPHA));\n                    }\n                    //RETURN\n                    Color=vec4(Light,Write3(vec3(MixedMoments,NSamples*I64)));\n                } else\n                    Color=vec4(0.,0.,0.,0.);\n            } else {\n                Color=vec4(0.,0.,0.,0.);\n            }\n        } else {\n            //Denoising pass 3 (GI)\n            vec2 uv=fragCoord;\n            vec4 CAttr=texture(iChannel0,(uv+vec2(0.,HRES.y))*IRES);\n            //World to view space attributes\n            vec3 Eye=texture(iChannel0,vec2(8.5,0.5)*IRES).xyz;\n            vec3 VDir=normalize(vec3((uv*IRES*4.-1.)*(ASPECT*CFOV),1.));\n            vec3 Tan; vec3 Bit=TBN(Eye,Tan);\n            vec3 HITVP=VDir*CAttr.w;\n            vec3 HITN=Read3(CAttr.y).xyz*2.-1.;\n            vec3 HITVN=vec3(dot(HITN,Tan),dot(HITN,Bit),dot(HITN,Eye));\n            vec3 Denoised=DenoiseGI(uv,uv+vec2(0.,HRES.y),fragCoord+vec2(0.,HRES.y),iChannel0,iChannel2,\n                                    4.,HITVP,HITN,HITVN,IRES,HRES,CFOV*ASPECT);\n            Color=vec4(Denoised,texture(iChannel2,(fragCoord+vec2(0.,HRES.y))*IRES).w);\n        }\n    }\n    fragColor=Color;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//First and fourth denoising pass\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Color=vec4(0.);\n    if (fragCoord.x>HRES.x && fragCoord.x<RES.x) {\n        if (fragCoord.y>HRES.y && fragCoord.y<RES.y) {\n            //Denoising pass 1 (Shadows and reflections)\n            vec2 uv=fragCoord-HRES;\n            vec2 lUV=fragCoord;\n            vec2 aUV=fragCoord;\n            vec4 CAttr=texture(iChannel0,aUV*IRES);\n            vec4 CTex=texture(iChannel1,lUV*IRES);\n            float CR=Read2(CAttr.z).y*2.;\n            //World to view space attributes\n            vec3 Eye=texture(iChannel0,vec2(6.5,0.5)*IRES).xyz;\n            vec3 VDir=normalize(vec3((uv*IRES*4.-1.)*(ASPECT*CFOV),1.));\n            vec3 Tan; vec3 Bit=TBN(Eye,Tan);\n            vec3 HITVP=VDir*CAttr.w;\n            vec3 HITN=Read3(CAttr.y)*2.-1.;\n            vec3 HITVN=vec3(dot(HITN,Tan),dot(HITN,Bit),dot(HITN,Eye));\n            //Projected cone radius\n            vec3 VBit=normalize(cross(VDir,vec3(0.,1.,0.)));\n            vec3 Proj_d1=(CTex.y+CAttr.w)*VDir+CR*CTex.y*VBit;\n            vec3 Proj_d2=(CTex.y+CAttr.w)*VDir-CR*CTex.y*VBit;\n            //REFLECTIONS\n            float Proj_r=abs(((Proj_d1.x/Proj_d1.z-Proj_d2.x/Proj_d2.z)/(CFOV*ASPECT.x))*0.125*iResolution.x);\n            vec3 DREF=DenoiseREF(uv,lUV,aUV,iChannel0,iChannel1,min(Proj_r,16.),HITVP,HITN,HITVN,IRES,HRES,CFOV*ASPECT);\n            //SHADOWS\n            Proj_d1=vec3(CTex.w*SunCR,0.,CAttr.w);\n            Proj_d2=vec3(-CTex.w*SunCR,0.,CAttr.w);\n            Proj_r=abs(((Proj_d1.x/Proj_d1.z-Proj_d2.x/Proj_d2.z)/(CFOV*ASPECT.x))*0.125*iResolution.x);\n            vec2 DSHAD=DenoiseSHAD(uv,lUV,aUV,iChannel0,iChannel1,min(Proj_r,16.),HITVP,HITN,HITVN,IRES,HRES,CFOV*ASPECT);\n            //OUTPUT\n            Color=vec4(Write3(min(DREF.xyz,vec3(0.9))),CTex.y,DSHAD);\n        } else {\n            //Denoising pass 4 (Shadows and reflections)\n            vec2 uv=fragCoord-vec2(HRES.x,0.);\n            vec2 lUV=fragCoord;\n            vec2 aUV=uv+vec2(0.,HRES.y);\n            vec4 CAttr=texture(iChannel0,aUV*IRES);\n            vec4 CTex=texture(iChannel1,lUV*IRES);\n            float CR=Read2(CAttr.z).y*2.;\n            //World to view space attributes\n            vec3 Eye=texture(iChannel0,vec2(8.5,0.5)*IRES).xyz;\n            vec3 VDir=normalize(vec3((uv*IRES*4.-1.)*(ASPECT*CFOV),1.));\n            vec3 Tan; vec3 Bit=TBN(Eye,Tan);\n            vec3 HITVP=VDir*CAttr.w;\n            vec3 HITN=Read3(CAttr.y)*2.-1.;\n            vec3 HITVN=vec3(dot(HITN,Tan),dot(HITN,Bit),dot(HITN,Eye));\n            //Projected cone radius\n            vec3 VBit=normalize(cross(VDir,vec3(0.,1.,0.)));\n            vec3 Proj_d1=(CTex.y+CAttr.w)*VDir+CR*CTex.y*VBit;\n            vec3 Proj_d2=(CTex.y+CAttr.w)*VDir-CR*CTex.y*VBit;\n            //REFLECTIONS\n            float Proj_r=abs(((Proj_d1.x/Proj_d1.z-Proj_d2.x/Proj_d2.z)/(CFOV*ASPECT.x))*0.125*iResolution.x);\n            vec3 DREF=DenoiseREF(uv,lUV,aUV,iChannel0,iChannel1,min(Proj_r,2.),HITVP,HITN,HITVN,IRES,HRES,CFOV*ASPECT);\n            //SHADOWS\n            Proj_d1=vec3(CTex.w*SunCR,0.,CAttr.w);\n            Proj_d2=vec3(-CTex.w*SunCR,0.,CAttr.w);\n            Proj_r=abs(((Proj_d1.x/Proj_d1.z-Proj_d2.x/Proj_d2.z)/(CFOV*ASPECT.x))*0.125*iResolution.x);\n            vec2 DSHAD=DenoiseSHAD(uv,lUV,aUV,iChannel0,iChannel1,min(Proj_r,2.),HITVP,HITN,HITVN,IRES,HRES,CFOV*ASPECT);\n            //OUTPUT\n            Color=vec4(Write3(min(DREF.xyz,vec3(0.9))),CTex.y,DSHAD);\n        }\n    } else {\n        if (fragCoord.y>HRES.y && fragCoord.y<RES.y) {\n            //Denoising pass 1 (GI)\n            vec2 uv=fragCoord-vec2(0.,HRES.y);\n            vec4 CAttr=texture(iChannel0,uv*IRES+0.5);\n            //World to view space attributes\n            vec3 Eye=texture(iChannel0,vec2(6.5,0.5)*IRES).xyz;\n            vec3 VDir=normalize(vec3((uv*IRES*4.-1.)*(ASPECT*CFOV),1.));\n            vec3 Tan; vec3 Bit=TBN(Eye,Tan);\n            vec3 HITVP=VDir*CAttr.w;\n            vec3 HITN=Read3(CAttr.y).xyz*2.-1.;\n            vec3 HITVN=vec3(dot(HITN,Tan),dot(HITN,Bit),dot(HITN,Eye));\n            vec3 Denoised=DenoiseGI(uv,uv+HRES,fragCoord,iChannel0,iChannel1,16.,HITVP,HITN,HITVN,IRES,HRES,CFOV*ASPECT);\n            Color=vec4(Denoised,texture(iChannel1,fragCoord*IRES).w);\n        } else {\n            //Denoising pass 4 (GI)\n            vec2 uv=fragCoord;\n            vec4 CAttr=texture(iChannel0,uv*IRES+vec2(0.,0.5));\n            //World to view space attributes\n            vec3 Eye=texture(iChannel0,vec2(8.5,0.5)*IRES).xyz;\n            vec3 VDir=normalize(vec3((uv*IRES*4.-1.)*(ASPECT*CFOV),1.));\n            vec3 Tan; vec3 Bit=TBN(Eye,Tan);\n            vec3 HITVP=VDir*CAttr.w;\n            vec3 HITN=Read3(CAttr.y).xyz*2.-1.;\n            vec3 HITVN=vec3(dot(HITN,Tan),dot(HITN,Bit),dot(HITN,Eye));\n            vec3 Denoised=DenoiseGI(uv,uv+vec2(0.,HRES.y),fragCoord,iChannel0,iChannel1,2.,HITVP,HITN,HITVN,IRES,HRES,CFOV*ASPECT);\n            Color=vec4(Denoised,texture(iChannel1,fragCoord*IRES).w);\n        }\n    }\n    fragColor=Color;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//Second and final denoising pass + composition\n\nfloat Schlick(float R0, float COS) {\n    //Schlick approximation\n    return R0+(1.-R0)*pow(1.-COS,5.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Color=vec4(0.);\n    if (fragCoord.x>HRES.x && fragCoord.x<RES.x) {\n        if (fragCoord.y>HRES.y && fragCoord.y<RES.y) {\n            //Denoising pass 2 (Shadows and reflections)\n            vec2 uv=fragCoord-HRES;\n            vec2 lUV=fragCoord;\n            vec2 aUV=uv+HRES;\n            vec4 CAttr=texture(iChannel0,aUV*IRES);\n            vec4 CTex=texture(iChannel1,lUV*IRES);\n            float CR=Read2(CAttr.z).y*2.;\n            //World to view space attributes\n            vec3 Eye=texture(iChannel0,vec2(6.5,0.5)*IRES).xyz;\n            vec3 VDir=normalize(vec3((uv*IRES*4.-1.)*(ASPECT*CFOV),1.));\n            vec3 Tan; vec3 Bit=TBN(Eye,Tan);\n            vec3 HITVP=VDir*CAttr.w;\n            vec3 HITN=Read3(CAttr.y)*2.-1.;\n            vec3 HITVN=vec3(dot(HITN,Tan),dot(HITN,Bit),dot(HITN,Eye));\n            //Projected cone radius\n            vec3 VBit=normalize(cross(VDir,vec3(0.,1.,0.)));\n            vec3 Proj_d1=(CTex.y+CAttr.w)*VDir+CR*CTex.y*VBit;\n            vec3 Proj_d2=(CTex.y+CAttr.w)*VDir-CR*CTex.y*VBit;\n            //REFLECTIONS\n            float Proj_r=abs(((Proj_d1.x/Proj_d1.z-Proj_d2.x/Proj_d2.z)/(CFOV*ASPECT.x))*0.125*iResolution.x);\n            vec3 DREF=DenoiseREF(uv,lUV,aUV,iChannel0,iChannel1,min(Proj_r,8.),HITVP,HITN,HITVN,IRES,HRES,CFOV*ASPECT);\n            //SHADOWS\n            Proj_d1=vec3(CTex.w*SunCR,0.,CAttr.w);\n            Proj_d2=vec3(-CTex.w*SunCR,0.,CAttr.w);\n            Proj_r=abs(((Proj_d1.x/Proj_d1.z-Proj_d2.x/Proj_d2.z)/(CFOV*ASPECT.x))*0.125*iResolution.x);\n            vec2 DSHAD=DenoiseSHAD(uv,lUV,aUV,iChannel0,iChannel1,min(Proj_r,8.),HITVP,HITN,HITVN,IRES,HRES,CFOV*ASPECT);\n            //OUTPUT\n            Color=vec4(Write3(min(DREF.xyz,vec3(0.9))),CTex.y,DSHAD);\n        } else {\n            //Denoising pass 5 (Shadows and reflections)\n            vec2 uv=fragCoord-vec2(HRES.x,0.);\n            vec2 lUV=fragCoord;\n            vec2 aUV=uv+vec2(0.,HRES.y);\n            vec4 CAttr=texture(iChannel0,aUV*IRES);\n            vec4 CTex=texture(iChannel1,lUV*IRES);\n            float CR=Read2(CAttr.z).y*2.;\n            //World to view space attributes\n            vec3 SunDir=texture(iChannel0,vec2(5.5,0.5)*IRES).xyz;\n            vec3 Eye=texture(iChannel0,vec2(8.5,0.5)*IRES).xyz;\n            vec3 VDir=normalize(vec3((uv*IRES*4.-1.)*(ASPECT*CFOV),1.));\n            vec3 Tan; vec3 Bit=TBN(Eye,Tan);\n            vec3 HITVP=VDir*CAttr.w;\n            vec3 Dir=VDir*TBN(Eye);\n            vec3 HITN=Gradient(texture(iChannel0,vec2(9.5,0.5)*IRES).xyz+Dir*CAttr.w,iTime);\n            vec3 HITVN=vec3(dot(HITN,Tan),dot(HITN,Bit),dot(HITN,Eye));\n            //Projected cone radius\n            vec3 VBit=normalize(cross(VDir,vec3(0.,1.,0.)));\n            vec3 Proj_d1=(CTex.y+CAttr.w)*VDir+CR*CTex.y*VBit;\n            vec3 Proj_d2=(CTex.y+CAttr.w)*VDir-CR*CTex.y*VBit;\n            //REFLECTIONS\n            float Proj_r=abs(((Proj_d1.x/Proj_d1.z-Proj_d2.x/Proj_d2.z)/(CFOV*ASPECT.x))*0.125*iResolution.x);\n            vec3 DREF=DenoiseREF(uv,lUV,aUV,iChannel0,iChannel1,min(Proj_r,1.),HITVP,HITN,HITVN,IRES,HRES,CFOV*ASPECT);\n            //SHADOWS\n            Proj_d1=vec3(CTex.w*SunCR,0.,CAttr.w);\n            Proj_d2=vec3(-CTex.w*SunCR,0.,CAttr.w);\n            Proj_r=abs(((Proj_d1.x/Proj_d1.z-Proj_d2.x/Proj_d2.z)/(CFOV*ASPECT.x))*0.125*iResolution.x);\n            vec2 DSHAD=DenoiseSHAD(uv,lUV,aUV,iChannel0,iChannel1,min(Proj_r,1.),HITVP,HITN,HITVN,IRES,HRES,CFOV*ASPECT);\n            //Composition\n            vec2 ARG=Read2(CAttr.z)*2.;\n            vec3 Light=vec3(0.);\n            if (ARG.x>1.5) {\n                //EMISSIVE\n                Color=vec4(Read3(CAttr.x)*I09,CAttr.y);\n            } else if (CAttr.w<9990.) {\n                if (ARG.x<0.99) {\n                    //REFLECTIONS\n                    vec3 RDir=reflect(Dir,HITN);\n                    float fSCHLICK=Schlick(0.1,dot(HITN,RDir));\n                    Light=mix(DREF*fSCHLICK,SunColor*(max(0.,dot(HITN,SunDir))*DSHAD.x*(1.-fSCHLICK)),ARG.x);\n                } else {\n                    //Direct light\n                    //vec3 RDir=reflect(Dir,HITN);\n                    //float fSCHLICK=Schlick(0.,dot(HITN,RDir));\n                    Light=SunColor*(max(0.,dot(HITN,SunDir))*DSHAD.x);\n                }\n                //COLOR\n                Light=Light*Read3(CAttr.x)*I09;\n                Color=vec4(Light,CAttr.w);\n            } else {\n                //SKY\n                Color=vec4(SkyColor*(1.-0.5*Dir.y),10000.); //SkyColor*(1.-0.5*Dir.y)+SunColor*pow(max(dot(SunVec,Dir),0.),12.);\n            }\n        }\n    } else {\n        if (fragCoord.y>HRES.y && fragCoord.y<RES.y) {\n            //Denoising pass 2 (GI)\n            vec2 uv=fragCoord-vec2(0.,HRES.y);\n            vec4 CAttr=texture(iChannel0,(uv+HRES)*IRES);\n            //World to view space attributes\n            vec3 Eye=texture(iChannel0,vec2(6.5,0.5)*IRES).xyz;\n            vec3 VDir=normalize(vec3((uv*IRES*4.-1.)*(ASPECT*CFOV),1.));\n            vec3 Tan; vec3 Bit=TBN(Eye,Tan);\n            vec3 HITVP=VDir*CAttr.w;\n            vec3 HITN=Read3(CAttr.y).xyz*2.-1.;\n            vec3 HITVN=vec3(dot(HITN,Tan),dot(HITN,Bit),dot(HITN,Eye));\n            vec3 Denoised=DenoiseGI(uv,uv+HRES,fragCoord,iChannel0,iChannel1,8.,HITVP,HITN,HITVN,IRES,HRES,CFOV*ASPECT);\n            Color=vec4(Denoised,texture(iChannel1,fragCoord*IRES).w);\n        } else {\n            //Denoising pass 5 (GI) + composition\n            vec2 uv=fragCoord;\n            vec4 CAttr=texture(iChannel0,(uv+vec2(0.,HRES.y))*IRES);\n            //World to view space attributes\n            vec3 Eye=texture(iChannel0,vec2(8.5,0.5)*IRES).xyz;\n            vec3 VDir=normalize(vec3((uv*IRES*4.-1.)*(ASPECT*CFOV),1.));\n            vec3 Tan; vec3 Bit=TBN(Eye,Tan);\n            vec3 HITVP=VDir*CAttr.w;\n            vec3 Dir=VDir*TBN(Eye);\n            vec3 HITN=Gradient(texture(iChannel0,vec2(9.5,0.5)*IRES).xyz+Dir*CAttr.w,iTime);\n            vec3 HITVN=vec3(dot(HITN,Tan),dot(HITN,Bit),dot(HITN,Eye));\n            vec3 Denoised=DenoiseGI(uv,uv+vec2(0.,HRES.y),fragCoord,iChannel0,iChannel1,1.,HITVP,HITN,HITVN,IRES,HRES,CFOV*ASPECT);\n            //Composition\n            vec3 Light=Denoised;\n            vec2 ARG=Read2(CAttr.z)*2.;\n            if (CAttr.w<9990.) {\n                if (ARG.x<1.5) {\n                    //DIFFUSE\n                    Light=Denoised*ARG.x;\n                } else if (ARG.x>1.5) {\n                    Light=vec3(1.);\n                }\n            }\n            //COLOR\n            Light=Light*Read3(CAttr.x)*I09;\n            //RETURN\n            Color=vec4(Light,0.);\n        }\n    }\n    fragColor=Color;\n}","name":"Buffer D","description":"","type":"buffer"}]}