{"ver": "0.1", "info": {"id": "lllSR2", "date": "1438214088", "viewed": 425, "name": "w10", "username": "gyabo", "description": "Windows10 wallpapar wip.\n\nOMG\nhttps://www.youtube.com/watch?t=128&v=hL8BBOwupcI\n\n\nhttps://www.youtube.com/watch?t=128&v=hL8BBOwupcI\n\nomg.", "likes": 7, "published": 3, "flags": 0, "tags": ["wind", "windows"], "requires": ["imagebuf"]}, "renderpass": [{"inputs": [], "outputs": [], "code": "\n#define PI     3.1415926535897921284\n#define REP    25\n#define d2r(x) (x * PI / 180.0)\n#define WBCOL  (vec3(0.5, 0.7,  1.7))\n#define WBCOL2 (vec3(0.15, 0.8, 1.7))\n\n\nfloat hash( vec2 p ) {\n\tfloat h = dot( p, vec2( 127.1, 311.7 ) );\n\treturn fract( sin( h ) * 458.325421) * 2.0 - 1.0;\n}\n\nfloat noise( vec2 p ) {\n\tvec2 i = floor( p );\n\tvec2 f = fract( p );\n\t\n\tf = f * f * ( 3.0 - 2.0 * f );\n\t\n\treturn mix(\n\t\tmix( hash( i + vec2( 0.0, 0.0 ) ), hash( i + vec2( 1.0, 0.0 ) ), f.x ),\n\t\tmix( hash( i + vec2( 0.0, 1.0 ) ), hash( i + vec2( 1.0, 1.0 ) ), f.x ),\n\t\tf.y\n\t);\n}\n\nvec2 rot(vec2 p, float a) {\n\treturn vec2(\n\t\tp.x * cos(a) - p.y * sin(a),\n\t\tp.x * sin(a) + p.y * cos(a));\n}\n\nfloat nac(vec3 p, vec2 F, vec3 o) {\n\tconst float R = 0.0001;\n\tp += o;\n\treturn length(max(abs(p.xy)-vec2(F),0.0)) - R;\t\n}\n\n\nfloat by(vec3 p, float F, vec3 o) {\n\tconst float R = 0.0001;\n\tp += o;\n\treturn length(max(abs(mod(p.xy, 3.0))-F,0.0)) - R;\t\n}\n\n\nfloat recta(vec3 p, vec3 F, vec3 o) {\n\tconst float R = 0.0001;\n\tp += o;\n\treturn length(max(abs(p)-F,0.0)) - R;\t\n}\n\n\nfloat map1(vec3 p, float scale) {\n\tfloat G = 0.50;\n\tfloat F = 0.50 * scale;\n\tfloat t =  nac(p, vec2(F,F), vec3( G,  G, 0.0));\n\tt = min(t, nac(p, vec2(F,F), vec3( G, -G, 0.0)));\n\tt = min(t, nac(p, vec2(F,F), vec3(-G,  G, 0.0)));\n\tt = min(t, nac(p, vec2(F,F), vec3(-G, -G, 0.0)));\n\treturn t;\n}\n\nfloat map2(vec3 p) {\n\tfloat t = map1(p, 0.9);\n\tt = max(t, recta(p, vec3(1.0, 1.0, 0.02), vec3(0.0, 0.0, 0.0)));\n\treturn t;\n}\n\n\n// http://glslsandbox.com/e#26840.0\nfloat gennoise(vec2 p) {\n\tfloat d = 0.5;\n\tmat2 h = mat2( 1.6, 1.2, -1.2, 1.6 );\n\t\n\tfloat color = 0.0;\n\tfor( int i = 0; i < 8; i++ ) {\n\t\tcolor += d * noise( p * 5.0 + iTime);\n\t\tp *= h;\n\t\td /= 2.0;\n\t}\n\treturn color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = -1.0 + 2.0 * ( fragCoord.xy / iResolution.xy );\n    uv *= 1.4;\n\tvec3 dir = normalize(vec3(uv * vec2(iResolution.x / iResolution.y, 1.0), 1.0));\n\tdir.xz = rot(dir.xz, d2r(70.0));\n\tdir.xy = rot(dir.xy, d2r(90.0));\n\tvec3 pos    = vec3(-0.1 + sin(iTime * 0.3) * 0.1, 2.0 + cos(iTime * 0.4) * 0.1, -3.5);\n\tvec3  col   = vec3(0.0);\n\tfloat t     = 0.0;\n\tfloat M     = 1.002;\n\tfloat bsh   = 0.01;\n\tfloat dens  = 0.0;\n\t\n\tfor(int i = 0 ; i < REP * 24; i++) {\n\t\tfloat temp = map1(pos + dir * t, 0.6);\n\t\tif(temp < 0.2) {\n\t\t\tcol += WBCOL * 0.005 * dens;\n\t\t}\n\t\tt += bsh * M;\n\t\tbsh *= M;\n\t\tdens += 0.025;\n\t}\n\n\t//windows\n\tt = 0.0;\n\tfloat y = 0.0;\n\tfor(int i = 0 ; i < REP * 50; i++) {\n\t\tfloat temp = map2(pos + dir * t);\n\t\tif(temp < 0.1) {\n\t\t\tcol += WBCOL2 * 0.005;\n\t\t}\n\t\tt += temp;\n\t\ty++;\n\t}\n\tcol += ((2.0 + uv.x) * WBCOL2) + (y / (25.0 * 50.0));\n\tcol += gennoise(dir.xz) * 0.5;\n\tcol *= 1.0 - uv.y * 0.5;\n\tcol *= vec3(0.05);\n\tcol  = pow(col, vec3(0.717));\n\tfragColor = vec4(col, 1.0 / (t));\n}\n\n", "name": "Image", "description": "", "type": "image"}]}