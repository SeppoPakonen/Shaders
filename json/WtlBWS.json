{"ver":"0.1","info":{"id":"WtlBWS","date":"1597612180","viewed":139,"name":"Pylon Terrascape","username":"pjkarlik","description":"Sunday shading - wanted to get into the landscape  and more photo real stuff - doing the FBM / terra explorations. Music is just for ambiance! I <3 Cabaret Nocturne","likes":6,"published":3,"flags":64,"tags":[]},"renderpass":[{"inputs":[{"id":"lt23WG","filepath":"https://soundcloud.com/sinchicollective/premiere-cabaret-nocturne-occult-spells-nein-records","previewfilepath":"https://soundcloud.com/sinchicollective/premiere-cabaret-nocturne-occult-spells-nein-records","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// Pylons (not really but close) | pjk 8.16.202\n//\n// Sunday mental shader-batting.\n// Starting to get into the landscape / terra building \n// first attempt at something real without killing the\n// speed.. its lagging to 59.fps on my desktop\n\n// I dont know sky or clouds yet - working on it..\n// cheat coloring based on noise value also\n// fog makes everthing cooler..\n\n// Music Cabaret Nocturne | Occult Spells\n// Just for ambience - felt right when coding it..\n\n\n#define MAX_DIST \t25.\n\n#define PI  \t\t3.1415926\n#define PI2 \t\t6.2831\n#define R \t\t\tiResolution\n#define M \t\t\tiMouse\n#define T \t\t\tiTime\n#define ZRO         (min(iFrame,0))\n#define hash(a, b) fract(sin(a*1.2664745 + b*.9560333 + 3.) * 14958.5453)\n#define r2(a)  mat2(cos(a), sin(a), -sin(a), cos(a))\n// hoisted to precal\nmat2 t1r,t2r;\nvec3 floatv;\nfloat tm;\n\n//@iq\nfloat sdTri( vec3 p, vec2 h ) {\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nvec3 map(vec3 p) {\n    vec2 res = vec2(100.,-1.);\n    p.y+=.5;\n    vec3 q = p;\n\t// bad attempt at doing LOD with noise\n\tfloat detail = (distance(p.xz,vec2(0.,0.))/1.15)*.4;\n    detail = mix(8., 1., exp(-.02*dot(p.xz,p.xz))); \n    float dfn = fbm((q.xz)*1.15,detail);\n    float d = q.y+dfn;\n    if(d<res.x) res = vec2(d/1.95,1.);\n\n    float bwt = (p.y+.45)+(dfn*.03);\n    if(bwt<res.x) res = vec2(bwt/1.5,4.);\n    \n    vec3 r = vec3(abs(p.x),p.y+.15,abs(p.z));\n\n    r-=floatv;\n\n    r.zx *=t1r;\n    r.zy *=t2r;\n    float dx = sdTri(r, vec2(.55, .05));\n    float tx = sdTri(r, vec2(.45, .07));\n    dx = max(dx,-tx);\n    \n    r.zx *=t1r;\n    r.zy *=t2r;\n    dx = min(sdTri(r, vec2(.35, .03)),dx);\n    tx = sdTri(r, vec2(.25, .06));\n    if (dot(p,p) < 20.) dx = max(dx,-tx);\n    \n    if(dx<res.x) res = vec2(dx,3.);\n    \n    return vec3(res,dfn);   \n}\n\n//https://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n/**vec3 calcNormal(in vec3 p, in float t) {\n    float e = 0.001*t;\n\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n}*/\n//@spalmer\nvec3 calcNormal(vec3 q, float t){\n    float h = .0001\n        * sqrt(1./3.)\n        * (1. + 128.*t)\n        ;\n    vec3 n = vec3(0);\n    int i = 0;\n    i = ZRO;\n    for (; i < 4; ++i) {\n        vec3 e = vec3((ivec3(i+3, i, i+i)&2) - 1);\n        n += map(q + e * h).x * e;\n    }\n    return normalize(n);\n}\n\nvec3 ray_march( in vec3 ro, in vec3 rd, int maxstep ) {\n    float t = .005;\n    vec2 m = vec2(0.);\n    for( int i=0; i<maxstep; i++ ) {\n        vec3 d = map(ro + rd * t);\n        m = d.yz;\n        if(d.x<.0005*t||t>MAX_DIST) break;\n        t += d.x*.75;\n    }\n    return vec3(t,m);\n}\n\nfloat get_diff(in vec3 p, in vec3 lpos, in vec3 n) {\n    vec3 l = lpos-p;\n    vec3 lp = normalize(l);\n    float dif = clamp(dot(n,lp),0. , 1.),\n          shadow = ray_march(p + n * 0.0005 * 2.,lp,64).x;\n    if(shadow < length(l)) dif *= .65;\n    return dif;\n}\n\nvec3 camera(vec3 lp, vec3 ro, vec2 uv) {\n    vec3 cf = normalize(lp - ro),\n         cr = normalize(cross(vec3(0,1,0),cf)),\n         cu = normalize(cross(cf,cr)),\n         c  = ro + cf *.95,\n         i  = c + uv.x * cr + uv.y * cu,\n         rd = i - ro;\n    return rd;\n}\n\nvec3 getColor(float m, float h) {\n    vec3 hue = vec3(0.);\n    \tif(m==1.) hue = mix(vec3(.01,.3,.01),vec3(.8,.3,.1),h*1.1);\n    \tif(m==4.) hue = vec3(.0,.07,.12)+(h*.1);\n        if(m==3.) hue= vec3(.3,.09,.02);\n    return hue;\n}\n\nfloat ao(float j, vec3 p, vec3 n) {\n    return clamp(map(p + n*j).x/j, 0.,1.);   \n}\n\nvoid mainImage( out vec4 O, in vec2 F ){\n    // precal\n    t1r =r2(T*.62);\n    t2r =r2(T*.83);\n    tm = mod(T*.1,3.);\n    float sp = 1.15+.8*sin(T*.2);\n    floatv =vec3(sp,1.35+.5*sin(T*.2),sp);\n    \n\t// reset coords\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 C = vec3(0.);\n    vec3 lp = vec3(0.,0.,0.),\n         ro = vec3(0.,.75,-4.5);\n    \n    float tm = mod(T*.1,3.);\n    if(tm<1.){\n       \tro = vec3(0.,3.75,4.5); \n    } else if (tm<2.) {\n        lp = vec3(0.,0.5,0.);\n\t\tro = vec3(0.5,.5,-2.15); \n    }\n\n    ro.xz*= r2(T*.05);\n\n    vec3 rd = camera(lp,ro,uv);\n\n    vec3 ray = ray_march(ro,rd,178);\n    float t = ray.x;\n    float m = ray.y;\n    \n\tvec3 fc = mix( vec3(.5,.65,.9),vec3(1.),  exp(-10.0*max(rd.y,0.0)));\n    \n    // sky clouds using same height map\n    float clouds = .0 - max(rd.y,0.0)*0.5; //@iq trick\n    vec2 sv = 1.5*rd.xz/rd.y;\n    clouds += 0.1*(-1.0+2.0*smoothstep(-0.5,1.1,fbm(sv.xy*1.75,2.)));\n    vec3 sky = mix( vec3(clouds), fc, exp(-10.0*max(rd.y*.5,0.0)) ) * fc; \n    \n    if(t<MAX_DIST) {\n\t\tvec3 p = ro + t * rd,\n             n = calcNormal(p,ray.x*.1),\n             h = getColor(m,ray.z);\n\n        vec3 lpos1 = vec3(0.,5.,-2.5),\n             diff =  vec3(2.) * get_diff(p, lpos1, n);\n\n        C += (ao(0.1,p,n) + ao(1.5,p,n))* h * diff;\n\n        if(m==3. || m==4. ){\n            \n        vec3 rr=reflect(rd,n);\n        vec3 ref=ray_march(p,rr,128);\n            \n            if(ref.x<MAX_DIST){\n                p+=ref.x*rr;\n                n = calcNormal(p,ref.x*.1);\n                h = getColor(m,ray.z);\n                diff =  vec3(2.) * get_diff(rr, lpos1, n);\n            }\n            \n            if(m==4.){\n             \tC += (h+mix( vec3(clouds), vec3(0), rd.y) * diff)*.7;\n            }else{\n            \tC += h * diff;\n                //C = mix(C, vec3(.0), exp(-0.0005*ref.x*ref.x*ref.x));\n            }\n            \n        }\n    } else {\n        C=fc;\n    }\n     vec2 nu = (uv.xy);\n    float star = hash(nu.x,nu.y)>.0 ? 0. : .4;\n\tC = mix( sky+ vec3(star), C, exp(-0.0005*t*t*t));\n     \n    // output plus gamma correction\n    O = vec4(pow(C,vec3(.4545)),1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define NUM_OCTAVES 8\n\nfloat random (in vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _st) {\n    vec2 i = floor(_st);\n    vec2 f = fract(_st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm ( in vec2 _st, float oct) {\n    oct = min(oct,5.);\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5),\n                    -sin(0.5), cos(0.50));\n    for (float i = 0.; i < 8.25-oct; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    \n    \n    }\n    return v;\n}\n","name":"Common","description":"","type":"common"}]}