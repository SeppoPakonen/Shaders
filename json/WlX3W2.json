{"ver":"0.1","info":{"id":"WlX3W2","date":"1557685095","viewed":99,"name":"Circle Design Study","username":"Yusef28","description":"I made a bunch of different circle functions, many not used in the final product, and just played around with them to try and create some basic variations. It's mainly a workflow exercise but also about design and discovery.","likes":6,"published":1,"flags":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//basic circle with size\nfloat circle (vec2 p , float r)\n{\n return length(p);\n}\n\n//circle with position and size [unused]\nfloat poscircle (vec2 p , float r, vec2 pos)\n{\n //subtracts positive or negative to the starting position at 0.0, 0.0\n //substraction so that positive vec means positive movement from origin\n p-=pos;\n return length(p) - r;\n}\n\n//solid stepped circle [unused]\nfloat SOLcircle(vec2 p, float r)\n{\n// returns white when length is = or less than r  \n return  step(length(p), r);  \n}\n\n//solid smoothstepped circle\nfloat SScircle(vec2 p, float r)\n{\n   float ss =  0.009;\n   float c = length(p);\n    \n return smoothstep(r-ss, r+ss, c);\n}\n\n//circle with color [unused]\nvec3 COLcircle(vec2 p, float r, vec3 col)\n{   \n    float c = 1.0-SScircle(p, r);\n    return c*col;   \n}\n\n//circle with opacity [unused]\nvec3 OPcircle(vec2 p, float r, vec3 col, float op)\n{\n\tfloat c = 1.0-SScircle(p, r);   \n    return vec3(c*col* op);\n    //[thought process]\n    //do I need to do vec4 anyways? because a simple mult\n    //would do the same thing woudln't it?...no becauase what if the circles color is\n    //like 2 or something, so bright that *0.5would still be 1...\n}\n\n//circle with Power based gradient \nfloat GRcircle(vec2 p, float r, float gr)\n{\n   //basic gradient, clamped for high powers!!\n   float c = clamp(pow(length(p), gr), 0.0, 1.0); \n   return c*clamp(1.0-SScircle(p, r), 0.0, 1.0)*2.;  \n}\n\n//circle with Sin-based gradient\nfloat SINcircle(vec2 p, float r, float gr)\n{\n   float c = sin(length(p)*gr);//sin waves\n    c = clamp(c, 0.0, 1.0);\n   return c*SOLcircle(p, r);  \n}\n\n//circle outline\nfloat OUTcircle(vec2 p, float r, float th)\n{\n   float ss = 0.009;\n   float c = length(p);\n    //I flipped the - and + in both ss and th parts to avoid having to \n    //do a 1.0-... later on.\n   return smoothstep(r+ss, r-ss, c) - smoothstep(th+ss, th-ss, c);  \n}\n\n// circle WITH outline\nfloat OLcircle(vec2 p, float r, float th)\n{\n   float ss = 0.009;\n   float spc = 0.1;\n   float c = length(p);\n    //I flipped the - and + in both ss and th parts to avoid having to \n    //do a 1.0-... later on.\n   return smoothstep(spc+ss, spc-ss, c) \n       + (smoothstep(r+ss, r-ss, c) \n          - smoothstep(th+ss, th-ss, c));  \n}\n\n//Two Color Circles\nfloat HALFcircle(vec2 p, float r)\n{\n    \n    float c = 1.0-SScircle(p, r);//can have other functions for half circles of\n    \t\t\t\t\t\t\t// other types\n    float hf = smoothstep(-0.1, 0.09, p.x);\n return c*hf;   \n}\n\nfloat HALFOLcircle(vec2 p, float r, float th)\n{\n    \n    float c = OLcircle(p, r, th);//can have other functions for half circles of\n    \t\t\t\t\t\t\t// other types\n    float hf = smoothstep(0.0, 0.009, p.x);\n return c*hf;   \n}\n\nfloat INcircle(vec2 p, float r)\n{\n    \n    \n return 0.0;   \n}\n/*[other ideas for later]\n//circle with brightness, outline (thickness), outline,repetition, texture\n//circle with rotation???, section???\n*/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 st = uv;//for vignett later;\n    \n    uv = uv*2.0-1.0;\n\tuv.x*=  iResolution.x/iResolution.y;\n    \n    //circles as float, vec3 and vec4\n    //float c = 0.0;\n    vec3 c3 = vec3(1.0)-vec3(texture(iChannel0, uv*.3+0.3).rrr)/4.; \n    \n    //color vector init\n    //vec3 col = vec3(1.0);\n\tvec3 orange = vec3(0.9, 0.5, 0.0);\n    orange -= vec3(texture(iChannel1, uv*2.9+0.3).rrr);\n    vec3 blue = vec3(0.29, 0.5, 0.9);\n    blue -= vec3(texture(iChannel2, uv*0.04+0.3).rrr); \n    //to use a texture instead of just blue, \"rrr\" is to get just a b&w value\n    \n    \n    /*[unused advice]\n    \n    creates basic circle, need to clamp from 0 to 1 to add to a scene!!\n    the other circles don't because they use step or smoothstep which cuts\n    off at 0 and 1, but you can always add clamp just to be sure.\n    c += clamp(1.- circle(uv-vec2(0.91, 0.91), 0.1), 0.0, 1.0);\n    but I opped for using mix instead of c+ anyways so I don't need to \n    worry about this.\n    \n    [end]*/\n    \n    \n    //Outline Rings\n    c3 = mix(c3, blue, OUTcircle(uv+vec2(1.3, -0.6), 0.25, 0.1));\n    c3 = mix(c3, orange, OUTcircle(uv+vec2(1.3, 0.0), 0.25, 0.23));\n    c3 = mix(c3, orange, OUTcircle(uv+vec2(1.3, 0.6), 0.25, 0.05));\n    \n    //Sin gradient circles\n    c3 = mix(c3, blue, SINcircle(uv+vec2(0.45, -0.6), 0.25, 200.)); \n    c3 = mix(c3, orange, SINcircle(uv+vec2(0.45, 0.), 0.25, 90.)); \n    c3 = mix(c3, orange, SINcircle(uv+vec2(0.45, 0.6), 0.25, 40.)); \n    \n    //Pow gradient circles\n    c3 = mix(c3, blue, GRcircle(uv+vec2(-0.45, -0.6), 0.25, 1.));\n    c3 = mix(c3, orange, GRcircle(uv+vec2(-0.45, 0.0), 0.25, 1.5));\n    c3 = mix(c3, blue, GRcircle(uv+vec2(-0.45, 0.6), 0.25, 0.52));\n    //c3 = mix(c3, vec3(0.0), c);\n     \n    //Outline Ring PLUS circles\n    c3 = mix(c3, orange,  OLcircle(uv+vec2(-1.3, -0.6), 0.25, 0.15));\n    c3 = mix(c3, blue, OLcircle(uv+vec2(-1.3, 0.0), 0.25, 0.23));\n    c3 = mix(c3, blue, OLcircle(uv+vec2(-1.3, 0.6), 0.25, 0.11));\n\n    \n    //Adding random half circles \n    c3 = mix(c3, blue, HALFcircle(uv+vec2(-1.3, -0.6), 0.25));\n    c3 = mix(c3, orange, HALFOLcircle(uv+vec2(-1.3, 0.6), 0.25, 0.112));\n    \n    \n    \n    /*[Unused code] creates textures\n    vec3 tx1 = texture(iChannel0, uv*0.4+0.3).rgb;\n    vec3 tx2 = texture(iChannel1, uv*0.4+0.3).rgb;\n    vec3 tx3 = texture(iChannel2, uv*0.4+0.3).rgb;    \n    */\n    \n    /*[Unused code] creates smoothstep circles and add them to the scene\n    c3 = mix(c3, tx3, 1.0-SScircle(uv+vec2(-0.45, -0.6), 0.25));\n    c3 = mix(c3, tx2, 1.0-SScircle(uv+vec2(-0.45, 0.0), 0.15)); \n    c3 = mix(c3, tx1, 1.0-SScircle(uv+vec2(-0.45, 0.6), 0.25)); */\n    \n    \n   // col = vec3(c)+c3;\n    \n    //vignette\n    st *=  1.0 - st.yx;\n    float vig = st.x*st.y*15.;\n    vig = pow(vig, 0.05);\n    \n    fragColor = vec4(vec3(c3)*vig, 1.);\n}","name":"Image","description":"","type":"image"}]}