{"ver":"0.1","info":{"id":"tddcRB","date":"1601820702","viewed":142,"name":"ispheres2torus Quartic Solver","username":"cyperus","description":"Translucent spheres to  torus smooth transition, raytraced using a method for solving quartic equations described by Lanczos.\n\nbased on code by mla@[url]https://www.shadertoy.com/view/ltVfDK[/url]\n\nMouse rotation","likes":3,"published":3,"flags":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////////\n//\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License.\n//\n// \"ispheres2torus Quartic Solver\"\n//\n// Created by Colling Patrik in 2020\n//\n// based on original code \n// - \"Lanczos Quartic Solver\" by Matthew Arcus (mla) in 2018\n//   https://www.shadertoy.com/view/ltVfDK\n//\n// FEATURES:\n// - smooth surface transition from two spheres to one sphere to one torus. \n// - translucent surface\n// - texture torsion and rotation\n// - solving quartic equation described by Lanczos-method\n//\n// USE:\n// - As bounding box.\n//\n// TODO:\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.141592654;\nconst float TWOPI = 2.0 * PI;\n\n#define ROTATION(alpha) mat2(cos(alpha),-sin(alpha),sin(alpha),cos(alpha))\n#define COLORIZATION(h)\tclamp(abs(fract(h+vec3(3,2,1)/3.0)*6.0-3.0)-1.0,0.0,1.0)\n//// helper functions\nfloat smoothrecpuls(float x,float aa,float ab,float ia,float ib)\n{\n    /*\n\tsmoothrecpuls is an periodic smooth rectangle-function\n\twith normalized periode == 1.\n\tIt starts at x == 0 with the first-transition-interval, followed by puls-a-const-\n\t, second-transition- and puls-b-const-interval.\n    float x  : in value\t\t(normalized)\n    float aa : in amplitude pulse a\n    float ia : in interval puls a\t\tia in [0,1]  (normalized)  \n    float ab : in amplitude pulse b\n    float ib : in interval puls b\t  \tib in [0,1]  (normalized)\n\n    check ia+ib < 1.0; it+ia+it+ib = 1.0;\n    */\n    ia = abs(ia);\n    ib = abs(ib);\n    // function smooth2puls\n    float it = 0.5*(1.-ia-ib); // interval transition   \n    x = fract(x);\n\treturn   (aa-ab)*smoothstep(0.0\t\t,it\t\t\t,x)+ab\n\t\t\t-(aa-ab)*smoothstep(it+ia\t,it+ia+it\t,x);\n}\n//// quartic equation solver using Lanczos method\nfloat evalcubic(float x, float a, float b, float c, float d) {\n\treturn ((x*a+b)*x+c)*x+d;\n}\n\nfloat evalquad(float x, float a, float b, float c) {\n\treturn (x*a+b)*x+c;\n}\n\n// Solve a*x**2 + b*x + c == 0\nbool quadratic(float a, float b, float c, out vec2 t) {\n\tfloat d = b*b - 4.0*a*c;\n\tif (d < 0.0) return false;\n\td = sqrt(d);\n\tif (b < 0.0) d = -d;\n\tt.x = 0.5*(-b-d)/a;\n\tt.y = c/(a*t.x);\n\tif (t.x > t.y) t.xy = t.yx; // Sort results\n\treturn true;\n}\n\n\nfloat cubic(float a, float b, float c) {\n\t/*\n\tFind real root of x**3 + a*x**2 + b*x + c\n\tAssume c < 0    \n\tc is always negative, but may be very\n\tsmall, in which case we return an\n\tapproximation. Never return < 0.\n\t*/\n\tif (c > -1e-6) {\n\t\tif (b > 1e-10) return -c/b;\n\t\tif (b > -1e-4) return 0.0;\n    }\n    // Now substitute to make c = -1\n\tfloat k = 1.0;\n\tk = pow(-c,1.0/3.0);\n\ta /= k; b /= k*k; c = -1.0;\n\t// Now bracket a root between 0 and 1\n\t// We may need to solve for 1/x\n\tbool reciprocate = evalcubic(1.0,1.0,a,b,c) < 0.0;\n\tif (reciprocate) {\n\t\tfloat a1 = -b;\n\t\tfloat b1 = -a;\n\t\ta = a1; b = b1;\n\t}\n\n\tvec2 res;\n\tfloat x = 0.0;\n\t// Chebyshev polynomial: |32x**3 - 48x**2 + 18x - 1| < 1\n\tif (quadratic(a+1.5, b-0.5625, c+0.03125,res)) {\n\t\t// Find root closest to unit interval,\n\t\tx = (abs(res[0]-0.5) < abs(res[1]-0.5))? res[0]: res[1];\n\t}\n    \n\t// 3 rounds of Newton-Raphson\n\tx -= evalcubic(x,1.0,a,b,c)/evalquad(x,3.0,2.0*a,b);\n\tx -= evalcubic(x,1.0,a,b,c)/evalquad(x,3.0,2.0*a,b);\n\tx -= evalcubic(x,1.0,a,b,c)/evalquad(x,3.0,2.0*a,b);\n    \n\tif (reciprocate) return k/x;\n\treturn k*x;\n}\n\nint quartic(float c1, float c2, float c3, float c4, out vec4 res) {\n\tfloat alpha = 0.5*c1;\n\tfloat A = c2-alpha*alpha;\n\tfloat B = c3-alpha*A;\n\tfloat a,b,beta,psi;\n\tif (B == 0.0) psi = 0.0;\n\telse psi = cubic(2.0*A-alpha*alpha, A*A+2.0*B*alpha-4.0*c4, -B*B);\n\ta = sqrt(psi);\n\tbeta = 0.5*(A + psi);\n\tif (psi == 0.0) {\n\t\tb = sqrt(max(beta*beta-c4,0.0));\n  \t}\n    else {\n\t\tb = 0.5*a*(alpha-B/psi);\n\t}\n\tvec2 tmp;\n\tint resn = 0;\n\tif (quadratic(1.0,alpha+a,beta+b,tmp)) {\n\t\tres.xy = tmp.xy;\n\t\tresn += 2;\n\t}\n\tif (quadratic(1.0,alpha-a,beta-b,tmp)) {\n\t\tres.zw = res.xy;\n\t\tres.xy = tmp.xy;\n\t\tresn += 2;\n\t}\n\treturn resn;\n}\n//// quartic surface\n\nvec4 compute(vec3 o, vec3 d) {\n\t/*\n\tray is defined by p(t) = o + t*d\n\tvec3 p : intersection point (x,y,z)\n\tvec3 o : ray-origin\n\tvec3 d : ray-direction\n\tvec4 t : ray-distance (maximal 4 solutions)\n    surface is defined by (x^2+y^2-z^2-co)^2+4.0*(x^2+y^2)*z^2-cr^2=0\n    float cr : circle radius\n\tfloat co : circle origine\n\tafter some calculations you get the quartic equation\n\tA * t^4 + B * t^3 + C * t^2 + D * t^1 + E = 0\n\t*/\n    \n\t// parameters\n    const float af = 1./20.; // animation frequency\n\tconst float cr = 1.0;\n    const float a0 = 3.0;\n    // anim\n    float time = af * iTime;\n\tfloat co = a0*sin(TWOPI*time);\n\t// commun factors\n\tfloat oo2 = o.x*o.x+o.y*o.y, oo3 = oo2-o.z*o.z; // squares\n\tfloat dd2 = d.x*d.x+d.y*d.y, dd3 = dd2-d.z*d.z;\n\tfloat od2 = o.x*d.x+o.y*d.y, od3 = od2-o.z*d.z; // mixed products\n\tfloat k = co*co-cr*cr; // const\n    // quartic equation coefficients\n\tfloat A = \t dd3*dd3\n      \t\t\t+4.0*dd2*d.z*d.z;\n    float B =  4.0*(\n      \t\t\t+od3*dd3\n      \t\t\t+2.0*d.z*(od2*d.z+dd2*o.z)\n    \t\t\t\t);\n\tfloat C =  2.0*(\n      \t\t\t+(2.0*od3*od3+dd3*oo3) \n\t\t\t\t-co*dd3\n      \t\t\t+2.0*(oo2*d.z*d.z+4.0*od2*o.z*d.z+dd2*o.z*o.z)\n\t\t\t\t\t);\n\tfloat D =  4.0*(\n      \t\t\t+oo3*od3\n      \t\t\t-co*od3\n      \t\t\t+2.0*o.z*(oo2*d.z+od2*o.z)\n\t\t\t\t\t);\n\tfloat E = \t oo3*oo3\n\t\t\t\t-2.0*co*oo3\n\t\t\t\t+4.0*oo2*o.z*o.z\n\t\t\t\t+k;\n  \n  \t// t^4 + B * t^3 + C * t^2 + D * t^1 + E = 0\n  \tif (A == 0.) A = 0.00000000001;\n  \tB = B/A; C = C/A; D = D/A; E = E/A;\n  \tvec4 t;\n  \tint n = quartic(B,C,D,E,t); // A == 1.0\n  \tif (n == 4) {\n    \t// t is sorted by pairs so if we have 4 results, put in order\n    \tif (t.y > t.z) t.yz = t.zy;\n    \tif (t.x > t.y) t.xy = t.yx;\n    \tif (t.z > t.w) t.zw = t.wz;\n    \tif (t.y > t.z) t.yz = t.zy;\n\t}\n    \n\t// colorization\n    // sky color\n    vec3 color = vec3(0.04999);\n    // switch texture\n    const float num_sequence = 4.0;\n    float a = time+4.0*af;\n\tint tex_id = int( floor(a-num_sequence*floor(a/num_sequence))); //tex_id = 3;\n  \t// Process from furthest point of intersection\n\tfor (int i = n; i > 0; i--) {\n\t\t// intersection-point  \n\t\tvec3 p = o+t[i-1]*d;\n        /*// normal\n\t\tvec3 n = 4.0*( (p.x*p.x*+p.y*p.y-p.z*p.z-co)*vec3(p.x,p.y,-p.z)\n\t\t\t\t\t   +2.0*p.z*vec3(p.x*p.z,p.y*p.z,p.x*p.x+p.y*p.y) );*/\n\t\t// uv-coords\n\t\tfloat u = atan(p.y,p.x)/PI; \n        float cosPIv= (oo3+2.0*od3*t[i-1]+dd3*t[i-1]*t[i-1]-co)/cr;       \n        float v = 0.5-2.0*atan(cosPIv,(1.0+sqrt(1.-cosPIv*cosPIv)))/PI; //v = arccos(cosPIv)/PI ;)\n        v *= sign(p.z); // texture symmetries\n\t\t// color texture\n\t\tvec3 c = vec3(0.0); // surface color\n\t\tif (tex_id == 0)\n        \tc = COLORIZATION((v));\n        if (tex_id == 1){\n        \tu = u+2.0*v+ 6.0*time;    \n\t\t\tc = COLORIZATION(u);\n        }\n        if (tex_id == 2){\n\t\t\tconst float shade_frac = 4.0;  \n\t\t\tc = COLORIZATION(u)\n\t\t\t* 1.4*(0.3+0.7*fract(0.5*shade_frac*(v+1.0)));    \n\t\t}\n        if (tex_id == 3){\n\t\t\t// animation texture ,continuous texture-torsion-constraint in torus-state\n\t\t\tfloat timeo = asin(1./a0)/TWOPI;\n\t\t\tfloat torsion = smoothrecpuls(time+timeo+0.5 , -1.0, 1.0, 0.0, 0.5-2.0*timeo);\n            //\n            u = u+torsion*v+ 6.0*time;\n\t\t\tconst float shade_frac = 4.0;  \n\t\t\tc = COLORIZATION(v)\n\t\t\t* 1.4*(0.3+0.7*fract(0.5*shade_frac*(u+1.0)));\n        }\n        color = mix(color, c, exp( -0.15*t[i-1]*t[i-1] ) );\n\t}\n    color = pow(color,vec3(0.4545)); // gamma correction\n\treturn vec4(color,1.0);\n}\n//// camera\nvec2 rotate(in vec2 p, in float t) {\n\treturn p * cos(t) + vec2(p.y, -p.x) * sin(t);\n}\nvec3 transform(in vec3 p) {\n\t// camera ray rotation   \n\tif (iMouse.x > 0.0) {\n\t\tfloat theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n\t\tfloat phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;   \n\t\tp.yz = rotate(p.yz,theta);\n\t\tp.zx = rotate(p.zx,-phi);\n    }\n\tp.yz = rotate(p.yz, 0.1*iTime);\n\tp.zx = rotate(p.zx, 0.2*iTime);\n\treturn p;\n}\n//// main\nvoid mainImage(out vec4 fragColor,vec2 fragCoord) {\n\tvec2 uv = (2.0*fragCoord - iResolution.xy)/min(iResolution.x,iResolution.y);\n\tvec3 o = vec3(0,0,-3); // camera ray-origin\n\tvec3 d = vec3(uv,2);   // camera ray-direction\n    \n\to = transform(o);\n\td = normalize(transform(d));\n\tfragColor = compute(o,d);\n}\n","name":"Image","description":"","type":"image"}]}