{"ver": "0.1", "info": {"id": "4ldcWS", "date": "1534603027", "viewed": 814, "name": "Two Tweet Turing Texture", "username": "Shane", "description": "GPU based, two tweet moving Turing pattern that forms in about two seconds.", "likes": 24, "published": 3, "flags": 32, "tags": ["fusion", "pattern", "reaction"], "requires": ["texture", "texturebuf", "imagebuf"]}, "renderpass": [{"inputs": [{"id": "4dXGR8", "filepath": "/media/previz/buffer00.png", "previewfilepath": "/media/previz/buffer00.png", "type": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "/*\n\n\tTwo Tweet Turing Texture\n\t------------------------\n\n    Every now and again, I'll obsess over creating something with minimal code -- \n\tI'm not as obsessed as Fabrice, but like plenty of others on here, I have that \n    tendency. Sometimes, it's just for fun, and others, to see if it can be done.\n\n\tAnyway, here's the smallest Turing pattern routine I could come up with. Turing\n\tpatterns usually require way more steps, so conceptually speaking, I doubt there'd \n    be a smaller routine out there. I had to employ a bit of voodoo to make this work. \n    There's some esoteric theory and some of my own refinements behind it, but since \n    it was coded for novelty purposes only, I won't bore you with the details. However, \n    I'll put up a couple of examples later that will be of more practical use.\n\n\tBy the way, the pattern might start to lose some integrity and take on a diagonal \n    appearance after a while, but you get what you pay for. :D By the way, there are \n    ways to get the character count much further down, but I think it's small enough \n    in its current form. Suggestions for improvements are always welcome. :)\n\n\n    Similar examples:\n\n    // Higher quality, more sophisticated, and way more interesting in general, \n    // but also about 50 times larger. :) I deliberately didn't look at Flexi's \n    // workings until after I'd completed this, because I didn't want it to \n    // inflence my thought process. Afterward, I perused the code, and it's really \n    // clever. For anyone interested in this kind of thing -- and Turing textures of\n    // the multiscale variety, it's definitely worth looking at.\n    //\n\tSimple Turing Pattern Mix - Flexi\n\thttps://www.shadertoy.com/view/4sGGRR\n\n\t// A while back, I was obsessed with creating the most conceptually \n\t// minimalistic Voronoi pattern:\n    //\n    One Tweet Cellular Pattern - Shane\n    https://www.shadertoy.com/view/MdKXDD\n\n*/\n\nvoid mainImage( out vec4 c, in vec2 f){\n    \n    c = texelFetch(iChannel0, ivec2(f), 0).xxxx*2. - .5;\n    // Alternatives.\n    //c = texelFetch(iChannel0, ivec2(f), 0)*2. - .5; // Multicolored.\n    //c = texture(iChannel0, f/iResolution.xy).xxxx;\n    //c = textureLod(iChannel0, f/iResolution.xy, 0.).xxxx;\n    //c = sqrt(smoothstep(0., .5, texelFetch(iChannel0, ivec2(f), 0).xxxx - .5));\n    //c = sqrt(smoothstep(0., .5, textureLod(iChannel0, f/iResolution.xy, 1.).xxxx - .5));\n}", "name": "Image", "description": "", "type": "image"}, {"inputs": [{"id": "Xsf3zn", "filepath": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "type": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "4dXGR8", "filepath": "/media/previz/buffer00.png", "previewfilepath": "/media/previz/buffer00.png", "type": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dXGR8", "channel": 0}], "code": "// Slightly less code than normally required to produce the average Turing pattern. :)\n#define t(n) textureLod(iChannel0, u, n) \nvoid mainImage(out vec4 c, in vec2 u){\n\n    u = (u + vec2(iFrame&1))/iResolution.xy;\n    \n    // This works with other textures too.\n    c = iFrame>15 ? clamp(t(1.) + (t(1.) - t(3.))/3., 0., 1.) : texture(iChannel1, u);\n    \n    // More robust starting conditions -- Thanks to IQ for the tip.\n    //c = textureSize(iChannel1, 0).x<2 || iFrame<1? \n        //texture(iChannel1, u) : clamp(t(1.) + (t(1.) - t(3.))/3., 0., 1.);\n\n    // Textureless. Needs work, but still safely under two tweets.\n    //c = iFrame > 9? clamp(t(1.) + (t(1.) - t(3.))/3., 0., 1.) : vec4(sin(length(u - .5)*1e7));\n    \n}\n", "name": "Buffer A", "description": "", "type": "buffer"}]}