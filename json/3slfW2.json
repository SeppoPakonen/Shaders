{"ver":"0.1","info":{"id":"3slfW2","date":"1589126996","viewed":160,"name":"Raymarched Moonscape","username":"dean_the_coder","description":"Raymarching a lunar landscape.\nIf anyone has any hints and tips they could suggest, they would be welcome! I'm trying to learn. :)","likes":10,"published":1,"flags":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float rfbm(vec2 xz) { return abs(2.0 * fbm(xz) - 1.0); }\n\nfloat sdEarth(vec3 p) {\n    return length(p - vec3(0.0, -0.8, 2.0)) - 0.7;\n}\n\nfloat sdTerrain(vec3 p) {\n    if (p.y > 0.0) return 1e10; // Quick exit.\n\n    float h = rfbm(p.xz * 0.2);\n    p.xz += vec2(1.0);\n    h += 0.5 * rfbm(p.xz * 0.8);\n    h += 0.25 * rfbm(p.xz * 2.0);\n    h += 0.03 * rfbm(p.xz * 16.1);\n    \n    h *= 0.7 * fbm(p.xz);\n    h -= 0.7;\n    \n    return abs(p.y - h) * 0.6;\n}\n\nvec2 map(vec3 p) {\n    float d1 = sdTerrain(p);\n    float d2 = sdEarth(p);\n    \n    return d1 < d2 ? vec2(d1, 1.0) : vec2(d2, 2.0);\n}\n\nvec3 calcNormal(in vec3 p) {\n    // Thanks iq! I didn't fancy deriving this...\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( p + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( p + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( p + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( p + e.xxx ).x );\n}\n\nfloat calcShadow(vec3 origin, vec3 lightOrigin) {\n    float s = 1.0;\n    \n    vec3 rayDir = normalize(lightOrigin - origin);\n    float d = 0.1;\n    while (d < 10.0 && s > 0.0) {\n        float distToObj = map(origin + rayDir * d).x;\n        s = min(s, distToObj / d);\n        d += clamp(distToObj, 0.2, 1.0);\n    }\n    \n    return smoothstep(0.0, 1.0, s);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, -3.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n\tfloat d = 0.01;\n    vec3 p;\n    float id = 0.0;\n    for (float steps = 0.0; steps < 80.0; steps++) {\n        p = ro + rd * d;\n        vec2 h = map(p);\n        if (abs(h.x) < 0.004 * d) {\n            id = h.y;\n            break;\n        }\n        \n        if (d > 5.0) break;\n         \n        d += h.x;\n    }\n    \n    vec3 col;\n    if (id < 0.5) {\n        // Stars.\n    \tcol = vec3(stars(uv));\n    } else {\n        vec3 sunPos = vec3(8.0 - 16.0 * iMouse.x / iResolution.x, 6.0 - cos(iTime * 0.2), -1.0 - iMouse.y / 360.0 * 20.0);\n        vec3 n = calcNormal(p);\n        vec3 mainLight = vec3(1.82, 1.8, 1.78) * dot(n, normalize(sunPos - p));\n        \n        if (id > 1.5) {\n            // Earth.\n            vec3 sea = vec3(0.05, 0.05, 0.8);\n            vec3 land = vec3(0.05, 0.25, 0.05);\n            vec3 cloud = vec3(1.0);\n            float landish = smoothstep(0.4, 0.52, fbm(n.xy * 3.1 + vec2(iTime * 0.05, 0.0)));\n            col = mix(sea, land, landish);\n            \n            float cloudish = smoothstep(0.8, 0.95, n.y) * smoothstep(0.1, 0.8, fbm(n.xz * 10.0 + vec2(iTime * .1, 0.0)));\n            col = mix(col, cloud, cloudish);\n            \n            vec3 glow = vec3(0.3, 0.5, 0.95);\n            float glowish = smoothstep(-0.5, 0.0, n.z);\n            col = mix(col, glow, glowish);\n                \n            col *= mainLight;\n        } else if (id > 0.5) {\n            // Terrain.\n\t        float shadow = pow(calcShadow(p, sunPos), 2.0);\n            col = vec3(0.5) * mainLight * shadow;\n        }\n    }\n   \n    col = pow(col, vec3(0.4545));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float hash(vec2 p) {\n    return fract(sin(dot(p, vec2(123.45, 875.43))) * 5432.3);\n}\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n    f = f * f * (3.0 - 2.0 * f); // smoothstep with no clamp.\n    \n    return mix(a, b, f.x) +\n            (c - a) * f.y * (1.0 - f.x) +\n            (d - b) * f.x * f.y;\n}\n\nfloat fbm(vec2 p) {\n\tfloat f = 0.0;\n    f += 0.5 * noise(p * 1.1);\n    f += 0.22 * noise(p * 2.3);\n    f += 0.155 * noise(p * 3.9);\n    f += 0.0625 * noise(p * 8.4);\n    f += 0.03125 * noise(p * 15.0);\n    \n    return f;\n}\n\nfloat smoothBounds(float a, float b, float v) {\n    float midPoint = a + (b - a) * 0.5;\n    return smoothstep(a, midPoint, v) *  smoothstep(b, midPoint, v);\n}\n\nmat2 rot(vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n/*  Not so common... */\n\nfloat stars(vec2 uv) {\n    return smoothBounds(0.195, 0.2, fbm(uv * 100.0));\n}","name":"Common","description":"","type":"common"}]}