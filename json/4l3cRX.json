{"ver":"0.1","info":{"id":"4l3cRX","date":"1533337307","viewed":103,"name":"3D Sierpinski Tetrahedron SDF","username":"mackycheese21","description":"3D Sierpinski Tetrahedron SDF, inspired by https://www.shadertoy.com/view/Xd2XDW.","likes":0,"published":1,"flags":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat floorSDF(vec3 p){\n    return p.y+1.0;\n}\n\nvec3 a1=vec3(1.0,1.0,1.0);\nvec3 a2=vec3(1.0,-1.0,-1.0);\nvec3 a3=vec3(-1.0,1.0,-1.0);\nvec3 a4=vec3(-1.0,-1.0,1.0);\n\nconst int maxIters = 10;\nconst float scale = 2.;\n\nmat3 rot;\n\nvoid initSDF(){\n    \n    float ang1 = 1.5707963268;\n    float ang2 = 0.0;\n    \n    mat3 rotation1 = mat3(\n        1,0,0,\n        0,cos(ang1),-sin(ang1),\n        0,sin(ang1),cos(ang1)\n    );\n    mat3 rotation2 = mat3(\n        cos(ang2),0,-sin(ang2),\n        0,1,0,\n        sin(ang2),0,cos(ang2)\n    );\n    rot=rotation1*rotation2;\n}\n\nfloat tetrahedron(vec3 p) {\n    p.y-=2.0;\n    p=rot*p;\n    //p*=3.0;\n      \n    const vec3 p0 = vec3(-1,-1,-1);\n    const vec3 p1 = vec3(1,1,-1);\n    const vec3 p2 = vec3(1,-1,1);\n    const vec3 p3 = vec3(-1,1,1);\n\n    for (int i = 0; i < maxIters; ++i) {\n        float d = distance(p, p0);\n        vec3 c = p0;\n        \n        float t = distance(p, p1);\n        if (t < d) {\n            d = t;\n            c = p1;\n        }\n        \n        t = distance(p, p2);\n        if (t < d) {\n            d = t;\n            c = p2;\n        }\n        \n        t = distance(p, p3);\n        if (t < d) {\n            d = t;\n            c = p3;\n        }\n        \n        p = (p-c)*scale;\n    }\n    \n    return length(p)*pow(scale,-float(maxIters))-0.025*0.5;//this scaling of the end result is VERY important\n}\n\n\nfloat sceneSDF(vec3 p){\n    return unionSDF(floorSDF(p),tetrahedron(p));\n}\nsdf_result send_ray(vec3 pos,vec3 dir,int maxIters){\n    sdf_result sdf;\n    sdf.dist=0.0;\n    sdf.start=pos;\n    sdf.end=sdf.start;\n    sdf.dir=normalize(dir);\n    int i=0;\n    float dist=0.0;\n    for(i=0;i<maxIters;i++){\n\t    float d=sceneSDF(sdf.end);\n        sdf.finalDist=d;\n        sdf.dist+=d;\n\t\tsdf.end+=d*sdf.dir;\n        if(d<EPSILON){\n            return sdf;\n        }\n    }\n    return sdf;\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nsdf_result send_ray_from_to(vec3 from,vec3 to,int maxIters){\n    return send_ray(from,to-from,maxIters);\n}\n\nvec3 shadeRay(lighting lit,vec3 end){\n    vec3 normal=estimateNormal(end);\n    vec3 phongShaded=phong(lit,normal,end)-0.2;\n    return phongShaded;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initSDF();\n\tvec2 uv = fragCoord.xy / iResolution.xy; // 0 <> 1\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float rot=6.2831853072*iMouse.x/iResolution.x;\n    camera cam=createCamera(uv,vec3(5.0*cos(rot),3.0,4.0*sin(rot)), vec3(0.0),0.3);\n\n    lighting lit;\n    lit.lightPos=vec3(-2.0,2.0*cos(iTime)+4.0,-3.0);\n    lit.diffuseMult=vec3(1.0,1.0,0.0);\n    lit.ambient=vec3(0.5);\n    \n    int maxIters=300;\n    \n    sdf_result ray=send_ray(cam.pos,cam.dir,maxIters);\n    sdf_result shadowRay=send_ray_from_to(lit.lightPos,ray.end,maxIters);\n\n    fragColor=vec4(shadeRay(lit,ray.end),1.0);\n    \n    bool inShadow=length(ray.end-shadowRay.end)>sqrt(EPSILON);\n    if(inShadow){\n        //fragColor=vec4(lit.ambient*0.75,1.0);\n        fragColor*=0.75;\n    }\n    //fragColor=vec4(vec3(0.25*shadowRay.dist),1.0);\n    //fragColor=vec4(vec3(abs(ray.finalDist-shadowRay.finalDist)),1.0);\n    //fragColor=vec4(vec3(dist/20.0),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nconst float EPSILON=0.001;\n\nstruct camera{\n    vec3 pos;\n    vec3 dir;\n};\n    \n    \nstruct sphere{\n\tfloat size;\n    vec3 p;\n};\nstruct cube{\n\tfloat size;\n\tvec3 p;\n};\n    \nstruct lighting {\n    vec3 lightPos;\n    vec3 diffuseMult;\n    vec3 ambient;\n};\n\nstruct sdf_result{\n    vec3 start;\n    vec3 end;\n    vec3 dir;\n    float dist;\n    int iters;\n    float finalDist;\n};\n/**\n * Signed distance function for a cube centered at the origin\n * with width = height = length = 2.0\n */\nfloat cubeSDF(cube cb, vec3 p) {\n    p-=cb.p;\n    p/=cb.size;\n    // If d.x < 0, then -1 < p.x < 1, and same logic applies to p.y, p.z\n    // So if all components of d are negative, then p is inside the unit cube\n    vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);\n    \n    // Assuming p is inside the cube, how far is it from the surface?\n    // Result will be negative or zero.\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    \n    // Assuming p is outside the cube, how far is it from the surface?\n    // Result will be positive or zero.\n    float outsideDistance = length(max(d, 0.0));\n    \n    return insideDistance + outsideDistance;\n}\n    \nfloat sphereSDF(sphere s,vec3 p){\n\treturn length(s.p-p)-s.size;\n}\n\n\n\nfloat intersectSDF(float a,float b){\n\treturn max(a,b);\n}\n\nfloat unionSDF(float a,float b){\n    return min(a,b);\n}\n\nfloat diffSDF(float a,float b){\n\treturn max(a,-b);\n}\n\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 phong(lighting l,vec3 normal, vec3 pos){\n    vec3 s=normalize(l.lightPos-pos);\n    vec3 n=normalize(normal);\n    float dotSN=dot(s,n);\n    if(dotSN<0.0)dotSN=0.0;\n    if(dotSN>1.0)dotSN=1.0;\n    vec3 diffuse=l.diffuseMult*dotSN;\n    \n    return diffuse+l.ambient;\n}\n\n    \ncamera createCamera(vec2 uv,vec3 camPos,vec3 lookAt,float zoom){\n    vec3 rayPos = camPos;\n\n    \n    vec3 f = normalize(lookAt-rayPos);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n    \n    vec3 c = rayPos + f*zoom;\n    vec3 i = c + uv.x*r + uv.y*u;\n    vec3 rayDirection = i-rayPos;\n    return camera(rayPos,rayDirection);\n}","name":"Common","description":"","type":"common"}]}