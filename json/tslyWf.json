{"ver": "0.1", "info": {"id": "tslyWf", "date": "1585770189", "viewed": 182, "name": "Gentle Bloby Thing", "username": "propagant", "description": "Playing around and made this... Uncomment WALLS_ENABLED to see walls. Just for fun.", "likes": 4, "published": 3, "flags": 0, "tags": ["blob"], "requires": ["imagebuf"]}, "renderpass": [{"inputs": [], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "//#define WALLS_ENABLED\n\nstruct ray\n{\n\tvec3 o;\n\tvec3 d;\n\tfloat l;\n};\n    \nvec4 opu(vec4 a, vec4 b)\n{\n\tif(a.w < b.w) return a;\n    else return b;\n}\n\t\nvec4 geo(vec3 p)\n{\n    float sXsin = sin(iTime * 0.8)*0.3; //---Sphere horizontal movement\n    float sXsin2 = sin(iTime * 0.8)*0.23;\n    float sXsinDouble = 0.2+sin(iTime * 1.5 )*0.1; //---Sphere horizontal movement 2xSpeed\n    float sBlob = sin(iTime * 3. + p.y * 8.); //---'Sphere blob'\n    \n\tvec4 o0 = vec4(0.2,0.6,1.0, length(p - vec3(sXsin,0.,1.5)) - 0.2 + sBlob * 0.0999);\n    o0.w *= smoothstep(0.1,0.05, -p.y-0.22) + clamp(abs(sXsin),0.05,0.2); //---The little 'slimy' effect below the 'blob'\n    #ifdef WALLS_ENABLED\n    o0.w *= smoothstep(0.02,0.01, abs(p.x)*0.02); //---'Wall' generation\n    #endif\n\tvec4 o0eye = vec4(vec3(1.0,1.0,1.0)*1.5, abs(length(p - vec3(sXsin,sXsinDouble,1.2)) - 0.01 + clamp(sBlob,-0.3,-0.1) * 0.0999)*0.45);\n    vec4 o0eyeb = vec4(vec3(0.0,0.0,0.0)*1.5, abs(length(p - vec3(sXsin2,sXsinDouble,1.15)) - 0.08 * 0.0999)*0.5);\n    vec4 o2 = vec4(0.2,0.4,0.5, p.y + 0.35);\n\t\n    vec4 g = opu(o2, o0);\n    vec4 g2 = opu(g, o0eye);\n    vec4 g3 = opu(g2, o0eyeb);\n    return g3;\n}\n\nvec4 march(ray r)\n{\n\tvec3 col = vec3(1.0);\n\tfor(int i = 0; i < 16; i++)\n\t{\n\t\tvec3 p = r.o + r.d * r.l; //---Traditional march operation\n\t\tvec4 g = geo(p);\n\t\tr.l += g.w;\n\t\tcol = g.rgb;\n\t\tif(r.l > 8.)\n\t\t\tbreak;\n\t}\n\treturn vec4(col, r.l);\n}\n\nvec3 normal(vec3 p)\n{\n\tvec2 of = vec2(0.001,0.0);\n\tvec4 copy = geo(p);\n\treturn normalize(copy.w - vec3(geo(p - of.xyy).w, geo(p - of.yxy).w, geo(p - of.yyx).w)); //---Traditional normals\n}\n\nfloat shadows(vec3 ro, vec3 rd, float b)\n{\n\tfloat t = 0.01;\n\tfloat res = 1.0;\n\tfor(int i = 0; i < 32; i++)\n\t{\n\t\tfloat g = geo(ro+rd*t).w;\n\t\tres = min(res, b * g / t); //---Traditional soft shadows\n\t\tt += g;\n\t\tif(g < 0.0005|| g > 3.0)\n        {\n\t\t\tbreak;\n        }\n\t}\n\treturn clamp(res,0.1,1.0);\n}\n\nfloat lighting(vec3 p, vec3 lp)\n{\n\tvec3 lPos = normalize(lp - p); //---Light source & uv position difference\n\tvec3 n = normal(p);\n    \n    float spec = pow(max(dot(lPos, n),0.),80.)*0.2; //---Specular Blinn Phong\n\t\n\tfloat light = clamp(dot(n, lPos), 0.6, 1.); //---Lighter ambient light\n\treturn light * shadows(p, normalize(lp), 1.0) + spec;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy) / iResolution.y;\n\n    ray r;\n\tr.o = vec3(0.);\n\tr.d = vec3(uv, 1.0);\n\tvec4 mm = march(r);\n\n\tvec3 m = r.o + r.d * mm.w;\n\tvec3 lPos = vec3(0.,2.5,1.);\n    #ifdef WALLS_ENABLED\n    #else\n        lPos = vec3(sin(iTime * 1.0)*1.5,1.5,cos(iTime * 1.0)*1.5); //---Light position\n    #endif\n\tvec3 col = mm.rgb * lighting(m, lPos);\n\tcol *= exp(-0.2 * mm.w * mm.w * mm.w * mm.w) *  5.; //---Fog + quick 'fake' gamma\n    if(mm.w > 2.5) col = mix(col, vec3(0.2,0.3,0.8), uv.y-0.1); //---Simple background gradient\n\n    fragColor = vec4(col,1.0);\n}", "name": "Image", "description": "", "type": "image"}]}