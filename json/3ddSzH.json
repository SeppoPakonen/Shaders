{"ver": "0.1", "info": {"id": "3ddSzH", "date": "1572557024", "viewed": 341, "name": "Infinity Machine", "username": "pjkarlik", "description": "Spent some time doing this marcher again - doesn't stop - transparent. Added some moving balls and trying to figure out that motion thing.. YAY For MODS!\n\nClick [x/y] Drag to pan around !\nupdated for VR", "likes": 12, "published": 3, "flags": 1, "tags": ["transparent"], "requires": ["imagebuf"]}, "renderpass": [{"inputs": [], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "#define MAX_STEPS \t100\n#define MAX_DIST\t150.\n#define MIN_DIST\t.001\n#define EPSILON\t\t.0001\n\n#define PI 3.1415926535897\n\n// Change to 2 to enable antialiasing\n#define AA 1\n\n#define ZERO (min(iFrame,0))\n\n/**\n\tMoar transparent marching\n\tNot sure I've got the motion thing\n\tright - using some mods but it works!\n\t100% sure there is some odd code!\n\n\tNew Camera Rig - way better!\n\tVR Render updated and it kicks butt!!\n*/\n\nvec2 hash2(vec2 p) {\n\tvec2 o = (p+0.5)/256.;\n  \treturn o;\n}\n\nfloat goldNoise(vec2 coord, float seed) {\n\tfloat phi = 1.6180339887498 * 0000.1;\n  \tfloat pi2 = PI * 0.1;\n  \tfloat sq2 = 1.4142135623730 * 10000.;\n  \tfloat temp = fract(\n    \tsin(dot(coord*(seed+phi), vec2(phi, pi2))) * sq2\n  \t);\n  \treturn temp;\n}\n\nfloat sdBox(vec3 p,vec3 s) {\n    p = abs(p) - s;\n    return max(max(p.x,p.y),p.z);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p)-r;    \n}\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  return mat2(cos(a), sin(a), -sin(a), cos(a)); \n}\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\nfloat map(vec3 pos) {\n\t// set up size for repetition\n   \tfloat size = 20.;\n\tfloat rep_half = size/2.;\n    // get center vec and some movement\n    vec3 center = vec3(0.,0., 20.- iTime * 5.);\n    vec3 pp = pos-center;\n\t// make the id's for beams\n    vec3 pi = vec3(\n        floor((pp + rep_half)/size)\n    );\n\t// make vec and ids for balls\n    vec3 tt = pos-center;\n    vec3 ti = vec3(\n        floor((tt + rep_half)/size)\n    );\n\n    // SHAKKADOO!! movement change based on time mod\n    // hash/noise vector direction.\n    // Using a mod of time < segment flip direction\n    if(mod(iTime,6.)<2.){\n        //up-down\n        // fhs gets the hash of the other vec2 \n        // its not moving in.\n        float fhs = goldNoise(pi.xz, 312.);\n        if(fhs>.5){\n            tt.y += fract(iTime ) * 20.;\n        } else {\n            tt.y -= fract(iTime ) * 20.;\n        } \n    } else if (mod(iTime,6.)<4.){\n        //left-right\n      \tfloat fhs = goldNoise(pi.zy, 312.);\n        if(fhs>.5){\n            tt.x += fract(iTime ) * 20.;\n        } else {\n            tt.x -= fract(iTime ) * 20.;\n        }   \n    } else {\n        //back-forth\n      \tfloat fhs = goldNoise(pi.xy, 312.);\n        if(fhs>.5){\n            tt.z += fract(iTime ) * 20.;\n        } else {\n            tt.z -= fract(iTime ) * 20.;\n        }   \n    }\n\n    pp =  mod(pp+rep_half,size) - rep_half;\n\ttt =  mod(tt+rep_half,size) - rep_half;\n    \n    float len = 11.;\n    float tx =  1.5;\n\n    //framework\n    float d1 = sdBox(abs(pp)-vec3(10.,10.,0.), vec3(tx,tx,len) );\n    float d2 = sdBox(abs(pp)-vec3(10.,0.,10.), vec3(tx,len,tx) );\n    float d3 = sdBox(abs(pp)-vec3(0.,10.,10.), vec3(len,tx,tx) );\n    d1 = min(min(d1,d3),d2);\n\n    //box clips\n\td2 = sdBox(abs(pp)-vec3(10.,10.,10.), vec3(3.5) );\n    d3 = sdBox(abs(pp)-vec3(10.,10.,10.), vec3(2.5,4.5,2.5) );\n    d1 = min(d1,min(d2,d3));\n    \n    d2 = sdBox(abs(pp)-vec3(10.,10.,10.), vec3(2.5,2.5,4.5) );\n    d3 = sdBox(abs(pp)-vec3(10.,10.,10.), vec3(4.5,2.5,2.5) );\n    d1 = min(min(d1,d2),d3);\n    \n    //balls\n    float d4 = sdSphere(tt-vec3(0.,0.,0.),2.5);\n    if(d4<d1) d1 = d4;\n    \n    return d1;\n}\n\n/**\n\ttransparent marcher\n\tjust go to the maxstep\n\tlike ao plus dist\n\tfun evil render below\n*/\nfloat trans_ray( in vec3 ro, in vec3 rd ) {\n    float depth = 0.;\n    for (int i = 0; i<MAX_STEPS; i++) {\n        vec3 p = ro + depth * rd;\n        float dist = map(p);\n        dist = max(abs(dist), MIN_DIST);\n        // make it look all dark and evil here\n        // dist = smoothstep(0.1,.6,max(abs(dist), MIN_DIST));\n        depth += abs(dist*.5);\n    }\n    return depth;\n}\n    \nmat3 get_camera(vec3 ro, vec3 ta, float rotation) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(rotation), cos(rotation),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\treturn mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 color = vec3(0.);\n    vec2 uv;\n    // \n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n    \t// pixel coordinates\n    \tvec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n\t\tuv = (2. * fragCoord.xy - (iResolution.xy+o))/iResolution.y;\n\t#else    \n        uv = (2. * fragCoord.xy - iResolution.xy )/iResolution.y;\n\n\t#endif\n    \n\tfloat ftime = iTime * 5.5;\n    float ftm = .5 + .5 * sin(iTime*.1);\n    \n    vec3 ta = vec3(0.0,0.0,0.);\n    vec3 ro = get_mouse(vec3(0.0,0.0,-7.));\n    \n    mat3 cameraMatrix = get_camera(ro, ta, 0. );\n    vec3 rd = cameraMatrix * normalize( vec3(uv.xy, .85) );\n\n    float dist = trans_ray(ro, rd);\n    vec3 col = vec3(0.);\n    if(dist>MIN_DIST) {\n        vec3 shade = vec3(dist*.005); \n        // fun with .1< and 1.> to filter\n        // out the fields and get dark and\n        // or washed out effects\n        col = 1. * smoothstep(.1,1.,shade); \n        col = pow(col, vec3(0.4545));\n        color += col;\n    }\n\n    // Color version if thats your thing..\n   \t color *= vec3(.4-rd.y,\t.8, .8);\n    // color *= vec3(.6,\t.4, .8-rd.y);\n        \n    // AA from NuSan\n    #if AA>1\n    \t}\n    \tcolor /= float(AA*AA);\n\t#endif\n    \n    fragColor = vec4(color,1.0);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ) {\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 rd = vec3(0.0,0.0,0.);\n    vec3 ro = vec3(4.0,4.,-7.);\n\tvec3 color = vec3(0.);\n    float dist = trans_ray(fragRayOri + ro, fragRayDir + rd);\n    vec3 col = vec3(0.);\n    if(dist>MIN_DIST) {\n        vec3 shade = vec3(dist*.005); \n        col = 1. * smoothstep(.1,1.,shade); \n        col = pow(col, vec3(0.4545));\n        color += col;\n    }\n\n   \tcolor *= vec3(.4-fragRayDir.y,\t.8, .8);\n  \n\tfragColor = vec4(color,1.0);\n}", "name": "Image", "description": "", "type": "image"}]}