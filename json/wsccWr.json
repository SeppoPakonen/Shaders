{"ver":"0.1","info":{"id":"wsccWr","date":"1600820298","viewed":1747,"name":"Claude Van Pixel","username":"pjkarlik","description":"It's been done before and better by @Shane - but this was more for me to learn pulling colors/pixels from textures (Click for texture color).\nStarted as just getting color/height from an image - but video is always fun!\n","likes":11,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n\tClaude Van Pixel | pjkarlik\n\n\tOriginally started out as a learning tool\n\taround sampling an image or texture and then\n\tturning that into noise, height, color, etc.\n\n\tYou can try other videos/webcam or\n\timage* (select linear filter on macs)\n\n\t4 tap grid based off @Shane's work and\n\thelp recieved around my hexagon tiled shader.\n\thttps://www.shadertoy.com/view/WtffDS @Shane\n\n\tMy Hexagon Tiles:\n\thttps://www.shadertoy.com/view/wtScRd\n\n*/\n\n#define M\t\t\tiMouse\n#define T\t\t\tiTime\n#define S\t\t\tsmoothstep\n#define PI          3.1415926\n#define PI2         6.2831853\n\n#define r2(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define hash(a, b) fract(sin(a*1.2664745 + b*.9560333 + 3.) * 14958.5453)\n\n#define min_dist\t.001\n#define max_dist\t50.\n\nvec3 gethue(float a){\n    return .5 + .45*cos(PI * a + vec3(2.5,1.75, 1.25));\n}\n\n// pulled out of getTex\nvec2 texP(vec2 p) {\n    // Stretching things out so that the image fills up the window.\n    p *= vec2(iResolution.y/iResolution.x, 1);\n    p+=vec2(5.,3.5);\n    return p;\n}\n// @Shane\nvec3 getTex(in vec2 p){\n    p = texP(p);\n    vec3 tx = texture(iChannel1, p/12.).xyz;\n    return tx*tx; \t\t\t\t\t\t// Rough sRGB to linear conversion.\n}\nfloat hm(in vec2 p){ return dot(getTex(p), vec3(.299, .587, .114)); }\n\n//globals//\nvec3 saveColor;\nvec2 savedId;\nmat2 r45,r24;\n\n//pixel size\n// 2. is nice - 4. is sweet - I've gone up to 12. but things breakdown.\n#define SCALE 3.\n\nvec2 map(vec3 q3){\n\tq3.y += 1.25;\n\t//q3.z -= 5.25;\n    vec2 res = vec2(1000.,0.);\n    \n    const float scale = 1./SCALE;\t\t// dimension | length to height ratio.\n\tconst vec2 l = vec2(scale);\n\tconst vec2 s = l*2.;\t\t\t\t// helper | size of the repeat cell.\n\n    vec2 p,\n         ip,\n         id = vec2(0),\n         ct = vec2(0);\n    const vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5),   vec2(.5, -.5), vec2(-.5));\n    \n    float d = 1e5,\n          boxID = 0.,\n          savedHeight,\n          sck;\n    \n    for(int i = 0; i<4; i++){\n        ct = ps4[i]/2. -  ps4[0]/2.;\t// Block center.\n        p = q3.xy - ct*s;\t\t\t\t// Local coordinates. \n        ip = floor(p/s) + .5;\t\t\t// Local tile ID. \n        p -= (ip)*s; \t\t\t\t\t// New local position.\t\t   \n        vec2 idi = (ip + ct)*s;\t\t\t// Correct position & tile ID.\n\n        vec3 q = vec3(p.x,p.y,q3.z);\n\t\t// if within allowed space sample otherwise\n        float ck = (idi.x>-9.5 && idi.x<12.5 && idi.y>-4.5 && idi.y<8.5) ? 1. : .0;\n\t\tfloat pt = ck > 0. ? hm(idi) : .01 ;\n\t\tsck=ck;\n        pt = floor(pt*75.999)/75.;\t\t// Discreet heights and making \n        float ht=max(pt,.01);\t\t\t// sure its never less than\n        \n        vec3 sz = vec3(l.x/2.2,l.y/2.2,ht);\n        float di = fBox(q+vec3(0,0,ht),sz,.005);\n\n        // box\n        if(di<d) {\n            d = di;\n            savedHeight = ht;\n            savedId = idi;\n            vec2 id = ck > 0. ? idi : vec2(4.);\n            saveColor= M.z>0. ? getTex(id).rgb : gethue(ht).rgb;\n        }\n    }\n    if(d<res.x&&sck>0.) res = vec2(d,1.);\n \t// the floor&&sck>0.\n    float g = q3.y+4.;\n    if(g<res.x) res = vec2(g,2.);\n    // random boxes\n    float f = fBox(q3+vec3(-3.75,3.,4.),vec3(1.),.015);\n    f=min(fBox(q3+vec3(2.15,3.5,2.75),vec3(.5),.015),f);\n    vec3 q4 = vec3(-abs(q3.x),q3.y,q3.z)+vec3(7.75,3.25,3.75);\n    q4.xz*=r45;\n    f=min(fBox(q4,vec3(.75),.025),f);\n    q4.xz*=r24;\n    f=min(fBox(q4-vec3(-1.95,-.22,3.5),vec3(.5),.015),f);\n   \n    if(f<res.x) {\n        res = vec2(f,3.);\n        saveColor= M.z>0. ? getTex(vec2(5.,5.)).rgb : gethue(2.7).rgb;\n    }\n    return res;\n}\n\nvec2 marcher(vec3 ro, vec3 rd, int maxsteps) {\n    float d = 0.,\n          m = 0.;\n    for(int i=0;i<maxsteps;i++){\n        vec2 t = map(ro + rd * d);\n        if(abs(t.x)<min_dist*d ||d>max_dist) break;\n        //progressive under-stepping @Shane - nice!\n       \td += i<64? t.x*.25 : t.x*.75;\n        m  = t.y;\n        \n    }\n    return vec2(d,m);\n}\n\n// Tetrahedron technique @iq\n// https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n/**\nvec3 getNormal(vec3 p, float t){\n    float e = min_dist * t;\n    vec2 h = vec2(1.5,-1.5)*.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n}*/\n//@spalmer - prevent inline of 4 maps\n#define ZRO min(iFrame,0)\nvec3 getNormal(vec3 q, float t){\n    float h = .00001\n        * sqrt(1./3.)\n        * (1. + 128.*t)\n        ;\n    vec3 n = vec3(0);\n    int i = 0;\n    i = ZRO;\n    for (; i < 4; ++i) {\n        vec3 e = vec3((ivec3(i+3, i, i+i)&2) - 1);\n        n += map(q + e * h).x * e;\n    }\n    return normalize(n);\n}\n\nfloat getDiff(vec3 p, vec3 n, vec3 lpos) {\n    vec3 l = normalize(lpos-p);\n    float dif = clamp(dot(n,l),.01 , 1.);\n    float shadow = marcher(p + n * .008, l, 128).x;\n    if(shadow < length(p -  lpos)) dif *= .2;\n    return dif;\n}\n\n//@Shane low cost AO\nfloat calcAO(in vec3 p, in vec3 n){\n    float sca = 2., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n        float hr = float(i + 1)*.17/5.; \n        float d = map(p + n*hr).x;\n        occ += (hr - d)*sca;\n        sca *= .9;\n        if(sca>1e5) break;\n    }\n    return clamp(1. - occ, 0., .8);\n}\n\nvec3 render(vec3 ro, vec3 rd, vec2 uv) {\n    vec3 C = vec3(0.),\n         p = ro;\n    \n    vec2 d = marcher(ro,rd,256);\n    vec3 rcolor = saveColor;\n\n    if(d.x<max_dist) {\n        p= ro+rd*d.x;\n        vec3 n = getNormal(p,d.x);\n\n        vec3 lpos = vec3(0.,1.,-2.5);\n    \tfloat diff = 2.* getDiff(p, n, lpos);\n        float ao = calcAO(p, n);\n        \n        vec3 color = d.y == 2. ? vec3(.1) : rcolor;\n        \n        C+=diff * ao * color;\n    }\n    \n    C = mix( C, vec3(.01), 1.-exp(-.00025*d.x*d.x*d.x));\n    return C; \n}\n\nvec3 camera(vec3 lp, vec3 ro, vec2 uv) {\n\tvec3 cf = normalize(lp-ro),\n         cr = normalize(cross(vec3(0,1,0),cf)),\n         cu = normalize(cross(cf,cr)),\n          c = ro + cf * .8,\n          i = c + uv.x * cr + uv.y * cu,\n         rd = i - ro;\n    return rd;\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    // Coords -1 to 1\n    vec2 uv = (2.*F.xy-iResolution.xy)/max(iResolution.x,iResolution.y);\n    // precal\n    r45 = r2(45.*PI/180.);\n    r24 = r2(24.*PI/180.);\n    // setup color and lp/ro\n    vec3 C = vec3(0.);\n    vec3 lp = vec3(.75,1.5,0.),\n         ro = vec3(.75,1.75,-11.75);\n\n    float mt = mod(T*.11,3.);\n    if(mt<1.){\n    \tlp = vec3(5.,0.5,1.),\n    \tro = vec3(9.,1.75,-1.75);\n    }\n\tro.xz *=r2(.1+.09*sin(T*.185));\n    ro.yz *=r2(-.1+.05*sin(T*.235));\n    \n    // Set camera and render\n    vec3 rd = camera(lp,ro,uv);\n  \tC += render(ro,rd,uv);\n    C *= texture(iChannel0, uv*1.05).yyy;\n    // Output and Gamma\n    O = vec4(pow(C, vec3(0.4545)),1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI          3.1415926\n#define r2(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n//http://mercury.sexy/hg_sdf/\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\treturn max(v.x, v.y);\t\t\t\t\t\t}\nfloat vmax(vec3 v) {\treturn max(max(v.x, v.y), v.z);\t\t\t\t}\n\n// Sign function that doesn't return 0\nfloat sgn(float x) { \treturn (x<0.)?-1.:1.;\t\t\t\t\t\t\t}\nvec2 sgn(vec2 v)   {\treturn vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);\t}\n\nfloat fBox(vec3 p, vec3 b, float r) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)))-r;\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n","name":"Common","description":"","type":"common"}]}