{"ver":"0.1","info":{"id":"WdffRn","date":"1587575074","viewed":206,"name":"Voxel Game (Sandbox)","username":"kastorp","description":"sandox for voxel game\n\nbuild your own logic!","likes":7,"published":1,"flags":48,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*---------------------------------------------------------\n\t\t        THIS SHADER IS BASED ON  \n\t\t\t\t\"[SH16C] Voxel Game\" by fb39ca4  \n\t\t\t\thttps://shadertoy.com/view/MtcGDH\n                I JUST ENHANCED IT\n   \nfor the full version see \"Voxel game Evolution\"\nhttps://www.shadertoy.com/view/wsByWV\n\nControls:\n    Click and drag mouse to look, select blocks\n    WASD to move\n    Space to jump\n    Double-tap space to start flying, use space and shift to go up and down.\n    Q + mouse button to place block\n    E + mouse button to destroy blocks\n\tR + mouse button to change shape of a block \n\tF + mouse button to rotate a shape on z axis \n\tG + mouse button to rotate a shape on y axis\n\tC + mouse button to select multiple blocks (hold on \"C\" to clear selection)\n    mouse click on inventory to select a block type\n\tM to toggle map\n\n\tO,P to decrease/increase speed of day/night cycles   \n    k,L to decrease/increase pixel sizes \n\tT to teleport to a random location\n    Page Up/Down to increase or decrease zoom \n\n\tF3 to display stats\n\tF4 to display BUFFER B\n    F5 to display BUFFER C\n    F6 for better performance and lower rendering distance \n\n#define settings in common file:\n    MAX_PICK_DISTANCE: distance for block selection with mouse (default = 10)\n    FAST_COMPILE: use cheaper noise function (default = defined)\n    SUBVOXEL: enable shapes actions with keys R,F,G (default = defined)\n\tSHADOW: renders shadows  (default = not defined  )\n\n\n\nBUFFERS:\n\n    - \"BUFFER A\": actions, collisions, settings\n    - \"BUFFER B\": voxel cache \n    - \"BUFFER C\": material textures\n    - \"BUFFER D\": rendering, map\n    - \"IMAGE\"   : gui, stats\n\nCHANGELOG \n\n\n*/\n\nvec4 load(vec2 coord) {\n\treturn textureLod(iChannel0, vec2((floor(coord) + 0.5) / iChannelResolution[0].xy), 0.0);\n}\n\nvec4 getTexture(float id, vec2 c) {\n    vec2 gridPos = vec2(mod(id, 8.), floor(id / 8.));\n\treturn textureLod(iChannel2, 16. * (c + gridPos) / iChannelResolution[3].xy, 0.0);\n}\n\n\nvoxel getVoxel(vec3 p) {\n    //return getVoxel(p,iChannel1,iChannelResolution[0]);\n    vec3 offset = floor(vec3(load(_pos).xy, 0.));\n    vec4 range = load(_loadRange);\n    vec3 oldOffset = floor(vec3(load(_old+_pos).xy, 0.));\n    \n    int mode = (iFrame==0)?0:1;\n    return getVoxelData( p,iChannel1,iChannelResolution[0],mode,range,offset);\n    \n}\n\n\n// ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n// Creative Commons CC0 1.0 Universal (CC-0) \n// https://www.shadertoy.com/view/4sBSWW\n\nfloat DigitBin(const in int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue(const in vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n    vec2 vStringCharCoords = (fragCoord.xy - vPixelCoords) / vFontSize;\n    if ((vStringCharCoords.y < 0.0) || (vStringCharCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCharCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n\t\t\t\tif(fDigitIndex < 0.0) fDigitIndex += 1.0;\n\t\t\t\tfloat fDigitValue = (abs(fValue / (pow(10.0, fDigitIndex))));\n                float kFix = 0.0001;\n                fCharBin = DigitBin(int(floor(mod(kFix+fDigitValue, 10.0))));\n\t\t\t}\t\t\n\t\t}\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCharCoords.x) * 4.0) + (floor(vStringCharCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n\n\n\nconst float numItems = NUM_ITEMS;\n\nvec4 drawSelectionBox(vec2 c) {\n\tvec4 o = vec4(0.);\n    float d = max(abs(c.x), abs(c.y));\n    if (d > 6. && d < 9.) {\n        o.a = 1.;\n        o.rgb = vec3(0.9);\n        if (d < 7.) o.rgb -= 0.3;\n        if (d > 8.) o.rgb -= 0.1;\n    }\n    return o;\n}\n\nmat2 inv2(mat2 m) {\n  return mat2(m[1][1],-m[0][1], -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);\n}\n\nvec4 drawInventory(vec2 c) {\n\tfloat scale = floor(iResolution.y / 128.);\n    c /= scale;\n    vec2 r = iResolution.xy / scale;\n    vec4 o = vec4(0);\n    float xStart = (r.x - 16. * numItems) / 2.;\n    c.x -= xStart;\n    float selected = load(_selectedInventory).r;\n    vec2 p = (fract(c / 16.) - .5) * 3.;\n    vec2 u = vec2(sqrt(3.)/2.,.5);\n    vec2 v = vec2(-sqrt(3.)/2.,.5);\n    vec2 w = vec2(0,-1);\n    if (c.x < numItems * 16. && c.x >= 0. && c.y < 16.) {\n        float slot = floor(c.x / 16.);\n    \to = getTexture(48., fract(c / 16.));\n        vec3 b = vec3(dot(p,u), dot(p,v), dot(p,w));\n        vec2 texCoord;\n        //if (all(lessThan(b, vec3(1)))) o = vec4(dot(p,u), dot(p,v), dot(p,w),1.);\n        float top = 0.;\n        float right = 0.;\n        if (b.z < b.x && b.z < b.y) {\n        \ttexCoord = inv2(mat2(u,v)) * p.xy;\n            top = 1.;\n        }\n        else if(b.x < b.y) {\n        \ttexCoord = 1. - inv2(mat2(v,w)) * p.xy;\n            right = 1.;\n        }\n        else {\n        \ttexCoord = inv2(mat2(u,w)) * p.xy;\n            texCoord.y = 1. - texCoord.y;\n        }\n        if (all(lessThanEqual(abs(texCoord - .5), vec2(.5)))) {\n            float id = getInventory(slot);\n            if (id == 3.) id += top;\n            o.rgb = getTexture(id, texCoord).rgb * (0.5 + 0.25 * right + 0.5 * top);\n            o.a = 1.;\n        }\n    }\n    vec4 selection = drawSelectionBox(c - 8. - vec2(16. * selected, 0));\n    o = mix(o, selection, selection.a);\n    return o;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float pixelSize = load(_pixelSize).r;\n    vec2 renderResolution = ceil(iResolution.xy / pixelSize); \n    fragColor = texture(iChannel3, fragCoord * renderResolution / iResolution.xy / iResolution.xy);\n    //fragColor = texture(iChannel3, fragCoord);\n    \n        \n    vec4 gui = drawInventory(fragCoord);\n    fragColor = mix(fragColor, gui, gui.a);\n    \n    \n    //DISPLAY STATS IF F3 IS TOGGGLED\n    float stats = load(_stats).r;    \n    if (stats >0.5) {\n        vec3 pos = load(_pos).xyz;\n        \n\n        //POS\n        fragColor = mix( fragColor, vec2(1,.5).xyyx, PrintValue(fragCoord, vec2(0., iResolution.y - 20.), vec2(8,15), pos.x, 5.0, 5.0));\n        fragColor = mix( fragColor, vec2(1,.5).yxyx, PrintValue(fragCoord, vec2(0., iResolution.y - 40.), vec2(8,15), pos.y, 5.0, 5.0));\n        fragColor = mix( fragColor, vec2(1,.5).xxyx, PrintValue(fragCoord, vec2(0., iResolution.y - 60.), vec2(8,15), pos.z, 5.0, 5.0));\n\n        //ANGLE\n        fragColor = mix( fragColor, vec2(1,.5).xyyx, PrintValue(fragCoord, vec2(0., iResolution.y -80.), vec2(8,15),  load(_angle).x, 5.0, 2.0));\n        fragColor = mix( fragColor, vec2(1,.5).xxxx, PrintValue(fragCoord, vec2(50., iResolution.y -80.), vec2(8,15),  load(_angle).y, 5.0, 2.0)); \n \n        //TIME\n        fragColor = mix( fragColor, vec2(1,.5).xxxx , PrintValue(fragCoord, vec2(0., iResolution.y -100.), vec2(8,15), load(_time).r, 5.0, 2.0));\n\n\n        \n        //if (fragCoord.x < 20.) fragColor.rgb = mix(fragColor.rgb, texture(iChannel0, fragCoord / iResolution.xy).rgb, texture(iChannel0, fragCoord / iResolution.xy).a);\n        \n        //FRAMERATE, MEMORY RANGE, HEIGHT LIMIT, RAY DISTANCE\n        fragColor = mix( fragColor, vec2(1,.5).xxyx, PrintValue(fragCoord, vec2(0.0, 105.), vec2(8,15), load(_pixelSize).r, 5.0, 1.0));\n        fragColor = mix( fragColor, vec2(1,.5).xxyx, PrintValue(fragCoord, vec2(0.0, 85.), vec2(8,15), 1./ iTimeDelta, 5.0, 1.0));\n        fragColor = mix( fragColor, vec2(1,.5).yxxx, PrintValue(fragCoord, vec2(0., 65.), vec2(8,15), calcLoadDist( iChannelResolution[0].xy,load(_loadDistLimit).r), 5.0, 2.0));\n        fragColor = mix( fragColor, vec2(1,.5).xxxx, PrintValue(fragCoord, vec2(0., 45.), vec2(8,15),  heightLimit, 5.0, 2.0));\n        fragColor = mix( fragColor, vec2(1,.5).xxxx, PrintValue(fragCoord, vec2(0., 25.), vec2(8,15),  load(_rayDistMax).r, 5.0, 2.0));\n\n    }\n\t\n    // \"BUFFER B\" DUMP\n    if(load(_stats).g>.5) {\n               \n        vec3 offset = floor(vec3(load(_pos).xy, 0.));\n        voxel vox= decodeVoxel( texture(iChannel1,fragCoord / iResolution.xy));\n        float textureId = vox.id;\n        \n        if (textureId == 3.) textureId +=1.;\n        vec3  color;\n        \n        color = getTexture(textureId, vec2(.5)).rgb;\n        if (textureId == 0.) color = vec3(.5,.75,1);\n        \n\t\tvec3 pos= texToVoxCoord(fragCoord,  offset);\n        //if(abs(pos.z-50.)>5.) color = vec3(0.);\n        color *=  clamp( (pos.z-30.) /30.,0.,1.);\n        //color = mix(color, vec3(1), 0.2);\n        fragColor.rgb = color; \n\t\t\n        \n    }\n    //\"BUFFER C\" DUMP\n    if(load(_stats).b>.5) fragColor= texture(iChannel2, fragCoord /iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define KEY_FORWARDS 87\n#define KEY_BACKWARDS 83\n#define KEY_LEFT 65\n#define KEY_RIGHT 68\n#define KEY_JUMP 32\n#define KEY_SNEAK 16\n#define KEY_PLACE 81\n#define KEY_DESTROY 69\n#define KEY_SHAPE 82\n#define KEY_ROTATE_Z 70\n#define KEY_ROTATE_Y 71\n#define KEY_MULTISELECT 67\n#define KEY_DECREASE_ZOOM 33\n#define KEY_INCREASE_ZOOM 34\n#define KEY_DECREASE_PIXELSIZE 75\n#define KEY_INCREASE_PIXELSIZE 76\n#define KEY_INCREASE_TIME_SCALE 80\n#define KEY_DECREASE_TIME_SCALE 79\n#define KEY_STATS 114\n#define KEY_DUMP1 115\n#define KEY_DUMP2 116\n#define KEY_TELEPORT 84\n#define KEY_INCREASE_PERFORMANCE 117\n#define KEY_WORLD 89\n\n\n//ACTIONS \n\nvec4 load(vec2 coord) {\n    return textureLod(iChannel0, vec2((floor(coord) + 0.5) / iChannelResolution[1].xy), 0.0);\n}\n\n\nbool inBox(vec2 coord, vec4 bounds) {\n    return coord.x >= bounds.x && coord.y >= bounds.y && coord.x < (bounds.x + bounds.z) && coord.y < (bounds.y + bounds.w);\n}\n\nvec2 currentCoord;\nvec4 outValue;\nbool store4(vec2 coord, vec4 value) {\n    if (inBox(currentCoord, vec4(coord, 1., 1.))) {\n        outValue = value;\n        return true;\n    }\n    else return false;\n}\nbool store3(vec2 coord, vec3 value) { return store4(coord, vec4(value, 1)); }\nbool store2(vec2 coord, vec2 value) { return store4(coord, vec4(value, 0, 1)); }\nbool store1(vec2 coord, float value) { return store4(coord, vec4(value, 0, 0, 1)); }\n\nfloat keyDown(int keyCode) {\n    return textureLod(iChannel2, vec2((float(keyCode) + 0.5) / 256., .5/3.), 0.0).r;   \n}\n\nfloat keyPress(int keyCode) {\n    return textureLod(iChannel2, vec2((float(keyCode) + 0.5) / 256., 1.5/3.), 0.0).r;   \n}\n\nfloat keySinglePress(int keycode) {\n    bool now = bool(keyDown(keycode));\n    bool previous = bool(textureLod(iChannel0, vec2(256. + float(keycode) + 0.5, 0.5) / iResolution.xy, 0.0).r);\n    return float(now && !previous);\n}\n\n\nfloat keyToggled(int keyCode) {\n    return textureLod(iChannel2, vec2((float(keyCode) + 0.5) / 256., 2.5/3.), 0.0).r;   \n}\n\nfloat rectangleCollide(vec2 p1, vec2 p2, vec2 s) {\n    return float(all(lessThan(abs(p1 - p2), s)));   \n}\n\nfloat horizontalPlayerCollide(vec2 p1, vec2 p2, float h) {\n    vec2 s = (vec2(1) + vec2(.6, h)) / 2.;\n    p2.y += h / 2.;\n    return rectangleCollide(p1, p2, s);\n}\n\n\n\nvoxel getCachedVoxel(vec3 p) {\n    return getCachedVoxel(p,iChannel1,iChannelResolution[0]);\n}\n\nfloat isSolidVoxel(vec3 p) {\n    return isSolidVoxel(p,iChannel1,iChannelResolution[0]);\n}\n\nstruct rayCastResults {\n    bool hit;\n    vec3 rayPos;\n    vec3 mapPos;\n    vec3 normal;\n    float dist;\n};\n\n\n    rayCastResults rayCast(vec3 rayPos, vec3 rayDir, vec3 offset) {\n        vec3 mapPos = floor(rayPos);\n        vec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);\n        vec3 rayStep = sign(rayDir);\n        vec3 sideDist = (sign(rayDir) * (mapPos - rayPos) + (sign(rayDir) * 0.5) + 0.5) * deltaDist; \n        vec3 mask;\n        bool hit = false;\n        for (int i = 0; i <= MAX_PICK_DISTANCE*3; i++) {\n            mask = step(sideDist.xyz, sideDist.yzx) * step(sideDist.xyz, sideDist.zxy);\n            sideDist += vec3(mask) * deltaDist;\n            mapPos += vec3(mask) * rayStep;\n\n            if (mapPos.z < 0. || mapPos.z >= heightLimit) break;\n            voxel vox = getCachedVoxel(mapPos - offset);\n            if (vox.id!= 0. && vox.id!= 12.) { \n                hit = true; \n                break;\n            }\n\n        }\n        vec3 endRayPos = rayDir / dot(mask * rayDir, vec3(1)) * dot(mask * (mapPos + step(rayDir, vec3(0)) - rayPos), vec3(1)) + rayPos;\n\n\n        rayCastResults res;\n        res.hit = hit;\n\n        res.mapPos = mapPos;\n        res.normal = -rayStep * mask;\n        res.rayPos = endRayPos;\n        res.dist = length(rayPos - endRayPos);\n        return res;\n    }\n\nfloat mouseSelect(vec2 c) {\n\tfloat scale = floor(iResolution.y / 128.);\n    c /= scale;\n    vec2 r = iResolution.xy / scale;\n    float xStart = (r.x - 16. * NUM_ITEMS) / 2.;\n    c.x -= xStart;\n    if (c.x < NUM_ITEMS * 16. && c.x >= 0. && c.y < 16.) {\n        float slot = floor(c.x / 16.);\n    \treturn slot;\n    }\n\n    return -1.;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    currentCoord = fragCoord;\n    vec2 texCoord = floor(fragCoord);\n    if (texCoord.x < 512.) {\n        if (texCoord.y == varRow) {\n            if (texCoord.x >= 256.) {\n                fragColor.r = texture(iChannel2, (fragCoord - 256.) / vec2(256,3)).r;\n                vec4 old = texture(iChannel0, (_old + fragCoord) / iResolution.xy);\n                if (fragColor.r != old.r) old.a = 0.;\n                fragColor.a = old.a + iTimeDelta;\n            }\n            else {\n                vec3 pos = load(_pos).xyz;\n                vec3 oldPos = pos;\n                vec3 offset = vec3(floor(pos.xy), 0.);\n                vec2 angle = load(_angle).xy;\n                vec4 oldMouse = load(_mouse);\n                vec3 vel = load(_vel).xyz;\n                vec4 mouse = iMouse / length(iResolution.xy);\n                float renderScale = load(_renderScale).r;\n                vec2 time = load(_time).rg;\n                vec2 flightMode = load(_flightMode).rg;\n                vec2 sprintMode = load(_sprintMode).rg;\n                float selected = load(_selectedInventory).r;\n                float dt = min(iTimeDelta, .05);\n                float rayDistMax = max(load(_rayDistMax).r,50.);\n\t\t\t\t\n                float pixelSize =load(_pixelSize).r;\n                \n\t\t\t\t\n\n                if (iFrame == 0 ) {\n \n                    pos = vec3(50.5,50.5,5.);\n                    angle = vec2(-2.,1.6  );\n     \n                    \n                    oldMouse = vec4(-1);\n                    vel = vec3(0);\n                    renderScale = -2.;\n                    time = vec2(400.,0.);\n                    selected = 0.;\n                    rayDistMax=250.;\n                    \n                    pixelSize=2.;\n                }\n                if ( bool(keyDown(KEY_TELEPORT))) {\n\n                    pos =vec3(hash33(pos).xy *10000.,72.); \n                    time.r=hash13(pos)*1200.;\n                    oldMouse = vec4(-1);\n                    vel = vec3(0);\n                    renderScale = -2.;                  \n                    selected = 0.;\n                    rayDistMax=250.;\n                }\n                if (oldMouse.z > 0. && iMouse.z > 0.)\n                    if(1==1){\n                        float zoom = pow(10., load(_renderScale).r/10.);\n                        angle += 5.*(mouse.xy - oldMouse.xy) * vec2(-1,-1)/zoom;\n                        angle.y = clamp(angle.y, 0.1, PI - 0.1);\n                    }\n                vec3 dir = vec3(sin(angle.y) * cos(angle.x), sin(angle.y) * sin(angle.x), cos(angle.y));\n                vec3 dirU = vec3(normalize(vec2(dir.y, -dir.x)), 0);\n                vec3 dirV = cross(dirU, dir);\n                vec3 move = vec3(0);\n\n                vec3 dirFwd = vec3(cos(angle.x), sin(angle.x), 0);;\n                    vec3 dirRight = vec3(dirFwd.y, -dirFwd.x, 0);\n                vec3 dirUp = vec3(0,0,1);\n                /*move += dir * (keyDown(87)-keyDown(83));\nmove += dirU * (keyDown(68) - keyDown(65));\nmove += vec3(0,0,1) * (keyDown(82) - keyDown(70));*/\n\n                if(isSolidVoxel(pos-offset) >.5)  pos.z+=1.;\n\n                float inBlock = 0.;\n                float minHeight = 0.;\n                vec3 vColPos, hColPos;\n                for (float i = 0.; i < 4.; i++) {\n                    vColPos = vec3(floor(pos.xy - 0.5), floor(pos.z - 1. - i));\n                    if (isSolidVoxel(vColPos - offset + vec3(0,0,0)) * rectangleCollide(vColPos.xy + vec2(0.5,0.5), pos.xy, vec2(.8))\n                        + isSolidVoxel(vColPos - offset + vec3(0,1,0)) * rectangleCollide(vColPos.xy + vec2(0.5,1.5), pos.xy, vec2(.8)) \n                        + isSolidVoxel(vColPos - offset + vec3(1,0,0)) * rectangleCollide(vColPos.xy + vec2(1.5,0.5), pos.xy, vec2(.8))\n                        + isSolidVoxel(vColPos - offset + vec3(1,1,0)) * rectangleCollide(vColPos.xy + vec2(1.5,1.5), pos.xy, vec2(.8))\n                        > .5) {\n                        minHeight = vColPos.z + 1.001; \n                        inBlock = 1.;\n                        break;\n                    }\n                }\n                float maxHeight = heightLimit - 1.8;\n                vColPos = vec3(floor(pos.xy - 0.5), floor(pos.z + 1.8 + 1.));\n                if (isSolidVoxel(vColPos - offset + vec3(0,0,0))* rectangleCollide(vColPos.xy + vec2(0.5,0.5), pos.xy, vec2(.8))\n                    + isSolidVoxel(vColPos - offset + vec3(0,1,0)) * rectangleCollide(vColPos.xy + vec2(0.5,1.5), pos.xy, vec2(.8)) \n                    + isSolidVoxel(vColPos - offset + vec3(1,0,0)) * rectangleCollide(vColPos.xy + vec2(1.5,0.5), pos.xy, vec2(.8))\n                    + isSolidVoxel(vColPos - offset + vec3(1,1,0)) * rectangleCollide(vColPos.xy + vec2(1.5,1.5), pos.xy, vec2(.8))\n                    > .5) {\n                    maxHeight = vColPos.z - 1.8 - .001; \n                    inBlock = 1.;\n                }\n                float minX = pos.x - 1000.;\n                hColPos = vec3(floor(pos.xy - vec2(.3, .5)) + vec2(-1,0), floor(pos.z));\n                if (isSolidVoxel(hColPos - offset + vec3(0,0,0)) * horizontalPlayerCollide(hColPos.yz + vec2(0.5, 0.5), pos.yz, 1.8)\n                    + isSolidVoxel(hColPos - offset + vec3(0,1,0)) * horizontalPlayerCollide(hColPos.yz + vec2(1.5, 0.5), pos.yz, 1.8)\n                    + isSolidVoxel(hColPos - offset + vec3(0,0,1)) * horizontalPlayerCollide(hColPos.yz + vec2(0.5, 1.5), pos.yz, 1.8)\n                    + isSolidVoxel(hColPos - offset + vec3(0,1,1)) * horizontalPlayerCollide(hColPos.yz + vec2(1.5, 1.5), pos.yz, 1.8)\n                    + isSolidVoxel(hColPos - offset + vec3(0,0,2)) * horizontalPlayerCollide(hColPos.yz + vec2(0.5, 2.5), pos.yz, 1.8)\n                    + isSolidVoxel(hColPos - offset + vec3(0,1,2)) * horizontalPlayerCollide(hColPos.yz + vec2(1.5, 2.5), pos.yz, 1.8)\n                    > .5) {\n                    minX = hColPos.x + 1.301;\n                }\n                float maxX = pos.x + 1000.;\n                hColPos = vec3(floor(pos.xy - vec2(-.3, .5)) + vec2(1,0), floor(pos.z));\n                if (isSolidVoxel(hColPos - offset + vec3(0,0,0)) * horizontalPlayerCollide(hColPos.yz + vec2(0.5, 0.5), pos.yz, 1.8)\n                    + isSolidVoxel(hColPos - offset + vec3(0,1,0)) * horizontalPlayerCollide(hColPos.yz + vec2(1.5, 0.5), pos.yz, 1.8)\n                    + isSolidVoxel(hColPos - offset + vec3(0,0,1)) * horizontalPlayerCollide(hColPos.yz + vec2(0.5, 1.5), pos.yz, 1.8)\n                    + isSolidVoxel(hColPos - offset + vec3(0,1,1)) * horizontalPlayerCollide(hColPos.yz + vec2(1.5, 1.5), pos.yz, 1.8)\n                    + isSolidVoxel(hColPos - offset + vec3(0,0,2)) * horizontalPlayerCollide(hColPos.yz + vec2(0.5, 2.5), pos.yz, 1.8)\n                    + isSolidVoxel(hColPos - offset + vec3(0,1,2)) * horizontalPlayerCollide(hColPos.yz + vec2(1.5, 2.5), pos.yz, 1.8)\n                    > .5) {\n                    maxX = hColPos.x - .301;\n                }\n                float minY = pos.y - 1000.;\n                hColPos = vec3(floor(pos.xy - vec2(.5, .3)) + vec2(0,-1), floor(pos.z));\n                if (isSolidVoxel(hColPos - offset + vec3(0,0,0))* horizontalPlayerCollide(hColPos.xz + vec2(0.5, 0.5), pos.xz, 1.8)\n                    + isSolidVoxel(hColPos - offset + vec3(1,0,0))* horizontalPlayerCollide(hColPos.xz + vec2(1.5, 0.5), pos.xz, 1.8)\n                    + isSolidVoxel(hColPos - offset + vec3(0,0,1)) * horizontalPlayerCollide(hColPos.xz + vec2(0.5, 1.5), pos.xz, 1.8)\n                    + isSolidVoxel(hColPos - offset + vec3(1,0,1)) * horizontalPlayerCollide(hColPos.xz + vec2(1.5, 1.5), pos.xz, 1.8)\n                    + isSolidVoxel(hColPos - offset + vec3(0,0,2)) * horizontalPlayerCollide(hColPos.xz + vec2(0.5, 2.5), pos.xz, 1.8)\n                    + isSolidVoxel(hColPos - offset + vec3(1,0,2)) * horizontalPlayerCollide(hColPos.xz + vec2(1.5, 2.5), pos.xz, 1.8)\n                    > .5) {\n                    minY = hColPos.y + 1.301;\n                }\n                float maxY = pos.y + 1000.;\n                hColPos = vec3(floor(pos.xy - vec2(.5, -.3)) + vec2(0,1), floor(pos.z));\n                if (isSolidVoxel(hColPos - offset + vec3(0,0,0)) * horizontalPlayerCollide(hColPos.xz + vec2(0.5, 0.5), pos.xz, 1.8)\n                    + isSolidVoxel(hColPos - offset + vec3(1,0,0)) * horizontalPlayerCollide(hColPos.xz + vec2(1.5, 0.5), pos.xz, 1.8)\n                    + isSolidVoxel(hColPos - offset + vec3(0,0,1)) * horizontalPlayerCollide(hColPos.xz + vec2(0.5, 1.5), pos.xz, 1.8)\n                    + isSolidVoxel(hColPos - offset + vec3(1,0,1))* horizontalPlayerCollide(hColPos.xz + vec2(1.5, 1.5), pos.xz, 1.8)\n                    + isSolidVoxel(hColPos - offset + vec3(0,0,2)) * horizontalPlayerCollide(hColPos.xz + vec2(0.5, 2.5), pos.xz, 1.8)\n                    + isSolidVoxel(hColPos - offset + vec3(1,0,2)) * horizontalPlayerCollide(hColPos.xz + vec2(1.5, 2.5), pos.xz, 1.8)\n                    > .5) {\n                    maxY = hColPos.y - .301;\n                }\n\n                if (abs(pos.z - minHeight) < 0.01) flightMode.r = 0.;\n                if (bool(keySinglePress(KEY_JUMP))) {\n                    if (flightMode.g > 0.) {\n                        flightMode.r = 1.- flightMode.r;\n                        sprintMode.r = 0.;\n                    }\n                    flightMode.g = 0.3;\n                }\n                flightMode.g = max(flightMode.g - dt, 0.);\n\n                if (bool(keySinglePress(KEY_FORWARDS))) {\n                    if (sprintMode.g > 0.) sprintMode.r = 1.;\n                    sprintMode.g = 0.3;\n                }\n                if (!bool(keyDown(KEY_FORWARDS))) {\n                    if (sprintMode.g <= 0.) sprintMode.r = 0.;\n                }\n                sprintMode.g = max(sprintMode.g - dt, 0.);\n\n                vec3 stats =vec3(\n                    bool(keyToggled(KEY_STATS))?1.:0.,\n                    bool(keyToggled(KEY_DUMP1))?1.:0.,\n                    bool(keyToggled(KEY_DUMP2))?1.:0.\n                );\n                 \n\n                \n                float loadDistLimit=80.;\n                float rayLimit=400.; \n                if(bool(keyToggled(KEY_INCREASE_PERFORMANCE))){        \n                    pixelSize=max(2.,pixelSize) ;\n                    loadDistLimit=50.;\n                    rayLimit=200.;\n                }\n                pixelSize=clamp( pixelSize  + keyPress(KEY_INCREASE_PIXELSIZE) - keyPress(KEY_DECREASE_PIXELSIZE)  ,1.,4.);\n\n\n                if (bool(flightMode.r)) {\n                    if (length(vel) > 0.) vel -= min(length(vel), 25. * dt) * normalize(vel);\n                    vel += 50. * dt * dirFwd * sign(keyDown(KEY_FORWARDS)-keyDown(KEY_BACKWARDS)+keyDown(38)-keyDown(40));\n                    vel += 50. * dt * dirRight * sign(keyDown(KEY_RIGHT)-keyDown(KEY_LEFT)+keyDown(39)-keyDown(37));\n                    vel += 50. * dt * dirUp * sign(keyDown(KEY_JUMP) - keyDown(KEY_SNEAK));\n                    if (length(vel) > 20.) vel = normalize(vel) * 20.;\n                }\n                else {\n                    vel.xy *= max(0., (length(vel.xy) - 25. * dt) / length(vel.xy));\n                    vel += 50. * dt * dirFwd * sign(keyDown(KEY_FORWARDS)-keyDown(KEY_BACKWARDS)+keyDown(38)-keyDown(40));\n                    vel += 50. * dt * dirFwd * 0.4 * sprintMode.r;\n                    vel += 50. * dt * dirRight * sign(keyDown(KEY_RIGHT)-keyDown(KEY_LEFT)+keyDown(39)-keyDown(37));\n                    if (abs(pos.z - minHeight) < 0.01) {\n                        vel.z = 9. * keyDown(32);\n                    }\n                    else {\n                        bool isWater=(getCachedVoxel(pos-offset).id ==12.);\n                        vel.z -= (isWater ?1.: 32.) * dt;\n                        vel.z = clamp(vel.z, isWater?-20.:-80., isWater?20.:30.);\n                    }\n                    if (length(vel.xy) > 4.317 * (1. + 0.4 * sprintMode.r)) vel.xy = normalize(vel.xy) * 4.317 * (1. + 0.4 * sprintMode.r);\n                }\n\n\n                pos += dt * vel; \n                if (pos.z < minHeight) {\n                    pos.z = minHeight;\n                    vel.z = 0.;\n                }\n                if (pos.z > maxHeight ) {\n                    pos.z = maxHeight;\n                    vel.z = 0.;\n                }\n                if (pos.x < minX) {\n                    pos.x = minX;\n                    vel.x = 0.;\n                }\n                if (pos.x > maxX) {\n                    pos.x = maxX;\n                    vel.x = 0.;\n                }\n                if (pos.y < minY) {\n                    pos.y = minY;\n                    vel.y = 0.;\n                }\n                if (pos.y > maxY) {\n                    pos.y = maxY;\n                    vel.y = 0.;\n                }\n\n                float timer = load(_old+_pickTimer).r;\n                vec4 oldPick = load(_old+_pick);\n                vec4 pick;\n                float pickAction;\n                if (iMouse.z > 0.) {\n                    float slot = mouseSelect(iMouse.xy);\n                    if(slot>= 0.){\n                        selected = slot;\n                    }\n                    else {\t\n                    \n\n                    float zoom = pow(10., load(_renderScale).r/10.);// /pixelSize;\n                    vec2 renderResolution = iResolution.xy *zoom; \n                    vec2 renderCenter=vec2(0.5);\n                    vec2 uv = (iMouse.xy- renderCenter) / renderResolution - (renderCenter/zoom);//  /pixelSize;\n                    vec3 pointerPos = load(_pos).xyz + vec3(0,0,1.6);    \n                    vec3 pointerDir = rayDirection(load(_angle).xy,uv,renderResolution);\n\n\n                    rayCastResults res = rayCast(pointerPos, pointerDir, offset);\n                    if (res.dist <= float(MAX_PICK_DISTANCE) && res.dist >=.1) {\n                        pick.xyz = res.mapPos;\n                        if (bool(keyDown(KEY_DESTROY))) {\n                            pick.a = 1.;\n                            store1(vec2(0,9),pick.a);\n                            timer += dt / 0.25;\n                        }\n                        else if (bool(keySinglePress(KEY_PLACE))) {\n                            pick.a = 2.;\n                            pick.xyz += res.normal;                         \n                        }\n                        else if (bool(keySinglePress(KEY_SHAPE))) {\n                            pick.a = 3.;\n                        }\n                        else if (bool(keySinglePress(KEY_ROTATE_Z))) {\n                            pick.a = 4.;\n                         }\n                        else if (bool(keySinglePress(KEY_ROTATE_Y))) {\n                            pick.a = 5.;\n                        }\n                         else if (bool(keyDown(KEY_MULTISELECT))) {\n                            pick.a = 6.;\n                             store1(vec2(0,9),pick.a);\n                             timer += dt / 0.25;\n                        }\n                        if (oldPick != pick) timer = 0.;\n                    }\n                    else {\n                        //pick = vec4(-1,-1,-1,0);\n                        timer = 0.;\n                    }\n                }\n                }\n                else { \n                    \n                    // NO MOUSE KEY PRESSED  \n                    //pick = vec4(-1,-1,-1,0);\n\t\t\t\t\t\tif (bool(keyDown(KEY_DESTROY))) {\n                            pick.a = 1.;\n                            store1(vec2(0,9),pick.a);\n                            timer += dt / 0.25;\n                        }\n                        else if (bool(keySinglePress(KEY_PLACE))) {\n                            pick.a = 2.;\n                        }\n                        else if (bool(keySinglePress(KEY_SHAPE))) {\n                            pick.a = 3.;\n                         }\n                        else if (bool(keySinglePress(KEY_ROTATE_Z))) {\n                            pick.a = 4.;\n                        }\n                        else if (bool(keySinglePress(KEY_ROTATE_Y))) {\n                            pick.a = 5.;\n                        }\n                        else if (bool(keyDown(KEY_MULTISELECT))) {\n                            pick.a = 6.;\n                             store1(vec2(0,9),pick.a);\n                             timer += dt / 0.25;                   \n                        }else timer = 0.;\n                }\n\n\n                renderScale = clamp(renderScale + keySinglePress(KEY_DECREASE_ZOOM) - keySinglePress(KEY_INCREASE_ZOOM), -5., 10.);\n                time.g = clamp(time.g + keySinglePress(KEY_INCREASE_TIME_SCALE) - keyPress(KEY_DECREASE_TIME_SCALE), 0., 8.);\n                time.r = mod(time.r + dt * sign(time.g) * pow(2., time.g - 1.), 1200.);\n\n                bool still= length(pos-oldPos)<0.01 && length(angle -load(_angle).xy )<0.01  &&  iMouse.z<1.;\n                rayDistMax= clamp(rayDistMax  \n                                  +(still?10.:0.) \n                                  - ((iTimeDelta>0.03 && !still)?5.:0.)\n                                  -((iTimeDelta>0.1)?1.:0.) \n                                  -((iTimeDelta>0.1  && !still)?50.:0.) \n                                  + ((iTimeDelta<0.03 && still)?20.:0.)\n                                  ,loadDistLimit*2.5,rayLimit);\n\n\n\n\n                store3(_pos, pos);\n                store2(_angle, angle);\n                store4(_loadRange, calcLoadRange(pos.xy,iResolution.xy,0.,loadDistLimit));\n                store4(_mouse, mouse);\n                store1(_inBlock, inBlock);\n                store3(_vel, vel);\n                store4(_pick, pick);\n                store1(_pickTimer, timer);\n                store1(_renderScale, renderScale);\n                store1(_selectedInventory, selected);\n                store2(_flightMode, flightMode);\n                store2(_sprintMode, sprintMode);\n                store2(_time, time);\n                store3(_stats, stats);\n                store1(_rayDistMax, rayDistMax);\n                store1(_loadDistLimit, loadDistLimit);\n                store1(_rayLimit, rayLimit);\n\n                store1(_pixelSize,pixelSize);\n                \n\n\n                fragColor = outValue;\n            }\n        }\n        else fragColor = texture(iChannel0, (fragCoord - _old) / iResolution.xy);\n    }\n    else fragColor.rgb = vec3(0,0,0);\n}\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n//VOXEL MEMORY\n\nvec4 load(vec2 coord) {\n    return texture(iChannel0, vec2((floor(coord) + 0.5) / iChannelResolution[1].xy));\n}\n\n\nvoxel getCachedVoxel(vec3 p) {\n    return getCachedVoxel(p,iChannel1,iChannelResolution[0]);\n}\n\nvoid  lightDiffusion(out voxel vox, in voxel temp ,vec3 rPos){\n    if(vox.id != 6. && vox.id != 26.){\n \t   vox.light.s =  max( vox.light.s ,  \ttemp.light.s  -(rPos.z==1.?0.:1.) - (temp.id==0.?0.: temp.id==11.?5.:15.));       \t\n \t   vox.light.t =  max( vox.light.t- 1.,   temp.light.t -1.); //- (temp.id==0. || temp.id==26. || temp.id==12. ?0.: 5.));\n    }        \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 textelCoord = floor(fragCoord);\n    vec3 offset = floor(vec3(load(_pos).xy, 0.));\n    vec3 voxelCoord = texToVoxCoord(textelCoord, offset); \n    vec4 range = load(_old+_loadRange);\n\n    vec4 memoryRange= calcLoadRange(offset.xy,iChannelResolution[0].xy,0.,load(_loadDistLimit).r);\n    if(!inRange(voxelCoord.xy, memoryRange)) {\n        fragColor=vec4(1.);\n        return;\n    }\n    vec3 oldOffset = floor(vec3(load(_old+_pos).xy, 0.));\n    vec4 pick = load(_pick);   \n\n    \n    int mode = (iFrame==0)?0:1;\n    voxel vox = getVoxelData( voxelCoord,iChannel1,iChannelResolution[0],mode,range,oldOffset);\n\n    if (voxelCoord == pick.xyz || vox.value==2 )  {\n        if(vox.value==0)vox.value=1;\n        \n        if (pick.a == 1. &&  vox.id != 16. && load(_pickTimer).r > 1.) \n        {vox.value=1; // unselect de\n                vox.id = 0.; \n                vox.shape=0;      \n        }\n        else if (pick.a == 2.) \n        {\n            vox.id = getInventory(load(_selectedInventory).r);\n            if(vox.id==10.) vox.life=3.;\n        }\n        else if (pick.a == 3. && vox.id != 10. && vox.id != 11. && vox.id != 12.) \n        {\n            if(vox.shape<7) vox.shape++; else vox.shape=0;\n        }\n        else  if (pick.a == 4. && vox.id != 10. && vox.id != 11. && vox.id != 12.) \n        {\n            if(vox.rotation<3) vox.rotation++; else vox.rotation=0;\n        }\n        else if (pick.a == 5. && vox.id != 10. && vox.id != 11. && vox.id != 12.) \n        {\n            if(vox.rotation<12) vox.rotation+=4; else vox.rotation= vox.rotation % 4;\n        }\n         \n    } \n        \n     if(voxelCoord == pick.xyz  &&  pick.a == 6. ) \n     {\n        vox.value= 2 ;\n            \n     }\n    if(load(_pickTimer).r >1. && pick.a == 6. && vox.value==2)\n     {\n        vox.value= 1 ;\n            \n     }\n\n \n   \t// SUN LIGHT SOURCES\n    \n    if (voxelCoord.z == heightLimit - 1.) {\n        vox.light.s = 15.;   \n    } else  {\n        vox.light.s = max(vox.light.s ,lightDefault(voxelCoord.z));\n        \n    }\n    \n    // TORCH LIGHT SOURCES\n    //if(vox.id==12.) vox.light.t=max(2.,vox.light.t);\n     if(vox.id==6.) vox.light.t=15.;\n    //if(length( load(_pos).xyz + vec3(0,0,3.)- voxelCoord.xyz) <2.) vox.light.t=max( 12.,vox.light.t);\n    \n\t//LIGHT DIFFUSE\n    voxel temp;\n    int air=0;\n    int border=0;    \n    \n    if (voxelCoord.z < heightLimit - 1.) {\n        temp = getCachedVoxel(voxelCoord + vec3(0,0,1) - oldOffset);\n        \n        lightDiffusion(vox,temp,vec3(0.,0.,1.));\n        \n         \n        if(temp.id==0.) air +=1;\n        \n        if(temp.id==0.  &&  vox.id==2.) {vox.id=3.;}\n        if(vox.id==0. && temp.id==12.) {vox.id=12.;}\n    }else {border +=1;}\n    if (voxelCoord.z > 1.) {\n        temp = getCachedVoxel(voxelCoord + vec3(0,0,-1) - oldOffset);\n        lightDiffusion(vox,temp,vec3(0.,0.,-1.));\n\t\tif(temp.id==0.) air +=2;\n        \n        \n    }else {border +=1;}\n    if (voxelCoord.x > range.x + 1.) {\n        temp = getCachedVoxel(voxelCoord + vec3(-1,0,0) - oldOffset);\n        lightDiffusion(vox,temp,vec3(-1.,0.,0.));\n\n        if(temp.id==0.) air +=4;\n        \n    } else {border +=1;}\n    if (voxelCoord.x < range.y - 1.) {\n        temp = getCachedVoxel(voxelCoord + vec3(1,0,0) - oldOffset);\n        lightDiffusion(vox,temp,vec3(1.,0.,0.));\n\n        if(temp.id==0.) air +=8;\n   \n    }else {border +=1;}\n    if (voxelCoord.y > range.z + 1.) {\n        temp = getCachedVoxel(voxelCoord + vec3(0,-1,0) - oldOffset);\n        lightDiffusion(vox,temp,vec3(0.,-1.,0.));\n\n        if(temp.id==0.) air +=16;\n   \n    }else {border +=1;}\n    if (voxelCoord.y < range.w - 1.) {\n        temp = getCachedVoxel(voxelCoord + vec3(0,1,0) - oldOffset);\n        lightDiffusion(vox,temp,vec3(0.,1.,0.));\n\n        if(temp.id==0.) air +=32;\n\n    }else {border +=1;}\n\n\n\n\n    \n    //REBUILD EVERY 30 FRAMES\n\n    if(iFrame==0 ){//|| (mod(float(iFrame),30.)==0.)  && vox.value<1){\n\n        for(float j=0.; j<7.;j++){\n            for(float i=1.;i<13.;i++){\n                if(voxelCoord.xyz== vec3(30. + i*3.,30.+ j*3., 3. -(i==12.?1.:0.))){vox.id=i;vox.shape=int(j);}\n\n            }\n        }\n    }\n\n\n\n    fragColor = encodeVoxel(vox);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// BLOCK TEXTURES - WORK IN PROGRESS\n\nvec4 load(vec2 coord) {\n\treturn texture(iChannel0, vec2((floor(coord) + 0.5) / iChannelResolution[0].xy));\n}\n\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\nvec4 noiseTex(vec2 c) {\n\treturn texture(iChannel1, c / iChannelResolution[1].xy);   \n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n/*\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n*/\nfloat signed(float x) {\n\treturn x * 2. - 1.;   \n}\n\n\n//From https://www.shadertoy.com/view/4djGRh\nfloat tileableWorley(in vec2 p, in float numCells)\n{\n\tp *= numCells;\n\tfloat d = 1.0e10;\n\tfor (int xo = -1; xo <= 1; xo++)\n\t{\n\t\tfor (int yo = -1; yo <= 1; yo++)\n\t\t{\n\t\t\tvec2 tp = floor(p) + vec2(xo, yo);\n\t\t\ttp = p - tp - hash22(256. * mod(tp, numCells));\n\t\t\td = min(d, dot(tp, tp));\n\t\t}\n\t}\n\treturn sqrt(d);\n\t//return 1.0 - d;// ...Bubbles.\n}\n\nfloat crackingAnimation(vec2 p, float t) {\n    t = ceil(t * 8.) / 8.;\n\tfloat d = 1.0e10;\n    //t *= ;\n    for (float i = 0.; i < 25.; i++) {\n    \tvec2 tp = texture(iChannel1, vec2(4, i) / 256.).xy - 0.5;\n        tp *= max(0., (length(tp) + clamp(t, 0., 1.) - 1.) / length(tp));\n        d = min(d, length(tp + 0.5 - p));\n    }\n    return pow(mix(clamp(1. - d * 3., 0., 1.), 1., smoothstep(t - 0.3, t + 0.3, max(abs(p.x - 0.5), abs(p.y - 0.5)) * 2.)), .6) * 1.8 - 0.8;\n}\n\nfloat brickPattern(vec2 c) {\n\tfloat o = 1.;\n    if (mod(c.y, 4.) < 1.) o = 0.;\n    if (mod(c.x - 4. * step(4., mod(c.y, 8.)), 8.) > 7.) o = 0.;\n    return o;\n}\nfloat woodPattern(vec2 c) {\n\tfloat o = 1.;\n    if (mod(c.y, 4.) < 1.) o = 0.;\n    if (mod(c.x + 2. - 6. * step(4., mod(c.y, 8.)), 16.) > 15.) o = 0.;\n    return o;\n}\n\n//From https://github.com/hughsk/glsl-hsv2rgb\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 getTexture(float id, vec2 c) {\n    vec2 gridPos = vec2(mod(id, 8.), floor(id / 8.));\n\treturn texture(iChannel2, (c + gridPos * 16.) / iChannelResolution[3].xy);\n}\n\n\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n/*\nfloat noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 uv = p.xy + f.xy*f.xy*(3.0-2.0*f.xy);\n\treturn textureLod( iChannel0, (uv+118.4)/256.0, 0.0 ).x;\n}\n*/\n\nfloat sum(vec3 v) { return dot(v, vec3(1.0)); }\n\nbool getMaterialColor( int i, vec2 coord, out vec3 color ) {\n\t// 16x16 tex\n\tvec2 uv = floor( coord );\n\n    float n = uv.x + uv.y*347.0 + 4321.0 * float(i);\n\tfloat h = hash(n);\n\t\t\n    float br = 1. - h * (96./255.);\n\tcolor = vec3( 150./255., 108./255.,  74./255.); // 0x966C4A;\n\t\t\t\n\tfloat xm1 = mod((uv.x * uv.x * 3. + uv.x * 81.) / 4., 4.);\n\t/*\n\tif (i == 1) {\n\t\tif( uv.y < (xm1 + 18.)) {\n\t\t\tcolor = vec3( 106./255., 170./255.,  64./255.); // 0x6AAA40;\n\t\t} else if (uv.y < (xm1 + 19.)) {\n\t\t\tbr = br * (2. / 3.);\n\t\t}\n\t}\n\tif (i == 4) {\n\t\tcolor = vec3( 127./255., 127./255., 127./255.); // 0x7F7F7F;\n\t}\n\t*/\n\tif (i == 7) { \n\t\tcolor = vec3( 103./255., 82./255.,  49./255.); // 0x675231;\n\t\tif ( h < 0.5 ) {\n\t\t\tbr = br * (1.5 - mod(uv.x, 2.));\n\t\t}\t\n\t}\t\n\t/*\n\tif (i == 5) {\n\t\tcolor = vec3( 181./255.,  58./255.,  21./255.); // 0xB53A15;\n\t\tif ( mod(uv.x + (floor(uv.y / 4.) * 5.), 8.) == 0. || mod( uv.y, 4.) == 0.) {\n\t\t\tcolor = vec3( 188./255., 175./255., 165./255.); // 0xBCAFA5;\n\t\t}\n\t}\n\t*/\n\tif (i == 9) {\n\t\tcolor = vec3(  64./255.,  64./255., 255./255.); // 0x4040ff;\n\t}\n    \n\tif (i == 8) {\n\t\tcolor = vec3(  40./255., 117./255.,  38./255.); // 0x50D937;\n\t\tif ( h < 0.5) {\n\t\t\treturn false;\n\t\t}\n\t}\n    \n\tif (i == 10) {\n\t\tcolor = vec3(0.65,0.68,0.7)*1.35; \n\t\tbr = 1.;\n\t}\n    \n\tcolor *= br;\n\t\n\treturn true;\n}\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n    \n    vec2 gridPos = floor(fragCoord / 16.);\n    vec2 c = mod(fragCoord, 16.);\n    int id = int(gridPos.x + gridPos.y * 8.);\n    o.a = 1.;\n    if (id == 0) {\n    \to = vec4(1,0,1,1);\n    }\n    if (id == 1) { //STONE\n        o.rgb = 0.45 + 0.2 * vec3(noiseTex(c * vec2(.5, 1.) + vec2(floor(hash12(c + vec2(27,19)) * 3. - 1.), 0.)).b);\n    }\n    if (id == 2) { //DIRT\n    \to.rgb = vec3(0.55,0.4,0.3) * (1. + 0.3 * signed(noiseTex(c + 37.).r));\n        if (hash12(c * 12.) > 0.95) o.rgb = vec3(0.4) + 0.2 * noiseTex(c + 92.).g;\n    }\n    if (id == 3) { //GRASS\n    \to.rgb = getTexture(2., c).rgb;\n        if (noiseTex(vec2(0, c.x) + 12.).a * 3. + 1. > 16. - c.y) o.rgb = getTexture(4., c).rgb;\n    }\n    if (id == 4) { //ROCK\n    \to.rgb = hsv2rgb(vec3(0.22, .8 - 0.3 * noiseTex(c + 47.).b, 0.6 + 0.1 * noiseTex(c + 47.).b));\n    }\n    if (id == 5) { //GRASS LATERAL\n    \to.rgb = vec3(clamp(pow(1. - tileableWorley(c / 16., 4.), 2.), 0.2, 0.6) + 0.2 * tileableWorley(c / 16., 5.));\n    }\n    if (id == 6 || id == 26) {//LIGHT OR FIREFLY\n        float w = 1. - tileableWorley(c / 16., 4.);\n        float l = clamp(0.7 * pow(w, 4.) + 0.5 * w, 0., 1.);\n        o.rgb = mix(vec3(.3, .1, .05), vec3(1,1,.6), l);\n        if (w < 0.2) o.rgb = vec3(0.3, 0.25, 0.05);\n    }\n    if (id == 7) { //BRICK\n    \to.rgb = -0.1 * hash12(c) + mix(vec3(.6,.3,.2) + 0.1 * (1. - brickPattern(c + vec2(-1,1)) * brickPattern(c)), vec3(0.8), 1. - brickPattern(c));\n    }\n    if (id == 8) {//GOLD\n    \to.rgb = mix(vec3(1,1,.2), vec3(1,.8,.1), sin((c.x - c.y) / 3.) * .5 + .5);\n        if (any(greaterThan(abs(c - 8.), vec2(7)))) o.rgb = vec3(1,.8,.1);\n    }\n    if (id == 9) { //WOOD\n        o.rgb = vec3(0.5,0.4,0.25)*(0.5 + 0.5 * woodPattern(c)) * (1. + 0.2 * noiseTex(c * vec2(.5, 1.) + vec2(floor(hash12(c + vec2(27,19)))) * 3. - 1.).b);\n    }\n    \n    if (id == 10) {//TREE\n\t\tgetMaterialColor(7,c,o.rgb);\n\t\t\n\t}\t\n    if (id == 11) {//LEAF\n\t\tgetMaterialColor(8,c,o.rgb);\n\t\t\n\t}\n    if (id == 12) {//WATER\n\t\tgetMaterialColor(9,c,o.rgb);\n\t\t\n\t}\t\n    if (id == 13) {//SAND\n\t\tgetMaterialColor(10,c,o.rgb);\n\t\t\n\t}\t\n\n    if (id == 16) { \n      \to.rgb = (-1. + 2. * getTexture(1., c).rgb) * 2.5;\n    }\n    if (id == 32) {\n    \to.rgb = vec3(crackingAnimation(c / 16., load(_pickTimer).r));\n    }\n    if (id == 48) {\n    \to = vec4(vec3(0.2), 0.7);\n        vec2 p = c - 8.;\n        float d = max(abs(p.x), abs(p.y));\n        if (d > 6.) {\n            o.rgb = vec3(0.7);\n            o.rgb += 0.05 * hash12(c);\n            o.a = 1.;\n            if ((d < 7. && p.x < 6.)|| (p.x > 7. && abs(p.y) < 7.)) o.rgb -= 0.3;\n        }\n        o.rgb += 0.05 * hash12(c);\n        \n    }\n    \n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//CONFIGURABLE SETTINGS\n\n#define MAX_PICK_DISTANCE 15\n#define FAST_COMPILE\n#define SUBVOXEL\n#define SHADOW\n \n//-------------------------\n//GLOBAL VARIABLES\n\n#define var(name, x, y) const vec2 name = vec2(x, y)\n#define varRow 0.\nvar(_pos, 0, varRow);\nvar(_angle, 2, varRow);\nvar(_mouse, 3, varRow);\nvar(_loadRange, 4, varRow);\nvar(_inBlock, 5, varRow);\nvar(_vel, 6, varRow);\nvar(_pick, 7, varRow);\nvar(_pickTimer, 11, varRow);\nvar(_renderScale, 12, varRow);\nvar(_selectedInventory, 13, varRow);\nvar(_flightMode, 14, varRow);\nvar(_sprintMode, 15, varRow);\nvar(_time, 16, varRow);\nvar(_stats, 17, varRow);\nvar(_rayDistMax,20,varRow);\nvar(_loadDistLimit,21,varRow);\nvar(_rayLimit,22,varRow);\n\nvar(_pixelSize,24,varRow);\n//var(_lastMouseClick,25,varRow);\nvar(_old, 0, 1);\n\nconst vec2 packedChunkSize = vec2(13,7);\nconst float heightLimit = packedChunkSize.x * packedChunkSize.y;\nconst float NUM_ITEMS=12.;\n\n// VOXEL CACHE FUNCTION\nvec2 unswizzleChunkCoord(vec2 storageCoord) {\n \tvec2 s = floor(storageCoord);\n    float dist = max(s.x, s.y);\n    float offset = floor(dist / 2.);\n    float neg = step(0.5, mod(dist, 2.)) * 2. - 1.;\n    return neg * (s - offset);\n}\n\nvec2 swizzleChunkCoord(vec2 chunkCoord) {\n    vec2 c = chunkCoord;\n    float dist = max(abs(c.x), abs(c.y));\n    vec2 c2 = floor(abs(c - 0.5));\n    float offset = max(c2.x, c2.y);\n    float neg = step(c.x + c.y, 0.) * -2. + 1.;\n    return (neg * c) + offset;\n}\n\n\nfloat calcLoadDist(vec2 iResolutionxy,float limit) {\n    \n\tvec2 chunks = floor(iResolutionxy / packedChunkSize);\n    float gridSize = min(chunks.x, chunks.y);\n    return min(floor((gridSize - 1.) / 2.),limit);\n}\n\nvec4 calcLoadRange(vec2 pos,vec2 iResolutionxy, float border,float limit) {\n\tvec2 d = (calcLoadDist(iResolutionxy,limit) - border)* vec2(-1,1);\n    return floor(pos).xxyy + d.xyxy;\n}\n\nvec3 texToVoxCoord(vec2 textelCoord, vec3 offset) {\n\tvec3 voxelCoord = offset;\n    voxelCoord.xy += unswizzleChunkCoord(textelCoord / packedChunkSize);\n    voxelCoord.z += mod(textelCoord.x, packedChunkSize.x) + packedChunkSize.x * mod(textelCoord.y, packedChunkSize.y);\n    return voxelCoord;\n}\n\nvec2 voxToTexCoord(vec3 voxCoord) {\n    vec3 p = floor(voxCoord);\n    return swizzleChunkCoord(p.xy) * packedChunkSize + vec2(mod(p.z, packedChunkSize.x), floor(p.z / packedChunkSize.x));\n}\n\n\nstruct voxel {\n\tfloat id;\n    int value;\n    vec2 light;\n    float life;\n    int shape;\n    int rotation;\n    //float hue;\n};\n\nvoxel decodeVoxel(vec4 textel) {\n\tvoxel o;\n    o.id =   floor(mod(textel.r, 256.));\n    o.value = int(floor(textel.r/ 256.));\n    o.light.s = floor(mod(textel.g, 16.));\n    o.light.t = floor(mod(textel.g / 16., 16.));\n    o.shape = int(floor(mod(textel.b, 16.)));\n    o.life = floor(mod(textel.b / 16., 16.));\n    o.rotation = int(o.life);\n    \n    return o;\n}\n\n\nvec4 encodeVoxel(voxel v) {\n\tvec4 t;\n    t.r = v.id +  float(v.value* 256);\n    t.g = clamp(floor(v.light.s), 0., 15.) + 16. * clamp(floor(v.light.t), 0., 15.);\n    if(v.id!=10. && v.id!=11.) v.life = float(v.rotation);\n    t.b = clamp(float(v.shape), 0., 15.) + 16. * clamp(floor(v.life), 0., 15.);\n    t.a = 1.;\n\n    return t;\n}\n\nvec4 readMapTex(vec2 pos, sampler2D iChannel,vec3 resolution) {\n    return textureLod(iChannel, (floor(pos) + 0.5) /  (floor (resolution.xy)), 0.0);   \n \n}\n\n\nvoxel getCachedVoxel(vec3 p,sampler2D iChannel,vec3 resolution) {\n    return decodeVoxel(readMapTex(voxToTexCoord(p),iChannel,resolution));\n}\n\n\nfloat isSolidVoxel(vec3 p,sampler2D iChannel,vec3 resolution) {\n    voxel vox= decodeVoxel(readMapTex(voxToTexCoord(p),iChannel,resolution));\n    return (vox.id==0. || vox.id==12. ||vox.id==26.)?0.:1.;\n}\n\nfloat getInventory(float slot) {\n\treturn slot + 1. + step(2.5, slot);  \n}\n\n\n\n// WORLD GENERATION \n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\nconst float PI = 3.14159265359;\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\nfloat hash( in vec3 x ) {\n\tfloat n = dot( x, vec3(1.0,113.0,257.0) );\n    return fract(sin(n)*43758.5453);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22( vec2 p ) \n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n}\n\n\n// Fork of \"Optimized Ashima SimplexNoise3D\" by Makio64. https://shadertoy.com/view/Xd3GRf\n// 2020-04-23 14:52:01\n\n// Optimized AshimaSimplexNoise by @makio64 https://www.shadertoy.com/view/Xd3GRf\n// Original : https://github.com/ashima/webgl-noise/blob/master/src/noise3D.glsl\n\nfloat snoise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash22(i+0.0)), dot(b,hash22(i+o)), dot(c,hash22(i+1.0)));\n    \n    return dot( n, vec3(70.0) );\n}\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,128.852))) * 43758.5453)*2.0-1.0;\n}\nfloat snoise(vec3 p)\n{\n\t\n\tfloat f3 = 1.0/3.0;\n\tfloat s = (p.x+p.y+p.z)*f3;\n\tint i = int(floor(p.x+s));\n\tint j = int(floor(p.y+s));\n\tint k = int(floor(p.z+s));\n\t\n\tfloat g3 = 1.0/6.0;\n\tfloat t = float((i+j+k))*g3;\n\tfloat x0 = float(i)-t;\n\tfloat y0 = float(j)-t;\n\tfloat z0 = float(k)-t;\n\tx0 = p.x-x0;\n\ty0 = p.y-y0;\n\tz0 = p.z-z0;\n\t\n\tint i1,j1,k1;\n\tint i2,j2,k2;\n\t\n\tif(x0>=y0)\n\t{\n\t\tif(y0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order\n\t\telse if(x0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order\n\t\telse { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }  // Z X Z order\n\t}\n\telse \n\t{ \n\t\tif(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order\n\t\telse if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order\n\t\telse { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order\n\t}\n\t\n\tfloat x1 = x0 - float(i1) + g3; \n\tfloat y1 = y0 - float(j1) + g3;\n\tfloat z1 = z0 - float(k1) + g3;\n\tfloat x2 = x0 - float(i2) + 2.0*g3; \n\tfloat y2 = y0 - float(j2) + 2.0*g3;\n\tfloat z2 = z0 - float(k2) + 2.0*g3;\n\tfloat x3 = x0 - 1.0 + 3.0*g3; \n\tfloat y3 = y0 - 1.0 + 3.0*g3;\n\tfloat z3 = z0 - 1.0 + 3.0*g3;\t\n\t\t\t\t \n\tvec3 ijk0 = vec3(i,j,k);\n\tvec3 ijk1 = vec3(i+i1,j+j1,k+k1);\t\n\tvec3 ijk2 = vec3(i+i2,j+j2,k+k2);\n\tvec3 ijk3 = vec3(i+1,j+1,k+1);\t\n            \n\tvec3 gr0 = normalize(vec3(noise3D(ijk0),noise3D(ijk0*2.01),noise3D(ijk0*2.02)));\n\tvec3 gr1 = normalize(vec3(noise3D(ijk1),noise3D(ijk1*2.01),noise3D(ijk1*2.02)));\n\tvec3 gr2 = normalize(vec3(noise3D(ijk2),noise3D(ijk2*2.01),noise3D(ijk2*2.02)));\n\tvec3 gr3 = normalize(vec3(noise3D(ijk3),noise3D(ijk3*2.01),noise3D(ijk3*2.02)));\n\t\n\tfloat n0 = 0.0;\n\tfloat n1 = 0.0;\n\tfloat n2 = 0.0;\n\tfloat n3 = 0.0;\n\n\tfloat t0 = 0.5 - x0*x0 - y0*y0 - z0*z0;\n\tif(t0>=0.0)\n\t{\n\t\tt0*=t0;\n\t\tn0 = t0 * t0 * dot(gr0, vec3(x0, y0, z0));\n\t}\n\tfloat t1 = 0.5 - x1*x1 - y1*y1 - z1*z1;\n\tif(t1>=0.0)\n\t{\n\t\tt1*=t1;\n\t\tn1 = t1 * t1 * dot(gr1, vec3(x1, y1, z1));\n\t}\n\tfloat t2 = 0.5 - x2*x2 - y2*y2 - z2*z2;\n\tif(t2>=0.0)\n\t{\n\t\tt2 *= t2;\n\t\tn2 = t2 * t2 * dot(gr2, vec3(x2, y2, z2));\n\t}\n\tfloat t3 = 0.5 - x3*x3 - y3*y3 - z3*z3;\n\tif(t3>=0.0)\n\t{\n\t\tt3 *= t3;\n\t\tn3 = t3 * t3 * dot(gr3, vec3(x3, y3, z3));\n\t}\n\treturn 96.0*(n0+n1+n2+n3);\n\t\n}\n\n\n\n\n//https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\n\nfloat lightDefault(float z){\n\tif(z>2.) return 15.;\n    else return 1.;\n}\n\nvoxel getGeneratedVoxel(vec3 voxelCoord){\n\t\tvoxel vox;\n    \t\n        //vox.light.t = voxelCoord.z>10.? 0.:12.;\n    \n     \t//TREE BASE\n       //if (hash13(voxelCoord) > 0.98 && !overworld(voxelCoord + vec3(0,0,+1))) {vox.id = 10.;vox.life = 5.;}\n\n    \tif (voxelCoord.z < 3.) vox.id = 3.; \n        //BEDROCK\n        if (voxelCoord.z < 1.) vox.id = 16.; \n    \n \n        vox.light.s = lightDefault(voxelCoord.z);\n            \n        return vox;\n\t\t\n}\n\n\n\n// MIX PROCEDURAL AND MEMORY VOXEL\nbool inRange(vec2 p, vec4 r) {\n\treturn (p.x > r.x && p.x < r.y && p.y > r.z && p.y < r.w);\n}\n\nvoxel getVoxelData( vec3 voxelCoord,sampler2D iChannel,vec3 resolution,int mode, vec4 range,vec3 offset){\n  \n    \n    if ((!inRange(voxelCoord.xy,range) && mode==1) || mode == 0 ) {\n        return getGeneratedVoxel(voxelCoord);\n    }\n    else {\n    \treturn getCachedVoxel(voxelCoord  - offset,iChannel,resolution); \n    }\n\t\n}\n\n// RENDERING\n\nvec3 rayDirection(vec2 angle, vec2 uv, vec2 renderResolution){\n    vec3 cameraDir = vec3(sin(angle.y) * cos(angle.x), sin(angle.y) * sin(angle.x), cos(angle.y));\n    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);\n    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) * renderResolution.y / renderResolution.x;\n\treturn normalize(cameraDir + uv.x * cameraPlaneU + uv.y * cameraPlaneV);\n\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\n\n//RAYTRACING\n\nvec4 load(vec2 coord) {\n\treturn textureLod(iChannel0, vec2((floor(coord) + 0.5) / iChannelResolution[0].xy), 0.0);\n}\n\n\n\n//From https://github.com/hughsk/glsl-hsv2rgb\nvec3 hsv2rgb(vec3 c) {\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 getTexture(float id, vec2 c) {\n    vec2 gridPos = vec2(mod(id, 8.), floor(id / 8.));\n\treturn textureLod(iChannel2, 16. * (c + gridPos) / iChannelResolution[3].xy, 0.0);\n}\n\n\n    \nvoxel getCachedVoxel(vec3 p) {\n    vec3 offset = floor(vec3(load(_pos).xy, 0.));\n    return getCachedVoxel(p-offset,iChannel1,iChannelResolution[0]);\n}\n   \n\nvoxel getVoxel(vec3 p) {\n    //return getVoxel(p,iChannel1,iChannelResolution[0]);\n    vec3 offset = floor(vec3(load(_pos).xy, 0.));\n    vec4 range = load(_loadRange);\n    vec3 oldOffset = floor(vec3(load(_old+_pos).xy, 0.));\n   \n    int mode = (iFrame==0)?0:1;\n    return getVoxelData( p,iChannel1,iChannelResolution[0],mode,range,offset);\n    \n}\n\n\nvec2 max24(vec2 a, vec2 b, vec2 c, vec2 d) {\n\treturn max(max(a, b), max(c, d));   \n}\n\nfloat lightLevelCurve(float t) {\n    t = mod(t, 1200.);\n\treturn 1. - ( smoothstep(400., 700., t) - smoothstep(900., 1200., t));\n}\n\nvec3 lightmap(vec2 light) {\n    light = 15. - light;\n    return clamp(mix(vec3(0), mix(vec3(0.11, 0.11, 0.21), vec3(1), lightLevelCurve(load(_time).r)), pow(.8, light.s)) + mix(vec3(0), vec3(1.3, 1.15, 1), pow(.75, light.t)), 0., 1.);   \n}\n\nfloat vertexAo(float side1, float side2, float corner) {\n\treturn 1. - (side1 + side2 + max(corner, side1 * side2)) / 5.0;\n}\n\nfloat opaque(float id) {\n\t//return id > .5 ? 1. : 0.;\n    return  id != 0. && id!= 12. && id!= 26. ? 1. :0.;\n}\n\nvec3 calcOcclusion(vec3 r,vec3 n, vec3 s, vec3 t, vec2 uv,voxel vox) {\n\tvoxel v1, v2, v3, v4, v5, v6, v7, v8, v9;\n    \n   \n   voxel v[9]; \n   \n   for (int i =-1; i <=1; i++) {\n        for (int j =-1; j <=1 ; j++) {\n            v[4+ i+3*j]=getVoxel(r +n + s* float(i +min(iFrame,0)) +t*float(j +min(iFrame,0)));          \n        }\n    }\n    \n    v1 = v[6];// getVoxel(r - s + t);\n    v2 = v[7];// getVoxel(r + t);\n    v3 = v[8];// getVoxel(r + s + t);\n    v4 = v[3];// getVoxel(r - s);\n    v5 = v[4];// getVoxel(r);\n    v6 = v[5];// getVoxel(r + s);\n    v7 = v[0];// getVoxel(r - s - t);\n    v8 = v[1];// getVoxel(r - t);\n    v9 = v[2];// getVoxel(r + s - t);\n    \n    //return vec3(uv, 0.) - .5 * opaque(v6.id);\n    \n    vec2 light1, light2, light3, light4, light;\n    light1 = max24(v1.light, v2.light, v4.light, v5.light);\n    light2 = max24(v2.light, v3.light, v5.light, v6.light);\n    light3 = max24(v4.light, v5.light, v7.light, v8.light);\n    light4 = max24(v5.light, v6.light, v8.light, v9.light);\n    \n    float ao1, ao2, ao3, ao4, ao;\n    ao1 = vertexAo(opaque(v2.id), opaque(v4.id), opaque(v1.id));\n    ao2 = vertexAo(opaque(v2.id), opaque(v6.id), opaque(v3.id));\n    ao3 = vertexAo(opaque(v8.id), opaque(v4.id), opaque(v7.id));\n    ao4 = vertexAo(opaque(v8.id), opaque(v6.id), opaque(v9.id));\n    \n    \n    \n    light = mix(mix(light3, light4, uv.x), mix(light1, light2, uv.x), uv.y);\n    ao = mix(mix(ao3, ao4, uv.x), mix(ao1, ao2, uv.x), uv.y);\n    if(opaque(v5.id)>0.) {ao=.75;} //average...\n    return vec3(light , ao);\n    //return vec3(v5.light.s/15.);\n}\n\n\nstruct rayCastResults {\n\tbool hit;\n    vec3 rayPos;\n    vec3 mapPos;\n    vec3 normal;\n    vec2 uv;\n    vec3 tangent;\n    vec3 bitangent;\n    float dist;\n    voxel vox;\n    float water;\n    float fog;\n\n};\n\n\nfloat fogDensity(vec3 p) {\n\n\tfloat density = 0.;p.z - 70.;\n    //density += mix(0., 30., pow(.5 + .5 * snoise(p.xy /557. + vec2(0.576, .492)), 2.)) * snoise((p ) / 31.51 + vec3(0.981, .245, .497 +iTime/10.));\n\n     return clamp(density ,0.,50.);\n\n}\n\nmat3 rotate(float theta,int axis) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    if (axis==1) return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, s),\n        vec3(0, -s, c)\n    );\n    if (axis==2) return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n    return mat3(\n        vec3(c, s, 0),\n        vec3(-s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\n#ifdef SUBVOXEL\nrayCastResults raySubCast(vec3 rayPosOrig, vec3 rayDir, int shape,int rotation){\n    float N=5.; \n\trayCastResults  res;\n    \n    vec3 c=vec3(.5);\n    float theta= PI/2.*float(rotation%4);\n    rayPosOrig = rotate( theta,3) *(rayPosOrig-c) +c;\n    rayDir= rotate( theta,3)*rayDir; \n    theta= PI/2.*float(rotation/4);\n    rayPosOrig = rotate( theta,2) *(rayPosOrig-c)+c;\n    rayDir= rotate( theta,2)*rayDir; \n    \n    \n     vec3 ro = (rayPosOrig) *N;\n\n    \n\t//if(abs(ro.x -N/2.)>N/2. ||abs(ro.y -N/2.)>N/2. ||abs(ro.y -N/2.)>N/2.)return vec4(0.,0.,0.,1.);\n\n       \n\tvec3 ri = 1.0/rayDir;\n\tvec3 rs = sign(rayDir);\n    vec3 pos = floor(ro+rs*0.001);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tres.hit=false;\n\tvec3 mm = vec3(0.);\n    float t=0.;\n    \n\tfor( int i=0; i<int(N)*3; i++ ) \n    {\t\n        if(i>0){\n            mm = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy);\n            vec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n            t = max ( mini.x, max ( mini.y, mini.z ) );\n        }\t\n        \n        dis += mm * rs * ri;\n        pos += mm * rs;\n        if( sdBox( ro+t*rayDir-vec3(N/2.),vec3(N/2.) )>.05) {res.hit=false; break;}\n        \n        //SHAPES\n        \n     \n        float x= floor(mod(iTime,N));\n        //SINGLE BLOCK\n        //if( sdBox( pos-vec3(x,x,x) +rs*0.001 ,vec3(.5,.5,.5) )<.01) {res.hit=true; break;}\n     \n\n        if(shape==1){// POLE\n        \tif( sdBox( pos-vec3(2.,2.,2.) +rs*0.001 ,vec3(.5,.5,2.5) )<.01) {res.hit=true; break;}\n\t      \n        }else if(shape==2){//STEP 1\n            if(sdBox( pos-vec3(2.,2.,0.) +rs*0.001 ,vec3(2.5,2.5,0.5) )<.01) {res.hit=true; break;}\n          \n        }else if(shape==3){//STEP 2\n             if( sdBox( pos-vec3(2.,2.,0.) +rs*0.001 ,vec3(2.5,2.5,1.5) )<.01) {res.hit=true; break;}\n           \n        }else if(shape==4){//FENCE 1\n         \tif( sdBox( pos-vec3(2.,2.,2.) +rs*0.001 ,vec3(.5,.5,2.5) )<.01) {res.hit=true; break;}\n          \tif( sdBox( pos-vec3(2.,2.,4.) +rs*0.001 ,vec3(.5,2.5,.5) )<.01) {res.hit=true; break;}\n          \n        }else if(shape==5){//FENCE 2\n        \tif( sdBox( pos-vec3(2.,2.,2.) +rs*0.001 ,vec3(.5,.5,2.5) )<.01) {res.hit=true; break;}\n          \tif( sdBox( pos-vec3(1.,2.,4.) +rs*0.001 ,vec3(1.5,.5,.5) )<.01) {res.hit=true; break;}\n          \tif( sdBox( pos-vec3(2.,1.,4.) +rs*0.001 ,vec3(.5,1.5,.5) )<.01) {res.hit=true; break;}\n\n        }else if(shape==6){//SLOPE 1\n            if( dot(pos,  vec3(0.,sqrt(2.),sqrt(2.))) -6. <0. ) {res.hit=true; break;}\n            \n        }else if(shape==7){//PANEL\n            if(sdBox( pos-vec3(0.,2.,2.) +rs*0.001 ,vec3(.5,2.5,2.5) )<0.) {res.hit=true; break;}\n            \n        }               \n\t}\n\n    if(res.hit){\n        res.normal = (- mm*rs); \n        vec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n        res.dist =max ( mini.x, max ( mini.y, mini.z ) )/N;\n       // res.rayPos =(ro+res.dist*rayDir)/N;\n\n    }\n    return res;\n   \n\n}\n#endif\n\nrayCastResults rayCast(vec3 rayPos, vec3 rayDir,int maxRayDist,vec4 range,int rayType) {\n\t   \n      \n    bool hit = false;\n    voxel vox;\n    vox.id=0.;\n    float waterDist=0.;\n    float fog=0.;   \n    rayCastResults subRes;\n    subRes.hit=false;\n\n    vec3 raySign= sign(rayDir);\n    vec3 rayInv = 1./rayDir;\n    vec3 mapPos=floor(rayPos+raySign*0.001);\n    vec3 sideDist = (mapPos-rayPos + 0.5 + sign(rayDir)*0.5) *rayInv;\n    vec3 mask=vec3(0.); \n    float t=0.;\n    \n\tvec3 hitWater =getCachedVoxel( mapPos).id==12.? rayPos: vec3(0.);\n\n        \n    for (int i = 0; i < int( load(_rayLimit).r); i++) {\n\n        if(i>0){\n       \t\tmask = step(sideDist.xyz, sideDist.yzx) * step(sideDist.xyz, sideDist.zxy);\n            vec3 mini = (mapPos-rayPos + 0.5 - 0.5*vec3(raySign))*rayInv;\n            t = max ( mini.x, max ( mini.y, mini.z ) );\n        }\n\t\tsideDist += mask *  raySign *rayInv;\n        mapPos += mask *  raySign;\n        \n        if ( mapPos.z < 0. ) break;\n        if ( mapPos.z >= heightLimit){\n            if(rayDir.z > 0.)  break;\n            \n            //MAP RAY FROM ABOVE\n            float nstep= -((mapPos.z - heightLimit)*rayInv.z);\n\t\t\tmapPos +=  rayDir *nstep;\n            sideDist = (mapPos-rayPos + 0.5 + raySign*0.5) *rayInv;\n            continue;\n        }\n                   \n        vox = getVoxel( mapPos);\n#ifdef SUBVOXEL        \n        if(vox.shape!=0){ \n            //SUB VOXEL\n            vec3 mini = (mapPos-rayPos + 0.5 - 0.5*raySign)*rayInv;\n\t\t\tfloat t = max ( mini.x, max ( mini.y, mini.z ) );\n    \t\tvec3 hitVoxelPos = rayDir * t + rayPos;\n            \n             subRes = raySubCast( hitVoxelPos - mapPos ,  rayDir, vox.shape,vox.rotation);\n            if(subRes.hit) { \t\t\n       \t\t \thit = true; \n                break;\n            }else {vox.id=0.;hit = false;}\n        }\n#endif        \n        \n        if(vox.id==12.){\n        \t//ENTERING WATER\n            if(hitWater.z<1.) {\n                hitWater=mapPos;\n                // deviate ray xy if intercept water\n                vec3 mini = (mapPos-rayPos + 0.5 - 0.5*raySign)*rayInv;\n\t\t\t    float t = max ( mini.x, max ( mini.y, mini.z ) );\n    \t\t\tvec3 endRayPos = rayDir * t + rayPos;\n \t\t\t\trayDir.xy*=0.8+.1*snoise(vec3(endRayPos.xy,iTime));\n                rayDir=normalize(rayDir);rayInv=1./rayDir;\n                sideDist = (mapPos-rayPos + 0.5 + raySign*0.5) /rayDir;\n                \n            }\n        \t\n            vox.id=0.;\n            continue;\n        }\n        if( vox.id !=0. && vox.id!=26.){\n        \thit = true; \n           \tbreak;\n        } \n        else if(hitWater.z>0.){\n        \t//HANDLE RAY OUTSIDE FROM THE WATER\n            hitWater =vec3(0.);\n            waterDist +=length(hitWater-mapPos) ;\n            \n            // deviate ray xy \n\t\t\tvec3 mini = (mapPos-rayPos + 0.5 - 0.5*raySign)*rayInv;\n\t\t\tfloat t = max ( mini.x, max ( mini.y, mini.z ) );\n    \t\tvec3 endRayPos = rayDir * t + rayPos;          \n            rayDir.xy*=1.2+.1*snoise(vec3(endRayPos.xy,iTime));\n            rayDir=normalize(rayDir);rayInv=1./rayDir;\n            sideDist = (mapPos-rayPos + 0.5 + raySign*0.5) /rayDir;\n            \n\n        }\n        \n        //FOG & CLOUDS\n        float fogd= fogDensity(mapPos)/4.;\n        if(fogd >4. && rayType!=2) break;        \n        fog += fogDensity(mapPos)/4.;\n        \n        \n        //NO HIT\n        if(!inRange(mapPos.xy, range) && i> maxRayDist) break;\n\n\t}\n    if(hitWater.z>0.)  waterDist +=length(hitWater-mapPos);      \n    \n    \n    if(load(_stats).r>0.5){\n    \tvec4 range2= calcLoadRange(rayPos.xy,iResolution.xy,1.,load(_loadDistLimit).r);\n    \tif(hit && inRange(mapPos.xy, range)  && !inRange(mapPos.xy, range2)) vox.id = 8.;    \n    }\n        \n    if(!hit  &&rayDir.z < 0. && !inRange(mapPos.xy, range)){\n        if(mapPos.z>55.) {vox.id = 0.; hit=false;}\n        else { vox.id=3.; hit = true;}\n    }\n    \n    vec3 mini = (mapPos-rayPos + 0.5 - 0.5*raySign)*rayInv;\n\t t = max ( mini.x, max ( mini.y, mini.z ) );\n    \n  \n    \n    rayCastResults res;\n    res.hit = hit;\n\n    res.mapPos = mapPos;\n    res.normal = -raySign * mask;\n    res.rayPos = rayDir * t + rayPos;\n    res.dist = length(rayPos - res.rayPos);\n    res.vox=vox;\n    res.water =waterDist;\n    res.fog=fog;\n    \n    if(subRes.hit){\n        res.rayPos = rayDir * (t + subRes.dist) + rayPos;\n       \tres.normal=subRes.normal;\n        mask=subRes.normal.xyz;\n        res.dist = length(rayPos - res.rayPos);\n        //res.vox=subRes.vox;\n        \n    }\n    \n    //vec3 endRayPos = rayDir / dot(mask * rayDir, vec3(1)) * dot(mask * (mapPos + step(rayDir, vec3(0)) - rayPos), vec3(1)) + rayPos;\n   \tvec2 uv;\n    vec3 tangent1;\n    vec3 tangent2;\n      \n                   \n    if (abs(mask.x) > 0.) {\n        uv = fract(res.rayPos.yz);\n        tangent1 = vec3(0,1,0);\n        tangent2 = vec3(0,0,1);\n    }\n    else if (abs(mask.y) > 0.) {\n        uv = fract(res.rayPos.xz);\n        tangent1 = vec3(1,0,0);\n        tangent2 = vec3(0,0,1);\n    }\n    else {\n        uv = fract(res.rayPos.yx);\n        tangent1 = vec3(0,1,0);\n        tangent2 = vec3(1,0,0);\n    }\n    \n    res.uv = uv ;\n    res.tangent = tangent1;\n    res.bitangent = tangent2;\n    \n    res.rayPos -= rayDir * t /100.; //trick to avoid wrong shadow if hitpoint inside cube\n    return res;\n}\n\nvec4 sun(){\n    float t = load(_time).r;\n    float sunAngle = (t * PI * 2. / 1200.) + PI / 4.;\n    const float risingAngle=PI/6.;\n    return  vec4(cos(sunAngle)*sin(risingAngle), cos(sunAngle)*cos(risingAngle), sin(sunAngle),lightLevelCurve(t));\n}\n\nvec3 skyColor(vec3 rayDir) {\n    \n    vec4 s= sun();\n    float lightLevel = s.w;\n\n    vec3 sunDir=s.xyz;\n    vec3 daySkyColor = vec3(.5,.75,1);\n    vec3 dayHorizonColor = vec3(0.8,0.8,0.9);\n    vec3 nightSkyColor = vec3(0.1,0.1,0.2) / 2.;\n    \n    vec3 skyColor = mix(nightSkyColor, daySkyColor, lightLevel);\n    vec3 horizonColor = mix(nightSkyColor, dayHorizonColor, lightLevel);\n    float sunVis = smoothstep(.99, 0.995, dot(sunDir, rayDir));\n    float moonVis = smoothstep(.999, 0.9995, dot(-sunDir, rayDir));\n    return mix(mix(mix(horizonColor, skyColor, clamp(dot(rayDir, vec3(0,0,1)), 0., 1.)), vec3(1,1,0.95), sunVis), vec3(0.8), moonVis);\n    \n}\n\n\n\n// ---- 8< -------- 8< -------- 8< -------- 8< ----\nvoid applyFog( inout vec3  rgb,       // original color of the pixel\n               in float distance ) // camera to point distance\n{\n    float fogAmount = 1.0 - exp( -distance*0.015 );\n    vec3  fogColor  = vec3(0.5,0.6,0.7)*clamp(sun().w,.3,1.);\n    rgb= mix( rgb, fogColor, fogAmount );\n}\n\nvoid render( out vec4 fragColor, vec3 rayPos, vec3 rayDir ,int  maxRayDist, int rayType) {\n\n    vec4 range = load(_old+_loadRange);\n    \n    rayCastResults res = rayCast(rayPos, rayDir,maxRayDist,range,rayType);\n\t\n\tvec3 color = vec3(0.);\n    \n    if (res.hit) {\n        \n        if(rayType==1){\n\n           //color *= hsv2rgb(vec3(getVoxel(mapPos + .5 - offset).hue, .1, 1));\n            float textureId = res.vox.id;\n            if (textureId == 3.) textureId += res.normal.z;\n            color = getTexture(textureId, res.uv).rgb;\n            \n            \n\t\t\tfloat shadow =0.;\n            \n            #ifdef SHADOW\n            vec3 sunDir = sun().xyz; sunDir *= sign(sunDir.z);\n            int shadowlenght = inRange(res.rayPos.xy, range) ? 25:5;\n            shadow = rayCast(res.rayPos , sunDir,shadowlenght,range,3 + min(iFrame,0)).hit?1.:0.;\n\t\t\t#endif\n            \n            \n            vec3 occ=calcOcclusion(res.mapPos, res.normal, res.tangent, res.bitangent, res.uv,res.vox);\n            color *= lightmap(vec2(occ.x*(1.-shadow*.2),occ.y)) *occ.z;   \n                \n            if(res.water>0.) color *=  pow( vec3(.05,.3,1.) ,vec3(res.water/5.));\n            vec4 pick = load(_pick);\n            if (res.mapPos == pick.xyz || res.vox.value==2) {\n                if (pick.a == 1.) color *= getTexture(32., res.uv).r;\n                else color = mix(color, vec3(1), 0.2);\n            }\n        }else\n        {\n            //lightmap(min(vox.light + 0.2, 15.));\n            float textureId = res.vox.id;\n            if (textureId == 3.) textureId += res.normal.z;\n            color = vec3(1.);\n            color *= getTexture(textureId, res.uv).rgb;\n            \n            color *=  clamp( (res.mapPos.z-30.) /30.,0.,1.);\n            color = mix(color, vec3(1), 0.2);\n           // color.rgb = res.uv.xyx;\n        }\n        //color.rgb = res.uv.xyx;\n    }\n     else color = skyColor(rayDir);\n    if(rayType==1) {\n        applyFog(color.rgb,res.fog);\n        color = pow( color, vec3(0.9) );\n             \n    }\n    fragColor.rgb = color; //pow(color, vec3(1.));\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \n    float pixelSize = load(_pixelSize).r;\n    vec2 renderResolution = ceil(iResolution.xy / pixelSize); \n    if (any(greaterThan(fragCoord, renderResolution))) {\n        fragColor = vec4(0);\n        return;\n    }\n    \n\n   \n    // MAIN CAMERA\n    float zoom = pow(10., load(_renderScale).r/10.)/pixelSize;\n     renderResolution = iResolution.xy *zoom; \n    vec2 renderCenter=vec2(0.5);\n    vec2 uv = (fragCoord.xy- renderCenter) / renderResolution - (renderCenter/zoom/pixelSize);\n    vec3 cameraPos = load(_pos).xyz + vec3(0,0,1.6);    \n    vec3 cameraDir = rayDirection(load(_angle).xy,uv,renderResolution);\n\n\n    \n    render(fragColor,cameraPos, cameraDir, int(load(_rayDistMax).r),1 + min(iFrame,0));\n    \n\n}","name":"Buf D","description":"","type":"buffer"}]}