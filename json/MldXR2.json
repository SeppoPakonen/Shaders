{"ver": "0.1", "info": {"id": "MldXR2", "date": "1480801521", "viewed": 117, "name": "Floor 'n Ceiling", "username": "TrueBoolean", "description": "Stupid simple, and inspired by some demoscene effects. I'd eventually like to put some procedural textures on this. This is probably also a useful method for texture-mapping after performing a raymarch.", "likes": 2, "published": 1, "flags": 0, "tags": ["floor"], "requires": ["texture", "imagebuf", "texturebuf"]}, "renderpass": [{"inputs": [{"id": "4sf3Rr", "filepath": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "previewfilepath": "/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "type": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "void mainImage( out vec4 c, vec2 p ){\n    //Translate the screen & mouse to between -1 and 1\n    #define UV(x) ((x / iResolution.xy) *2. -1.)\n\tp=UV(p);\n    vec2 mouse = UV(iMouse.xy);\n    //Some transformations need to be done before the projection:\n    p.y+=mouse.y + sin(iTime); //Move the horizon, which looks like looking up/down\n    #define ROT(x) mat2(cos(x), - sin(x), sin(x), cos(x))\n    p*=ROT(iTime);//Roll the camera around.\n    p.y=abs(p.y); //Make the floor and ceiling reflections of each other.\n    float y=p.y;\n    \n    /*IN/=IN.y-1.;//Old version distorts FOV when moving horizon, but good for super small code*/\n    p = vec2(p.x, p.y + 1.) / p.y; \n    \n    //Other transformations need to be done after the projection.\n    p*=ROT(mouse.x + iTime); // Look left and right\n    p*=sin(iTime)+1.5; //Changes the height of the walls\n    p-=vec2(sin(iTime*2.), -iTime*2.); //Scrolls in x and y\n    \n    c = texture(iChannel0, p);\n    c.xyz*=y;\n}", "name": "Image", "description": "", "type": "image"}]}