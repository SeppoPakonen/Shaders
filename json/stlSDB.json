{"ver":"0.1","info":{"id":"stlSDB","date":"1626565245","viewed":174,"name":"Raycaster 4 Rooms","username":"Yusef28","description":"Features Wayfinding Design (Directional, Chromatic) | Fake Ceiling Lights | Keyboard Controls | Collision Detection\nMovement Controls: (W,A,D,S) | Camera/View Controls (Q,E)\nYou can ignore the signage. I was going for something but maybe later.","likes":9,"published":1,"flags":112,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XtlXDB","filepath":"https://soundcloud.com/marko-mcpwner-maravi/solar-fields-mirrors-edge-main","previewfilepath":"https://soundcloud.com/marko-mcpwner-maravi/solar-fields-mirrors-edge-main","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//The code is a mess so probably don't bother\n//You have to click on the screen with the mouse once\n//to enable mouse movement I think.\n//but don't keep clicking with the mouse \n//that can messup the controls.\n\n//Most of the raycaster levels/worlds I've seen were\n//dark/gloomy and featured bricks and metal.\n//I wanted to get away from that here.\n//A lot of the feel of this is based loosly on the\n//design in the game \"Mirror's Edge\" \n//as well as on wayfinding design (very roughly)\n\n//The texturing is a mess. Hexagons get cut off and the arrows \n//could be better. \n//I'm happy with the overall feel though.\n\n//I was suprised how much thecieling lighhts actually \n//feel like real lighting lol.\n\n//Text Function stuff\n#define C(c) U.x-=.5; O+= char(U,64+c)\n\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel2, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\nvec3 noOneHearsYou(vec2 uv)\n{\n    vec2 st = abs(uv);\n    uv = uv+vec2(fract(iTime/4.)*2.-0.3,0.55);\n    vec4  O = vec4(0.0);\n    //uv/=iResolution.y;\n    vec2 position = vec2(.5)-vec2(.23,0.);\n    float FontSize = 6.;\n    vec2 U = ( uv - position)*64.0/FontSize;\n    C(14);C(15);C(23);C(-32);\n    C(16);C(12);\n    C(1);C(25);C(9);C(14);C(7);C(-32);\n    /*C(13);\n    C(9);C(18);C(18);C(15);C(18);C(19);C(-32);\n    C(5);C(4);C(7);C(5);C(-32);C(19);C(15);C(21);C(14);\n    C(4);C(20);C(18);C(1);C(3);C(11);*/\n    float f;\n    vec3 col = O.xxx;\n    //f = smoothstep(0.34,0.35,max(st.x*0.51,st.y));\n    //col = mix(col,vec3(0.,0.9,0.9),f);\n     \n     float xScale = 1.;\n     float yScale = 1.5;\n    f = smoothstep(0.35,0.355,max(st.x*xScale,st.y*yScale));\n    col = mix(col,vec3(1.),f);\n    f = smoothstep(0.36,0.365,max(st.x*xScale,st.y*yScale));\n    col = mix(col,vec3(0.),f);\n    f = smoothstep(0.365,.4,max(st.x*xScale,st.y*yScale));\n    col = mix(col,vec3(1.),f);\n    return vec3(col.xy,f);\n}\n\nvec3 underConstruction(vec2 uv)\n{\n    vec2 st = abs(uv);\n    uv = uv+vec2(fract(iTime/4.)*2.-0.5,0.55);\n    vec4  O = vec4(0.0);\n    //uv/=iResolution.y;\n    vec2 position = vec2(.5)-vec2(.23,0.);\n    float FontSize = 8.;\n    vec2 U = ( uv - position)*64.0/FontSize;\n    C(21);C(14);C(4);C(5);C(18);C(-32);\n    C(3);C(15);C(14);C(19);C(20);C(18);C(21);\n    C(3);C(20);C(9);C(9);C(15);C(14);\n    float f;\n    vec3 col = O.xxx;\n    //f = smoothstep(0.34,0.35,max(st.x*0.51,st.y));\n    //col = mix(col,vec3(0.,0.9,0.9),f);\n     \n     float xScale = 1.;\n     float yScale = 1.5;\n    f = smoothstep(0.35,0.355,max(st.x*xScale,st.y*yScale));\n    col = mix(col,vec3(1.),f);\n    f = smoothstep(0.36,0.365,max(st.x*xScale,st.y*yScale));\n    col = mix(col,vec3(0.),f);\n    f = smoothstep(0.365,.4,max(st.x*xScale,st.y*yScale));\n    col = mix(col,vec3(1.),f);\n    return vec3(col.xy,f);\n}\n\nvec3 cyberia(vec2 uv)\n{\n    vec2 st = abs(uv);\n    uv = uv+vec2(fract(iTime/4.)*2.-0.5,0.55);\n    vec4  O = vec4(0.0);\n    //uv/=iResolution.y;\n    vec2 position = vec2(.5)-vec2(.23,0.);\n    float FontSize = 8.;\n    vec2 U = ( uv - position)*64.0/FontSize;\n    /*C(3);C(25);C(2);C(5);C(18);C(9);\n    C(1);*/\n    C(13);\n    C(9);C(18);C(18);C(15);C(18);C(19);C(-32);\n    C(5);C(4);C(7);C(5);C(-32);C(19);C(15);C(21);C(14);\n    C(4);C(20);C(18);C(1);C(3);C(11);\n\n    float f;\n    vec3 col = O.xxx;\n    //f = smoothstep(0.34,0.35,max(st.x*0.51,st.y));\n    //col = mix(col,vec3(0.,0.9,0.9),f);\n     \n     float xScale = 1.;\n     float yScale = 1.5;\n    f = smoothstep(0.35,0.355,max(st.x*xScale,st.y*yScale));\n    col = mix(col,vec3(1.),f);\n    f = smoothstep(0.36,0.365,max(st.x*xScale,st.y*yScale));\n    col = mix(col,vec3(0.),f);\n    f = smoothstep(0.365,.4,max(st.x*xScale,st.y*yScale));\n    col = mix(col,vec3(1.),f);\n    return vec3(col.xy,f);\n}\n\n\n//End of stext function stuff\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //Step 0: set up a color\n    vec3 col = vec3(0.);\n     \n    //Step 1: Initialize the vectors that give this whole simulation it's structure:\n    \n    // Normalized pixel coordinates (from -1 to 1)\n    //playing with the size of uv (the proj plane) to get wider fov and shorter walls\n    vec2 uv = (fragCoord-iResolution.xy*0.5)*2./iResolution.xy*vec2(1.,1.1);\n    //having the uv moving here affects things later and creates\n    //a moving texture problem\n    uv.y += 0.0;\n    //let's start with ground and sky already there\n    //col = mix(vec3(0.4,0.7,0.5),texture(iChannel1,vec2(uv.x,1./uv.y)).rgb,step(0.0,uv.y));\n    \n    //camera origin. Where the person is.\n    vec2 co =vec2(0.,0.);\n     //   float(MAP_WIDTH)  * (iMouse.x / iResolution.x),\n        //float(MAP_HEIGHT) * (iMouse.y / iResolution.y)\n    //); ///* vec2(0.,0.);\n    vec4 controls = texture(iChannel3,vec2(0.,0.));\n    co.xy = controls.xy;//8,8 start point\n    //camera direction. Where the person is looking.\n    \n    \n    vec2 cd = vec2(0.,.99);//*mat2(cos(iTime),-sin(iTime),sin(iTime),cos(iTime));\n    cd = controls.zw;\n\n    vec2 po = co + cd;\n    //the direction of the project plane is perpendicular to the camera direction\n    //because it's basically the \"x axis\" that we use for all our rays. (not the world\n    //axis, just one for our purposes.)\n    vec2 pd = cd*mat2(0.,-1.,1.,0.);// *mat2(0.0,1.,-1.,0.);\n    //ray origin is the same as the camera origin. So we shine rays starting from\n    //the camera...\n    vec2 ro = co;\n    //and directed by\n    \n\n    vec2 rd = cd + pd*uv.x; //* pd*uv.x - ro\n    \n    \n  //  rd = normalize(rd);\n    //float yProjHit = uv.y; //null bis eins\n   // float z = 1.;//Kam isst bei mittel die proj plane \n    //dist to x of floor hitpoint based on height of cam and y of cam/proj-plane hit\n    float rowDist = 1./uv.y*sign(uv.y);; //z/yProjHit\n    //added the sign so ....that ...it works!\n    //rowDist *= uv.x;  //since it's proportional to the x of projPlane hit\n    //then we take this ratio and apply it to the x and y of rd to get start and\n    //use it as a step to get to floor\n    \n    //the hits\n    float fhitX = ro.x + rowDist*rd.x;\n    float fhitY = ro.y + rowDist*rd.y;\n    float fX = fract(fhitX);\n    float fY = fract(fhitY);\n    \n    //darken farther\n    float darkFar = length(vec2(fhitX,fhitY)-ro)*0.1;\n    darkFar = 0.;//smoothstep(0.,0.6,pow(darkFar,1.))*0.8;\n    //floorTex\n    vec3 floorTex = texture(iChannel2, vec2(fX,fY)).rgb - darkFar;\n    vec3 ceilTex1 = texture(iChannel1, vec2(fX,fY)).rgb - darkFar;\n    vec3 ceilTex2 = lightsTexture(vec2(fX,fY));\n    vec3 ceilTex3 = mix(vec3(0.95,0.95,1.1),ceilTex2*2.,ceilTex2.x);\n    ceilTex3*=vec3(0.95,0.95,1.);\n    ceilTex3 = mix(ceilTex3,vec3(0.0),1.0-texture3(vec2(fX,fY)-vec2(0.,0.5)));\n    float t = float(tile_at( ivec2(int(fhitX),int(fhitY) )));\n    floorTex = 0.5+0.5*cos(vec3(1.,2.,4.) + t*10.);\n    //need clamp or else we get a weird line\n    floorTex = clamp(tileTexture(vec2(fX,fY))*0.9,0.,1.);\n    if(t == -2.) floorTex = clamp(tilesAndArrows(vec2(fX,fY), iTime, 0.)*0.9,0.,1.);\n    if(t == -3.) floorTex = clamp(tilesAndArrows(vec2(fX,fY), iTime, PI/2.)*0.9,0.,1.);\n    if(t == -4.) floorTex = clamp(tilesAndArrows(vec2(fX,fY), iTime, 0.)*0.9,0.,1.);\n    if(t == -5.) floorTex = clamp(tilesAndArrows(vec2(fX,fY), iTime, PI/2.)*0.9,0.,1.);\n    \n    \n    \n    \n    //It's easier to just keep them separate.\n    float currentX,currentY; \n    float firstX,firstY;\n    //we obsever that for any given line on a grid between two\n\n    //Whenever we move 1 unit from x to x, we move \"dx\" along the ray\n    //Whenever we move 1 unit from y to y, we move \"dy\" along the ray\n    float dx,dy;\n    \n    //These are the 1 unit portions x,y which will be positive if\n    //that component of the ray is positive, otherwise negative.\n    float stepX,stepY;\n    \n \n    \n    //*rd.x > 0.0 ? floor(ro.x) : ceil(ro.x)\n    firstX = floor(ro.x);\n    //and same for y\n    firstY = floor(ro.y);\n    //rd.y > 0.0 ? floor(ro.y) : ceil(ro.y);\n    //this isn't on the ray, but it's the square we are in.\n    \n    //the denom.\n    dx = rd.x != 0.0 ? abs(1./rd.x) : abs(1./(rd.x + 0.00001));\n    dy = rd.y != 0.0 ? abs(1./rd.y) : abs(1./(rd.y + 0.00001));\n    //so we have our ratios/distances and we are going to abuse the sh*t out of them.\n   \n\n    currentX = rd.x < 0.0 ? (ro.x - firstX)*dx : (firstX + 1. - ro.x)*dx;\n    currentY = rd.y < 0.0 ? (ro.y - firstY)*dy : (firstY + 1. - ro.y)*dy;\n    \n\n    //Now we just need to know which direction we step in with units of 1\n    //from ray direction:\n    stepX = rd.x > 0.0 ? 1. : -1.; \n    stepY = rd.y > 0.0 ? 1. : -1.; \n    \n    //if we hit a wall, it could be either n/s or e/w and we can color slightly\n    //differently depending to get a shading effect.\n    float side = 0.;\n    float endDist;\n    //if we don't hit anything we'll color the sky and ground\n    float hit = 0.;\n\n    float xDist,yDist;\n    xDist = firstX;\n    yDist = firstY;\n    \n  \n    for(int i = 1; i < 30; i++){\n    \n        if(hit == 1.){break;}\n        \n        if(currentX < currentY){\n        \n            currentX += dx;\n            firstX += stepX;\n            xDist += stepX;\n            side = 0.;\n        }\n        else\n        {\n            currentY += dy;\n            firstY += stepY;\n            yDist += stepY;\n            side = 1.;\n        }\n       \n       if(tile_at(ivec2(int(firstX),int(firstY)))==1){\n\n               \n            hit = 1.;\n        }\n        \n\n\n    }\n \n        \n        \n        if(side == 1.){\n        //maybe yDist + firstY will work iunno\n        //* abs!\n            endDist = abs((firstY - ro.y + (1. - stepY)/2.)/rd.y);\n        }\n        else{\n            endDist = abs((firstX - ro.x + (1. - stepX)/2.)/rd.x);\n        }\n        \n        //if distance is very near, like 1, then heightt will be 1\n        //1 = full height, 0. = zero height\n        float height = 1./endDist;//+side/10.;\n        //we use a step with 1.-height and abs.y\n        //1 - height means if height is 1 the step should be white\n        //starting from 0.\n        //abs meaning, if uv.y (-1 to 1) is negative, just mirror it.\n        \n        float texX, texY;\n        \n        float wallP = side == 1. ? ro.x + endDist*rd.x : ro.y + endDist*rd.y;\n        wallP = fract(wallP);\n        texX = wallP;//*1024 *text_width from lodev not nessesary\n        \n        vec3 skyTex = texture(iChannel1,vec2(atan(rd.y,rd.x)/8.,uv.y/8.)).rgb;\n        \n        //lights \n        \n        vec2 wallTexCoords = vec2(texX, (uv.y/height/2.));\n       //col = mix(floorTex,skyTex,step(0.0,uv.y));\n        col = mix(floorTex,ceilTex3,step(0.0,uv.y));\n    \n        float furVideo = (uv.y);//*0.5;\n        vec3 tex = texture(iChannel0, wallTexCoords).xyz;\n        \n        //tex = tex.gbr*(smoothstep(-0.7,-.3,(furVideo/height/2.)));\n        tex = mix(tex,vec3(0.,0.2,0.2)*6.,(1.0-smoothstep(-0.7,-.3,(furVideo/height/2.))));\n        ///klein verbesseruning. Jetzt ich habe ein uv.y steigung\n        //das verandert sich nicht!\n        //und das war die gottverdammter antwort!\n        //col = mix(col,vec3(0.6,0.6,0.0)*(uv.y/height),1.0-step(height,abs(uv.y)));\n        \n        tex = texture3(wallTexCoords);\n        vec3 wallCol;\n        //texe = mix(tex,0.5+0.5*cos(vec3(1.,2.,4.)/2.+firstY), firstX/8.);\n        //shadiqwng but nt strong\n        if(firstX <= 8. && firstY > 8. )wallCol = vec3(1.,.6,0.3);\n        if(firstX <= 8. && firstY <= 8. )wallCol = vec3(0.6,1.,0.2);\n        if(firstX > 8. && firstY > 8. )wallCol = vec3(0.3,0.5,1.);\n        if(firstX > 8. && firstY <= 8. )wallCol = vec3(1.,0.3,0.3);\n        \n        //tex = mix(halfColor(wallTexCoords, wallCol),vec3(0.), 1.0-texture3(wallTexCoords).x);\n        tex = hexTexture(wallTexCoords, wallCol, tex, vec2(firstX,firstY));\n        col = mix(col,tex-step(0.5,side)*0.2,1.0-step(height,abs(uv.y)));//*(1./endDist);\n        \n        //to texture only one side of one wall\n       // if(tile_at(ivec2(int(firstX),int(firstY)))==1){\n       //we may not need the above but we need this\n       //row, axis, direction ray is casted from ro.y works also here\n       if(firstY == 0. && (firstX == 2. || firstX == 3.) && rd.y <= 0.){\n            vec3 noOne = underConstruction(wallTexCoords-vec2(0.5,0.));\n            tex = mix(tex,noOne.xxx,1.-noOne.z);\n            col = mix(col,tex-step(0.5,side)*0.2,1.0-step(height,abs(uv.y)));\n        }\n        else if(firstY == 0. && (firstX == 12. || firstX == 13.) && rd.y <= 0.){\n            vec3 noOne = cyberia(wallTexCoords-vec2(0.5,0.));\n            tex = mix(tex,noOne.xxx,1.-noOne.z);\n            col = mix(col,tex-step(0.5,side)*0.2,1.0-step(height,abs(uv.y)));\n        }\n        else if(firstY == 13. && (firstX == 2. || firstX == 3.) && side == 1. && rd.y <= 0.){\n            vec3 noOne = noOneHearsYou(wallTexCoords-vec2(0.5,0.));\n            tex = mix(tex,noOne.xxx,1.-noOne.z);\n            col = mix(col,tex-step(0.5,side)*0.2,1.0-step(height,abs(uv.y)));\n        }\n        else if(firstY == 12. && (firstX == 7.) && side == 1. && rd.y <= 0.){\n            vec3 noOne = noOneHearsYou(wallTexCoords-vec2(0.5,0.));\n            tex = mix(tex,noOne.xxx,1.-noOne.z);\n            col = mix(col,tex-step(0.5,side)*0.2,1.0-step(height,abs(uv.y)));\n        }\n        else if((firstY == 12. && firstX == 11. && side == 1. && rd.y <= 0.)){\n            vec3 noOne = noOneHearsYou(wallTexCoords-vec2(0.5,0.));\n            tex = mix(tex,noOne.xxx,1.-noOne.z);\n            col = mix(col,tex-step(0.5,side)*0.2,1.0-step(height,abs(uv.y)));\n        }\n        //}\n            \n        //shading (the /endDist would give floor reflection)\n        //col = mix(col,tex-step(0.5,side)*0.2,1.0-step(height,abs(uv.y)));///max(0.4,endDist);\n        \n        \n        //varying height\n        //col = mix(col,tex-step(0.5,side)*0.2,1.0-step(height+sign(uv.y)*side/10.,abs(uv.y)));\n        \n        //col = mix(col,tex-step(0.5,side)*0.2,1.0-step(height,abs(uv.y)));\n        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define R_LEFT  81\n#define R_RIGHT 69\n#define LEFT    65\n#define RIGHT   68\n#define DOWN    83\n#define UP      87\n\n#define iTimeDelta (1./60.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(any(greaterThan(fragCoord, vec2(1.)))) return;\n    if(iFrame == 0) {\n        fragColor = vec4(2., 2., 1., 1.); return;\n    }\n    fragColor = texelFetch(iChannel1, ivec2(0.), 0);\n    float c = cos(2. * iTimeDelta);\n    float s = sin(2. * iTimeDelta);\n    if(texelFetch(iChannel0, ivec2(R_RIGHT, 0), 0).x > .5) fragColor.zw *= mat2(c,-s,s,c);\n    if(texelFetch(iChannel0, ivec2(R_LEFT , 0), 0).x > .5) fragColor.zw *= mat2(c,s,-s,c);\n    \n    vec2 newU = fragColor.zw * 3. * texelFetch(iChannel0, ivec2(UP   , 0), 0).x * iTimeDelta;\n    vec2 newD = fragColor.zw * 3. * texelFetch(iChannel0, ivec2(DOWN , 0), 0).x * iTimeDelta;\n    vec2 newL = fragColor.wz * vec2(1., -1.) * 1. * texelFetch(iChannel0, ivec2(LEFT , 0), 0).x * iTimeDelta;\n    vec2 newR = fragColor.wz * vec2(1., -1.) * 1. * texelFetch(iChannel0, ivec2(RIGHT, 0), 0).x * iTimeDelta;\n    \n    vec2 ud = newU-newD;\n    vec2 lr = newL-newR;\n    ud = ud+lr;\n    int xHit = tile_at( ivec2( (fragColor.xy + ud).x ,0 ));\n    int yHit = tile_at( ivec2( 0, (fragColor.xy + ud).y ));\n    float a;\n    \n    if(tile_at(ivec2(fragColor.xy + vec2(0.,ud.y))) <= 0)\n    {\n        fragColor.xy += vec2(0.,ud.y);\n        }\n        \n    if(tile_at(ivec2(fragColor.xy + vec2(ud.x, 0.))) <= 0)\n    {\n        fragColor.xy += vec2(ud.x,0.);\n        }\n        \n\n\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//Currently Listening to:\n//Resident Evil & Chill\n//Main learning resource https://lodev.org/cgtutor/raycasting.html\n\n#define MAP_WIDTH 5\n#define MAP_HEIGHT 7\n#define MAP_LENGTH MAP_WIDTH*MAP_HEIGHT\n#define PI 3.14159265359\nprecision highp float;\n\nint[256] map1 = int[](\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1,\n  1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1,\n  1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1,\n  1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1,\n  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1,\n  1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,\n  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1,\n  1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,\n  1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1,\n  1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1,\n  1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1,\n  1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1,\n  1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\n);\n\nint[256] map = int[](\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 0, 0, -3, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1,\n  1,-2, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1,\n  1,-2, 0, 1, -2, 1, 1, 1, 1, 1, 1, -2, 1, 1, 0, 1,\n  1, 0, 0, 0, 0, 0,-5,-5,-5,-5,-5, 0, 0, 0, -2, 1,\n  1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0,-3, 0, 0, 1,\n  1, 1, 1,-2, 1, 1, 1, 0, 0, 0, 1, 1,-4, 1, 1, 1,\n  1, 0, 1,-2, 1, 0, 0, 0, 0, 0, 0, 1,-4, 1, 0, 1,\n  1, 1, 1,-2, 1, 1, 1, 0, 0, 0, 1, 1,-4, 1, 1, 1,\n  1, 1, 1,-2, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1,\n  1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0,-2, 1,\n  1, 0, 0,-3, 0, 0,-3,-3,-3,-3,-3,-3,-2, 1, 0, 1,\n  1,-2, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1,-2, 1,\n  1, 0, 1, 1,-2, 1, 1, 0, 1, 0, 1, 0,-2, 1, 0, 1,\n  1, 0,-3, 0,-3, 0, 0, -2, 1, 0, 1, 0,-3, 0, 0, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\n);\n\nint[256] map2 = int[](\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,\n  1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1,\n  1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1,\n  1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1,\n  1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1,\n  1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1,\n  1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1,\n  1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1,\n  1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1,\n  1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1,\n  1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1,\n  1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1,\n  1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1,\n  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\n);\n\n//https://www.shadertoy.com/view/wtXSW8\nint tile_at(ivec2 p) {\n    //p.x = p.x % 16;\n    //if(p.x < 0) p.x += 16;\n    //p.y = p.y % 16;\n    //if(p.y < 0) p.y += 16;\n    return map[p.y * 16 + p.x];\n}\n\nmat2 rot(float a){\n    float cs = cos(a);\n    float si = sin(a);\n    return mat2(cs,-si,si,cs);\n}\n\nvec3 texture1(vec2 uv){\n    vec3 col = vec3(0.);\n    float f = step(0.5,fract(uv.x*8.))*step(0.5,fract(uv.y*8.));\n    col = mix(col, vec3(1.),f);\n    return col;\n    \n}\n\nvec3 texture2(vec2 uv){\n    vec3 col = vec3(0.);\n    float f = step(0.5,fract(uv.y*8.));\n    col = mix(col, vec3(1.,0.,1.),f);\n    \n    vec2 auv = abs(uv-vec2(0.5,0.));\n    col = mix(col, vec3(0.), smoothstep(0.45,0.48,max(auv.x,auv.y)));\n    return col;\n    \n}\n\nvec3 tileTexture(vec2 uv){\n    float f;\n    vec3 col = vec3(1.);\n    vec2 st = (fract(uv*4.)*2.-1.);\n    \n    f = pow(1.0-abs(st.x*st.y),80.);\n    f = pow(max(abs(st.x),abs(st.y)),15.)-0.2;\n    \n    col = mix(col, vec3(0.), f);\n    return col;\n}\n\nvec3 arrows(vec2 uv, float time, float a){\n    vec3 col;\n    float f1,f2,f3,f4;\n    uv = uv*2.-1.;\n    uv*=rot(a);\n    \n    \n    vec2 st = uv;//*2.;\n    st.x=fract(st.x*1.)-0.5;\n    st.y-=time*sign(-uv.x);\n   //st= dot(st,vec2(1.,1.));\n    //st.y=abs(fract(st.y*8.)-0.5);\n    f1 = dot(st,vec2(1.,1.)*sign(-uv.x));\n    f2 = dot(st,vec2(-1.,1.)*sign(-uv.x));\n    f3 = max(f1,f2);\n    f3 = abs(fract(f3*2.)-0.5);\n    f3 = smoothstep(0.1,0.13,f3);\n    f3 *= 1.0-smoothstep(0.3,0.31,abs(st.x));\n    f3 *= 1.0-smoothstep(0.3,0.31,abs(uv.x/3.7));\n    col = mix(col,vec3(1.),f3);\n    return col;\n\n}\n\nvec3 tilesAndArrows(vec2 uv, float time, float a){\n    vec3 col = tileTexture(uv);\n    float arrows = arrows(uv,time,a).x;\n    \n    col = mix(col,vec3(0.),arrows);\n    \n    return col;\n}\n//Utility outline texture\nvec3 texture3(vec2 uv){\n    vec3 col = vec3(0.);\n    vec2 auv = abs(uv-vec2(0.5,0.));\n    col = mix(col, vec3(1.), 1.0-smoothstep(0.48,0.55,max(auv.x,auv.y)));\n    return col;\n    }\n    \nvec3 lightsTexture(vec2 uv){\n    vec3 col = vec3(0.);\n    vec2 auv = abs(uv-vec2(0.5));\n    float f = 1.0-smoothstep(0.2,0.35,max(auv.x,auv.y));\n    f = pow(f,2.);\n    //col = mix(col, vec3(1.2,1.2,0.9), f);\n    col = mix(col, vec3(0.95,0.95,1.), f);\n    return col;\n}\n\nvec3 halfColor(vec2 uv, vec3 color){\n    float f;\n    vec3 col = vec3(1.);\n    f = 1.0-smoothstep(0., 0.02,uv.y+0.1);\n    col = mix(col, color, f);\n    \n    f = pow(clamp(1.0-abs(uv.y+0.1-0.01)-0.02,0.,1.),100.);\n    col = mix(col,vec3(0.),(f));\n    f = pow(smoothstep(-0.5,-0.4, uv.y), 0.1);\n    col = mix(col, vec3(0.), 1.0-f);\n    return col;\n}\n\nfloat rnd(vec2 id){\n    return fract(sin(id.x*12.49 + id.y*78.99)*41235.32);\n}\n\nvec3 hexTexture(vec2 uv, vec3 color, vec3 tex, vec2 firstXY)\n{\n\tvec2 u = 6.*uv;;\n    vec2 s = vec2(1.,1.732);\n    vec2 a = mod(u,s)*2.-s;\n    vec2 idA = floor(u/s);\n    vec2 b = mod(u+s*.5,s)*2.-s;\n    vec2 idB = floor((u+s*.5)/s);\n    \n    float la = length(a);\n    float lb = length(b);\n    \n    u = la < lb ? a : b;\n    vec2 idSeed = la < lb ? idA : idB*1000.;\n    float id = rnd(idSeed+firstXY.x*firstXY.y/800.);\n    vec2 st = abs(u);\n    float q = max(st.x, dot(st,normalize(s)));\n    float radius = pow(id*0.2,4.);\n    float f = smoothstep(radius + 0., radius + 0.05, 1.0-q);\n    //+firstXY.y/16.\n    vec3 col = mix(tex,color-fract(8.*id)*0.5,f*step(0.2,id));\n    return col;\n}\n","name":"Common","description":"","type":"common"}]}