{"ver": "0.1", "info": {"id": "XtV3RG", "date": "1475196295", "viewed": 599, "name": "Bayer Matrix Generator", "username": "MartyMcFly", "description": "The only algorithm on the web I am aware of that shows how a bayer matrix is computed. There is a book afaik that explains it as well but I figured a small shadertoy example illustrates it best.", "likes": 8, "published": 1, "flags": 0, "tags": ["dither"], "requires": ["imagebuf"]}, "renderpass": [{"inputs": [], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "/* Created by Pascal Gilcher 2016 \n * This creates the more or less famous bayer dither pattern, \"bayer matrix\".\n *\n * Shadertoy has an 8x8 texture version of this as standard asset, flipped vertically,\n * which corresponds to MAX_LEVEL 3.\n * The algorithm can be made shorter probably, at least it's readable.\n * \n * The MAX_LEVEL operator controls the size of the texture, 2^@param is the width\n * and height of it.\n * Be aware that the 16x16 texture is the max size that can be displayed on a screen\n * because it contains all values from 0 to 255 exactly once.\n * The code is used in the MXAO algorithm for the popular postprocessing injector\n * ReShade as lookup for sampling directions.\n */\n\n\n#define MAX_LEVEL 4\n/*\n//some optimizations by FabriceNeyret2, \n//I decided to keep some things expanded for imho better readability\nfloat GetBayerFromCoordLevel2(vec2 pixelpos)\n{\n\tfloat finalBayer   = 0.0;\n\tfloat finalDivisor = 0.0;\n    float layerMult\t   = 1.0;\n    \n  \tfor(float bayerLevel = float(MAX_LEVEL); bayerLevel >= 1.0; bayerLevel--)\n\t{\n\t\tfloat bayerSize \t= exp2(bayerLevel)*0.5;\n\t\tvec2 bayercoord \t= mod(floor(pixelpos.xy / bayerSize),2.0);\n\t\tlayerMult \t\t   *= 4.0;\n\t\t\n\t\tfloat line0202 = bayercoord.x*2.0;\n\n\t\tfinalBayer += mix(line0202,3.0 - line0202,bayercoord.y) / 3.0 * layerMult;\n\t\tfinalDivisor += layerMult;\n\t}\n\n\treturn finalBayer / finalDivisor;\n}\n\n*/\n#define bayer2x2(a) (4-(a).x-((a).y<<1))%4\n\n//some more optimizations, using bitwise ops\nfloat GetBayerFromCoordLevel(vec2 pixelpos)\n{\n    ivec2 ppos = ivec2(pixelpos);\n    int sum = 0;\n    for(int i=0; i<MAX_LEVEL; i++)\n    {\n        sum += bayer2x2(ppos>>(MAX_LEVEL-1-i)&1)<<(2*i);\n    }\n\n    return float(sum) / float(2<<(MAX_LEVEL*2-1));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //align matrix with window\n    uv =floor(uv*exp2(float(MAX_LEVEL)));\n    \n    float bayerPattern = GetBayerFromCoordLevel(uv.xy);\n    \n\tfragColor = vec4(bayerPattern);\n}", "name": "Image", "description": "", "type": "image"}]}