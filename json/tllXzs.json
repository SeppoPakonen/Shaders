{"ver": "0.1", "info": {"id": "tllXzs", "date": "1563988351", "viewed": 252, "name": "Amethyst Tunnel", "username": "peet", "description": "Bit of a fortuitous accident while i was tinkering, thought it worth sharing :)", "likes": 9, "published": 1, "flags": 0, "tags": ["triplanar", "crystal"], "requires": ["texture", "imagebuf", "texturebuf"]}, "renderpass": [{"inputs": [{"id": "XsX3Rn", "filepath": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "type": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "Xsf3zn", "filepath": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "type": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "///////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n\n#define MARCH_EPSILON 0.1\n#define MARCH_ITERATIONS 600\n\n#define FLIGHT_SPEED 5.0\n\n///////////////////////////////////////////////////////////////////////////////////\n\nstruct Material {\n    vec3 colour;\n    float diffuse;\n    float specular;\n};\n    \nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n};\n    \nstruct Light {\n    vec3 pos;\n    vec3 colour;\n};\n    \nstruct Result {\n    vec3 pos;\n    vec3 normal;\n    Material mat;\n};\n\n///////////////////////////////////////////////////////////////////////////////////\n\nMaterial g_NoMaterial = Material(vec3(1.0, 0.0, 1.0), 0.0, 1.0);\n    \n///////////////////////////////////////////////////////////////////////////////////\n        \nconst int numlights = 2;\nLight g_lights[numlights];\n\n///////////////////////////////////////////////////////////////////////////////////\n\nfloat blerp(float x, float y0, float y1, float y2, float y3) {\n\tfloat a = y3 - y2 - y0 + y1;\n\tfloat b = y0 - y1 - a;\n\tfloat c = y2 - y0;\n\tfloat d = y1;\n\treturn a * x * x * x + b * x * x + c * x + d;\n}\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat perlin(float x, float h) {\n\tfloat a = floor(x);\n\treturn blerp(mod(x, 1.0),\n\t\trand(vec2(a-1.0, h)), rand(vec2(a-0.0, h)),\n\t\trand(vec2(a+1.0, h)), rand(vec2(a+2.0, h)));\n}\n\nfloat noise( in vec3 x )\n{\n\treturn texture( iChannel0, (x.xy + x.z*37.0 + 0.5)/256.0, 0.0 ).x*0.75;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n//Tri-planar Texturing Function\nvec3 tritex(sampler2D tex, vec3 p)\n{\n \treturn  (texture(tex,p.xy).rgb\n            +texture(tex,p.zy).rgb\n            +texture(tex,p.xz).rgb)/3.0;\n}\n//Smooth Tri-planar Texturing Function (https://www.shadertoy.com/view/Xd3XDS)\nvec3 tritex(sampler2D tex, vec3 p, vec3 n)\n{\n \treturn  (texture(tex,p.xy).rgb*n.z*n.z\n            +texture(tex,p.zy).rgb*n.x*n.x\n            +texture(tex,p.xz).rgb*n.y*n.y);\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// raymarch query, returning intersection point, normal, surface colour\n\nResult g_result;\n\nfloat cavern(vec3 p)\n{\n    p*=2.0;\n    vec3 floorpos = p;\n    vec3 ceilpos = p;    \n    \n    float value = noise(vec3(p.x*1.0, p.z*1.0, 0.5))*1.75\n                + noise(vec3(p.x*0.25, p.z*0.25, 0.5))*0.55\n                + noise(vec3(p.x*8.125, p.z*8.125, 1.5))*0.4;\n    float value2 = noise(vec3(p.x*1.0, p.z*1.0, 1.5))*1.65\n                + noise(vec3(p.x*0.25, p.z*0.25, 1.5))*0.45\n\t\t\t    + noise(vec3(p.x*8.0, p.z*8.0, 0.5))*0.4;\n\n    floorpos.y = -5.0 + (value*value*value);\n    ceilpos.y = 6.0 - (value2*value2*value2);\n\n    float val1 = p.y - floorpos.y;\n    float val2 = ceilpos.y - p.y;\n        \n    val1-=abs(p.x)*0.25 - 3.0f;\n    val2-=abs(p.x)*0.25 - 1.5f;\n    \n    return min(val1, val2);\n}\n\nfloat ceiling(vec3 p)\n{\n    vec3 ceilpos = p;    \n    \n    float value2 = noise(vec3(p.x*1.0, p.z*1.0, 1.5))*1.75\n                + noise(vec3(p.x*0.25, p.z*0.25, 1.5))*0.55\n                + noise(vec3(p.x*0.125, p.z*0.125, 1.5))*0.125;\n    \n    return (value2*value2*value2);\n}\n\nvec3 normal(vec3 p)\n{\n\tfloat f0 = cavern(p);    \n\tfloat fx = cavern(p+vec3(0.1, 0.0, 0.0));    \n\tfloat fy = cavern(p+vec3(0.0, 0.1, 0.0));    \n\tfloat fz = cavern(p+vec3(0.0, 0.0, 0.1));\n    vec3 norm = vec3(fx-f0, fy-f0, fz-f0);\n    norm = normalize(norm);\n    return norm;\n}\n\nvec3 ceilingnormal(vec3 p)\n{\n\tfloat f0 = ceiling(p);    \n\tfloat fx = ceiling(p+vec3(0.1, 0.0, 0.0));    \n\tfloat fy = ceiling(p+vec3(0.0, 0.1, 0.0));    \n\tfloat fz = ceiling(p+vec3(0.0, 0.0, 0.1));\n    vec3 norm = vec3(fx-f0, fy-f0, fz-f0);\n    norm = normalize(norm);\n    return norm;\n}\n\nResult raymarch_query(Ray ray, int iterations, float delta)\n{\n    Result result = Result(ray.pos+ray.dir*10000.0, vec3(0.0, 0.0, 0.0), g_NoMaterial);\n    float dist = 0.0;\n    float fog=0.0;\n\tfor (int i=0; i<iterations; i++)\n    {\n    \tfloat signeddist = cavern(ray.pos);\n        if (signeddist < 0.0)\n        {\n        \tresult.normal = normal(ray.pos);\n            result.pos = ray.pos;\n            return result;\n        }\n        ray.pos += ray.dir*delta;\n        delta*=1.0025f;\n    }\n    return result;\n}\n\nvec3 colourAt(Result result, Ray inputray)\n{\n    vec3 colour;\n    // texture\n    vec3 tpos = result.pos.xyz*0.15;\n    colour.xyz = tritex(iChannel1, tpos, result.normal);\n    \n    float f0=dot(colour, colour);    \n    vec3 specular = vec3(0.0);\n    vec3 illumination = vec3(0.0);\n    \n    for (int i=0; i<numlights; i++)\n    {\n        // lighting\n        vec3 lightdiff = result.pos - g_lights[i].pos;       \n        float lightdist = length(lightdiff);\n        float falloff = clamp((1.0/pow(lightdist, 3.0)*125.0), 0.0, 0.5);\n        vec3 lightdir = normalize(lightdiff);\n        vec3 illum = clamp(dot(lightdir, -result.normal), 0.0, 1.0)*g_lights[i].colour*falloff;\n        vec3 spec = pow(clamp(dot(lightdir, -result.normal), 0.0, 1.0), 100.0)*g_lights[i].colour*falloff;\n        vec3 col;\n\n        Ray shadowray;    \n        shadowray.pos = result.pos + result.normal*0.3f;\n        shadowray.dir = normalize(g_lights[i].pos - shadowray.pos);\n        Result shadowresult=raymarch_query(shadowray, MARCH_ITERATIONS/10, 0.1);\n        float shadowdist = length(shadowresult.pos - shadowray.pos);\n        if (shadowdist < lightdist)\n        {\n            illum*=0.25f;\n        }\n        illumination+=illum;\n        specular+=spec;\n    }\n    \n    return colour*illumination + specular;\n}\n\nvec3 raymarch(Ray inputray)\n{\n    vec3 colour = vec3(0.0, 0.0, 0.0);\n    Ray ray=inputray;        \n    g_result = raymarch_query(ray, MARCH_ITERATIONS, 0.01);\n    colour = colourAt(g_result, inputray);\n            \n    return colour;    \n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\nvec3 drawlights( Ray ray )\n{   \n    float castdistance=13.0;\n    float caststep=0.1;    \n    float castscale=castdistance/caststep;\n\n    vec3 colour = vec3(0.0, 0.0, 0.0);            \n    \n    for (int i=0; i<numlights; i++)\n    {        \n        float lightdistance = length(g_lights[i].pos-ray.pos);\n        float maindistance = length(g_result.pos - ray.pos);\n        if (maindistance < lightdistance)\n            return vec3(0.0);\n        castdistance = min(castdistance, maindistance);\n\n        for (float t=0.0; t<castdistance; t+=caststep)\n        {\n            vec3 pos = ray.pos + ray.dir*t;        \n            vec3 deltapos = g_lights[i].pos-pos;\n            float d2=dot(deltapos, deltapos);\n\n            if (d2<8.0)\n            {\n                colour.xyz += g_lights[i].colour/(d2*castscale*0.9);\n            }                    \n        }\n    }\n    \n    return colour;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// main loop\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{           \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    Ray ray;\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y / iResolution.x;\n    \n    float speed = FLIGHT_SPEED;\n    float roll = 2.5;\n    float time = iTime + 49.0;\n    \n    float ft = time-1.0;\n\tvec3 p0 = vec3(3.0 - perlin(ft*0.25, 7.5)*6.0, 1.5 - perlin(ft*0.25, 8.5)*3.0, 0.0);  \n    ft+=0.5;\n\tvec3 p1 = vec3(3.0 - perlin(ft*0.25, 7.5)*6.0, 1.5 - perlin(ft*0.25, 8.5)*3.0, 0.0); \n    vec3 dir = (p1-p0) + vec3(0.0, 0.0, 4.0);\n    dir = normalize(dir);\n    vec3 up = vec3(dir.x*roll, 1.0, 0.0);\n    up = normalize(up);\n    vec3 right = cross(dir, up);\n    right = normalize(right);\n    up = cross(right, dir);\n    up = normalize(up);\n    \n    ray.pos = vec3(0.0, 0.0, time*speed) + p0;\n    ray.dir = dir*1.0 + up*uv.y + right*uv.x;\n    //ray.dir = normalize(ray.dir);\n        \n    ray.pos += ray.dir*1.0;\n    \n    g_lights[0].pos = vec3(0.0, 0.0, time*speed) + vec3(perlin(time*0.4, 2.5)*4.0-2.0, perlin(time*0.4, 3.5)*2.0-1.0, 7.0 + perlin(time*0.4, 13.5)*4.0-2.0);\n    g_lights[1].pos = vec3(0.0, 0.0, time*speed) + vec3(perlin(time*0.6, 1.5)*4.0-2.0, perlin(time*0.6, 2.5)*2.0-1.0, 7.0 + perlin(time*0.6, 11.5)*4.0-2.0);\n    \n    const float looptime = 3.0;\n    \n    float fft1 = perlin(time*0.8, 112.5)*0.25;\n    float fft2= perlin(time*0.5, 112.5)*0.25;\n    g_lights[0].colour = vec3(1.0, fft1, fft1);\n    g_lights[1].colour = vec3(fft2, fft2, 1.0);        \n    \n    fragColor.xyz = vec3(0.0);\n            \n    fragColor.xyz += raymarch(ray);  \n    fragColor.xyz += drawlights(ray);        \n}\n\n///////////////////////////////////////////////////////////////////////////////////\n", "name": "Image", "description": "", "type": "image"}]}