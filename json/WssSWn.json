{"ver":"0.1","info":{"id":"WssSWn","date":"1551061161","viewed":613,"name":"Apollonian again","username":"neozhaoliang","description":"My experiment on the 3d apollonian fractal. A hyperbolic tiling pattern appeared with this coloring scheme.","likes":15,"published":1,"flags":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA               2\n#define FOV_DIST         4.0\n#define FOLDING_NUMBER   8\n#define MAX_TRACE_STEPS  255\n#define MIN_TRACE_DIST   0.01\n#define MAX_TRACE_DIST   10.0\n#define PRECISION        1e-4\n#define PI               3.14159265358979323\n#define T                (iTime * 0.005)\n\n\n// view to world transformation\nmat3 viewMatrix(vec3 camera, vec3 lookat, vec3 up)\n{\n    vec3 f = normalize(lookat - camera);\n    vec3 r = normalize(cross(f, up));\n    vec3 u = normalize(cross(r, f));\n    return mat3(r, u, -f);\n}\n\n// 2D rotatation\nvoid R(inout vec2 p, float a)\n{\n    p = cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\n\nvec2 DE(vec3 p)\n{\n    float k, r2;\n    float scale = 1.0;\n    float orb = 1e4;\n    for (int i = 0; i < FOLDING_NUMBER; i++)\n\t{\n\t    p = 2.0 * fract(0.5 * p + 0.5) - 1.0;\n\t    r2 = dot(p, p);\n\t    k = max(1.2 / r2, 1.0);\n\t    p *= k;\n\t    scale *= k;\n        orb = min(orb, r2);\n\t}\n    return vec2(0.25 * abs(p.y) / scale,\n                0.2 + k * cos(PI * 0.5 * length(p * 12.0)) * sqrt(orb));\n}\n\nvec3 calcNormal(vec3 p)\n{\n    const vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n\t\t\t  DE(p + e.xyy).x - DE(p - e.xyy).x,\n\t\t\t  DE(p + e.yxy).x - DE(p - e.yxy).x,\n\t\t\t  DE(p + e.yyx).x - DE(p - e.yyx).x));\n}\n\nvec2 trace(vec3 ro, vec3 rd)\n{\n    float t = MIN_TRACE_DIST;\n    vec2 h;\n    for (int i = 0; i < MAX_TRACE_STEPS; i++)\n    {\n        h = DE(ro + rd * t);\n        if (h.x < PRECISION * t || t > MAX_TRACE_DIST)\n            return vec2(t, h.y);\n        t += h.x;\n    }\n    return vec2(-1.0, 0.0);\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float tmin, float tmax, float k)\n{\n    float res = 1.0;\n    float t = tmin;\n    for (int i = 0; i < 30; i++)\n    {\n        float h = DE(ro + rd * t).x;\n        res = min(res, k * h / t);\n        t += clamp(h, 0.01, 0.1);\n        if (h < 0.001 || t > tmax)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat calcAO(vec3 p, vec3 n)\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++)\n    {\n        float h = 0.01 + 0.15 * float(i) / 4.0;\n        float d = DE(p + h * n).x;\n        occ += (h - d) * sca;\n        sca *= 0.9;\n    }\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\n// https://www.shadertoy.com/view/4dSfRc\nvec3 render(vec3 ro, vec3 rd, vec3 lig)\n{\n    vec3 background = vec3(0.08, 0.16, 0.32);\n    vec3 col = background;\n    vec2 res = trace(ro, rd);\n    float t = res.x;\n    if (t >= 0.0)\n\t{\n        col = 0.5 + 0.5 * cos(2.0 * PI * res.y + vec3(0.0, 1.0, 2.0));\n\t    vec3 pos = ro + rd * t;\n\t    vec3 nor = calcNormal(pos);\n        vec3 ref = reflect(rd, nor);\n\n        float occ = calcAO(pos, nor);\n        float amb = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n        float dif = clamp(dot(nor, lig), 0.0, 1.0);\n        float bac = clamp(dot(nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0 ) * clamp(1.0 - pos.y, 0.0, 1.0);\n        float dom = smoothstep(-0.1, 0.1, ref.y);\n        float fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n        float spe = pow(clamp(dot(ref, lig), 0.0, 1.0), 16.0);\n        dif *= softShadow(pos, lig, 0.02, 5.0, 32.0);\n        dom *= softShadow(pos, ref, 0.02, 5.0, 32.0);\n\n        vec3 lin = vec3(0.5);\n        lin += 1.8 * dif * vec3(1.0, 0.8, 0.55);\n        lin += 5.0 * spe * vec3(1.0, 0.9, 0.7) * dif;\n        lin += 0.3 * amb * vec3(0.4, 0.6, 1.0) * occ;\n        lin += 0.5 * bac * vec3(0.25) * occ;\n        lin += 0.5 * dom * vec3(0.4, 0.6, 1.0) * occ;\n        lin += 0.25 * fre * vec3(1.0) * occ;\n\n        col *= lin;\n\n        float atten = 1.0 / (1.0 + t * t * 0.01);\n\t    col *= atten * occ;\n\t    col = mix(col, background, smoothstep(0.0, 0.95, t / MAX_TRACE_DIST));\n    }\n    return sqrt(col);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 tot = vec3(0.0);\n    for (int ii = 0; ii < AA; ii ++)\n\t{\n\t    for (int jj = 0; jj < AA; jj++)\n\t\t{\n\t\t    // map uv to (-1, 1) and adjust aspect ratio\n\t\t    vec2 offset = vec2(float(ii), float(jj)) / float(AA);\n\t\t    vec2 uv = (fragCoord.xy + offset) / iResolution.xy;\n\t\t    uv = 2.0 * uv - 1.0;\n\t\t    uv.x *= iResolution.x / iResolution.y;\n\t\t    vec3 camera = vec3(1.0, 0.6, 0.0);\n\t\t    vec3 lookat = vec3(0.3, 0.3, 0.3);\n\t\t    vec3 up = vec3(0.0, 1.0, 0.0);\n\t\t    // set camera\n\t\t    vec3 ro = camera;\n\t\t    R(ro.xz, T);\n\t\t    mat3 M = viewMatrix(ro, lookat, up);\n\t\t    // put screen at distance FOV_DISt in front of the camera\n\t\t    vec3 rd = M * normalize(vec3(uv, -FOV_DIST));\n\n            vec3 lig = normalize(vec3(1.0, 1.0, 0.2));\n\t\t    vec3 col = render(ro, rd, lig);\n\t\t    tot += col;\n\t\t}\n\t}\n    tot /= float(AA * AA);\n    fragColor = vec4(tot, 1.0);\n}","name":"Image","description":"","type":"image"}]}