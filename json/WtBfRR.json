{"ver": "0.1", "info": {"id": "WtBfRR", "date": "1598130732", "viewed": 71, "name": "Imitation Rothko", "username": "gunthern", "description": "An imitation Mark Rothko, for Book of Shaders ch. 11.", "likes": 2, "published": 1, "flags": 0, "tags": ["painting"], "requires": ["imagebuf"]}, "renderpass": [{"inputs": [], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "// 2D Random\nfloat random (in vec2 _uv) {\n    return fract(sin(dot(_uv.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _uv) {\n    vec2 i = floor(_uv);\n    vec2 f = fract(_uv);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat block( in vec2 _uv, in float _edge, in vec2 _size, in vec2 _pos ) \n{\n    _size = vec2(.5) - _size*.5;\n    _uv -= _pos;\n    vec2 uv = smoothstep (_size, _size+vec2(_edge), _uv);\n    uv *= smoothstep (_size, _size+vec2(_edge), vec2(1.0)-_uv);\n    return uv.x * uv.y;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    //color blocks\n    float block0 = block(uv, 0.04, vec2(1.01,0.2), vec2(0.0,-0.4));\n    block0 = floor(block0 + noise(uv*500.));\n    block0 *= clamp(noise(uv*500.),.6,.7) + .3;\n    \n    float block1 = block(uv, 0.06, vec2(1.,0.475), vec2(0.0,-0.075));\n    block1 = floor(block1 + noise(uv*900.));\n    block1 *= clamp(noise(vec2(uv.x*500.,uv.y*200.)),.45,0.6) + .4;\n    \n    float block2 = block(uv, 0.05, vec2(1.01,0.13), vec2(0.0,0.21));\n    block2 = floor(block2 + noise(uv*400.));\n    block2 *= clamp(noise(uv*500.),.6,.7) + .3;\n    \n    float block3 = block(uv, 0.028, vec2(.99,0.22), vec2(0.0,0.38));\n    block3 = floor(block3 + noise(uv*300.));\n    block3 *= clamp(noise(vec2(uv.x*600.,uv.y*200.)),.56,.7) + .3;\n    \n    \n    //combine\n    vec3 col = vec3(noise(uv*600.)*.05 + 0.1);\n    col -= vec3(block0);\n    col = clamp(col,0.,1.);\n    col += vec3(block0*.54, block0*.49, block0*.9);\n    col -= vec3(block1);\n    col = clamp(col,0.,1.);\n    col += vec3(block1*.25,block1*.34,block1*.47);\n    col -= vec3(block2);\n    col = clamp(col,0.,1.);\n    col += vec3(block2*.85,block2*.34,block2*.27);\n    col -= vec3(block3);\n    col = clamp(col,0.,1.);\n    col += vec3(block3*.4,block3*.47,block3*.73);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "name": "Image", "description": "", "type": "image"}]}