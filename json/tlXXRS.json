{"ver":"0.1","info":{"id":"tlXXRS","date":"1563334098","viewed":316,"name":"Smooth 1-Bit Isosurfaces","username":"paniq","description":"Sampling a 1-bit volume and integrating 8x8 values into a density value with resolution 1/64, then using biquadratic interpolation to compute the isosurface and surface gradient.","likes":6,"published":3,"flags":32,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 weight(vec3 p) {\n    return vec3(\n\t\t(p[0]+p[1])*0.5,\n        p[1],\n        (p[1]+p[2])*0.5);\n}\n\nvec3 b2(float x) {\n    float rx = 1.0 - x;\n\treturn vec3(rx*rx, 2.0*rx*x, x*x);\n}\n\nvec3 b2d(float x) {\n    float x2 = 2.0 * x;\n\treturn vec3(x2 - 2.0, 2.0 - 4.0 * x, x2);\n}\n\nfloat interpolate2d(mat3 p, vec3 s, vec3 t) {\n    vec3 q = vec3(\n    \tdot(weight(p[0]), s),\n    \tdot(weight(p[1]), s),\n    \tdot(weight(p[2]), s));\n    \n\treturn dot(weight(q), t);\n}\n\nvec3 interpolate2d_grad(mat3 p, vec2 o) {\n    vec3 s2 = b2(o.x);\n    vec3 t2 = b2(o.y);\n    vec3 s1 = b2d(o.x);\n    vec3 t1 = b2d(o.y);\n    return\n        vec3(\n            interpolate2d(p, s1, t2),\n            interpolate2d(p, s2, t1),\n        \tinterpolate2d(p, s2, t2));\n}\n\nfloat interpolate2d(mat3 p, vec2 o) {\n    vec3 s = b2(o.x);\n    vec3 t = b2(o.y);\n    return interpolate2d(p, s, t);\n}\n\nfloat fetch(ivec2 uv) {\n    int count = 0;\n    for (int y = 0; y < 8; ++y) {\n        for (int x = 0; x < 8; ++x) {\n\t\t    float d = texelFetch(iChannel0, uv * 4 + ivec2(x,y), 0).x;\n            if (d > 0.5) {\n                count++;\n            }\n\t\t}\n    }\n    float d = float(32 - count) / 32.0;\n    return d;\n}\n\nvec3 samplef(vec2 uv) {\n    vec2 suv = uv / 4.0;\n    vec2 n = floor(suv);\n    vec2 f = fract(suv);\n    \n    ivec2 iuv = ivec2(n + 0.5);\n    mat3 p;\n    for (int i = 0; i <= 2; ++i) {\n        for (int j = 0; j <= 2; ++j) {\n            float col = fetch(iuv + ivec2(i-1,j-1));\n            p[j][i] = col;\n        }\n    }\n    \n    return interpolate2d_grad(p, f);\n}\n\nvec4 sample_biquadratic(sampler2D channel, vec2 res, vec2 uv) {\n    vec2 q = fract(uv * res);\n    vec2 c = (q*(q - 1.0) + 0.5) / res;\n    vec2 w0 = uv - c;\n    vec2 w1 = uv + c;\n    vec4 s = texture(channel, vec2(w0.x, w0.y))\n    \t   + texture(channel, vec2(w0.x, w1.y))\n    \t   + texture(channel, vec2(w1.x, w0.y))\n    \t   + texture(channel, vec2(w1.x, w1.y));\n\treturn s / 4.0;\n}\n\n// accurate analytical gradient with 8 taps\nvec2 sample_biquadratic_gradient(sampler2D channel, vec2 res, vec2 uv) {\n    vec2 q = fract(uv * res);\n    vec2 c = (q*(q - 1.0) + 0.5) / res;\n    vec2 w0 = uv - c;\n    vec2 w1 = uv + c;\n    vec2 cc = 0.5 / res;\n    vec2 ww0 = uv - cc;\n    vec2 ww1 = uv + cc;\n    float nx0 = texture(channel, vec2(ww1.x, w0.y)).r - texture(channel, vec2(ww0.x, w0.y)).r;\n    float nx1 = texture(channel, vec2(ww1.x, w1.y)).r - texture(channel, vec2(ww0.x, w1.y)).r;\n    \n    float ny0 = texture(channel, vec2(w0.x, ww1.y)).r - texture(channel, vec2(w0.x, ww0.y)).r;\n    float ny1 = texture(channel, vec2(w1.x, ww1.y)).r - texture(channel, vec2(w1.x, ww0.y)).r;\n    \n\treturn vec2(nx0 + nx1, ny0 + ny1) / 2.0;\n}\n\n// approximate analytical gradient with 4 taps\nvec2 sample_biquadratic_gradient_approx(sampler2D channel, vec2 res, vec2 uv) {\n    vec2 q = fract(uv * res);\n    vec2 cc = 0.5 / res;\n    vec2 ww0 = uv - cc;\n    vec2 ww1 = uv + cc;\n    float nx = texture(channel, vec2(ww1.x, uv.y)).r - texture(channel, vec2(ww0.x, uv.y)).r;\n    float ny = texture(channel, vec2(uv.x, ww1.y)).r - texture(channel, vec2(uv.x, ww0.y)).r;\n\treturn vec2(nx, ny);\n}\n\n// from: beyond trilinear interpolation\nvec3 samplef2(vec2 position) {\n\tfloat d = sample_biquadratic(iChannel0, iChannelResolution[0].xy, position).r;\n    vec2 n = sample_biquadratic_gradient_approx(iChannel0, iChannelResolution[0].xy, position);\n    return vec3(n, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //fragCoord = fragCoord * 0.25 + vec2(300.0, 240.0);\n    fragCoord = fragCoord * 0.4 + vec2(300.0, 170.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 d;\n    if (uv.x < -0.2) {        \n\t    d = vec3(texelFetch(iChannel0, ivec2(fragCoord), 0).x);\n    } else {\n        vec3 c = samplef2(fragCoord.xy / iResolution.xy).xyz;\n        vec2 n = -normalize(c.xy);\n        d = (1.0 - (abs(c.z - 0.5)*2.6*2.0)) * vec3(n*0.5+0.5,0.0);\n        //d = vec3(n*0.5+0.5, 0.0);\n    }    \n    \n    fragColor = vec4(d,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float sdBox( vec2 p, vec2 b ) {\n  vec2 d = abs(p) - b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec2 anglevec(float a) {\n    return vec2(cos(a),sin(a));\n}\n\nvoid rotate(inout vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    p = vec2(\n        c * p.x - s * p.y,\n        s * p.x + c * p.y\n        );\n}\n\nfloat mapf(vec2 p) {\n    float d0 = length(p) - 0.4;\n    float d1 = length(p - vec2(0.3, -0.1)) - 0.4;\n    float d2 = length(p - vec2(0.1, mix(0.1,0.3,sin(iTime*0.2)*0.5+0.5))) - 0.1;\n    \n    //p -= vec2(0.5);\n    rotate(p, radians(iTime*10.0));\n        \n    float d3 = sdBox(p - vec2(0.0, -0.45), vec2(0.25,0.05));\n    float d4 = sdBox(p, vec2(2.0/64.0,0.3));\n    \n    float r = radians(iTime*5.0);\n    float d5 = dot(p, anglevec(r));\n    float d6 = dot(p, anglevec(-r-radians(90.0)));\n    \n    float d = min(d2, max(d0, -d1));\n    return min(d, d3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //fragCoord -= mod(fragCoord, 2.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float d = mapf(uv);\n    //d = (d<=0.0)?1.0:0.0;\n    d = clamp(0.5 - d*iResolution.y/4.0, 0.0,1.0);\n    \n    fragColor = vec4(vec3(d),1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}