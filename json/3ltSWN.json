{"ver":"0.1","info":{"id":"3ltSWN","date":"1580961186","viewed":59,"name":"Pond Simple","username":"JackSolace","description":"Basic Raymarch of a Pond","likes":4,"published":1,"flags":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Carter S. Jan 2020\n//Basic Raymarch of a Pond\n//\n\n\n\n//Cubic smooth minimum union function from user TinyTexel\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n//distance to plane\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\n//Plane but with pebble heightmap\nfloat sdTerrain(vec3 p, vec4 n)\n{\n\tfloat to_plane = sdPlane(p,n);\n    float to_pebble = texture(iChannel1,p.xz).x*0.2;//play with pebble max height\n    return to_plane - to_pebble;\n}\n\n//This function grows with more objects and operations (unions, distortions, perturbations, ect)\n//This is usually where acceleration structures and ad hoc hackery goes down\n//x  index is distance, y index is material type (sometimes other meta info)\nvec2 map_the_world(in vec3 p)\n{\n    \n\t//Plane is represented as a vec4 using ax+by+cz+w = 0 formulation\n    float to_ground = sdPlane(p, normalize(vec4(0.0,1.0,0.0,0.3)));\n    float to_rock = sdTerrain(p, normalize(vec4(0.0,1.0,0.0,0.3)));\n    float to_water = abs(sdPlane(p, normalize(vec4(0.0,1.0,0.0,0.0))));\n    if (to_water < to_rock) {//early quit since we expect to be closest to water often\n        return vec2(to_water,2.0);\n    }\n    //Rocks at the bottom of the pond\n    float pebble_start = 0.45;//play with this range(0.0,1.0)\n    float mat = 0.0;\n    float height = texture(iChannel1, p.xz*0.15).x;\n    if (height > pebble_start){//using pebbles to decide where pebbles are lol (play with numbers)\n        //change mat\n        float prop = height-pebble_start;\n        //nonlinear interp between ground and rocks to make sure it looks like they touch (rocks dont get cut off) \n        to_ground = mix(to_ground,to_rock,1.0 - (1.0/pow(prop+1.0,8.0)));\n    \tmat = 1.0;\n    }\n    \n    return vec2(to_ground,mat);\n}\n\n\n//Find the normal of the surface at this point P\nvec3 calculate_normal( in vec3 pos)\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map_the_world( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map_the_world( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map_the_world( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map_the_world( pos + e.xxx ).x );  \n}\n\nvec2 march_ray(vec3 ray_origin, vec3 ray_direction, float tmax) {\n\tfloat t = 0.0;//current depth\n    float m = 0.0;\n    for( int i=0; i<256; i++ )\n    {\n        vec3 pos = ray_origin + t*ray_direction;\n        //get dist to nearest surface\n        vec2 h = map_the_world(pos);\n        m = h.y;\n        //if we hit something break\n        if( h.x<0.0001 || t>tmax ) return vec2(t,m);\n        //step forward\n        t += h.x;\n    }\n    return vec2(t,m);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n\tvec3 ray_origin = vec3( 1.0*cos(an), 0.4, 1.0*sin(an) );\n    vec3 origin = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix (for ease of animation)\n    vec3 ww = normalize( origin - ray_origin );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    //initialize color\n    vec3 total = vec3(0.0);\n    \n \t//what pixel are we marching through\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n\n\t// create view ray\n    vec3 ray_direction = normalize( p.x*uu + p.y*vv + 1.5*ww );\n    \n\n    // raymarch\n    const float tmax = 4.0; //max march depth\n    vec2 res = march_ray(ray_origin,ray_direction,tmax);\n    float t = res.x;\n    \n     // ambient + diffuse light color calculations\n     vec3 color = vec3(0.0);\n     if( t<tmax )\n     {//we hit something\n        vec3 pos = ray_origin + t*ray_direction;\n        //break up the surface normal\n        vec3 normal = calculate_normal(pos) + vec3(0.2*texture(iChannel3,1.0*pos.xz));//play with values\n        //get the refracted ray direction\n        vec3 ref_dir = refract(ray_direction, normal, 1.0/1.33);\n        vec3 refract_color = vec3(0.0);\n        vec3 water_color = vec3(0.0,0.3,0.4);\n        vec3 reflect_color = pow(texture(iChannel0, reflect(ray_direction, normal)).rbg, vec3(2.2));\n        res = march_ray(pos + ref_dir*0.001, ref_dir, tmax);\n        t = res.x;\n        float m = res.y;\n         \n        if( t<tmax )\n     \t{\n            pos = (pos + ref_dir*0.001) + t*ref_dir;\n            \n        \tif(m < 1.0) {//is dirt area\n             \trefract_color = texture(iChannel2, pos.xz*1.0).rgb;\n        \t}else{//is rock area\n            \tfloat rock_val = texture(iChannel1,pos.xz).x;\n            \tif (rock_val <0.25){//get some dirt in between rocks (play with this value)\n             \t\trefract_color =  texture(iChannel2, pos.xz*1.0).rgb;\n            \t}else{\n                    //rock color (grey whoda thunk it)\n         \t\t\trefract_color = vec3(0.8*rock_val);\n            \t}\n        \t}\n        }else{\n        \trefract_color = pow(texture(iChannel0, ref_dir).rgb, vec3(2.2));\n        }\n        //combine all effects\n        color = refract_color*0.4 + water_color*0.3 + reflect_color*0.25;//play with the combo\n     }else{//missed pond hit background\n     \tcolor = pow(texture(iChannel0, ray_direction).rgb, vec3(2.2));\n     }\n\n     // gamma color calculation    \n     color = sqrt( color );\n\t total += color;\n\n\t fragColor = vec4( total, 1.0 );\n}","name":"Image","description":"","type":"image"}]}