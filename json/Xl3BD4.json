{"ver":"0.1","info":{"id":"Xl3BD4","date":"1539592144","viewed":630,"name":"pmod quantize chord tartan","username":"ollj","description":"pause time andrag mouse to set AABV corners\n\nprogress on fixing [spartial folding of chords in 4d] of\nhttps://www.shadertoy.com/view/XtdfDH\nwith\nhttps://www.shadertoy.com/view/lsffDM\nis slow but significant\ni did not expect quantum physics to be relevant.","likes":6,"published":3,"flags":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//three voice harmony minor major chord (old)\n//parent: https://www.shadertoy.com/view/lsffDM \n//parent: https://www.shadertoy.com/view/XtdfDH\n/*\nmaking 2 dots at start and end of a line, set by mouse.\nmaking 3rd dot at half way point.\nfloor the points with flc() to get minor or major chords.\n*/\n\n/*\nI thought of a rather simple way to represent longer chords, \nascending and descending melodies.\n\nthis is the simple more constrained approach, only 3 dots.\nsolve a special case BEFORE trying a general case!\n\nThe reason why tesselation of music pitches works is\n...because we fail do distinguish hiigher resolutions of pitches.\nBlack piano keys ARE Moire ARE aliasing:\nhttps://en.wikipedia.org/wiki/Aliasing\nhttps://en.wikipedia.org/wiki/Moir%C3%A9_pattern\n*/\n\n\n/*\na problem suupoptimal case i keep running into is\na sequence of notes on a sheet \n...that are pretty much an ascending or descending line.\nof 4 to 8 notes.\n\ni want a very general case to check \nif(at time [t] note [n] exists in pith [y]) \nfor a linear equation of notes.\nto be checked AFTER applying a floor() tesselation.\nvia pModInterval1() of \nhttp://mercury.sexy/hg_sdf/\n\nthe same can also floor(pModInterval1()) \nto tell which of every 12 piano keys are black.\n*/\n\n#define u5(a) ((a)*.5+.5)\n\n#define vec1 float\n//red circle radius\n#define radius 1.\n//blur of all the lines\n#define hl2 min(iResolution.x,iResolution.y)\n#define viewZoom mix(9.,hl2,u5(-cos(cos(iTime))))\n#define hl (viewZoom/hl2)\n#define fra(u) (u-.5*iResolution.xy)*viewZoom/iResolution.y\n\nfloat ss(vec1 a,vec2 b){return smoothstep(b.x,b.y,a);}\nvec2  ss(vec2 a,vec2 b){return smoothstep(b.x,b.y,a);}\nfloat ss(vec1 a){return ss(a,vec2(1,-1)*hl);}\nvec2  ss(vec2 a){return ss(a,vec2(1,-1)*hl);}\n\n//return distance of [u] to line srgment from [a] to [b]\nfloat Segment(vec2 p,vec2 a,vec2 b){p-=a;b-=a;\n a.x=clamp(dot(p,b)/dot(b,b),0.,1.);return length(p-b*a.x);}\n\n////ss2t(a) changes a seesaw waves output (range [0..1]) to a triangle wave.\n#define ss2t(a) a=abs(a*2.-1.)\n//floor offset,centred \n#define flc(a) floor(a+.5)\n\n//return square tesselaion grod for [u]fragmentPos\nfloat grid(vec2 u){u=fract(u);u=ss2t(u);float r=1.-min(u.x,u.y);\n return smoothstep(hl,-hl,abs(r-1.)-hl);}\n\n//domain-general pmod():\n#define pMOD(d,e) d e(inout d a,d b){d c=floor((a/b)+.5);a=(fract((a/b)+.5)-.5)*b;return c;}\npMOD(vec1,pmod)pMOD(vec2,pmod)pMOD(vec3,pmod)pMOD(vec4,pmod)\n    //repetitive only for less repetitive legacy namespace support.\n\n//because this shader scales and rounds (translates) one invertal into another (quantized) inverval:\n//it takes an excursion into; Maxwellian dimensional relativism:\n#define dd(a) dot(a,a)\n//step 0, the dotproduct of a vector and itself ==dd(a)==is a length*length of the vector.\n//it doesnt matter much what unit you measure distance|length in, what matters is that:\n//step 1, realize that length(a-b)=length(b-a)=sqrt(dd(a-b))=sqrt(dd(b-a))=distance(a,b)=distance(b,a)\n//step 2, the sqrt((a-b)) implies differential calculus:\n//sorting equations like this evades a bias to [systems of length] ie, metric systrems.\n//how often you divide a length by /second\n//, defines what [time-integral of displacement];[length over time] you are calculating in\n//Drop        =length/second/second/second/second/second/second/second/second\n//Lock        =length/second/second/second/second/second/second/second\n//Pop         =length/second/second/second/second/second/second\n//Crackle     =length/second/second/second/second/second\n//jounce      =length/second/second/second/second\n//jerk        =length/second/second/second\n//acceleration=length/second/second\n//velocity    =length/second\n//Displacement=length                        https://en.wikipedia.org/wiki/Displacement_(vector)\n//Absement    =length*second                 https://en.wikipedia.org/wiki/Absement\n//Absity      =length*second*second    \n//Abseleration=length*second*second*second    \n//Abserk      =length*second*second*second*second    \n//Absounce    =length*second*second*second*second*second     \n\n//the fun part of this shader is that it easily extends into 4d\n//, so you can scale (and quantize) a displacement, velocity, an accelleration, and a jerk in one vec4()\n//, useful for [automatic differentiation] shaders?\n\n//length*kilogram is newtonian:\n//newton = kilogram*       length/second/second                  =       kilogram*acceleration\n//joule  = kilogram*length*length/second/second == length*newton =length*kilogram*acceleration\n\n#define coVelEm 2.99792458e8\n#define lightspeed coVelEm\n//commonly known as \"speed of light\" or \"c\"; in in length/second==velocity\n//a better term would be [Electromagnetic velocity]\n//this is a maximum velocity in a vacuum. Usually a straight direct path is obstructed by mass\n//, cuvring spacetime, deforming a straight and shootrest path into a longer line.\n//Without a maximum velocity, causality over time is nonlinear/discontinuous.\n#define coPlanck 6.62607004e-34\n//smallest EM-observable quantity, smallest physically EM-percievable interval \n//;in joule*second==newton*length*second==length*length*kilogram/second/second == length*kilogram*acceleration\n//==length*kilogram*acceleration\n#define coPlanckR (coPlanck/pi/2.)\n//==1.0545718e-34\n//\"reduced PlanckConstant\" is a common scalar, where EM interferrences are about [fourier butterflies]\n//this involves the issue of [squaring an (epi)circle], within limited resolution of DFT|FFT\n#define coGravity 6.674e-11\n//gravitational constant; in newton/kilogram/kilogram/length/length\n//spacetime curvature over inverse_squared_distance to mass\n//gravity is not a force, but an effect of curving spacetime, poportional to squared mass and inverse squared distance.\n//you can model gravity as if it is a force, but that model will not be relativistic.\n#define coPlanckT sqrt(coPlanckR*coGravity/coVelEm/coVelEm/coVelEm/coVelEm/coVelEm)\n//PlanckTime; smallest EM-ovservavle interval over time\n//;5.3911252e-44 == sqrt(1.0545718e-34*6.674e-11/2.99792458e8/2.99792458e8/2.99792458e8/2.99792458e8/2.99792458e8)\n//minimum time that information takes to traverse length(coPlanck) in coMaVelEm\n//whilst smaller units of time can exist, they are so small their effect on our existence is negligible\n#define planckT .0001    \n//smallest measurable distance to an asymptote\n//smallest measurable angle between 1 non-parallel lines\n//smallest feasible epsilon, regardles of contextual scaling, to evade divisions by 0.\n//an ideall model defines planck==coPlanckT or planck=coPlanck, depending on context of your model\n//, but 32bit float precision is not good enough for this.\n//so we chose to scale our model resolution down significantly, with less addressSpace/precision\n\n////\n    // PlanckLengt/PlanckTime =coMaxSpeed\n    \n    \n//[u]FragmentPos, [m]=start [n]=end\nvec3 tripplet(vec2 u, vec2 m, vec2 n\n){//m=vec2(0)//debug overwrite to a null-offset\n ;vec3 r=vec3(0)\n ;r.z=Segment(u,m,n)\n ;//u-=m\n ;float d=length(m-u)\n      ,e=length(n-u)\n      ,f=length(n+m-u*2.)*.5;\n ;r.x=min(min(d,e),f);\n ;float t=0.;\n ;m=floor(m+.5)\n ;n-=m;u-=m//offset by m\n \n ;float fraction=3. //this splits in thirds, and any other value is fine!\n ;fraction=max(fraction,1.+planckT)\n //the \"fraction of an interval\" is a confucing term\n //, simple if you assert half-open intervals for below function\n //, while a chord of 3 keys is a clodes interval, and the difference is [-=1.]\n ;vec2 a=floor(u+.5),b=(n)/(fraction-1.)//modulate pmod inputs\n ;b=max(vec2(1),abs(b))//contextually worksave agaisntdividing by values <1\n ;u=(fract((a/b)+.5)-.5-planckT)*b//pmod fractional part\n ;u=floor(u+.5)\n ;//if(all(equal(abs(u),vec2(0))))r.y+=.4;//oversimplified dots\n ;//if(any(equal(abs(u),vec2(0))))r.y+=.2;//oversimplified crosses     \n ;if(all(lessThan(abs(u),vec2(planckT))))r.y+=.4;//dots\n ;if(any(lessThan(abs(u),vec2(planckT))))r.y+=.2;//crosses\n\n ;//vec3 r=vec3(d,t,)\n ;r.xz=ss(abs(r.xz-radius*vec2(1,.2))-hl);\n ;return r;}\n\nvec2 cs(float a){return vec2(cos(a),sin(a));}\n\nvoid mainImage(out vec4 O,in vec2 U\n){vec3 c=vec3(0)\n ;vec2 u=fra(U)\n ;vec2 m=fra(iMouse.zw);//start of holding mouse\n ;vec2 n=fra(iMouse.xy);//current mouse pos held\n ;if(iMouse.z<=0.\n ){n=vec2(.0)\n  ;vec2 rr=viewZoom*vec2(.3,.1)//.x is average radius .y is distance from averate\n  ;n=cs(iTime*.61).yx*(rr.x-rr.y)\n  ;m=cs(iTime    )   *(rr.x+rr.y)\n  ;c.xy+=.2*ss(abs(abs(length(u)-rr.x)-rr.y)-viewZoom*.5/hl2)//yellow circles show path of red dots\n  ;}\n ;c+=tripplet(u,m,n)//core function, dodo split in 3 parts.\n ;c+=grid(u)*.2;// greyscale grid    \n ;O=vec4(c,1.)\n ;}","name":"Image","description":"","type":"image"}]}