{"ver":"0.1","info":{"id":"tsVfW3","date":"1608147069","viewed":147,"name":"Blur Brush","username":"me_123","description":"please Comment improvements/Cool things that you make with this. \nbuffer A has the input data;\nbuffer B has the conventional filter and state;\nImage just draw buffer B.\nI am planning on making a neural network that can recolonize text and shapes and stuf.","likes":3,"published":3,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float hash(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat hash3(vec3 pp) {\n    vec2 p = pp.xy+(pp.z/100.);\n\treturn fract(sin(dot(p.xy, vec2(12.9898, 78.233)))*43758.5453);\n}\nfloat nois( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash3(i+vec3(0,0,0)), \n                        hash3(i+vec3(1,0,0)),f.x),\n                   mix( hash3(i+vec3(0,1,0)), \n                        hash3(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash3(i+vec3(0,0,1)), \n                        hash3(i+vec3(1,0,1)),f.x),\n                   mix( hash3(i+vec3(0,1,1)), \n                        hash3(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy;\n    vec4 colr;\n    if (!(fragCoord.x < mouse.x || fragCoord.y < mouse.y || fragCoord.x-20. > mouse.x || fragCoord.y-20. > mouse.y)) {\n        vec2 uv = (iMouse.xy/iResolution.xy);\n        vec3 color = vec3(hash(uv), hash(uv+1.), hash(uv+2.));\n        colr = vec4(color, 1);\n    }\n    if (iMouse.z < 1.0) {\n        vec2 uv = (fragCoord.xy/iResolution.xy)-0.5;\n        uv.x *= iResolution.x/iResolution.y;\n        float frame = float(iFrame)/100.;\n        float speed  = cos(frame/2.)*10.;\n        vec2 pos = (vec2(sin(frame*speed), cos(frame*speed))*sin((frame*speed)/2.))/2.;\n        float SDF = length(uv-pos)-0.05;\n        if (SDF < 0.0) {\n            if (mod(frame, 3.) < 1.5) {\n                colr = vec4(vec3(2.0), 1);\n            } else {\n                colr = vec4(vec3(0.0, -0.5, -1.0), 1);\n            }\n        }\n    }\n    fragColor = colr;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec3 getPixel(vec2 p) {\n    p /= iResolution.xy;\n    return texture(iChannel1, p).xyz;\n}\nvec3 getColor(vec2 p) {\n    int size = 3;\n    float filt[9];\n    filt[0] = 0.33;\n    filt[1] = 0.33;\n    filt[2] = 0.33;\n    filt[3] = 0.33;\n    filt[4] = 0.33;\n    filt[5] = 0.33;\n    filt[6] = 0.33;\n    filt[7] = 0.33;\n    filt[8] = 0.33;\n    vec3 c = vec3(0);\n    for (int x = 0; x < size; x += 1) {\n        for (int y = 0; y < size; y += 1) {\n            float xx = float(x)-float(size)/2.;\n            float yy = float(y)-float(size)/2.;\n            int index = x+(y*size);\n            c += getPixel(p+vec2(floor(xx)+1., floor(yy)+1.))*filt[index];\n        }\n    }\n    return c*0.33333;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0);\n    vec4 sf = texture(iChannel0, uv);\n    col = getColor(fragCoord);\n    if (iFrame != 0) {\n        fragColor = vec4(col,1.0);\n    } else {\n        fragColor = sf;\n    }\n    if (sf.w != 0.) {\n        fragColor = sf;\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}