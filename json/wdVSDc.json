{"ver": "0.1", "info": {"id": "wdVSDc", "date": "1575520451", "viewed": 275, "name": "sofake", "username": "cmarangu", "description": "wip... 2020 1/17", "likes": 9, "published": 3, "flags": 0, "tags": ["lake", "snowflake"], "requires": ["imagebuf"]}, "renderpass": [{"inputs": [], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "\n\n\n\n// TODO\n// - use digits of number as array (hard but super awesome)\n// - or just use nested for-loops\n// to traverse binary tree ignoring \"other side\" branches each iter\n// figure out what \"level\" using floor(log_2(y))\n\n\n\n\n \n\n#define debuglines 0\n\n\n\n// i know more\n#define PI 3.1415926535897932384626433832795028841971693993751058209749\n#define TAU (PI*2.)\n\n#define arg mod(float(iFrame)/60./6., 1.)\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n    vec2 q = (fragCoord.xy-iResolution.xy/2.)/iResolution.y*2.;\n    float SDFp = 1e6;\n    float scalene = 1.;\n    \n    // weird slice morphthingy\n    //float qyx = atan(q.y, q.x)+rot+iTime*PI*.1;\n    float th = mod(atan(q.y, q.x)+arg*TAU/6., TAU/6.)+arg*TAU/6.;\n    float r = length(q);\n    q.x = r*cos(th);\n    q.y = r*sin(th);\n    \n    // rotate to make 6 branch from 1\n    th = mod(atan(q.y, q.x)+arg*TAU/6., TAU/6.)+PI*.5-PI*.5/3.;\n    r = length(q)*2.;\n    q.x = r*cos(th);\n    q.y = r*sin(th);\n    \n    // recursion\n    for (int i=0; i<10; ++i) {\n        q.x = abs(q.x);\n        // top branch\n        if ((q.y-.9)-q.x*.4+.1 > 0.) {\n            q.y -= .9;\n            q *= 1.6;\n            scalene *= 1.6;\n        }\n        // left and right branches\n        else if (q.x > .04) {\n            q.x -= .03;\n            q.y -= .23;\n            float qyx = atan(q.y, q.x)+PI*.27;\n            float qyxr = length(q);\n            q.x = qyxr*cos(qyx);\n            q.y = qyxr*sin(qyx);\n            // q.y -= .2;\n            q *= 3.;\n            scalene *= 3.;\n        }\n    }\n    \n    \n    // rounded rect\n    q.y -= .46;\n    q = abs(q);\n    q = max(q-vec2(.0, .4), 0.);\n    SDFp = min(SDFp, length(q)-.02);\n    // distance scaling correction\n    SDFp /= scalene;\n    \n    \n    \n    // rendering\n    vec3 retina;\n    if (SDFp <= 0.) {\n        retina = vec3(1.);\n    }\n    else {\n        retina = mix(\n            vec3(0., 1., 1.),\n            vec3(0., 0., 100./255.),\n            clamp(pow(SDFp, .2), 0., 1.)\n        );\n        #if debuglines\n        \tif (mod(SDFp-iTime*.1, .1) < .01) {\n            \tretina = mix(retina, vec3(0., 0., 0.), .4);\n            }\n        \t// if (mod(atan(dFdy(SDFp),dFdx(SDFp)), .25)<.05 && SDFp > .25) {\n            // \tretina = mix(retina, vec3(0., 0., 0.), .4);\n            // }\n        #endif\n        // retina = vec3(0.);\n    }\n    fragColor = vec4(retina, 1.);\n    \n}\n/**/\n", "name": "Image", "description": "", "type": "image"}]}