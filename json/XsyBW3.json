{"ver": "0.1", "info": {"id": "XsyBW3", "date": "1530676738", "viewed": 175, "name": "Display TRC Graph", "username": "Tynach", "description": "This shader provides a visualization for the conversion from the transfer characteristics (TRC) of one display, to the TRC of another display. It defaults to converting linear light into sRGB.", "likes": 1, "published": 1, "flags": 0, "tags": ["character", "char"], "requires": ["imagebuf"]}, "renderpass": [{"inputs": [], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "/*\n * Structures\n */\n\n// Parameters for transfer characteristics (gamma curves)\nstruct transfer {\n\t// Exponent used to linearize the signal\n\tfloat power;\n\n\t// Offset from 0.0 for the exponential curve\n\tfloat off;\n\n\t// Slope of linear segment near 0\n\tfloat slope;\n\n\t// Values below this are divided by slope during linearization\n\tfloat cutoffToLinear;\n\n\t// Values below this are multiplied by slope during gamma correction\n\tfloat cutoffToGamma;\n};\n\n// Automatically calculate the slope and cutoffs for transfer characteristics\n#define Transfer(po, of)\\\ntransfer(\\\n\t(po),\\\n\t(of),\\\n\t(pow((po)*(of)/((po) - 1.0), 1.0 - (po))*pow(1.0 + (of), (po)))/(po),\\\n\t(of)/((po) - 1.0),\\\n\t(of)/((po) - 1.0)*(po)/(pow((po)*(of)/((po) - 1.0), 1.0 - (po))*pow(1.0 + (of), (po)))\\\n)\n\n\n/*\n * Gamma curve parameters\n */\n\n// Gamma of 1.0; linear light\nconst transfer gam10 = transfer(1.0, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 1.8; Approximately what old Apple computers used\nconst transfer gam18 = transfer(1.8, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.2; not linear near 0. Was defined abstractly to be used by early\n// NTSC systems, before SMPTE 170M was modified to specify a more exact curve\nconst transfer gam22 = transfer(2.2, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.4; not linear near 0. Seems a popular choice among some people\n// online, so I included it. I don't think any standard uses this\nconst transfer gam24 = transfer(2.4, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.5; not linear near 0. Approximately what old Sony TVs used\nconst transfer gam25 = transfer(2.5, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.8; not linear near 0. Loosely defined gamma for European SDTV\nconst transfer gam28 = transfer(2.8, 0.0, 1.0, 0.0, 0.0);\n\n// Modern SMPTE 170M, as well as Rec. 601, Rec. 709, and a rough approximation\n// for Rec. 2020 content as well. Do not use with Rec. 2020 if you work with\n// high bit depths!\nconst transfer gam170m = transfer(1.0/0.45, 0.099, 4.5, 0.0812, 0.018);\n\n// Gamma for sRGB. Besides being full-range (0-255 values), this is the only\n// difference between sRGB and Rec. 709.\nconst transfer gamSrgb = transfer(2.4, 0.055, 12.92, 0.04045, 0.0031308);\n\n// Gamma for the CIE L*a*b* Lightness scale\nconst transfer gamLab = transfer(3.0, 0.16, 243.89/27.0, 0.08, 216.0/24389.0);\n\n\n/*********************************************************\n * Settings - Change these to adjust the displayed curve *\n *********************************************************/\nconst transfer gamFrom = gam10;\nconst transfer gamTo = gamSrgb;\n\n// Display gamma (for gamma correct antialiasing)\nconst transfer gamDisp = gamSrgb;\n\n\n/*\n * Conversion Functions\n */\n\n// Converts RGB colors to a linear light scale\nvec3 toLinear(vec3 color, const transfer trc)\n{\n\tbvec3 cutoff = lessThan(color, vec3(trc.cutoffToLinear));\n\tbvec3 negCutoff = lessThanEqual(color, vec3(-1.0*trc.cutoffToLinear));\n\tvec3 higher = pow((color + trc.off)/(1.0 + trc.off), vec3(trc.power));\n\tvec3 lower = color/trc.slope;\n\tvec3 neg = -1.0*pow((color - trc.off)/(-1.0 - trc.off), vec3(trc.power));\n\n\tcolor = mix(higher, lower, cutoff);\n\treturn mix(color, neg, negCutoff);\n}\n\n// Gamma-corrects RGB colors to be sent to a display\nvec3 toGamma(vec3 color, const transfer trc)\n{\n\tbvec3 cutoff = lessThan(color, vec3(trc.cutoffToGamma));\n\tbvec3 negCutoff = lessThanEqual(color, vec3(-1.0*trc.cutoffToGamma));\n\tvec3 higher = (1.0 + trc.off)*pow(color, vec3(1.0/trc.power)) - trc.off;\n\tvec3 lower = color*trc.slope;\n\tvec3 neg = (-1.0 - trc.off)*pow(-1.0*color, vec3(1.0/trc.power)) + trc.off;\n\n\tcolor = mix(higher, lower, cutoff);\n\treturn mix(color, neg, negCutoff);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 coord)\n{\n\tfloat offset = 1.0;\n\n\t// Center resulting value range to be evenly distributed when\n\t// flooring the resulting color values to the next lowest 8-bit int\n\tcoord = floor(coord);\n\n\tvec2 maxCoord = iResolution.xy - 1.0;\n\tvec2 uv = coord/maxCoord;\n\tvec3 color = vec3(uv.x);\n\n\tvec3 bef = vec3(uv.x - offset/maxCoord.x);\n\tvec3 aft = vec3(uv.x + offset/maxCoord.x);\n\n\tbef = toLinear(bef, gamFrom);\n\taft = toLinear(aft, gamFrom);\n\tbef = toGamma(bef, gamTo);\n\taft = toGamma(aft, gamTo);\n\n\t// Calculate distance from the line\n\tvec2 p1 = vec2(coord.x - offset, bef.x*maxCoord.y);\n\tvec2 p2 = vec2(coord.x + offset, aft.x*maxCoord.y);\n\tvec2 toUv = p2 - coord;\n\tvec2 unit = normalize(p2 - p1);\n\tfloat dist = length(toUv - dot(toUv, unit)*unit);\n\n\tcolor = toLinear(color, gamFrom);\n\tcolor = toGamma(color, gamTo);\n\n\t// Draw the actual line in linear light for better antialiasing\n\tcolor = toLinear(color, gamDisp);\n\n\tcolor = mix(vec3(0), color, clamp(dist - 1.5, 0.0, 1.0));\n\tcolor = mix(vec3(1), color, clamp(dist - 0.5, 0.0, 1.0));\n\n\tcolor = toGamma(color, gamDisp);\n\n\tfragColor = vec4(round(color*255.0)/255.0, 1);\n}", "name": "Image", "description": "", "type": "image"}]}