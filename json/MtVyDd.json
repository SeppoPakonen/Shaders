{"ver":"0.1","info":{"id":"MtVyDd","date":"1538266510","viewed":579,"name":"Vector Field Feature Dither","username":"JeroenDStout","description":"Dithering using my great love, vector fields.\n\nBoth (gaussian corrected) video and dithering are analysed with feature detection. A vector is derived between them which has the potential to flip pixels. (Formerly erroneously called gradient descent.)","likes":12,"published":3,"flags":32,"tags":[]},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 samp = texture(iChannel0, uv);\n    \n    float ditheredVal = texture(iChannel3, uv).z;\n    \n    fragColor.z = ditheredVal;// * 0.1;//min(1., max(0., ditheredVal * 1e10));\n    \n    //fragColor.z = 0.5 + texture(iChannel3, uv).y * .1;\n    \n    fragColor.x = fragColor.z;\n    fragColor.y = fragColor.z;\n    \n    float edge = 4.;\n    \n    if (fragCoord.x < edge || fragCoord.y < edge ||\n        fragCoord.x + edge >= iResolution.x || fragCoord.y + edge >= iResolution.y)\n    {\n        edge = 2.;\n        \n        if (fragCoord.x < edge || fragCoord.y < edge ||\n            fragCoord.x + edge >= iResolution.x || fragCoord.y + edge >= iResolution.y)\n        {\n            fragColor = vec4(1.);\n        }\n        else {\n        \tfragColor = vec4(0.);\n        }\n    }\n    \n    vec3 bg = pow(texture(iChannel2, uv * .01).xyz, vec3(0.02));\n    \n    fragColor.xyz *= bg;\n    fragColor.xyz += bg * 1e-1;\n    \n   // float testLum = pow(texture(iChannel1, uv).x, .4545);    \n   // fragColor.xyz = vec3(testLum);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void sampleArray( out float[25] vid, out float[25] dith, in vec2 uv, in vec2 po )\n{\n    int s = 0;\n    \n    for (int y = 0; y < 5; y++) {\n        float v = uv.y + po.y * float(y);\n        \n        for (int x = 0; x < 5; x++, s++) {\n            float rVid = texture(iChannel1, vec2(uv.x + po.x * float(x), v)).x;\n            float rDith = texture(iChannel0, vec2(uv.x + po.x * float(x), v)).x;\n            \n            vid[s] = preProcessVid(rVid);\n            dith[s] = ditherPotentialToDither(rDith);\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float arrayVid[25];\n    float arrayDith[25];\n    \n    float edge = 4.;\n    \n    if (fragCoord.x < edge || fragCoord.y < edge ||\n        fragCoord.x + edge >= iResolution.x || fragCoord.y + edge >= iResolution.y)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n        \n    \n    sampleArray(arrayVid, arrayDith, (fragCoord-2.)/iResolution.xy, vec2(1.) / iResolution.xy);\n    \n    fragColor.x = kernelGradH(arrayVid, arrayDith);\n    fragColor.y = kernelGradV(arrayVid, arrayDith);\n    fragColor.z = kernelBandH(arrayVid, arrayDith);\n    fragColor.w = kernelBandV(arrayVid, arrayDith);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float gradValues[5] = float[5](-1., -.6, -0.1,  .7, 1.0);\nfloat bandValues[5] = float[5](.2,  -.7, 1.0,  -.7, .2);\n\nfloat lumValues[9] = float[9]( 0.10, 0.17, 0.19,\n                               0.17, 0.20, 0.21,\n                               0.19, 0.21, 0.25  );\n\nfloat polValues[9] = float[9]( -0.17, -0.21, -0.31,\n                               -0.21,  0.15,  0.23,\n                               -0.31,  0.23,  0.33  );\n\nint   cornerMap[5] = int[5](0, 1, 2, 1, 0);\n\nfloat preProcessVid( in float v )\n{\n    return max(0., v) * 3.;\n}\n\nfloat combineEff( float a, float b )\n{\n    return a - b;\n}\n\nfloat ditherPotentialToDither( float d )\n{\n    return d > 0. ? 1. : 0.;\n}\n\nfloat kernelLum( in float[25] vid, in float [25] dith)\n{\n    float r0 = 0., r1 = 0.;\n    \n    for (int y = 0; y < 5; y++) {\n        int rowY = cornerMap[y];\n        \n        for (int x = 0; x < 5; x++) {            \n        \tr0 +=  vid[y*5+x] * lumValues[rowY*3 + cornerMap[x]] / 3.;\n        \tr1 += dith[y*5+x] * lumValues[rowY*3 + cornerMap[x]];\n        }\n    }\n    \n    return r0 - r1;;\n}\n\nfloat kernelPol( in float[25] vid, in float [25] dith)\n{\n    float r0 = 0., r1 = 0.;\n    \n    for (int y = 0; y < 5; y++) {\n        int rowY = cornerMap[y];\n        \n        for (int x = 0; x < 5; x++) {\n        \tr0 +=  vid[y*5+x] * polValues[rowY*3 + cornerMap[x]];\n        \tr1 += dith[y*5+x] * polValues[rowY*3 + cornerMap[x]];\n        }\n    }\n    \n    return combineEff(r0, r1);\n}\n\nfloat kernelGradH( in float[25] vid, in float [25] dith)\n{\n    float r0 = 0., r1 = 0.;\n    \n    for (int y = 0; y < 5; y++) {\n        for (int x = 0; x < 5; x++) {\n        \tr0 +=  vid[y*5+x] * gradValues[x];\n        \tr1 += dith[y*5+x] * gradValues[x];\n        }\n    }\n    \n    return combineEff(r0, r1);\n}\n\nfloat kernelGradV( in float[25] vid, in float [25] dith)\n{\n    float r0 = 0., r1 = 0.;\n    \n    for (int y = 0; y < 5; y++) {\n        for (int x = 0; x < 5; x++) {\n        \tr0 +=  vid[y*5+x] * gradValues[y];\n        \tr1 += dith[y*5+x] * gradValues[y];\n        }\n    }\n    \n    return combineEff(r0, r1);\n}\n\nfloat kernelBandH( in float[25] vid, in float [25] dith)\n{\n    float r0 = 0., r1 = 0.;\n    \n    for (int y = 0; y < 5; y++) {\n        for (int x = 0; x < 5; x++) {\n        \tr0 +=  vid[y*5+x] * bandValues[x];\n        \tr1 += dith[y*5+x] * bandValues[x];\n        }\n    }\n    \n    return combineEff(r0, r1);\n}\n\nfloat kernelBandV( in float[25] vid, in float [25] dith)\n{\n    float r0 = 0., r1 = 0.;\n    \n    for (int y = 0; y < 5; y++) {\n        for (int x = 0; x < 5; x++) {\n        \tr0 +=  vid[y*5+x] * bandValues[y];\n        \tr1 += dith[y*5+x] * bandValues[y];\n        }\n    }\n    \n    return combineEff(r0, r1);\n}\n\nuint HashWang( uint a )\n{\n\ta = (a ^ 61u) ^ (a >> 16u);\n\ta = a + (a << 3u);\n\ta = a ^ (a >> 4u);\n\ta = a * 0x27d4eb2du;\n\ta = a ^ (a >> 15u);\n\treturn a;\n}\n\nuint Rand( inout uint seed )\n{\n    seed += 13u;\n    return HashWang( seed );\n}\n\nfloat FRand( inout uint seed )\n{\n    uint urand = Rand( seed );    \n    const uint mantissaMask = (0xffffffffu) >> ( 32u - 23u );\n    return fract(float(urand & mantissaMask) / float(mantissaMask)); \n    //return uintBitsToFloat( (urand & mantissaMask) | (127u << 23u) );\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void sampleArray( out float[25] vid, out float[25] dith, in vec2 uv, in vec2 po )\n{\n    int s = 0;\n    \n    for (int y = 0; y < 5; y++) {\n        float v = uv.y + po.y * float(y);\n        \n        for (int x = 0; x < 5; x++, s++) {\n            float rVid = texture(iChannel1, vec2(uv.x + po.x * float(x), v)).x;\n            float rDith = texture(iChannel0, vec2(uv.x + po.x * float(x), v)).x;\n            \n            vid[s] = preProcessVid(rVid);\n            dith[s] = ditherPotentialToDither(rDith);\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float arrayVid[25];\n    float arrayDith[25];\n    \n    float edge = 4.;\n    \n    if (fragCoord.x < edge || fragCoord.y < edge ||\n        fragCoord.x + edge >= iResolution.x || fragCoord.y + edge >= iResolution.y)\n    {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    sampleArray(arrayVid, arrayDith, (fragCoord-2.)/iResolution.xy, vec2(1.) / iResolution.xy);\n    \n    fragColor.x = kernelLum(arrayVid, arrayDith);\n    fragColor.y = kernelPol(arrayVid, arrayDith);\n    //fragColor.z = kernelBandH(arrayVid, arrayDith);\n    //fragColor.w = kernelBandV(arrayVid, arrayDith);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void sampleArray( out float[25] refA, out float[25] refB,\n                  out float[25] refC, out float[25] refD,\n                  out float[25] refE, out float[25] refF,\n                  in vec2 uv, in vec2 po )\n{\n    int s = 0;\n    \n    for (int y = 0; y < 5; y++) {\n        float v = uv.y + po.y * float(y);\n        \n        for (int x = 0; x < 5; x++, s++) {\n            vec4 tmpA = texture(iChannel0, vec2(uv.x + po.x * float(x), v));\n            vec4 tmpB = texture(iChannel1, vec2(uv.x + po.x * float(x), v));\n            \n            refA[s] = tmpA.x;\n            refB[s] = tmpA.y;\n            refC[s] = tmpA.z;\n            refD[s] = tmpA.w;\n            refE[s] = tmpB.x;\n            refF[s] = tmpB.y;\n        }\n    }\n}\n\nfloat solveLuminance( in float[25] ref )\n{    \n    float gradient;\n    \n    for (int y = 0; y < 5; y++) {\n        int rowY = cornerMap[y];\n        \n        for (int x = 0; x < 5; x++) {\n        \tgradient += ref[y*5+x] * lumValues[24 - rowY*3 + cornerMap[x]];\n        }\n    }\n    \n    return gradient;\n}\n\nfloat solvePol( in float[25] ref )\n{    \n    float gradient;\n    \n    for (int y = 0; y < 5; y++) {\n        int rowY = cornerMap[y];\n        \n        for (int x = 0; x < 5; x++) {\n        \tgradient += ref[y*5+x] * polValues[24 - rowY*3 + cornerMap[x]];\n        }\n    }\n    \n    return gradient;\n}\n\nfloat kernelH( in float[25] ref, in float[5] kern)\n{\n    float gradient;\n    \n    for (int y = 0; y < 5; y++) {\n        for (int x = 0; x < 5; x++) {\n        \tgradient += ref[y*5+x] * kern[x];\n        }\n    }\n    \n    return gradient;\n}\n\nfloat kernelV( in float[25] ref, in float[5] kern)\n{\n    float gradient;\n    \n    for (int y = 0; y < 5; y++) {\n        for (int x = 0; x < 5; x++) {\n        \tgradient += ref[y*5+x] * kern[y];\n        }\n    }\n    \n    return gradient;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint seed = uint( iTime * 23.456 ) + uint(fragCoord.x *23.45f) * 12326u + uint(fragCoord.y * 36.43) * 42332u;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 po = vec2(1.) / iResolution.xy;\n    \n    vec4 curSample = texture(iChannel3, uv);\n    \n    float currentDither = texture(iChannel3, uv).x;\n    float gradient = 0.;\n    \n    float grLum[25], grPol[25], grGradH[25], grGradV[25], grBandH[25], grBandV[25];\n    \n    sampleArray(grGradH, grGradV, grBandH, grBandV, grLum, grPol, (fragCoord-2.)/iResolution.xy, po);\n    \n    float luminance = solveLuminance(grLum);\n    float gradientH = kernelH(grGradH, gradValues);\n    float gradientV = kernelV(grGradV, gradValues);\n    float bandsH    = kernelH(grBandH, gradValues);\n    float bandsV    = kernelV(grBandV, gradValues);\n    \n   // gradientH *= abs(gradientH * gradientH * 1e-1);\n    //gradientV *= abs(gradientV * gradientV * 1e-1);\n    //bandsH    *= abs(bandsH * bandsH * 1e-1);\n    //bandsV    *= abs(bandsV * bandsV * 1e-1);\n    \n    float edgeStrength = -4e-1 + abs(luminance) * 2e-2;\n    \n    gradient += luminance * 5e0;\n    gradient += solvePol(grPol) * edgeStrength * 1.0;\n    gradient += gradientH * edgeStrength;\n    gradient += gradientV * edgeStrength;\n    gradient += bandsH * edgeStrength;\n    gradient += bandsV * edgeStrength;\n    \n    gradient *= 5e-2;\n    //gradient += (-1. + 2. * FRand(seed)) * 4e-2 * abs(luminance);\n    gradient += sign(currentDither) * 7e-1;\n    gradient += 1e-2;\n    \n    float rnd = FRand(seed);\n    \n    currentDither += gradient * rnd * (1. + rnd * (1. + rnd));//min(3., max(-3., gradient));\n    currentDither *= 0.9;\n    \n    currentDither = min(2.5, max(-2.5, currentDither));\n    \n    fragColor.x   = currentDither;\n    fragColor.y   = bandsV * 1e-2;//kernelV(grBandV, bandValues) * 1e0;\n    fragColor.z   = curSample.z;\n\tfragColor.z = (curSample.x >= 0.0) ? 1.0 : 0.;//0.5 - diffY;\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"float videoToPixel( vec3 pix )\n{\n    return max(pix.x, max(pix.y, pix.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv   = fragCoord/iResolution.xy;\n    vec4 samp = texture(iChannel0, uv);\n    vec2 off  = vec2(1. / 40.);//vec2(16.) / iResolution.xy;\n    \n    float val[12];\n    vec2  acc = vec2(0.);\n    \n    val[ 0] = videoToPixel(texture(iChannel0, vec2(uv.x - off.x, uv.y - off.y * 2.)).xyz);\n    val[ 1] = videoToPixel(texture(iChannel0, vec2(uv.x + off.x, uv.y - off.y * 2.)).xyz);\n    val[ 2] = videoToPixel(texture(iChannel0, vec2(uv.x - off.x * 2., uv.y - off.y * 1.)).xyz);\n    val[ 3] = videoToPixel(texture(iChannel0, vec2(uv.x - off.x * 1., uv.y - off.y * 1.)).xyz);\n    val[ 4] = videoToPixel(texture(iChannel0, vec2(uv.x + off.x * 2., uv.y - off.y * 1.)).xyz);\n    val[ 5] = videoToPixel(texture(iChannel0, vec2(uv.x + off.x * 1., uv.y - off.y * 1.)).xyz);\n    val[ 6] = videoToPixel(texture(iChannel0, vec2(uv.x - off.x * 2., uv.y + off.y * 1.)).xyz);\n    val[ 7] = videoToPixel(texture(iChannel0, vec2(uv.x - off.x * 1., uv.y + off.y * 1.)).xyz);\n    val[ 8] = videoToPixel(texture(iChannel0, vec2(uv.x + off.x * 2., uv.y + off.y * 1.)).xyz);\n    val[ 9] = videoToPixel(texture(iChannel0, vec2(uv.x + off.x * 1., uv.y + off.y * 1.)).xyz);\n    val[10] = videoToPixel(texture(iChannel0, vec2(uv.x - off.x, uv.y + off.y * 2.)).xyz);\n    val[11] = videoToPixel(texture(iChannel0, vec2(uv.x + off.x, uv.y + off.y * 2.)).xyz);\n    \n    acc += texture(iChannel1, vec2(uv.x - off.x * .125, uv.y - off.y * .125)).zw;\n    acc += texture(iChannel1, vec2(uv.x + off.x * .125, uv.y - off.y * .125)).zw;\n    acc += texture(iChannel1, vec2(uv.x - off.x * .125, uv.y + off.y * .125)).zw;\n    acc += texture(iChannel1, vec2(uv.x + off.x * .125, uv.y + off.y * .125)).zw;\n    \n    \n    float mean = 0.;\n    for (int i = 0; i < 12; i++) {\n        val[i] = pow(val[i], 2.2);\n        mean += val[i];\n    }\n    mean /= 12.;\n    \n    float var = 0.;\n    for (int i = 0; i < 12; i++) {\n        var += pow(val[i]-mean, 2.);\n    }\n    \n    mean *= 0.05;\n    mean += acc.x * 0.95 * 0.25;\n    var *= 0.05;\n    var += acc.y * 0.95 * 0.25;\n    \n    float overShot = max(0., sqrt(var)*1.5 + mean * 0.8 - 1.);\n    //overShot -= max(0., 1. - sqrt(var)*1.5 - mean);\n    //mean += overShot * 0.015;\n    \n    fragColor.y     = overShot;\n    \n    fragColor.z     = mean;\n    fragColor.w     = var;\n    \n    float vid = videoToPixel(texture(iChannel0, uv).xyz);\n    \n    fragColor.x = pow(vid, 2.2) - mean;\n    fragColor.x /= min(1., max(5e-2, sqrt(var) * 1.1));\n    fragColor.x += 0.15 + mean * 0.7;// - overShot * 0.1;\n\n    //fragColor.x = var;//pow(vid, 2.2);\n}","name":"Buffer C","description":"","type":"buffer"}]}