{"ver":"0.1","info":{"id":"4dtBzs","date":"1526393184","viewed":513,"name":"HeightLerp","username":"OskarSwierad","description":"Height-based linear interpolation. The concept is similar to Unreal's \"HeightLerp\" material node. The \"edges\" of the transitions are additionally masked, so that full black and full white on the original mask are untouched.","likes":3,"published":3,"flags":0,"tags":[]},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float PI_HALF = 1.5707963267948966;\n\nfloat getAnimationPhase()\n{\n    float phase = iTime * 0.75;\n    vec2 waves = vec2(phase) + vec2(0.0, PI_HALF);\n    waves = vec2(\n        sin(waves.x),\n        sin(waves.y)\n    );\n    float transitionHardness = 8.0;\n    waves = clamp(waves * transitionHardness, -1.0, 1.0);\n    phase = smoothstep(-2.0, 2.0, waves.x + waves.y);\n    return phase;\n}\n\nfloat remapTo01Clamped(float value, float start, float end)\n{\n\treturn clamp((value - start) / (end - start), 0.0, 1.0);\n}\n\nfloat parabola(float x, float k)\n{\n    // from http://www.iquilezles.org/www/articles/functions/functions.htm\n    return pow(4.0 * x * (1.0 - x), k);\n}\n\nfloat heightLerp(float mask, float height, float heightContrast, float outContrast, float transitionSmoothness)\n{\n    // Makes height zero-centered, then applies contrast\n    // Contrast of 0 is flat, 1 is default, >1 increases contrast\n    height = mix(0.0, height - 0.5, heightContrast);\n\n    // Doesn't modify full black and full white in the original mask,\n    // only the transition\n    float transition = parabola(mask, transitionSmoothness);\n    height *= transition;\n    \n    float outMask = clamp(mask + height, 0.0, 1.0);\n    outMask = mix(0.5, outMask, outContrast);\n    return clamp(outMask, 0.0, 1.0);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 aspect = vec2(1.0, iResolution.y / iResolution.x);\n    vec2 uv = fragCoord / iResolution.xy * aspect;\n    \n    float animPhase = pow(getAnimationPhase(), 2.0);\n    float result;\n    \n    if (uv.y > 0.5 * aspect.y)\n    {\n    \tfloat inAlpha = remapTo01Clamped(uv.x, 0.05, 0.95);\n        vec2 texUV = fragCoord / vec2(128.0);\n        \n        result = heightLerp(\n            inAlpha,\n            texture(iChannel0, texUV).x,\n            mix(0.0, 0.6, animPhase), // height contrast\n            1.0, // output contrast\n            0.5  // edge transition smoothness\n        );\n    }\n    else\n    {\n        float inAlpha = remapTo01Clamped(uv.x, 0.05, 0.95);\n        vec2 texUV = uv * vec2(2.0);\n        \n        result = heightLerp(\n            inAlpha,\n            pow(texture(iChannel1, texUV).x, 0.7),\n            mix(0.7, 3.1, animPhase),\n            mix(1.3, 6.5, animPhase),\n            0.4\n        );\n    }\n        \n    // Output to screen\n    fragColor = vec4(vec3(result), 1.0);\n}","name":"Image","description":"","type":"image"}]}