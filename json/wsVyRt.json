{"ver":"0.1","info":{"id":"wsVyRt","date":"1603908192","viewed":2253,"name":"Shifter (truchet cubes)","username":"pjkarlik","description":"Play shader, just  trying to see how to map on all sides a pattern/design thats moving. Kind of hard, and not sure if the animation works from other angles.. Standard 4 tap grid / globals / 1 tile truchet.","likes":29,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R\t\t\tiResolution\n#define T\t\t\tiTime\n#define M\t\t\tiMouse\n\n#define PI\t\t\t3.141592653589793\n#define PI2\t\t\t6.283185307\n\n#define MAX_DIST \t50.\n#define MIN_DIST\t.0001\n\n#define r2(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define hue(a) .55 + .45 * cos(PI2* a * vec3(.25,.75,.5));\n\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\nvoid getMouse( inout vec3 p ) {\n    float x = M.xy == vec2(0) ? 0. : -(M.y/R.y * .65 - .325) * PI;\n    float y = M.xy == vec2(0) ? 0. :  (M.x/R.x * .45 - .225) * PI;\n    p.zy *=r2(x);\n    p.xz *=r2(y);   \n}\n\n//http://mercury.sexy/hg_sdf/\nfloat vmax(vec3 v) {\treturn max(max(v.x, v.y), v.z);\t\t\t\t}\nfloat fBox(vec3 p, vec3 b, float r) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)))-r;\n}\n\nvec3 shp;\nvec2 sid;\nfloat saveHash;\n\nfloat txx = .5;\n#define SCALE 1.15\nconst float scale = 1./SCALE;\nconst vec2 l = vec2(scale);\nconst vec2 s = l*2.; \nconst vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5), vec2(.5, -.5), vec2(-.5));\n\nvec2 map(vec3 q3){\n    vec2 res = vec2(1000.,0.);\n\n    q3.xy -= vec2(T*.05,T*.4);\n    vec2 p,\n         ip,\n         id = vec2(0),\n         ct = vec2(0);\n\n    float t = 1e5;\n    \n    for(int i =0; i<4; i++){\n        ct = ps4[i]/2. -  ps4[0]/2.;    \n        p = q3.xy - ct*s;               \n        ip = floor(p/s) + .5;           \n        p -= (ip)*s;                   \n        vec2 idi = (ip + ct)*s;\n\t\tfloat hs = hash21(idi);\n        float back = floor(hs*5.)*(l.x*.5);\n        float bz = back*sin(hs+T*.2);\n        vec3 q = vec3(p.x,p.y,q3.z+bz);\n\n\t\tif(hs>txx) q.x *= -1.;\n\n        float b = fBox(q,l.xyx*.455,.045 * scale);\n        if(b<t) {\n            t = b;\n            sid = ps4[i];\n            shp = q;\n            saveHash=hs;\n        }\n        \n    }\n\n  \tif(t<res.x) res = vec2(t,2.);\n    return res;\n}\n\n// Tetrahedron technique @iq\n// https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 getNormal(vec3 p, float t){\n    // method to prevent compiler inlining map\n    float h = t * MIN_DIST;\n    #define ZERO (min(iFrame,0))\n    vec3 n = vec3(0.0);\n    for(int i=ZERO; i<4; i++) {\n        vec3 e = 0.5773*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.);\n        n += e*map(p+e*h).x;\n    }\n    return normalize(n);\n    //original tetrahedron normal\n    //float e = t*MIN_DIST;\n    //vec2 h = vec2(1.,-1.)*.5773;\n    //return normalize( h.xyy*map( p + h.xyy*e).x + \n\t//\t\t\t\t  h.yyx*map( p + h.yyx*e).x + \n\t//\t\t\t\t  h.yxy*map( p + h.yxy*e).x + \n\t// \t\t\t\t  h.xxx*map( p + h.xxx*e).x );\n}\n\nvec2 marcher(vec3 ro, vec3 rd, int maxsteps) {\n\tfloat d = 0.;\n    float m = -1.;\n    for(int i=0;i<maxsteps;i++){\n    \tvec2 t = map(ro + rd * d);\n        if(abs(t.x)<d*MIN_DIST||d>MAX_DIST) break;\n        d += t.x*.5;\n        m  = t.y;\n    }\n\treturn vec2(d,m);\n}\n\nfloat getDiff(vec3 p, vec3 n, vec3 lpos) {\n    vec3 l = normalize(lpos-p);\n    float dif = clamp(dot(n,l),.01 , 1.);\n    float shadow = marcher(p + n * .01, l, 98).x;\n    if(shadow < length(p -  lpos)) dif *= .25;\n    return dif;\n}\n\n\n//@Shane AO\nfloat calcAO(in vec3 p, in vec3 n){\n    float sca = 2., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n        float hr = float(i + 1)*.16/8.; \n        float d = map(p + n* hr).x;\n        occ += (hr - d)*sca;\n        sca *= .9;\n        if(sca>1e5) break;\n    }\n    return clamp(1. - occ, 0., 1.);\n}\n\nvec3 camera(vec3 lp, vec3 ro, vec2 uv) {\n\tvec3 cf = normalize(lp - ro),\n         cr = normalize(cross(vec3(0,1,0),cf)),\n         cu = normalize(cross(cf,cr)),\n         c  = ro + cf *.95,\n         i  = c + uv.x * cr + uv.y * cu,\n         rd = i - ro;\n    return rd;\n}\n\nvec3 thp;\nvec2 tip;\nfloat thsh;\n\nvec3 getTiles(vec2 p) {\n    vec3 h = vec3(.75),\n         j = vec3(.25);  \t\n\n    float scale = 1./SCALE;\n    p/=scale;\n\n    float dir = mod(tip.x + tip.y ,2.) * 2. - 1.;       \n    \n    vec3 ca = hue((9.45+p.y*.045)*PI);\n    vec3 cb = hue((6.4+p.y*.075)*PI);\n    vec3 cc = thsh>.6 ? ca : cb;\n    vec3 cf = thsh>.6 ? cb : ca;\n    \n    vec2 cUv= p.xy-sign(p.x+p.y+.001)*.5;\n\n    float d = length(cUv);\n    float mask = smoothstep(.01, .001, abs(abs(abs(d-.5)-.02)-.15)-.03 );\n    float mask2 = smoothstep(.01, .001, abs(d-.5)-.08 );\n    float angle = atan(cUv.x, cUv.y);\n    float a = sin(dir * angle * 32. + iTime * 3.5);\n\tfloat b = sin(dir * angle * 12. - iTime * 4.5);\n    \n    h = mix(cf,cc,smoothstep(.01, .05, a)); \n    j = mix(cf,cc,smoothstep(.01, .05, b)); \n    \n    h = mix(cc,h,mask);\n    j = mix(cc,j,mask2);\n\tj = mix(h,j,mask2);\n    return j;\n}\n\n// Tri-Planar blending function. @Shane\n// https://www.shadertoy.com/view/XlXXWj\n// hacked to work with my truchet\nvec3 getColor( in vec3 p, in vec3 n ) {  \n\n    n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n    n /= dot(n, vec3(1)); \n    //n /= length(n); \n\n    vec3 tx = getTiles(thp.yz).xyz;\n    vec3 ty = getTiles(thp.zx).xyz;\n    vec3 tz = getTiles(thp.xy).xyz;\n    return mat3(tx*tx, ty*ty, tz*tz)*n; // Equivalent to: tx*tx*n.x + ty*ty*n.y + tz*tz*n.z;\n\n}\n    \n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    // Normalized coordinates (from -1 to 1)\n    vec2 uv = (2.*F.xy-iResolution.xy)/max(iResolution.x,iResolution.y);\n    vec3 C = vec3(0.),\n         FC= vec3(.1); //hue(201.15*.1);//\n    \n    vec3 lp = vec3(0.,0.,0.),\n         ro = vec3(0.,0.,3.5);\n    \t getMouse(ro);\n    ro.xz*=r2(.15*sin(T*.15));\n    ro.yz*=r2(.08*sin(T*.2));\n    vec3 rd = camera(lp,ro,uv);\n    vec2 t = marcher(ro,rd, 256);\n    thsh = saveHash;\n    thp = shp;\n\ttip = sid;\n\n    if(t.x<MAX_DIST){\n    \tvec3 p = ro + rd * t.x;\n    \tvec3 n = getNormal(p, t.x);\n        vec3 lpos = vec3(0.,0.,3.25);\n    \tfloat diff = getDiff(p, n, lpos);\n        float ao = calcAO(p, n);\n  \t\tvec3 h = getColor(p,n);\n       \n        C+=diff * ao * h;\n        // 1 bounce\n        if(t.y==2.){\n        \tvec3 rr=reflect(rd,n); \n            vec2 tr = marcher(p ,rr, 128);\n\t\t\tthsh = saveHash;\n            thp = shp;\n            tip = sid;\n            if(tr.x<MAX_DIST){\n                p += rr*tr.x;\n                n = getNormal(p,tr.x);\n                diff = getDiff(p,n,lpos);\n                vec3 h = getColor(p,n);\n                //dull reflection\n                C+=(diff * ao * h)*.35;\n            }  \n        }\n        \n    } else {\n     \tC += FC;   \n    }\n    \n    C = mix( C, FC, 1.-exp(-.00345*t.x*t.x*t.x));\n    // Output to screen\n    O = vec4(C,1.0);\n}","name":"Image","description":"","type":"image"}]}