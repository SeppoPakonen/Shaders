{"ver": "0.1", "info": {"id": "tstXRj", "date": "1573022541", "viewed": 1041, "name": "Humidity", "username": "granito", "description": "A 2d particle solver with temporally-accumulated motion trails. (Used to simulate water drops on a fogged-up glass surface.) \n\nSet DEBUG to 1 for more info under Common.", "likes": 39, "published": 3, "flags": 32, "tags": ["wet", "particles", "histor", "face", "buffer"], "requires": ["texture", "imagebuf", "library", "texturebuf"]}, "renderpass": [{"inputs": [{"id": "4dfGRn", "filepath": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "type": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "4dXGR8", "filepath": "/media/previz/buffer00.png", "previewfilepath": "/media/previz/buffer00.png", "type": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "XsXGR8", "filepath": "/media/previz/buffer01.png", "previewfilepath": "/media/previz/buffer01.png", "type": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "XsBSR3", "filepath": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "type": "texture", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "float bnoise (vec2 uv)\n{\n    return texture(iChannel3, uv).x * 2. - 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n    vec2 uv = fragCoord/res;\n    float noise = bnoise(fragCoord / vec2(1024.));\n    vec4 bufB = texture(iChannel0, uv);\n    vec2 bguv = uv + vec2(sin(iTime*0.2)*0.05,cos(iTime*0.1)*0.025);\n    \n    //setup passes\n    vec3 drops = texture(iChannel1, bguv + bufB.xy * -.3, 0.).xyz; //drops on glass\n    float spec = max( smoothstep( 0.75, 0.9, saturate(dot( vec3(0.25,-0.7,1.) , buildnormalz(bufB.xy)) * 2. - 1.5 )  ) * floor(bufB.w), 0.); // specular highlight\n    drops = drops * vec3(0.8) + vec3(spec * 0.2); // combine drops and spec\n    vec3 hazyglass = multisample( iChannel1, bguv, (1.- smoothstep(0.3, 0.5, bufB.w) ) * 1.5 + 4., 0.1 + 0.002 * noise).xyz; //hazy glass\n    hazyglass *= smoothstep(0.3, 0.5, bufB.w) * 0.1 + .9; //highlight streaks\n\n    if (DEBUG < 1) //Output\n    {\n    \tfragColor.rgb = pow( mix(hazyglass, drops, smoothstep(0.6, 0.9, bufB.w) ), vec3(1.75,1.2,.8) ); //put passes together\n    }\n    else //Debug views\n    {\n        float time = fract(iTime * 0.25);\n        if (time < 0.25)\n        {\n        \tfragColor.rgb = buildnormalz(bufB.xy) * vec3(0.5) + vec3(0.5);\n        }\n        else if (time < 0.5)\n        {\n            fragColor.rgb = buildnormalz(texture(iChannel2, uv).xy) * vec3(0.5) + vec3(0.5);\n        }\n        else if (time < 0.75)\n        {\n\t\t\tfragColor.rgb = vec3(bufB.w);\n        }\n        else\n        {\n            fragColor.rgb = vec3(texture(iChannel2, uv).w);        \n        }      \n    }\n}", "name": "Image", "description": "", "type": "image"}, {"inputs": [], "outputs": [], "code": "#define DEBUG 0\n\n//some basic controls\nconst int COUNT = 64;\nconst float GRAVITY = 0.005;\nconst float DROPSIZE = 0.0045;\nconst float DROPJITTER = 0.3;\nconst int LIFETIME = 200;\n\nfloat saturate(float x)\n{\n    return clamp(x, 0., 1.);\n}\n\nuint baseHash(uint p)\n{\n    p = 1103515245U*((p >> 1U)^(p));\n    uint h32 = 1103515245U*((p)^(p>>3U));\n    return h32^(h32 >> 16);\n}\n\nvec2 hash21(int x)\n{\n    uint n = baseHash(uint(x));\n    uvec2 rz = uvec2(n, n*48271U); //see: http://random.mat.sbg.ac.at/results/karl/server/node4.html\n    return vec2((rz.xy >> 1) & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec2 hash21f(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash11(int x)\n{\n    uint n = baseHash(uint(x));\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nvec3 buildnormalz(vec2 normal)\n{\n    return vec3(normal, sqrt(1. - normal.x*normal.x - normal.y*normal.y));\n}\n\nvec4 multisample( sampler2D tex, vec2 uv, float mip, float offset)\n{\n\tvec4 outcol;\n    outcol += texture( tex, uv + vec2(    0.0, 0.0), mip);\n    outcol += texture( tex, uv + vec2( offset, 0.0), mip);\n    outcol += texture( tex, uv + vec2(-offset, 0.0), mip);\n    outcol += texture( tex, uv + vec2( 0.0, offset), mip);\n    outcol += texture( tex, uv + vec2( 0.0,-offset), mip);\n    return outcol * 0.2;\n}", "name": "Common", "description": "", "type": "common"}, {"inputs": [{"id": "4dXGR8", "filepath": "/media/previz/buffer00.png", "previewfilepath": "/media/previz/buffer00.png", "type": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dXGR8", "channel": 0}], "code": "vec2 writePos (int i, vec2 fragCoord, vec2 res, vec2 value)\n{\n    if (fragCoord.x == float(i))\n    {\n\t\treturn value;\n    } \n    else {return vec2(0);}\n}\n\nfloat writeLife (int i, vec2 fragCoord, vec2 res, float value)\n{\n    if (fragCoord.x == float(i))\n    {\n\t\treturn value;\n    } \n    else {return 0.;}\n}\n\nfloat loadLife(int index) \n{ \n    return texture( iChannel0, vec2((float(index)+0.5) / iChannelResolution[0].x, 0.), -100.0 ).z; \n}\n\nvec4 loadData(int index) \n{ \n    return texture( iChannel0, vec2((float(index)+0.5) / iChannelResolution[0].x, 0.), -100.0 ); \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 res = iResolution.xy;\n    vec2 uv = fragCoord/res;\n    vec2 inv = vec2(1., res.x / res.y); \n    \n    vec2 pos;\n    vec4 col;\n    float radius = DROPSIZE;\n    float life01 = 1. / float(LIFETIME);\n    float life;\n    \n    if (fragCoord.y < 2.) //update particle values (stored on 1st pixel row of buffer A)\n    {\n        for (int i = 0; i < COUNT-1; ++i)\n        {\n            if (iFrame == 0) //re-init particles\n            {\n                pos += writePos(i, floor(fragCoord), res, hash21f(float(i)+iDate.x+iDate.y+iDate.z+iDate.w) ); //randomize position at index\n                life += writeLife(i, floor(fragCoord), res, hash11(i) * 121.317 );\n\n            }\n            else //increment \n            {\n                float rndgrav = -GRAVITY * ( 0.55 + 0.45 * sin(hash11(i) * 5. + iTime * 0.05) );\n                pos += writePos(i, floor(fragCoord), res, (hash21(i*COUNT+int(iTime*60.)) * 2. - 1.) * DROPJITTER * inv * rndgrav + vec2(0., rndgrav )   );\n            \tlife += writeLife(i, floor(fragCoord), res, life01 / abs(pos.y * 10.) * 0.01 );\n            }\n        }\n        float vel = pos.y; \n        pos = fract(texture(iChannel0,uv).xy + pos);\n        life = fract(texture(iChannel0,uv).z + life);\n    \tfragColor = vec4(pos, life, vel);\n    }\n    else //draw results to buffer A\n    {\n        for (int i = 0; i < COUNT-1; ++i) \n        {\n            vec4 get = loadData(i);\n            vec2 uvscale = (uv-get.xy) / max( (1. - get.w * 100. * inv * inv), 0.1) + get.xy; \n            float mask = 1. - saturate( (distance(get.xy, uvscale) / radius) );\n            mask *= smoothstep( 0.7, 0.9, get.z);\n            vec2 normal = normalize(get.xy - uvscale) *(1. - mask)*ceil(mask);\n            mask = ceil(mask);\n            col.xy += normal;\n            col.w = max(col.w,mask) ;\n        }\n        fragColor = col;  \n    }\n}", "name": "Buffer A", "description": "", "type": "buffer"}, {"inputs": [{"id": "XdXGzn", "filepath": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "type": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "4dXGR8", "filepath": "/media/previz/buffer00.png", "previewfilepath": "/media/previz/buffer00.png", "type": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "XsXGR8", "filepath": "/media/previz/buffer01.png", "previewfilepath": "/media/previz/buffer01.png", "type": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "XsXGR8", "channel": 0}], "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n    vec2 uv = fragCoord/res;\n    vec2 inv = vec2(1., res.y / res.x); \n\n    vec4 bufA = multisample( iChannel0, uv, 0., 0.0025); //bufer A input\n    \n    vec2 uvoffset = (texture(iChannel2, uv * inv * 0.5).xy * 2. - 1.) * 0.00005; //distortion offset\n\n    vec4 bufB = multisample( iChannel1, uv + uvoffset, 0., 0.001); //history buffer\n    \n    fragColor = mix( bufB * 0.995, bufA, bufA.w); //mix history buffer behind\n}", "name": "Buffer B", "description": "", "type": "buffer"}]}