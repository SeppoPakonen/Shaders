{"ver":"0.1","info":{"id":"7s33RX","date":"1630633015","viewed":265,"name":"Radio Tunnel ","username":"byt3_m3chanic","description":"Fun early start to the holiday weekend - Add your own music - responsive with mic. Mouseable - mix of tunnel/path and menger sponge fractal with some sine waves and a radio thrown in!","likes":16,"published":3,"flags":36,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n   \n    The Radio Tunnel - audio viz / mouseable.\n    \n    Path / Tunnel shaders are fun and most of what I know is learned from @Shane\n    https://www.shadertoy.com/view/MlXSWX\n    \n    It's an early start to my holiday weekend and I had a nice cup of coffee and just\n    started to play around. Trying some things, like no diffused - just color and reflections\n    and well fractals are always fun. \n    \n    Some domain rep tricks from http://mercury.sexy, shapes from @iq, tricks from @Fabrice \n    and others\n    \n    @byt3_m3chanic | 09/02/21\n\n*/\n\nvec2 scanLineOpacity = vec2(.125);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {  \n\tvec2 uv = fragCoord.xy/iResolution.xy;\n\n    uv=(uv*1.05)-vec2(.025,.025);\n    vec2 vuv = remapUV(uv);\n    \n    vec4 baseColor = texture(iChannel0, vuv);\n\n    baseColor *= vignette(vuv, iResolution.xy, .75);\n    baseColor *= scanLine(vuv.x, iResolution.y*.9, scanLineOpacity.x);\n    baseColor *= scanLine(vuv.y, iResolution.x*.9, scanLineOpacity.y);\n    float t1 = 0.;\n    if (vuv.x < 0.0 || vuv.y < 0.0 || vuv.x > 1.0 || vuv.y > 1.0){\n        baseColor = vec4(vec3(.0),0);\n        t1=0.;\n    }\n\n    //vec4 altColor = texture(iChannel0, fragCoord.xy/iResolution.xy);\n    fragColor = baseColor;\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI          3.1415926\n#define PHI (sqrt(5.)*0.5 + 0.5)\n\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\n//http://mercury.sexy/hg_sdf/\nfloat vmax(vec2 v) { return max(v.x, v.y); }\nfloat vmax(vec3 v) { return max(max(v.x, v.y), v.z); }\nfloat sgn(float x) { return (x<0.)?-1.:1.; }\nvec2  sgn(vec2  v) { return vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);\t}\n\nfloat pMod(inout float p, float size) {\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;\n}\nfloat pMirror (inout float p, float dist) {\n    float s = sgn(p);\n    p = abs(p)-dist;\n    return s;\n}\nvec2 pMirrorOctant (inout vec2 p, vec2 dist, float r) {\n    vec2 s = sgn(p);\n    pMirror(p.x, dist.x);\n    pMirror(p.y, dist.y);\n    p*=rot(r);\n    if (p.y > p.x) p.xy = p.yx;\n    return s;\n}\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\nfloat fCircle(vec3 p, float r) {\n\tfloat l = length(p.xz) - r;\n\treturn length(vec2(p.y, l));\n}\n//@iq\nfloat sdCap( vec3 p, float h, float r ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat box( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n// path functions \nvec2 path(in float z){ \n    vec2 p1 =vec2(2.3*sin(z * .15), 2.0*cos(z * .075));\n    vec2 p2 =vec2(1.7*cos(z * .06), 1.5*sin(z * .105));\n    return p1 - p2;\n}\nvec2 fragtail(vec3 pos) {\n    float scale = 3.;\n    float xcale = scale-1.;\n \tvec3 cxz = vec3(4.,4.,4.);\n    float r = 1e5;\n    float ss=.75;\n    \n    for (int i = 0;i<3;i++) {\n        pos=abs(pos);\n        if ( pos.x- pos.y<0.) pos.yx = pos.xy;\n        if ( pos.x- pos.z<0.) pos.zx = pos.xz;\n        if ( pos.y- pos.z<0.) pos.zy = pos.yz;\n        pos.x=scale * pos.x-cxz.x*xcale;\n        pos.y=scale * pos.y-cxz.y*xcale;\n        pos.z=scale * pos.z;\n        if (pos.z>0.5*cxz.z*xcale) pos.z-=cxz.z*xcale;\n        r = fBox2(pos.xy,vec2(scale));\n        ss*=1./scale;\n    }\n\n    return vec2(r*ss,2.);\n}\n\n// CRT effect adapted from online blog post. \n// https://babylonjs.medium.com/retro-crt-shader-a-post-processing-effect-study-1cb3f783afbc\nvec2 curvature = vec2(4.,3.75);\nvec2 remapUV(vec2 uv) {\n    uv = uv * 2. -1.;\n    vec2 offset = abs(uv.yx) / vec2(curvature.x, curvature.y);\n    uv = uv + uv * offset * offset;\n    uv = uv * .5 + .5;\n    return uv;\n}\nvec4 scanLine(float uv, float resolution, float opacity) {\n     float intensity = sin(uv * resolution * PI * 2.);\n     intensity = ((.5 * intensity) + .5) * .9 + .1;\n     return vec4(vec3(pow(intensity, opacity)), 1.);\n}\nvec4 vignette(vec2 uv, vec2 resolution, float opacity) {\n    float intensity = uv.x * uv.y * (1. - uv.x) * (1. - uv.y);\n    return vec4(vec3(clamp(pow((resolution.x / 4.) * intensity, opacity), 0.0, 1.)), 1.);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdXGRr","filepath":"/presets/mic.png","previewfilepath":"/presets/mic.png","type":"mic","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n   \n    The Radio Tunnel - audio viz / mouseable.\n    \n    Path / Tunnel shaders are fun and most of what I know is learned from @Shane\n    https://www.shadertoy.com/view/MlXSWX\n    \n    It's an early start to my holiday weekend and I had a nice cup of coffee and just\n    started to play around. Trying some things, like no diffused - just color and reflections\n    and well fractals are always fun. \n    \n    Some domain rep tricks from http://mercury.sexy, shapes from @iq, tricks from @Fabrice \n    and others\n    \n    @byt3_m3chanic | 09/02/21\n\n*/\n\n#define R\t\t\tiResolution\n#define M\t\t\tiMouse\n#define T\t\t\tiTime\n\n#define PI2        6.28318530718\n\n#define MIN_DIST     .001\n#define MAX_DIST     45.\n\nfloat sampleFreq(float freq) { return texture(iChannel0, vec2(freq, 0.25)).x;}\nfloat hash21(vec2 p){return fract(sin(dot(p,vec2(27.86,48.32)))*4274.132);}\nfloat glow=0.,iqd=0.,travelSpeed=0.,carWave=0.;\nvec3 hit=vec3(0),hitPoint=vec3(0);\nfloat time;\nmat2 turn;\n\nvec2 radio(vec3 p) {\n\tvec2 res = vec2(1e5,0.);\n    vec3 q = p;\n   \n    float d = fBox(q,vec3(2.,.75,.25));\n    d = max(d,-fBox(q-vec3(0,0,.25),vec3(.6,.4,.1)));\n    d = min(sdCap(vec3(abs(q.x),q.zy)-vec3(.76,.2,.575),.12,.12),d);\n    d = max(d,-fBox(q-vec3(0,.6,.25),vec3(.45,.1,.08)));\n    \n    q.x = abs(q.x);\n\tif(d<res.x) res = vec2(d,21.);\n    d = fBox(q-vec3(0,0,.1),vec3(.6,.4,.1));\n \tif(d<res.x)  res = vec2(d,24.); \n\n    //buttons\n    float bt = min(\n        fBox(q-vec3(.1,-.55,.2),vec3(.065,.1,.1)),\n        fBox(q-vec3(.3,-.55,.2),vec3(.065,.1,.1))\n    );\n\tfloat bd = min(\n    \tfBox(q-vec3(.5,-.55,.2),vec3(.065,.1,.1)),\n    \tfBox(q-vec3(.7,-.55,.2),vec3(.065,.1,.1))\n   \t);\n    bt=min(bd,bt);\n\n    //speakers\n\td = fCircle(q.xzy-vec3(1.3,.25,0.),.55)-.05;\n    d = min(fCircle(q.xzy-vec3(1.825,.25,.575),.1)-.025,d);\n    d=min(bt,d);\n    if(d<res.x) res = vec2(d,22.);\n\n    return res;\n}\n\n\nvec2 map (in vec3 pos, float sg) {\n \tvec2 res = vec2(1e5,-1.);\n \tvec3 p = pos;\n    \n    // set path(s) vector(s)\n \tvec2 track = p.xy - path(p.z);\n    vec3 q = vec3(track,p.z);\n    \n    float wv = 10.+7.*sin(T*.15);\n    vec3 qt = vec3(track,p.z+travelSpeed+wv);\n    qt.yz*=turn;\n    qt.xz*=turn;\n    vec3 r = vec3(abs(q.xy),q.z);\n\n    vec2 ppd = pMirrorOctant(q.xy,vec2(.75),.75+.2*sin(p.z*.6+T*.8));\n    float qiz = pMod(q.z,4.5);\n\n    // fractal\n    vec2 d1 = fragtail(q);\n    if(d1.x<res.x) {\n        res = d1;\n        hit=q;\n    }\n    // beams\n    float d4 = length(r.xy-vec2(1.25,.75)+.15*sin(p.z*.75-T*3.5))-.025;\n    if(d4<res.x && sg > 0.) {\n        res = vec2(d4,31.);\n        hit=p;\n    }\n\n    vec2 d9=radio(qt);\n    if(d9.x<res.x) {\n        res = d9;\n        hit=qt;\n    }\n\n    if(sg==1.) glow = clamp(0.,1.,glow+(.0002/(.0075+d4*d4)) );\n    if(sg==2.) glow = clamp(0.,1.,glow+(.0001/(.0095+d4*d4)) );\n    if(res.y==22. && sg==1.) glow = clamp(0.,1.,glow+(.0012/(.0075+res.x*res.x)) );\n \treturn res;\n}\n\nvec3 normal(vec3 p, float t){\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e,0.).x+\n             h.yyx * map(p+h.yyx*e,0.).x+\n             h.yxy * map(p+h.yxy*e,0.).x+\n             h.xxx * map(p+h.xxx*e,0.).x;\n    return normalize(n);\n}\n\nvoid marcher(vec3 ro, vec3 rd, inout float d, inout float m, inout vec3 p, int steps, float sg) {\n    for(int i=0;i<steps;i++)\n    {\n        p=ro+rd*d;\n        vec2 ray = map(p, sg);\n        if(abs(ray.x)<MIN_DIST||d>MAX_DIST)break;\n        d+=i<64?ray.x*.5:ray.x;\n        m =ray.y;\n    }\n}\nvec3 eq(vec2 uv){\n// eq code\n    vec3 h=vec3(0);\n    vec2 vuv = uv;\n    vec3 ledc = vec3(0.020,0.710,0.941);\n    vec3 ledh = vec3(0.800,0.000,0.667);\n    vec3 clr=mix(ledh,ledc,(vuv.y+.5)*1.25);\n    float px = fwidth(uv.x);\n    vec2 mf = vec2(.005);\n    uv*=1.;uv*=10.;uv-=vec2(0,.5);\n    vec2 f = fract(uv)-.5;\n    vec2 fid = floor(uv)+.5;\n    float ht = sampleFreq(.005+(fid.x*mf.x));\n    ht*=1.25;\n    \n    float ff = box(f,vec2(.275))-.075;\n    float fm = abs(ff)-.05;\n    ff=smoothstep(.1+px,-px,ff);\n    fm=smoothstep(-px,+px,fm);\n    float avg = (fid.y*.095);  \n    if(ht>avg)h=mix(h,clr,ff);\n    return h;\n}\nvec3 render(vec3 ro,vec3 rd,vec2 uv) {\n\n    vec3 C = vec3(0);\n    vec3 FC= mix(vec3(0.220,0.063,0.376),vec3(0.086,0.851,0.953),.5+uv.y*.75);\n\n    float d = 0., m = 0.,bnc = 0.;\n    float fog = 0.;\n    vec3 p = ro + rd;\n    marcher(ro,rd,d,m,p,164,1.);\n\n    hitPoint=hit;\n    \n    if(d<MAX_DIST){\n        vec3 n = normal(p,d);\n\n        vec3 h = vec3(.0);\n     \n        if(m==31.) C = vec3(0.541,1.000,0.910);\n        if(m==22.) C = vec3(1.000,0.937,0.541);\n        if(m==24.) C = eq((hitPoint.xy+vec2(1.,.25))*1.75);\n        if(m==2.) {\n            vec2 hp = hitPoint.xz;\n            float count = R.y * .15;\n            float sl = sin(hp.y * count);\n            vec3 scanlines = vec3(0.514,0.380,1.000)* sl;\n            float st = abs(mod(time*1.75,25.))-6.;\n            float pz =(ro.z-p.z);\n            if(pz>=st && pz<=st+5.75) {\n                vec3 sclr = vec3(0.086,0.996,0.812)*( (pz-st)*max(st*.5,.5) *(scanlines*.5));\n                C=clamp(C+sclr,vec3(0),vec3(1));\n            }\n        }\n \n        fog=d;\n        if(m==2.||m==21.||m==22.) {\n            d=0.;m=0.;\n            vec3 rr=reflect(rd,n);\n            marcher(p+(n*MIN_DIST),rr,d,m,p,100,2.);\n            hitPoint=hit;\n            if(d<MAX_DIST){\n                C = mix(C, C+h,.075);\n                if(m==31.) C = vec3(0.541,1.000,0.910);\n                fog+=d;\n            } else {\n                C = FC;\n            }\n        } \n\n    } else {\n        C = FC;\n    }\n\n    C = mix(FC,C,  exp(-.000125*fog*fog*fog));\n    C = mix(C,min(vec3(1),(vec3(0.000,0.710,0.761)*glow)+glow),clamp(0.,1.,glow));   \n    return C;\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    time = iTime;\n    travelSpeed = time*2.25;\n    turn = rot(T*25.*PI/180.);\n    vec2 uv = (2.*F.xy - R.xy)/max(R.x,R.y);\n\tfloat md = mod(time*.1,2.);\n\n    vec3 lp = vec3(0.,0.,0.-travelSpeed);\n    vec3 ro = vec3(0.,.0,.25);\n    \n    float x = M.xy==vec2(0) || M.z<0. ? 0.:-(M.y/R.y*0.5-.25)*PI;\n    float y = M.xy==vec2(0) || M.z<0. ? 0.: (M.x/R.x*1.0-.50)*PI;\n    ro.zy*=rot(x);\n    \n    ro +=lp; \n \tlp.xy += path(lp.z);\n    ro.xy += path(ro.z);\n\n    // full camera setup \ud83c\udfa5\n    \n    vec3 f=normalize(lp-ro),\n         r=normalize(cross(vec3(0,1,0),f)),\n         u=normalize(cross(f,r)),\n         c=ro+f*.85,\n         i=c+uv.x*r+uv.y*u,\n         rd = i-ro;\n     \n    rd.xy = rot( -path(lp.z).x/ 24. )*rd.xy;\n    rd.xz = rot( y-path(lp.z+1.).y/ 14. )*rd.xz;\n    \n    vec3 C = render(ro,rd,uv);\n\n    C =pow(C, vec3(0.4545));\n    O = vec4(C,1.0);\n}\n// end\n","name":"Buffer A","description":"","type":"buffer"}]}