{"ver": "0.1", "info": {"id": "wsGcRK", "date": "1603273741", "viewed": 138, "name": "Voxel Game Test", "username": "gelami", "description": "WIP", "likes": 2, "published": 3, "flags": 48, "usePreview": 0, "tags": ["keyboard"], "requires": ["library", "texturebuf", "keyboardbuf", "imagebuf", "texture"]}, "renderpass": [{"inputs": [{"id": "4dXGR8", "filepath": "/media/previz/buffer00.png", "previewfilepath": "/media/previz/buffer00.png", "type": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "/*\n\tVoxel Game by gelami\n\thttps://www.shadertoy.com/view/wsGcRK\n\n\tTrying to make a voxel scene with controls and block placement.\n\n\tContents:\n\t- Buffer A: Raycasting and controls code\n\t- Buffer B: Terrain Generation\n\t- Buffer C: Textures\n\n\tControls:\n\t- Mouse: Look\n\t- LEFT/RIGHT ARROW KEYS: Turn left/right\n\t- A/S: Look up/down\n\t- UP/DOWN ARROW KEYS: Forward/backwards\n\t- SPACE: Fly up\n\t- LSHIFT: Fly down\n\t- Z/X: Place/remove block\n\n    TODO:\n\t- Terrain loading\n    - Fix gravity and ground collision code\n\t- Block place/remove delay\n\t- Bigger world (Bit pack tiles)\n\t- Optimizations (suggestions welcome!)\n\t- Anti-aliasing\n\t- Texture mipmapping and/or AA\n\n\tSpecial thanks:\n    - Branchless Voxel raycasting from fb39ca4 - https://www.shadertoy.com/view/4dX3zl\n\t- Other voxel code from Voxel Edges by iq - https://www.shadertoy.com/view/4dfGzs\n\t- Volume data structure derived from Flyguy - https://www.shadertoy.com/view/Ml3SD4\n\n*/\n\nvec4 highPassFilter(sampler2D sam, vec2 uv) {\n\n    vec2 st = vec2(1.) / iResolution.xy;\n    \n    vec2 off[9] = vec2[9]( vec2(-st.x, -st.y), vec2(0., -st.y), vec2(st.x, -st.y),\n                           vec2(-st.x, 0.), vec2(0., 0.), vec2(st.x, 0.),\n                           vec2(-st.x, st.y), vec2(0., st.y), vec2(st.x, st.y) );\n    \n    float k[9] = float[9]( -1., -1., -1.,\n                           -1.,  8., -1.,\n                           -1., -1., -1. );\n    \n\tvec4 sum = vec4(0.);\n    \n    for (int i = 0; i < 9; i++) {\n        vec4 tex = texture(sam, uv+off[i]);\n        \n    \tsum += tex * k[i];\n    }\n    //sum.a = 1.;\n    \n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 st = vec2(1.) / iResolution.xy;\n    \n    vec4 tex = texture(iChannel0, uv);\n    \n    // Wacky AA\n    vec4 texU = texture(iChannel0, uv+vec2(0., st.y));\n    vec4 texD = texture(iChannel0, uv+vec2(0., -st.y));\n    vec4 texL = texture(iChannel0, uv+vec2(st.x, 0.));\n    vec4 texR = texture(iChannel0, uv+vec2(-st.x, 0.));\n\n    float dx = step(st.x, abs(texL.a - texR.a));\n    float dy = step(st.y, abs(texU.a - texD.a));\n    \n    float ch = mod(fragCoord.x + fragCoord.y, 2.);\n    float dxdy = dx * dy;\n\n    float blockAA = smoothstep(.4, 1., tex.a);\n    \n    float blur = min(dxdy * (ch*.4+.6) + blockAA, 1.);\n    \n    vec4 col = mix(tex, (texU + texD + texL + texR) * .25, blur);\n    \n    // HPF AA (eugh)\n    //vec4 hpf = highPassFilter(iChannel0, uv);\n    //float b = step(st.x, hpf.a);\n    \n    //fragColor = vec4(cosPallete(tex.a * 4.), 1.);\n    //fragColor = vec4(tex.rgb + b, 1.);\n    \n    /*\n    if (uv.x > .5) {\n    \tfragColor = vec4(col);\n    } else {\n    \tfragColor = vec4(tex);\n    }*/\n    \n\tvec2 cruv = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n    \n    // Cross Pointer\n    vec2 sp = abs(cruv);\n    vec2 crs = step(st, sp);\n    \n    vec2 box = step(vec2(.02), sp);\n    float c = (1.-max(box.x, box.y))*(1.-crs.x*crs.y);\n    \n    col = mix(col, vec4(1.), c);\n    \n    fragColor = vec4(col);\n    \n    // Middle separator\n    //fragColor -= smoothstep(st.x*1.5, .0, abs(uv.x - .5));\n}", "name": "Image", "description": "", "type": "image"}, {"inputs": [{"id": "4dXGRr", "filepath": "/presets/tex00.jpg", "previewfilepath": "/presets/tex00.jpg", "type": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "4dXGR8", "filepath": "/media/previz/buffer00.png", "previewfilepath": "/media/previz/buffer00.png", "type": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "XsXGR8", "filepath": "/media/previz/buffer01.png", "previewfilepath": "/media/previz/buffer01.png", "type": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "4sXGR8", "filepath": "/media/previz/buffer02.png", "previewfilepath": "/media/previz/buffer02.png", "type": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dXGR8", "channel": 0}], "code": "\n#define Y_AXIS -1.\n\n// Constants\nconst float MOVE_SPEED = 0.6;\nconst float ROT_SPEED = .05;\nconst float JUMP_HEIGHT = .5;\n\nconst float PLACE_LENGTH = 100.;\n\nconst float GRAVITY = .2;\n\n// Raycasting Constants\nconst float MAX_RAY_STEPS = 150.;\nconst float FOG_START = MAX_RAY_STEPS * .8;\nconst float FOG_END = MAX_RAY_STEPS;\n\n\nbool getKeyPress(int key) {\n    return texelFetch(iChannel3, ivec2(key, 0), 0).x > 0.;\n}\n\nfloat getKeyPressF(int key) {\n    return texelFetch(iChannel3, ivec2(key, 0), 0).x;\n}\n\n// Volume data structure from Flyguy - https://www.shadertoy.com/view/Ml3SD4\nvec4 texture3D(sampler2D tex, vec3 uvw, vec3 vres)\n{\n    uvw = mod(floor(uvw * vres), vres);\n    float idx = (uvw.z * (vres.x*vres.y)) + (uvw.y * vres.x) + uvw.x;\n    vec2 uv = vec2(mod(idx, iResolution.x), floor(idx / iResolution.x));\n    \n    return texture(tex, (uv + 0.5) / iResolution.xy);\n}\n\nvec3 getTerrainFromVolume(vec3 p, vec3 vres) {\n    \n    vec4 tex = texture3D(iChannel2, p / vres, vres);\n    \n    vec3 st = step(p, vec3(0.)) + step(vres, p);\n    \n    //tex.r *= dot(st, vec3(1.)) > .5 ? 0. : 1.;\n    \n    return tex.rgb;\n}\n\nvec3 getVoxel(vec3 c, vec3 vres) {\n\tvec3 p = vec3(c);\n    \n    vec3 d = getTerrainFromVolume(p, vres);\n\treturn d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screenPos = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n    \n    vec4 oldMouse = textureLod(iChannel0, vec2(0., 2.5) / iResolution.xy, 0.);\n    vec4 mouse = iMouse / iResolution.xyxy;\n    \n    float px = 1. / iResolution.y;\n    \n\tvec3 camDir = vec3(0., 0., 1.);\n    vec3 camRot = textureLod(iChannel0, vec2(0., 1.5) / iResolution.xy, 0.).rgb;\n\tvec3 camPos = textureLod(iChannel0, vec2(0., 0.), 0.).rgb;\n    \n    if (iFrame == 0) {\n        camPos = vec3(6., 24., 12.);\n        camRot = vec3(.1, 0., 0.);\n        oldMouse = vec4(0.);\n    }\n    \n    camDir *= rot3d(camRot.xy * vec2(1., Y_AXIS));\n   \n    float zoom = 1.;\n\tvec3 camU = normalize(cross(vec3(0., 1., 0.), camDir));\n\tvec3 camV = cross(camDir, camU);\n\tvec3 rayDir = normalize(camDir*zoom + screenPos.x * camU + screenPos.y * camV);\n    \n\tvec3 vres = vec3(floor(pow(iResolution.x*iResolution.y, 1.0/3.0)));\n    \n    vec3 tilePos = vec3(camPos.x, 0., camPos.z);\n    vec3 chunkId = floor(tilePos / vres);\n    vec3 offset = chunkId * vres;//vec3(tilePos.x, 0., tilePos.z);\n    \n    camPos = mod(camPos, vres);\n    \n\tvec3 mapPos = floor(camPos);\n    \n    vec3 irayDir = 1. / rayDir;\n\t\n\tvec3 rayStep = sign(rayDir);\n\n\tvec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);\n\n\tvec3 sideDist = ((mapPos - camPos) + (rayStep * 0.5) + 0.5) * irayDir; \n\t\n\tbvec3 mask;\n    vec3 vmask;\n    \n    // From fb39ca4\n    // https://www.shadertoy.com/view/4dX3zl\n\tfloat d = 0.;\n    vec3 tile = vec3(0.);\n\tfor (; d < MAX_RAY_STEPS; d++) {\n        tile = getVoxel(mapPos, vres);\n        if (tile.r > 0.)\n            break;\n        \n        mask = lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy));\n        //mask = step(sideDist.xyz, sideDist.yzx) * step(sideDist.xyz, sideDist.zxy);\n        vmask = vec3(mask);\n        \n        sideDist += vmask * rayStep * irayDir;\n        mapPos += vmask * rayStep;\n\t}\n    \n    vec3 norm = -vmask * rayStep;\n    // Voxel UV mapping from Voxel Edges by iq\n    // https://www.shadertoy.com/view/4dfGzs\n    vec3 mini = (mapPos - camPos - (rayStep * 0.5) + 0.5) * irayDir;\n\tfloat t = max (mini.x, max(mini.y, mini.z));\n    \n    vec3 hitPos = camPos + rayDir*t;\n    \n    vec3 uvw = hitPos - mapPos;\n    vec2 uv = vec2(dot(vmask.yzx, hitPos), dot(vmask.zxy, hitPos));\n    \n    float ao = smoothstep(MAX_RAY_STEPS, 0., d);\n    float h = smoothstep(0., 10., mapPos.y);\n\t\n\tvec3 color;\n    \n    // Get tile from texture atlas\n    float idx = tile.g;\n    float w = floor(iResolution.x / TILE_SIZE);\n    \n    vec2 tuv = (fract(uv) + vec2(mod(idx, w), 0.)) * (TILE_SIZE);\n    \n    color = texture(iChannel1, tuv / iResolution.xy).rgb;\n    \n    mapPos = mod(mapPos, vres);\n    color = vec3(cosPallete(mapPos.y * mapPos.x * mapPos.z));\n    \n    float n = 0.;\n    \n    color *= dot(vmask, vec3(.6, 1., .8));\n    n = dot(vmask, vec3(0., 1., 2.));\n    \n    vec3 skyColor = vec3(.4, .6, .85);\n    vec3 skyColor2 = vec3(.7, .45, .5);\n    \n    vec3 sunDir = normalize(vec3(.1, -.5, .2));\n    sunDir.yx *= rot2d(iTime * .2);\n    \n    //color *= max(dot(norm, sunDir) * .8, .2);\n    \n    vec3 lightDir = normalize(camPos - hitPos);\n    \n    color *= max(dot(norm, lightDir), .2);\n    \n    color += pow(max(dot(norm, normalize(lightDir - rayDir)), 0.), 24.) * .6;\n    \n    float sunf = dot(rayDir, vec3(sunDir));\n    float sunc = pow(sunf, 12.);\n    \n    vec3 sunColor = mix(vec3(1., .7, .1), vec3(1., .98, .7), smoothstep(.95, .98, sunc));\n    \n    skyColor = mix(skyColor, skyColor2, max(sunf, 0.));\n    skyColor = mix(skyColor, sunColor, smoothstep(.8, 1., sunc));\n    \n    float cloudf = dot(rayDir, vec3(0., 1., 0.));\n    \n    if (d >= MAX_RAY_STEPS)\n        color = skyColor;\n    \n   \tfloat fogAmt = smoothstep(FOG_START, FOG_END, d);\n   \tcolor = mix(color, skyColor, fogAmt);\n    \n    // Vignette\n    color *= vec3(1. - pow(length(fragCoord.xy / iResolution.xy -.5), 3.) * .6);\n    \n\tfragColor = vec4(color, (d + n) / MAX_RAY_STEPS);\n    //fragColor = texture(iChannel2, fragCoord.xy / iResolution.xy);\n\t//fragColor = vec4(vec3(0.), 1.);\n    \n    // Controls\n    if (fragCoord.x < 1.) {\n    \n        vec3 tilePos = textureLod(iChannel0, vec2(0., 3.5) / iResolution.xy, 0.).rgb;\n        \n        if (fragCoord.y < 1.) {\n           \tvec3 flPos = floor(camPos - vec3(0., 2., 0.));\n            vec3 ter = getVoxel(flPos, vres);\n            float td = flPos.y - ter.x;\n            \n            /*if (td > 0.) {\n            \tcamPos.y -= GRAVITY;\n            } else {\n            \tcamPos.y -= camPos.y - ter.x;\n            }*/\n            \n            camPos.y += (getKeyPressF(KEY_SPACE) - getKeyPressF(KEY_LSHIFT)) * JUMP_HEIGHT;\n            \n            camPos += (getKeyPressF(KEY_UP) - getKeyPressF(KEY_DOWN)) * camDir * MOVE_SPEED;\n            \n            //camPos = vec3(fract(camPos.x), camPos.y, fract(camPos.z));\n            \n        \tfragColor = vec4(camPos, 1.);\n        } else if (fragCoord.y < 2.) {\n            \n            camRot.x += (getKeyPressF(KEY_LEFT) - getKeyPressF(KEY_RIGHT)) * ROT_SPEED;\n            camRot.y += (getKeyPressF(KEY_A) - getKeyPressF(KEY_S)) * ROT_SPEED;\n            \n            if (oldMouse.z > 0. && mouse.z > 0.) {\n                vec2 mouseDiff = mouse.xy - oldMouse.xy;\n            \tcamRot.xy += mouseDiff.xy * PI * -1.;\n            }\n            \n            camRot.y = clamp(camRot.y, -HALF_PI + .01, HALF_PI - .01);\n            \n            fragColor = vec4(camRot, 1.);\n        } else if (fragCoord.y < 3.) {\n            fragColor = mouse;\n        } else if (fragCoord.y < 4.) {\n            \n            tilePos = floor(camPos);// * step(camPos, vec3(1.));\n            \n        \tfragColor = vec4(tilePos, 1.);\n        }\n    }\n    \n    if (abs(screenPos.x) < px && abs(screenPos.y) < px &&\n        d < PLACE_LENGTH) {\n        if (getKeyPress(KEY_Z)) {\n        \tfragColor = vec4(mapPos - vmask * rayStep, 2.);\n        } else if (getKeyPress(KEY_X)) {\n        \tfragColor = vec4(mapPos, -1.);\n        }\n    }\n}", "name": "Buffer A", "description": "", "type": "buffer"}, {"inputs": [], "outputs": [], "code": "\n// Keys\n// Key codes from https://keycode.info/\nconst int KEY_SPACE = 32; // Fly up\n\nconst int KEY_LSHIFT = 16; // Fly down\n\nconst int KEY_LEFT  = 37; // Look\nconst int KEY_RIGHT = 39;\n\nconst int KEY_UP    = 38; // Forward\nconst int KEY_DOWN  = 40; // Backwards\n\nconst int KEY_Z = 90; // Place block\nconst int KEY_X = 88; // Remove block\n\nconst int KEY_C = 67; // unused\n\nconst int KEY_A = 65; // Look up\nconst int KEY_S = 83; // Look down\n\nconst float PI = \t 3.14159265359;\nconst float TWO_PI = 6.28318530718;\nconst float HALF_PI = PI * .5;\n\nmat2 rot2d(float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(c, -s, s, c);\t\n}\n\nmat3 rot3d(vec2 a) {\n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(a.y), sin(a.y), 0.0, -sin(a.y), cos(a.y));\n    mat3 rotY = mat3(cos(a.x), 0.0, -sin(a.x), 0.0, 1.0, 0.0, sin(a.x), 0.0, cos(a.x));\n    \n    return rotX * rotY;\n}\n\nvec3 cosPallete(float t) {\n\tvec3 a = vec3(.5,.5,.5);\n\tvec3 b = vec3(.5,.5,.5);\n    vec3 c = vec3(1.,1.,1.);\n    vec3 d = vec3(.0,.33,.67);\n    \n    return a + b * cos(2.*PI*(c*t+d));\n}\n\nvec3 cosPalleteD(float t, vec3 d) {\n\tvec3 a = vec3(.5,.5,.5);\n\tvec3 b = vec3(.5,.5,.5);\n    vec3 c = vec3(1.,1.,1.);\n    //vec3 d = vec3(.0,.33,.67);\n    \n    return a + b * cos(2.*PI*(c*t+d));\n}\n\n// Hash functions\n// from https://www.shadertoy.com/view/4djSRW\nfloat hash(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nconst float TILE_SIZE = 16.;\nconst float TILE_SIZE_P1 = TILE_SIZE + 1.;\n\nbool getMaterialColor( int i, vec2 coord, out vec3 color ) {\n\t// 16x16 tex\n\tvec2 uv = floor( coord );\n\n    float n = uv.x + uv.y*347.0 + 4321.0 * float(i);\n\tfloat h = hash(n);\n\t\t\n    float br = 1. - h * (96./255.\n\t\t\t\t\t\t);\n\tcolor = vec3( 150./255., 108./255.,  74./255.); // 0x966C4A;\n\t\n\tif (i == 4) {\n\t\tcolor = vec3( 127./255., 127./255., 127./255.); // 0x7F7F7F;\n\t}\n\t\n\tfloat xm1 = mod((uv.x * uv.x * 3. + uv.x * 81.) / 4., 4.);\n\t\n\tif (i == 1) {\n\t\tif( uv.y < (xm1 + 18.)) {\n\t\t\tcolor = vec3( 106./255., 170./255.,  64./255.); // 0x6AAA40;\n\t\t} else if (uv.y < (xm1 + 19.)) {\n\t\t\tbr = br * (2. / 3.);\n\t\t}\n\t}\n\t\n\tif (i == 7) {\n\t\tcolor = vec3( 103./255., 82./255.,  49./255.); // 0x675231;\n\t\tif (uv.x > 0. && uv.x < 15.\n\t\t\t&& ((uv.y > 0. && uv.y < 15.) || (uv.y > 32. && uv.y < 47.))) {\n\t\t\tcolor = vec3( 188./255., 152./255.,  98./255.); // 0xBC9862;\n\t\t\tfloat xd = (uv.x - 7.);\n\t\t\tfloat yd = (mod(uv.y, 16.) - 7.);\n\t\t\tif (xd < 0.)\n\t\t\t\txd = 1. - xd;\n\t\t\tif (yd < 0.)\n\t\t\t\tyd = 1. - yd;\n\t\t\tif (yd > xd)\n\t\t\t\txd = yd;\n\t\t\t\n\t\t\tbr = 1. - (h * (32./255.) + mod(xd, 4.) * (32./255.));\n\t\t} else if ( h < 0.5 ) {\n\t\t\tbr = br * (1.5 - mod(uv.x, 2.));\n\t\t}\n\t}\n\t\n\tif (i == 5) {\n\t\tcolor = vec3( 181./255.,  58./255.,  21./255.); // 0xB53A15;\n\t\tif ( mod(uv.x + (floor(uv.y / 4.) * 5.), 8.) == 0. || mod( uv.y, 4.) == 0.) {\n\t\t\tcolor = vec3( 188./255., 175./255., 165./255.); // 0xBCAFA5;\n\t\t}\n\t}\n\tif (i == 9) {\n\t\tcolor = vec3(  64./255.,  64./255., 255./255.); // 0x4040ff;\n\t}\n\t\n\tfloat brr = br;\n\tif (uv.y >= 32.)\n\t\tbrr /= 2.;\n\t\n\tif (i == 8) {\n\t\tcolor = vec3(  80./255., 217./255.,  55./255.); // 0x50D937;\n\t\tif ( h < 0.5) {\n\t\t\treturn false;\n\t\t}\n\t}\n\t\n\tcolor *= brr;\n\t\n\treturn true;\n}\n\n\n// From https://www.shadertoy.com/view/4dS3Wd\nfloat noise(vec3 x) {\n    const vec3 st = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, st);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(st, vec3(0, 0, 0))), hash(n + dot(st, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(st, vec3(0, 1, 0))), hash(n + dot(st, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(st, vec3(0, 0, 1))), hash(n + dot(st, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(st, vec3(0, 1, 1))), hash(n + dot(st, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\n#define OCTAVES 3\n\nfloat fbm(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < OCTAVES; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20201014 (stegu)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n{ \n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n    // Permutations\n    i = mod289(i); \n    vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}", "name": "Common", "description": "", "type": "common"}, {"inputs": [{"id": "4dXGzn", "filepath": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "type": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "4dXGR8", "filepath": "/media/previz/buffer00.png", "previewfilepath": "/media/previz/buffer00.png", "type": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "XsXGR8", "filepath": "/media/previz/buffer01.png", "previewfilepath": "/media/previz/buffer01.png", "type": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "XsXGR8", "channel": 0}], "code": "\n\nvec2 uv3Dto2D(vec3 uvw, vec3 vres) {\n\tuvw = mod(floor(uvw * vres), vres);\n    float idx = (uvw.z * (vres.x*vres.y)) + (uvw.y * vres.x) + uvw.x;\n    vec2 uv = vec2(mod(idx, iResolution.x), floor(idx / iResolution.x));\n    \n    return (uv + .5) / iResolution.xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy / iResolution.xy;\n    vec2 screenPos = (fragCoord.xy-.5*iResolution.xy) / iResolution.y;\n    \n    vec3 vres = vec3(floor(pow(iResolution.x*iResolution.y, 1.0/3.0)));\n    \n    vec4 place = texture(iChannel3, vec2(.5));\n    \n    vec2 px = vec2(1.) / iResolution.xy;\n    \n    vec2 coord = uv3Dto2D(place.rgb / vres, vres);\n    \n    fragColor = texture(iChannel0, pos);\n    \n\tvec3 tilePos = textureLod(iChannel3, vec2(0., 3.5) / iResolution.xy, 0.).rgb;\n    tilePos = vec3(tilePos.x, 0., tilePos.z);\n    \n    vec3 chunkId = floor(tilePos / vres);\n    vec3 offset = chunkId * vres;//vec3(tilePos.x, 0., tilePos.z);\n    \n    if (iFrame == 0) {\n        vec2 st = fragCoord.xy / iResolution.y;\n\n        vec2 uv = floor(fragCoord - 0.5);\n\n        float idx = (uv.y * iResolution.x) + uv.x;\n\n        vec3 stu = mod(floor(vec3(idx) / vec3(1.0, vres.x, vres.x*vres.y)), vres);\n        vec3 uvw = (stu + offset) / vres;\n\t\t\n        vec3 color = vec3(0.);\n    \t\n        color.r = fbm(vec3(uvw.x, 0., uvw.z)) - uvw.y * 2.;\n        color.g = floor(hash13(stu) * 8. + 1.);\n        \n        fragColor = vec4(color, 1.);\n    }\n    \n    if (abs(pos.x - coord.x) < px.x && abs(pos.y - coord.y) < px.y) {\n        if (place.a > 1.) {\n            vec3 color = vec3(floor(hash13(place.xyz) * 8. + 1.), .0, 0.);\n            fragColor = vec4(color, 1.);\n        } else if (place.a < 0.) {\n            fragColor = vec4(vec3(0.), 1.);\n        }\n    }\n}\n\n", "name": "Buffer B", "description": "", "type": "buffer"}, {"inputs": [{"id": "4sXGR8", "filepath": "/media/previz/buffer02.png", "previewfilepath": "/media/previz/buffer02.png", "type": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4sXGR8", "channel": 0}], "code": "\n\nvec3 getTexture(vec2 uv, float id) {\n    vec2 res = vec2(TILE_SIZE) / iResolution.xy;\n    float xs = floor(id * res.x);\n    uv = mod(uv * res, res);\n    \n\treturn texture(iChannel1, uv).rgb;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screenPos = fragCoord.xy / iResolution.xy;\n    \n    if (iFrame == 0) {\n\n        vec3 color;\n        \n        vec2 px = 1. / iResolution.xy;\n\n        float w = floor(iResolution.x / TILE_SIZE);\n        vec2 pos = floor(fragCoord.xy / TILE_SIZE);\n        vec2 uv = fragCoord.xy - pos;\n\n        float idx = mod(pos.x, w) + pos.y * w;\n        \n        uv = uv - pos;\n\n        getMaterialColor(int(idx), uv, color);\n\n        if (idx > 15.)\n            color = vec3(.8, 0., .8) * mod(pos.x + pos.y, 2.);\n\n        vec2 grid = vec2(1.-step(mod(fragCoord, TILE_SIZE), vec2(TILE_SIZE)));\n\n        color = mix(color, vec3(1.), grid.x+grid.y);\n\n        fragColor = vec4(color, 1.);\n    } else {\n        fragColor = texture(iChannel0, screenPos);\n    }\n}", "name": "Buffer C", "description": "", "type": "buffer"}]}