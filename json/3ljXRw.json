{"ver":"0.1","info":{"id":"3ljXRw","date":"1565397652","viewed":262,"name":"Paper Shapes ","username":"Yusef28","description":"Thats the best name I could think of.","likes":15,"published":1,"flags":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Most of these comments are helpful\n//some maybe not so much.\n\nmat2 rot(float a)\n{\n return mat2(cos(a), -sin(a), sin(a), cos(a));   \n}\nfloat shadowCircle(vec2 p, float r, float i)\n    {\n        //hacked: moving the shadow for light direction\n        p +=vec2(0.02, 0.02)*rot(iTime/10.);\n        \n        //using polor coordinates to make a cool shape : https://thebookofshaders.com/07/\n        float a  =atan( p.y,p.x);\n        float shape = sin(a*i+i/1.)/10.;\n \t\n        //SS is used as smoothstep range\n    \t//there is a much better way that fabrice told me about.\n        //It's in another shader. (Applause)\n        float ss = 0.05;\n        //shadow created with shape and 1.0-shadow so it returns as black where it should\n    \tfloat k = 1.0-smoothstep(r-ss, r+ss, length(p/1.5)+shape);\n    \treturn pow(k,1.2);\n}\n\nfloat rimCircle(vec2 p, float r, float i)\n{\n    //using polor coordinates to make a cool shape : https://thebookofshaders.com/07/\n    float a  =atan( p.y,p.x);\n    float shape = sin(a*i+i/1.)/10.;\n    \n    //SS is used as smoothstep range\n    //there is a much better way that fabrice told me about.\n    //It's in another shader. (Applause)\n \tfloat ss = 0.0042; \n        \n    //a rim range \n    float rim = 0.003;\n    //rim is a bigger circle subtracted by a smaller circle to leave just an edge\n    float k = smoothstep(r-ss, r+ss, length(p/1.5)+shape);\n    //k2 uses \"rim\" as the thickness of that edge\n    float k2 = smoothstep(r-ss+rim, r+ss+rim, length(p/1.5)+shape);\n    //here is the subtraction\n    k =k-k2;\n    //I return it clamped for some reason (applause)\n    return clamp(k/2., 0.0, 1.);\n}\n\nfloat Circle(vec2 p, float r, float i)\n{\n    \n    //SS is used as smoothstep range\n    //there is a much better way that fabrice told me about.\n    //It's in another shader. (Applause)\n \tfloat ss = 0.009;\n    \n    //using polor coordinates to make a cool shape : https://thebookofshaders.com/07/\n    float a  =atan( p.y,p.x);\n    float shape = sin(a*i+i/1.)/10.;\n    //creating the smoothstepped circle\n    float k = smoothstep(r-ss, r+ss, length(p/1.5)+shape); \n    //adding the rim circle here even though I do it in main. \n    //I dont' know why I did this but it seems to help! (APPLAUSE)\n    return k+rimCircle(p,r-0.001, i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //scaling and shifting so it goes from -1 to 1\n\tuv = uv*2.0-1.0;\n    //scaling uv.x to fix screen aspect ratio\n    uv.x*=iResolution.x/iResolution.y;\n    vec3 col = vec3(0.5, 0., 0.0);//init with a red color\n    //init a texture with rotating coordinate system so the texture moves with the shapes\n    float t = vec3(texture(iChannel0,uv/3.*rot(iTime/40.))).x;\n    \n    for(float i = 0.0;i<10.;i++){\n        //rotate coordinate system with time slowly\n        uv*=rot(iTime/40.);\n        t = vec3(texture(iChannel0,uv/3.)).x;\n        //add shadow to scene first since it's darkest and is shade of black.\n    \tcol *=shadowCircle(uv, 0.2+i/10., i);  \n\t\t//the most important part of this effect I think is the changing color brightness between layers, \n        //darkest at bottom although it's not exact since I'm not using a monochrome palette\n        col = mix(col, vec3(1., 0.2+i/10., 0.2+i/10.)-t*step(1.,mod(i,2.)), Circle(uv, 0.2+i/10., i));\n\t\t//creating a \"rim\" or a contour at the edges. Shane has a better one.\n        col = mix(col, vec3(1.,0.2+i/10.,0.2+i/10.), rimCircle(uv, 0.2+i/10., i)*i/10.);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}