{"ver": "0.1", "info": {"id": "3lSfDw", "date": "1599081224", "viewed": 197, "name": "Castle one", "username": "pjkarlik", "description": "Attempt to do some building using one wall and a lot of abs(p.xyz) functions to mirror space.  ", "likes": 22, "published": 3, "flags": 0, "tags": ["castle"], "requires": ["texture", "imagebuf", "library", "texturebuf"]}, "renderpass": [{"inputs": [{"id": "XsBSR3", "filepath": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "type": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "/** \n\tShader Experiments | Building practice\n\tBuilding stuff with just a wall\n\n\tCheezy moon and sky for mood\n*/\n\n#define R\t\t\tiResolution\n#define M\t\t\tiMouse\n#define T\t\t\tiTime\n#define S\t\t\tsmoothstep\n#define PI          3.1415926\n#define PI2         6.2831853\n\n#define MINDIST     .0001\n#define MAXDIST     115.\n#define r2(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nvec3 getMouse(vec3 ro) {\n    float x = M.xy == vec2(0) ? 0.5 : -(M.y/R.y * 1. - .5) * PI;\n    float y = M.xy == vec2(0) ? 0. : (M.x/R.x * 1. - .5) * PI;\n    ro.zy *=r2(x);\n    ro.xz *=r2(y);\n\treturn ro;   \n}\n//@Shane 3D Noise\nfloat n3D(vec3 p){\n    const vec3 s = vec3(113, 57, 27);\n    vec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    //p = p*p*(3. - 2.*p); // Equivalent to: p = smoothstep(0., 1., p);\n    p *= p*p*(p*(p*6. - 15.) + 10.); // Smoother alternative.\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n//2d noise\nvec3 noised( in vec2 x ){\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n    ivec2 p = ivec2(floor(x));\n    float a = texelFetch( iChannel1, (p+ivec2(0,0))&255, 0 ).x;\n\tfloat b = texelFetch( iChannel1, (p+ivec2(1,0))&255, 0 ).x;\n\tfloat c = texelFetch( iChannel1, (p+ivec2(0,1))&255, 0 ).x;\n\tfloat d = texelFetch( iChannel1, (p+ivec2(1,1))&255, 0 ).x;\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t\t\t6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n//---------------------------------------------------------------\n// @iq fbm generator\nfloat fbmd( in vec3 x, float oct ) {\n    const float scale  = .8;\n    float h = 0.0,w = 0.5,m = 2.0;\n    vec3  d = vec3(0.0);\n    for( float i=0.; i<oct; i++ ) {      \n        float n = n3D(m*x*scale);\n        h += w*n;\n        w *= 0.5;\n        m *= 1.8;\n    }\n\treturn h;\n}\n//2d fbm generator\nfloat cloudy( vec2 p, int freq ) {\t\n\tfloat h = -1.,w = 1.6, m = 0.35;\n\tfor (int i = 0; i < freq; i++) {\n\t\th += w * noised((p * m)).x;\n\t\tw *= 0.5;\n\t\tm *= 2.0;\n\t}\n\treturn h;\n}\n\n// http://mercury.sexy/hg_sdf/\n// Cylinder standing upright on the xz plane\nfloat fCyl(vec3 p, float r, float height) {\n\tfloat d = length(p.xy) - r;\n\td = max(d, abs(p.z) - height);\n\treturn d;\n}\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n// Same as above, but in two dimensions (an endless box)\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\nfloat zoom = 20.5;\nfloat glow = 0.;\nfloat speed = 1.;\nfloat oct = 4.;\n// --------- map functions ---------\nvec2 map(vec3 p, float sol) {\n\tvec2 res = vec2(MAXDIST,-1.);\n    vec3 q = p-vec3(0,0,T*speed);\n\tfloat df = fbmd(q*2.25,oct);//turn up or down depending on system (octaves)\n    df -= .65; // amount of decay\n    float dt = df*.03;\n    float f = q.y-.05;\n    if(f<res.x) res = vec2(f,1.);\n    \n\tfloat xd= pMod1(q.z,50.);\n    float yd= pMod1(q.x,50.);\n    pModPolar(q.zx,6.);\n    pMirrorOctant(q.zx,vec2(12., 5.));  \n    pMirrorOctant(q.xz,vec2(5.,15));   \n  \tq.x = - abs(q.x)+2.;\n    \n    float id= pMod1(q.z,2.);\n   \n    float wall = fBox(q,vec3(.25,5.,5.));\n    wall = max(wall,df/1.15);\n    wall = min(fBox(q+vec3(1.5,0.,0.),vec3(.25,.2,5.)),wall);\n    wall = min(fBox(q+vec3(2.,0.,0.),vec3(.5,.1,5.)),wall);\n\n    vec3 qb = vec3(q.x,q.y,mod(fract(q.z)+.5,1.)-.5);\n    wall = min(fBox(qb+vec3(1.5,0.,0.),vec3(.05,1.2,.05)),wall);\n\n    float lits = length(qb+vec3(1.5,-1.35,0.))-.05;\n    if (lits<res.x && sol==1.) {\n        res = vec2(lits,6.);\n    \tglow += .0025/(.000005+lits*lits);\n    }\n    \n    vec3 qr = q;\n    float roof = fBox(qr-vec3(2.75,4.5,0.),vec3(3.,.1,5.));\n    vec3 q2 = q;\n    q2.z = abs(q2.z)+.6;\n\n    float window = fBox(q2-vec3(0,.99,0),vec3(.4,1.,1.));\n    window=min(fCyl(q2.zyx-vec3(0,1.99,0.),1.,.4),window);\n\n    float tip = fBox(q2-vec3(0,5.,0),vec3(.08,.25,.8));\n    tip=min(fCyl(q2.zyx-vec3(0,5.24,0.),.8,.08),tip);\n    roof = min(tip,roof);\n    \n    float mainwall = fOpDifferenceStairs(wall,window,.25,3.);\n    float building = fOpUnionStairs(mainwall,roof,.25,3.)-dt;\n\n    if(building<res.x) res = vec2(building,2.);\n    \n    return res;\n}\n\n// ---------------------------------\n\nvec3 marcher(vec3 ro, vec3 rd, int maxstep, float sol){\n\tfloat d =  .00001,\n     \t  m = -1.;\n    \tfloat glowDist = 1e9;\n    \tint i = 0;\n        for(i=0;i<maxstep;i++){\n        \tvec3 p = ro + rd * d;\n            vec2 t = map(p, sol);\n            if(abs(t.x)<MINDIST)break;\n            d += t.x*.85;\n            m  = t.y;\n            if(d>MAXDIST)break;\n            glowDist = min(glowDist, d);\n        }\n    return vec3(d,m,glowDist);\n}\n\n// Tetrahedron technique @iq\n// https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 getNormal(vec3 p, float t){\n    float e = (MINDIST + .0001) *t;\n    vec2 h = vec2(1.,-1.)*.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ,0.).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ,0.).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ,0.).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ,0.).x );\n}\n\n//camera setup\nvec3 camera(vec3 lp, vec3 ro, vec2 uv) {\n    vec3 f=normalize(lp-ro),//camera forward\n         r=normalize(cross(vec3(0,1,0),f)),//camera right\n         u=normalize(cross(f,r)),//camera up\n         c=ro+f*.8,//zoom\n         i=c+uv.x*r+uv.y*u,//screen coords\n        rd=i-ro;//ray direction\n    return rd;\n}\n\nvec3 getCheck(vec3 p) {\n    float sc = .5;\n    vec2 f=fract(p.xz*sc)-0.5,h=fract(p.xy*sc)-0.5;\n    return f.x*f.y*h.y>0.? vec3(.8) : vec3(.5,.6,.55);  \n}\n\nvec3 getColor(float m, vec3 p) {\n    vec3 h = vec3(.5);\n    if(m==1.) h = getCheck(p-vec3(0,0,T*speed));\n    if(m==2.) h = vec3(.5,.6,.55);\n    if(m==5.) h = vec3(.5,.6,.7);\n    return h;\n}\n\nfloat getDiff(vec3 p, vec3 n, vec3 lpos) {\n    vec3 l = normalize(lpos-p);\n    float dif = clamp(dot(n,l),0. , 1.);\n    float shadow = marcher(p + n * .001 * 2., l, 64,0.).x;\n    if(shadow < length(p -  lpos)) dif *= .3;\n    return dif;\n}\n\n//https://www.shadertoy.com/view/MsVSWt\nvec3 getMoon(vec2 uv){\n    vec2 ms = vec2(.0,.5);\n\tfloat moon = 1.0 - distance(uv,ms);\n    moon = clamp(moon,0.0,1.0);\n    moon = pow(moon,50.0);\n    moon *= 100.0;\n    moon = clamp(moon,0.0,1.0);\n    return vec3(vec3(.65,.8,.7) * moon);\n}\n\nvoid mainImage( out vec4 O, in vec2 F ){\n    // Normalized pixel coordinates -1 to 1\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 C = vec3(0.);//default color\n    vec3 FC = vec3(.02);//fade color\n\n    // Look Point and Ray order\n\tvec3 lpos2 = vec3(-1.5,8.,15);\n    vec3 lp = vec3(0.,1.5,0.);\n    vec3 ro = vec3(2.,8.,15.);\n    \n    float tm = mod(T*.05, 3.);\n    // move x steps in rotation\n    if(tm>0.0 && tm<1.0){\n        lp = vec3(0.,1.5,0.);\n        ro = vec3(0.,2.-(.05*sin(T*1.5)),4.);\n        lpos2 = vec3(-1.5,2.,-6);\n        speed = .55;\n    }\n\n    if(tm>1.0 && tm<2.0){\n        lp = vec3(0,2.25,0.);\n        ro = vec3(1.-(7.*sin(25.+T*.05)),12.5,10.);\n        speed = 1.;\n        oct = 3.;\n    }\n    \n    if(tm>2.0 && tm<3.0){\n        lp = vec3(0.,1.2,0.);\n        ro = vec3(0.,1.25,.39);\n        ro.xz *=r2(90.*PI/180.);\n        lpos2 = vec3(1.5,12.,25.);\n        speed = .35;\n    }\n\n    //ro = getMouse(ro);\n\n\t// solve for Ray direction\n    vec3 rd = camera(lp,ro,uv);\n    \n    // trace scene\n    vec3 t = marcher(ro,rd,256,1.);\n    //vec2 rt = refmarcher(ro,rd,256);\n    float d = t.x,\n          m = t.y;\n\n    vec3 p;\n    \n    // sky clouds\n    float clouds = .0 - max(rd.y,0.0)*0.5; //@iq trick\n    vec2 sv = 1.75*rd.xz/rd.y;\n    clouds += 1.45*(-1.0+4.*S(-0.01,0.75,cloudy(sv-vec2(T*.75)*.75,4)));\n    vec3 sky = vec3(0.001);\n    \n    // if visible \n    if(d<MAXDIST){\n    \t\t p = ro + rd * d;\n        vec3 n = getNormal(p,d);\n\n        vec3 lpos  = vec3(1.5,8.,-15.),\n             l = normalize(p-lpos),\n             l2= normalize(p-lpos2);\n\n        float dif = getDiff(p,n,lpos);\n        \t  dif+= getDiff(p,n,lpos2);\n        vec3 h = getColor(m,p);\n        \n        C += h*dif;\n\n    } else {\n     \tsky = mix( vec3(clouds), C, exp(-00.10*max(rd.y,0.0)) )+ getMoon(uv); \n    }\n\t\n    C = mix(sky,C ,  exp(-.00012*t.x*t.x*t.x));\n\tC +=vec3(glow*.2);\n    O = vec4(pow(C, vec3(0.4545)),1.0);\n}", "name": "Image", "description": "", "type": "image"}, {"inputs": [], "outputs": [], "code": "// Helper functions\n// http://mercury.sexy/hg_sdf/\n\n#define PI          3.1415926\n#define PI2         6.2831853\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n    return (x<0.)?-1.:1.;\n}\nvec2 sgn(vec2 v) {\n    return vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);\n}\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n    return max(v.x, v.y);\n}\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\n// Repeat space along one axis.\nfloat pMod1(inout float p, float size) {\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;\n}\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = 2.*PI/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    float r = length(p);\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if (abs(c) >= (repetitions/2.)) c = abs(c);\n    return c;\n}\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n    float s = sgn(p);\n    p = abs(p)-dist;\n    return s;\n}\n// Mirror in both dimensions and at the diagonal, yielding one eighth of the space.\n// translate by dist before mirroring.\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) {\n    vec2 s = sgn(p);\n    pMirror(p.x, dist.x);\n    pMirror(p.y, dist.y);\n    if (p.y > p.x)\n        p.xy = p.yx;\n    return s;\n}\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n    p = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n// The \"Chamfer\" flavour makes a 45-degree chamfered edge (the diagonal of a square of size <r>):\nfloat fOpUnionChamfer(float a, float b, float r) {\n    return min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\n// Intersection has to deal with what is normally the inside of the resulting object\n// when using union, which we normally don't care about too much. Thus, intersection\n// implementations sometimes differ from union implementations.\nfloat fOpIntersectionChamfer(float a, float b, float r) {\n    return max(max(a, b), (a + r + b)*sqrt(0.5));\n}\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\n// BOS timing\nfloat linearstep(float begin, float end, float t) {\n    return clamp((t - begin) / (end - begin), 0.0, 1.0);\n}\n", "name": "Common", "description": "", "type": "common"}]}