{"ver": "0.1", "info": {"id": "XllGRl", "date": "1424307327", "viewed": 4764, "name": "Surface Splats", "username": "iq", "description": "Stochastic sampling a point cloud. A points cloud is generated per pixel, and the points are projected into screen space. A z/depth buffer mechanism resolves visibility, and then shading happens in a deferred manner.", "likes": 55, "published": 3, "flags": 0, "tags": ["cloud", "projection"], "requires": ["texture", "imagebuf", "texturebuf"]}, "renderpass": [{"inputs": [{"id": "XsXGRn", "filepath": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "type": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "// Created by inigo quilez - iq/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Stochastic rasterization of splats.\n//\n// Random points are generated at the surface of some parametric objects, and the points are\n// projected into screen space. A z/depth buffer mechanism resolves visibility, and then shading\n// happens in a dererred manner.\n//\n// I think I first saw this technique in Texel's entry to js01k a few years ago.\n//\n// The object probability distribution is proportional to the area of the object's surface area.\n\nvec3 sphere( in vec2 t )\n{\n    float y = -1.0 + 2.0*t.y;\n    vec2 q = vec2( t.x*6.2831, acos(y) );\n    return vec3( cos(q.x)*sin(q.y), y, sin(q.x)*sin(q.y) );\n}\n\nvec3 cylinder( in vec2 t )\n{\n    float q = t.x*6.2831;\n    return vec3( 0.5*cos(q), -1.0 + 4.0*t.y, 0.5*sin(q) );\n}\n\nvec3 quad( in vec2 t )\n{\n    return 3.0*vec3( -1.0+2.0*t.x, 0.0, -1.0+2.0*t.y );\n}\n\nfloat rand( in float p )  { return fract( p/0.123454); }\nvec3  rand( in vec3  p )  { return fract( p/0.123454); }\n\nfloat hash1( in float n ) { return fract(sin(n)*43758.5453123); }\nvec2  hash2( in float n ) { return fract(sin(vec2(n,n+3.1))*43758.5453123); }\nvec3  hash3( in float n ) { return fract(sin(vec3(n,n+3.1,n+5.7))*43758.5453123); }\n\nmat4 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat4( cu.x, cu.y, cu.z, 0.0,\n                 cv.x, cv.y, cv.z, 0.0,\n                 cw.x, cw.y, cw.z, 0.0,\n                 ro.x, ro.y, ro.z, 1.0 );\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\n//==============================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel    \n\tvec2 p = (-iResolution.xy+2.0*fragCoord.xy) / iResolution.y;\n    \n    // camera\n    float an = iTime;\n    vec3  ro = 4.0*normalize(vec3(cos(an), 0.0, sin(an)));\n\tvec3  ta = vec3(0.0, 0.0, 0.0);\n    \n    // camera-to-world abd world-to-camear transform\n    mat4 c2w = setCamera( ro, ta, 0.0 );\n    mat4 w2c = inverse(c2w);\n    \n    vec3 col = vec3( 0.0 );\n\n    float dither = smoothstep( -0.1, 0.1, sin(iTime) );\n    \n    float off = 0.5 + hash1( iTime*0.0 + dither*dot(fragCoord.xy,vec2(113.0,317.0)) );\n    vec3 t = hash3( off );\n    \n    \n    float fz = 1e10;         // depth buffer\n    vec2  uv = vec2(-1.0);                  \n    float fi = -1.0;\n    for( int i=0; i<1024; i++ )\n    {\n        // pick a random point on the surface of the scene\n\n        // area of the sphere   = 12.6\n        // area of the plane    = 36.0\n        // area of the cylinder = 15.7\n        vec3 w; float id;\n             if( t.z<((15.7     )/64.3) ) { id=0.0; w = vec3(2.0, 0.0,0.0)+cylinder( t.xy ); }\n        else if( t.z<((15.7+36.0)/64.3) ) { id=1.0; w = vec3(0.0,-1.0,0.0)+quad(     t.xy ); }\n        else                              { id=2.0; w =                    sphere(   t.xy ); }\n            \n        // convert to camera space\n        vec3 q = (w2c * vec4(w,1.0)).xyz;\n            \n        // if in front of clipping plane\n        if( q.z>0.01 )\n        {\n#if 0            \n            // project            \n            vec2 s = q.xy/q.z;\n\n            // splat with depth test        \n            if( (q.z*q.z*dot2(s-p))<0.02 && q.z<fz )\n#else\n            // project and splat with depth test, WITHOUT divisions!!\n            if( dot2(q.xy-p*q.z)<0.02 && q.z<fz )\n#endif\n            {\n                fz = q.z;\n                uv = t.xy;\n                fi = id;\n            }\n        }\n        \n        // generate new random sample        \n        t = rand( t );\n    }\n    \n    // if splat\n    if( fi>-0.5 )\n    {\n        // compute position, normals and occlusion\n        vec3 pos, nor; float occ;\n        \n             if( fi<0.5 ) { pos = vec3(2.0, 0.0,0.0)+cylinder( uv ); nor = normalize( cylinder( uv )*vec3(1.0,0.0,1.0) ); occ = 0.5 + 0.5*smoothstep(-1.0,1.0,pos.y ); }\n        else if( fi<1.5 ) { pos = vec3(0.0,-1.0,0.0)+quad(     uv ); nor = vec3(0.0,1.0,0.0);                             occ = smoothstep(0.0,2.0,length(pos.xz)) * smoothstep(0.0,2.0,length(pos.xz-vec2(2.0,0.0)));}\n        else              { pos =                    sphere(   uv ); nor = normalize(sphere( uv ));                       occ = 0.5 + 0.5*nor.y; }\n\n        // shade        \n        col = texture( iChannel0, 2.0*uv, -1000.0 ).xyz * occ + 0.1*nor.yxz*occ;\n        \n        // gamma\n        col = sqrt( col );\n    }\n    \n\tfragColor = vec4( col, 1.0 );\n}", "name": "Image", "description": "", "type": "image"}]}