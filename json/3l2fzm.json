{"ver": "0.1", "info": {"id": "3l2fzm", "date": "1598621431", "viewed": 222, "name": "Fractal Reactor", "username": "pjkarlik", "description": "Playing with glow / neon and some fractal formulas - this one is really fun actually as long as you keep things .001 and less..\nClick / Drag - check full screen", "likes": 18, "published": 3, "flags": 0, "tags": ["neon"], "requires": ["texture", "imagebuf", "texturebuf"]}, "renderpass": [{"inputs": [{"id": "XsBSR3", "filepath": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "type": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "// My standard defines and constants\n// Also makes transport of code easy\n// not tied to uniform names\n#define R\t\t\tiResolution\n#define M\t\t\tiMouse\n#define T\t\t\tiTime\n#define S\t\t\tsmoothstep\n#define PI          3.1415926\n#define PI2         6.2831853\n#define d5\t\t\t.5773\n#define MINDIST     .0001\n#define MAXDIST     100.\n\n#define r2(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define hash(a, b) fract(sin(a*1.2664745 + b*.9560333 + 3.) * 14958.5453)\n/**\n\tFractal Reactor | pjk\n\n*/\nfloat circle(vec2 pt, vec2 center, float r, float lw) {\n  float len = length(pt - center),\n        hlw = lw / 2.,\n        edge = .01;\n  return smoothstep(r-hlw-edge,r-hlw, len)-smoothstep(r+hlw,r+hlw+edge, len);\n}\n\nvec3 getMouse(vec3 p) {\n    float x = M.xy == vec2(0) ? 0. : -(M.y/R.y * 1. - .5) * PI;\n    float y = M.xy == vec2(0) ? 0. :  (M.x/R.x * 1. - .5) * PI;\n    \n    p.zy *=r2(x);\n    p.xz *=r2(y);\n    return p;\n}\n\nfloat orbit = 0.,\n      glw \t= 0.;\nfloat zoom = .5; \nmat2 rotA,rotB,spin;\nvec3 map(vec3 p) {\n    p.xz*=spin;\n    vec3 res = vec3(1000.,0.,-1);\n    float Tm = sin(.003);\n    vec4 z = vec4(p,1.25);\n    // 2 ok - 4 is cool - 6 is nuts\n    for (int n = 0; n < 4; n++) {\n        z.xyz=clamp(z.xyz, -Tm, Tm) *2.0-z.xyz;\n        z.zy*=rotA;\n        z*=Tm/max(dot(z.xyz, z.xyz), 0.037 *Tm); //.137\n        z.xy*=rotB;\n    }\n\t// all numbers gotta be smol \n  \tvec3 dn = max(abs(z.xyz)-vec3(.005,.25,.005),0.0);\n    // shape just for glow\n    float df =length(max(abs(z.yxz)-vec3(.0001,3.,.0001),-dn))/z.w;\n    glw += .0000025/(.000005+df*df);\n\n    orbit = log2(z.w*.735);\n    float d = length(dn)/z.w;\n\n    res = vec3(d,1.,orbit);\n    if(df<res.x) res = vec3(df,2.,orbit);\n    return res;\n}\n\n// distance estimator\nvec3 marcher(vec3 ro, vec3 rd, int maxsteps) {\n    float d = 0.,\n          m = -1.,\n          o = 0.;\n    int i = 0;\n    for(i = 0; i<maxsteps; i++) {\n    \tvec3 p = ro + rd * d;\n        vec3 t = map(p);\n        if(t.x<MINDIST||d>MAXDIST) break;\n        d += t.x*.75;\n        m  = t.y;\n        o  = t.z;\n    }\n    float de = float(i)/float(maxsteps);\n\treturn vec3(d,m,o);\n}\n\n// Tetrahedron technique @iq\n// https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 getNormal(vec3 p, float t){\n    float e = (MINDIST + .0002) *t;\n    vec2 h = vec2(1.,-1.)*.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n}\n\n//camera setup\nvec3 camera(vec3 lp, vec3 ro, vec2 uv) {\n    vec3 f=normalize(lp-ro),//camera forward\n         r=normalize(cross(vec3(0,1,0),f)),//camera right\n         u=normalize(cross(f,r)),//camera up\n         c=ro+f*.95,//zoom\n         i=c+uv.x*r+uv.y*u,//screen coords\n         rd=i-ro;//ray direction\n    return rd;\n}\n\nvec3 gethue(float a){return  .45 + .42*cos((8.5*a) - vec3(1.,2.,2.5));}\n\nvec3 getColor(float m, float o){\n    vec3 h = gethue(o*.25);\n    // use orbit number to band coloring\n    if(o>7.15  \t&& o<7.65) \th=vec3(1.);\n    if(o>8.  \t&& o<8.1) \th=vec3(1.);\n    if(o>.0  \t&& o<.5) \th=vec3(1.);\n    if(o>-.1  \t&& o<-.05) \th=vec3(1.);\n    if(o>-2.4 \t&& o<-1.75) h=vec3(1.);\n    if(o>-4.8 \t&& o<-2.75) h=vec3(1.);\n    if(o>-6.  \t&& o<-5.75) h=vec3(1.);\n    if(o>-9.  \t&& o<-8.75) h=vec3(1.);\n    if(o>-8.5  \t&& o<-6.75) h=vec3(1.);\n \treturn h;\n}\n\nfloat ao(float j, vec3 p, vec3 n) {\n    return clamp(map(p + n*j).x/j, 0.,1.);   \n}\n\nvoid mainImage( out vec4 O, in vec2 F ){\n    // Precalculations to speed map \n    rotA = r2(45.*PI/180.);\n    rotB = r2(25.*PI/180.);\n    spin = r2(T*.06);\n    // zoom in and out by time\n    float ft = mod(T*.05,2.);\n    if(ft<1.) zoom = .099;\n\n    // Normalized pixel coordinates -1 to 1\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 C = vec3(0.);\n    zoom += .11+.04*sin(T*.12);\n    vec3 lp = vec3(0.,0.,0.),\n         ro = vec3(0.,0.,zoom);\n    \t ro = getMouse(ro);\n\n    vec3 rd = camera(lp, ro, uv);\n    vec3 t = marcher(ro,rd, 256);\n    \n    float m = t.y;\n    float o = t.z;\n    \n    if(t.x<MAXDIST) {\n    \tvec3 p = ro + rd * t.x,\n             n = getNormal(p, t.x);\n        \n        vec3 light1 = vec3(0,1.,-1.0),\n             light2 = vec3(0,1.,1.0);\n    \tfloat dif  = clamp(dot(n,normalize(light1-p)),0. , 1.);\n              dif += clamp(dot(n,normalize(light2-p)),0. , 1.);\n\n        vec3 h = (m==1.) ? getColor(m,o) : vec3(1);\n        \n        C += dif* (ao (0.005,p,n) + ao(.01,p,n))*h*vec3(2.);\n        \n    } else {\n        C += vec3(.45);\n    }\n    // Background - I enjoy the slight motion stuff\n\tvec2 dv = uv+vec2(T*.041,-T*.023);\n    float cir = .45+circle(fract(dv*12.),vec2(0.5),.64,.01)*2.5;\n    cir += circle(fract(dv*12.),vec2(0.5),.55,.015);\n    // Fog / Blending\n    C = mix( C, vec3(cir*.08), 1.-exp(-.00125*t.x*t.x*t.x));\n    // add back glow\n    C += vec3(glw*.3);\n    // Texture-ish\n    C *=vec3(texture(iChannel1,uv/.95)).x*.5;\n    // Output to screen\n    O = vec4(pow(C, vec3(0.4545)),1.0);\n}", "name": "Image", "description": "", "type": "image"}]}