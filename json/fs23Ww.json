{"ver":"0.1","info":{"id":"fs23Ww","date":"1617491089","viewed":62,"name":"Analytic 2D Optimization","username":"oneshade","description":"It took me a while to figure out how optimization works in 2D. Well, now I know!","likes":1,"published":1,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) 0.6 + 0.6 * cos(6.3 * hue + vec3(0.0, 23.0, 21.0))\n\n// Settings\n#define CONTOUR_SPACING 1.0\n#define CONTOUR_THICKNESS 2.0\n#define DELTA 0.001\n\n// Coefficients\n#define a vec2(1.0 + 0.5 * cos(iTime), 1.0 + 0.5 * sin(iTime)) // vec2(a, b)\n#define b vec2(sin(iTime * 0.5) * 0.5, cos(iTime) * 0.5)       // vec2(c, d)\n#define c cos(iTime)                                           // e\n\n// Function\nfloat f(in vec2 p) {\n    return dot(a, p * p) + dot(b, p) + c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float unit = CONTOUR_THICKNESS / iResolution.y * 4.0;\n    vec3 color = vec3(0.0);\n\n    // Draw contours\n    float hSpacing = 0.5 * CONTOUR_SPACING;\n    float fRes = f(uv);\n\n    float grad = length(vec2(f(uv + vec2(DELTA, 0.0)) - f(uv - vec2(DELTA, 0.0)),\n                             f(uv + vec2(0.0, DELTA)) - f(uv - vec2(0.0, DELTA)))) / (2.0 * DELTA);\n\n    float contour = abs(mod(fRes + hSpacing, CONTOUR_SPACING) - hSpacing) / grad;\n    color = vec3(fRes * 0.1) - smoothstep(unit, 0.0, contour);\n\n    // Optimization\n    /*\n    f(x, y) = ax^2 + by^2 + cx + dy + e\n\n    Compute partial derivatives\n    \u2202f/\u2202x = 2ax + c\n    \u2202f/\u2202y = 2by + d\n\n    Set the partial derivatives equal to zero\n    2ax + c = 0\n    2by + d = 0\n\n    The solution to the system is the optimum\n    x = -c/(2a)\n    y = -d/(2b)\n    */\n\n    vec2 optimum = -b / (2.0 * a);\n    color = mix(color, vec3(1.0, 0.0, 0.0), smoothstep(unit, 0.0, abs(2.0 * a.x * uv.x + b.x) - 0.025));\n    color = mix(color, vec3(0.0, 0.0, 1.0), smoothstep(unit, 0.0, abs(2.0 * a.y * uv.y + b.y) - 0.025));\n    color = mix(color, vec3(0.0, 1.0, 0.0), smoothstep(unit, 0.0, length(uv - optimum) - 0.05));\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}