{"ver":"0.1","info":{"id":"Wt3cRr","date":"1608740496","viewed":725,"name":"GRDXTRI2","username":"pjkarlik","description":"grid play / triangles - phased glow effect on grid triangles based on noise return.","likes":17,"published":3,"flags":32,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define LOOKUP(COORD) texture(iChannel0,(COORD))\n// silly rgb sepration based post effect\n\n// MORE JUST LEARNING - ways of doing grids and stuff\n// Triangle using the 4 tap system\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\n\tvec2 uv = fragCoord.xy/iResolution.xy;    \n\n    vec3 color = LOOKUP(uv).rgb;\n    // effect sammple\n    vec3 fgclr = vec3(0.);\n    float f = length(uv  - 1.75);\n    fgclr.x = LOOKUP(uv - vec2(f*0.002,.001)).x;\n    fgclr.y = LOOKUP(uv + vec2(f*0.002,.003)).y;\n    fgclr.z = LOOKUP(uv + vec2(f*0.002,.002)).z;\n    // mask for effect and mixdown \n    float dt = distance(uv.xy,vec2(.5))*.32;\n    dt = smoothstep(0.85,.9,1.-dt);\n    vec3 fColor = mix(fgclr,color,dt)*vec3(0.976,0.984,0.596);\n    // output\n    fragColor = vec4(fColor,1.);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define R       iResolution\n#define T       iTime\n#define M       iMouse\n#define PI      3.141592653\n#define PI2     6.283185307\n#define r2(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define min_dist    .001\n#define max_dist    200.\n\nvoid getMouse( inout vec3 p ) {\n    float x = M.xy == vec2(0) ? 0. : -(M.y/R.y * .5 - .25) * PI;\n    float y = M.xy == vec2(0) ? 0. : (M.x/R.x * .125 - .0625) * PI;\n    p.zy *=r2(x);\n    p.xz *=r2(y);   \n}\n\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n// vec2 to vec2 hash.\n// @Shane https://www.shadertoy.com/view/3d2fzK\nvec2 hash22(vec2 p) { \n    float n = sin(dot(p, vec2(27, 57)));\n    return fract(vec2(262144, 32768)*n)*2. - 1.;  \n}\n// Based on IQ's gradient noise formula.\nfloat n2D3G( in vec2 p ){\n    vec2 i = floor(p); p -= i;\n    \n    vec4 v;\n    v.x = dot(hash22(i), p);\n    v.y = dot(hash22(i + vec2(1, 0)), p - vec2(1, 0));\n    v.z = dot(hash22(i + vec2(0, 1)), p - vec2(0, 1));\n    v.w = dot(hash22(i + 1.), p - 1.);\n    p = p*p*(3. - 2.*p);\n\n    return mix(mix(v.x, v.y, p.x), mix(v.z, v.w, p.x), p.y);\n}\n//@iq\nfloat sdTriPrism( vec3 p, vec2 h ){\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n// set const and globals\nconst float scale = 2./ 4.25;\nconst vec2 l = vec2(scale*1.732/2.93, scale);\nconst vec2 s = l*2.;\nconst vec2[4] ps4 = vec2[4](vec2(-l.x, l.y),l + vec2(0., l.y),vec2(l.x, -l.y),vec2(0.,l.y) + vec2(-l.x, -l.y));\n        \nmat2 r180,r90,r45;\nfloat gh,gm,t25,ft,glow;\n\nvec2 map(vec3 q3, float sg){\n    q3.y -= t25;\n    float d = 1e5, m = 0.;\n    vec2 p, ip,\n        id = vec2(0),\n        ct = vec2(0);\n\n    for(int i = 0; i<4; i++){\n        ct = ps4[i]/2.; \n        p = q3.xy - ct; \n        ip = floor(p/s) + .5;\n        p -= (ip)*s; \n        vec2 idi = (ip)*s + ct;\n        \n        vec3 q = vec3(p.x,p.y,q3.z);\n        //flip\n        if(i==1||i==3) {\n            q.xy *= r180;\n            q.y  -= scale*.1725;\n        } \n\n        float sw = n2D3G(idi*.62);\n        float zw = n2D3G(idi+ft);\n        float dw = sw*2.5;\n        q.z+=dw;\n        \n        float tt = .22+.1*sin((sw*.7)+(T*.2));\n        float di = sdTriPrism(q,l.xy);\n\n        if(di<d) {\n            d = di*.95;\n            gh = sw;\n            m= (zw>.15) ? 2. : 1.;\n            if(tt>.22 && tt<.235 && sg>0.) glow += .00045/(.0002+di*di);\n        }\n    }\n    \n    return vec2(d/1.25,m);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, float sg, int maxsteps) {\n    float d = 0.;\n    float m = 0.;\n    for(int i = 0;i<maxsteps;i++){\n        vec2 t = map(ro+rd*d, sg);\n        if(abs(t.x)<min_dist*d||d>max_dist) break;\n        d += i<64 ?t.x*.35 : t.x *.85;\n        m  = t.y;\n    }\n    return vec2(d,m);\n}\n\n// Tetrahedron technique @iq\n// https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 getNormal(vec3 p, float t){\n    float e = min_dist *t;\n    vec2 h = vec2(1.,-1.)*.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ,0. ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ,0. ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ,0. ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ,0. ).x );\n}\n\n// softshadow www.pouet.net\n// http://www.pouet.net/topic.php?which=7931\nfloat softshadow( vec3 ro, vec3 rd, float mint, float maxt, float k ){\n    float res = 1.0;\n    for( float t=mint; t < maxt; ){\n        float h = map(ro + rd*t, 0.).x;\n        if( h<0.001 ) return 0.2;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res+0.2;\n}\n\n//@Shane AO\nfloat calcAO(in vec3 p, in vec3 n){\n    float sca = 2., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n        float hr = float(i + 1)*.16/8.; \n        float d = map(p + n* hr, 0.).x;\n        occ += (hr - d)*sca;\n        sca *= .8;\n        if(sca>1e5) break;\n    }\n    return clamp(1. - occ, 0., 1.);\n}\n\n//@iq https://iquilezles.org/www/articles/palettes\nvec3 getHue(float t){ \n    vec3 c = vec3(.5, .5, .25),\n         d = vec3(1., .5, .25);\n    return .45+.35 *cos(T*.1+PI*(c*t+d) ); \n}\n\nvec3 camera(vec3 lp, vec3 ro, vec2 uv) {\n    vec3 cf = normalize(lp-ro),\n         cr = normalize(cross(vec3(0,1,0),cf)),\n         cu = normalize(cross(cf,cr)),\n          c = ro + cf * .65,\n          i = c + uv.x * cr + uv.y * cu,\n         rd = i - ro;\n    return rd;\n}\n\nfloat ghash;\nvoid mainImage( out vec4 O, in vec2 F ) {\n    // Normalized pixel coordinates\n    r180 = r2(180.*PI/180.);\n    r90 = r2(90.*PI/180.);\n    r45 = r2(45.*PI/180.);\n    t25 = (T*.55);\n    ft = floor(T*.75);\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 C = vec3(0.),\n         FC = vec3(.35);\n    \n    vec3 lp = vec3(0,0.,0),\n         ro = vec3(0,0.,4.);\n    getMouse(ro);\n    vec3 rd = camera(lp,ro,uv);\n    \n    vec2 t = marcher(ro,rd,1.,164);\n\tghash=gh;\n    vec3 h;\n    if(t.x<max_dist){\n        vec3 p = ro+t.x*rd,\n             n = getNormal(p,t.x);\n             h = t.y == 1. ? getHue(ghash*2.75) : getHue(125.+ghash*1.25); //+(ghash*5.75)\n        vec3 lpos1 = vec3(2.5, -4., 5.5);\n        vec3 lp = normalize(lpos1-p);\n        float shadow = softshadow(p + n * min_dist, lp, .1, 28., 32.);     \n        float diff = clamp(dot(n,lp),.01 , 1.);\n\n        float ao = calcAO(p,n);\n        \n        C += (h * diff * shadow) + (ao*h);\n\n    }\n    // Output to screen\n   \n    C = mix( C, FC, 1.-exp(-.000065*t.x*t.x*t.x));\n    C += (glow*.25);\n    O = vec4(pow(C, vec3(0.4545)),1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}