{"ver":"0.1","info":{"id":"XdlXz4","date":"1397571160","viewed":3348,"name":"Fur character face","username":"hat","description":"The shader works much better with more furLayers (~100) and a little less furThreshold (~0.4). Sadly it requires low iterations to work in most computers.","likes":4,"published":1,"flags":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\t\r\n\t//These values control the general shape ray marching\r\n\tconst int max_iterations = 20;\r\n\tconst int furLayers = 50;\r\n\tconst float stop_threshold = 0.001;\r\n\tconst float grad_step = 0.001;\r\n\tconst float clip_far = 5.0;\r\n\tconst float PI = 3.14159265359;\r\n\t\r\n\r\n\t//These values are for the simple animation.\r\n\tfloat animateAfter = step(-iTime, -5.);\r\n\tfloat rotationY = 14. * sin(iTime * 1.4) * animateAfter;\r\n\tfloat rotationX = (8. * cos(iTime * 0.9) * animateAfter + 10.);\r\n\tfloat elevation = cos(iTime * 0.9) * animateAfter;\r\n\r\n\r\n\t//Rotation functions\r\n\tmat3 rotX(float g) {\r\n\t\tg = radians(g);\r\n\t\tvec2 a = vec2(cos(g), sin(g));\r\n\t\treturn mat3(1.0, 0.0, 0.0, 0.0, a.x, -a.y, 0.0, a.y, a.x);\r\n\t}\r\n\t\r\n\tmat3 rotY(float g) {\r\n\t\tg = radians(g);\r\n\t\tvec2 a = vec2(cos(g), sin(g));\r\n\t\treturn mat3(a.x, 0.0, a.y, 0.0, 1.0, 0.0, -a.y, 0.0, a.x);\r\n\t}\r\n\r\n\tmat3 rotZ(float g) {\r\n\t\tg = radians(g);\r\n\t\tvec2 a = vec2(cos(g), sin(g));\r\n\t\treturn mat3(a.x, a.y, 0.0, -a.y, a.x, 0.0, 0.0, 0.0, 1.0);\r\n\t}\r\n\r\n\t//Axis displacement on a surface.\r\n\tfloat dd(float u, vec3 v) {\r\n\t\tv.x *= 0.5;\r\n\t\tfloat s = (u + v.x) * step(-u, v.x) * step(u, v.y - v.x) / v.y;\r\n\t\ts += step(-u, v.x - v.y) * step(u, v.x - v.z);\r\n\t\ts += (v.x - u) * step(-u, v.z - v.x) * step(u, v.x) / v.z;\t\t\r\n\t\ts = s * s * (3. - 2. * s);\r\n\t\t\r\n\t\treturn s;\r\n\t}\r\n\r\n\t//Iq noise functions...\r\n\tfloat hash( float n ) {\r\n\t    return fract(sin(n)*43758.5453);\r\n\t}\r\n\r\n\tfloat noise( in vec3 x ) {\r\n   \t vec3 p = floor(x);\r\n   \t vec3 f = fract(x);\r\n\t\r\n\t    f = f*f*(3.0-2.0*f);\r\n\t    float n = p.x + p.y*57.0 + 113.0*p.z;\r\n\t    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\r\n\t                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\r\n\t               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\r\n\t                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\r\n\t}\r\n\r\n\t/*\r\n\t* Deformations used to modify a sphere into the \r\n\t* shape of the head, it deforms the space to obtain\r\n\t* global or local changes like the zone of the eyes.\r\n\t*/\r\n\tvec3 deformation(vec3 p) {\r\n\t\t\r\n\t\tp *= rotY(rotationY);\r\n\t\tp *= rotX(rotationX);\r\n\t\tp.y *= 0.85;\t\t\r\n\t\t\r\n\t\t\r\n\t\t//Deformation for the zone of the eyes.\r\n\t\tfloat n= .99 * pow(abs(4.2 * (p.y + 4.8 * pow(abs(p.x), 2.4) * clamp((p.y - 0.4), -1., 1.)) - 1.5), 3.6);\r\n\t\tp.z *= 1. + 0.4 * step(p.z, 0.) / (0.9 + n) ;\r\n\t\t\r\n\t\t//Making the sphere less rounded.\r\n\t\tn = sqrt(p.y + 1.);\r\n\t\tp.xz = 1.2 * pow(abs(p.xz), vec2(1.2)) * ( 1.08 - 0.7 * (1. - n) * exp( -1.0 * pow(abs(p.y + 0.2), 12.)));\r\n\t\t\r\n\t\t//Making more planar the upper and lower border of the head\r\n\t\tp.y -= 0.26 * p.x * exp( -1.0 * pow(abs(p.y - 1.1), 12.)) - 0.085;\r\n\t\t\r\n\t\t\r\n\t\treturn p;\r\n\t}\r\n\r\n\t/*\r\n\t* Most of the modelling is made using displacements over a deformed\r\n\t* sphere since the raymarching of the hair does not allow multiple\r\n\t* objects using the mix function.\r\n\t*\r\n\t* The main idea is to deform a sphere to create a basic shape and then\r\n\t* use the displacements to give more details to it.\r\n\t*\r\n\t* The function return all the displacemts that will occur on the sphere\r\n\t* and it also return the differents displacements for coloring phases. It\r\n\t* also works deforming local vectors on the deformed sphere.\r\n\t*\r\n\t*/\r\n\r\n\tfloat  displacements(in vec3 p, out float displace[6]) {\r\n\t\t\t\t\t\t\r\n\t\t//displacement for the eyes\r\n\t\tvec3 u = p;\r\n\t\tu.x = abs(u.x);\r\n\t\tu += vec3(-0.17, -0.42, 0.46);\r\n\t\tdisplace[1] = -0.15 * exp(-500000. * pow(length(u), 6.5));\r\n\t\tu.y += 2.6 * pow(abs(u.x), 2.2);\r\n\t\tdisplace[2] = length(u.xy);\r\n\t\tdisplace[2] = 0.04 * dd(u.y - 0.16 + 0.03 * elevation, vec3(0.25, vec2(0.025))) * step(displace[2], 0.22) * exp(-6200. * pow(abs(displace[2]), 4.2));\r\n\t\t\r\n\t\t//displacement for the nose.\r\n\t\tu = p;\r\n\t\tdisplace[0] = abs(cos(pow(u.y, 2.) * 12. - 0.8));\r\n\t\tdisplace[0] *= displace[0] * displace[0] * displace[0] * (3. - 2. * displace[0]);\r\n\t\tu.x *= (2. - 1. * displace[0]) * (1. + pow(abs(3. * u.y), 3.));\r\n\t\tdisplace[3] = 0.38 * dd(u.y - 0.3, vec3(0.5, vec2(0.2, 0.3))) * dd(u.x, vec3(0.5, vec2(0.25))) * (1. - exp(-21.1 * pow(abs((u.y - 1.22 + 1.5 * pow(abs(u.x), 2.))), 66.))) * (1. + pow(abs(8. * p.x), 4.));\r\n\t\tdisplace[4] = displace[3] * step(u.y, .47) * step(p.z, 0.5);\r\n\t\t\r\n\t\t//displacement for the holes of the nose.\r\n\t\tu = p;\r\n\t\tu.x = abs(p.x);\r\n\t\tu.xy -= vec2(0.065, 0.15);\r\n\t\tdisplace[3] -= .1 * exp(-1400. * pow(length(u.xy), 2.2));\r\n\t\t\r\n\t\t//displacement for the horns.\t\t\r\n\t\tu = p;\r\n\t\tu.x = abs(p.x) - 1.1;\r\n\t\tu.yz += 0.003 * sin(u.x * 90.) + vec2(-0.2, 0.05);\r\n\t\tdisplace[0] = clamp(1., 0., u.x + 0.45);\r\n\t\tu.y -= 0.45 * sqrt(1. - displace[0] * displace[0]) - 0.2;\r\n\t\tdisplace[0] = 0.9 * exp(- 1000. * pow(length(u.yz), 3.5));\r\n\t\t\r\n\t\t//displacement for the mouth.\r\n\t\tu = p;\r\n\t\tu.y += 0.15 - 0.6 * pow(abs(u.x), 2.);\r\n\t\tu.xy = 1.6 * pow(abs(u.xy), vec2(1.5));\r\n\t\tu.xy *= vec2(0.6, 15. + 1500. * pow(abs(u.x * 0.7), 2.));\r\n\t\tdisplace[5] = 0.5 * exp(-400. * pow(length(u.xy), 2.9));\r\n\t\tu.xy = 1.3 * pow(abs(u.xy), vec2(1.1));\r\n\t\tdisplace[5] -= 0.03 * exp(-500000. * pow(0.12 * length(u.xy), 6.6));\r\n\t\tdisplace[5] *= smoothstep(0.16, 0., u.x);\r\n\r\n\t\t\r\n\t\treturn (displace[1] -displace[2] - displace[3] + displace[5]) * step(p.z, 0.5) - displace[0];\r\n\t}\r\n\r\n\t//This function return the depth from the distance field.\r\n\tvec3 map(vec3 p) {\r\n\t\t\r\n\t\tvec3 u = p;\r\n\t\tfloat displace[6];\r\n\t\t\r\n\t\tu *= rotY(rotationY);\r\n\t\tu *= rotX(rotationX);\r\n\t\tp = deformation(p);\r\n\t\tvec3 s = vec3(length(p) - 1., 0., 0.);\r\n\t\t\r\n\t\ts.x += displacements(u, displace);\t\t\r\n\t\ts.x *= 0.2;\r\n\t\treturn s;\r\n\t}\r\n\r\n\t//This is map function that also defines the color for the differents displacemetns\r\n\tvec3 colorMap(vec3 p) {\r\n\t\t\t\r\n\t\tvec3 u = p;\r\n\t\tvec4 r = 0.8 * vec4(0.09, .077, .055, 0.01);\r\n\t\tfloat displace[6];\r\n\t\t\r\n\t\tu *= rotY(rotationY);\r\n\t\tu *= rotX(rotationX);\r\n\t\t\r\n\t\tp = deformation(p);\r\n\t\tvec3 s = vec3(length(p) - 1., 0., 0.);\r\n\t\ts.x += displacements(u, displace);\r\n\t\t\r\n\t\tu.x = abs(u.x);\r\n\t\tu -= vec3(0.17, 0.40 - 0.01 * elevation, -0.46);\r\n\t\tfloat n = length(u.xy);\r\n\t\ts.z = atan(u.y, u.x);\r\n\t\t\r\n\t\t/*\r\n\t\t* Colors for the displacements, the values displace[i]\r\n\t\t* make reference to the return values from the displacement function\r\n\t\t*/\r\n\t\t\r\n\t\ts.y = step(1. + displace[1], 0.98);\r\n\t\ts.y += (3. - s.y) * step(-n, -r.y) * step(n, r.x) * step(u.z, 0.0);\r\n\t\ts.y += (4. - s.y) * step(-n, -r.z) * step(n, r.y) * step(u.z, 0.0);\r\n\t\ts.y += (3. - s.y) * step(n, r.z) * step(u.z, 0.0);\r\n\t\t\r\n\t\tu.xy += vec2(-0.05, -0.03);\r\n\t\ts.y += (0. - s.y) * step(length(u.xy), r.w) * step(u.z, 0.0);\r\n\t\t\r\n\t\ts.y += (0. - s.y) * step(1. - displace[2], 0.9999);\r\n\t\ts.y += (2. - s.y) * step(1. - displace[4], 0.995);\r\n\t\ts.y += (3. - s.y) * step(1. - displace[5], 0.99);\r\n\t\ts.y += (1. - s.y) * step(1. - displace[0], 0.9999);\r\n\t\t\r\n\t\ts.x *= 0.2;\r\n\t\t\r\n\t\treturn s;\r\n\t}\r\n\r\n\t//This function sets a texture mapping to the distance field to define the hair zones.\r\n\tvec2 cartesianToSpherical(vec3 p) {\t\r\n\t\t\r\n\t\tfloat r = length(p);\r\n\t\tp = normalize(p);\r\n\t\tr = (r - (1.0 - 0.4)) / 0.4;\r\n\t\tp.zyx *= rotX(rotationY);\r\n\t\tp.zyx *= rotZ(-rotationX);\r\n\r\n\t\tvec2 uv = vec2(atan(p.y, p.x), acos(p.z));\r\n\t\tuv.y -= r * r * 0.15 * clamp(noise(8. * p), 0.1, 1.);;\r\n\t\t\r\n\t\treturn uv;\r\n\t}\r\n\t\r\n\t/*\r\n\t* This function defines the hair density bases on a texture\r\n\t* it also change the density based on a 3D noise function and the\r\n\t* the displacements made on the sphere.\r\n\t*/\r\n\tfloat furDensity(vec3 p, out vec3 dp) {\r\n\t\t\r\n\t\tvec4 tex = texture(iChannel0, cartesianToSpherical(p.xzy) * 0.5);\r\n\t\t\r\n\t\tvec3 u = p;\r\n\t\tu *= rotY(rotationY);\r\n\t\tu *= rotX(rotationX);\r\n\t\t\r\n\t\tfloat displace[6];\r\n\t\tfloat dis = displacements(u, displace);\r\n\t\tdp = deformation(p);\r\n\t\tp = dp + dis;\r\n\t\t\r\n\t\tfloat density = smoothstep(0.3, 1.0, tex.x);\t\t\r\n\t\t\r\n\t\tfloat r = (length(p) + dis - 0.6) / 0.4;\r\n\t\t\r\n\t\tdensity *= 1.- r;\r\n\t\t\r\n\t\tfloat val = noise(2.1 * p);\r\n\t\tdensity -= 0.030 * pow(abs(val), 3.);\r\n\t\t\r\n\t\tr = step(1. + dis, 0.98);\r\n\t\tdensity *= 1. + 1. * r;\r\n\t\t\r\n\t\treturn density;\r\n\t\t\r\n\t}\r\n\r\n\t//Gradient to define the normal of a surface.\r\n\tvec3 gradient( vec3 v ) {\r\n\t\tconst vec3 delta = vec3( grad_step, 0.0, 0.0 );\r\n\t\tfloat va = map(v).x;\r\n\t\treturn normalize (vec3(map( v + delta.xyy).x - va, map( v + delta.yxy).x - va, map( v + delta.yyx).x - va));\r\n\t}\r\n\r\n\t//function that raymarch the base distance field (without hair).\r\n\tvec3 ray_marching( vec3 origin, vec3 dir, float start, float end ) {\r\n\t\t\r\n\t\tfloat depth = start;\r\n\t\tvec3 salida = vec3(end);\r\n\t\tvec3 dist = vec3(0.1);\r\n\t\t\r\n\t\tfor ( int i = 0; i < max_iterations; i++ ) \t\t{\r\n\t\t\tif ( dist.x < stop_threshold || depth > end ) break;\r\n                dist = map( origin + dir * depth );\r\n                depth += dist.x;\r\n\t\t}\r\n\t\t\r\n\t\tdist = colorMap( origin + dir * depth );\r\n\t\t\r\n\t\tsalida = vec3(depth, dist.y, dist.z);\r\n\t\treturn salida;\r\n\t}\r\n\r\n\t//Shading for the base distance field (without hair)\r\n\tvec3 shading( vec3 v, vec3 n, vec3 eye, vec3 l) {\r\n\t\r\n\t\tvec3 ev = normalize( v - eye );\r\n\t\tvec3 ref_ev = reflect( ev, n );\r\n\t\tvec3 light_pos   = vec3(0.0, 2.0, -8.0);\r\n\t\tvec3 vl = normalize( light_pos - v );\r\n\t\tfloat d  = max( 0.0, dot( vl, n ) );\r\n\t\tfloat s = max( 0.0, dot( vl, ref_ev ) );\r\n\t\ts = pow( s, l.x );\r\n\t\t\r\n\t\treturn vec3( 0.9 ) * ( d * l.y + s * l.z) + vec3(0.1);\r\n\t}\r\n\r\n\t//Ray direction to the rendering plane\r\n\tvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\r\n\t\tvec2 xy = pos - size * 0.5;\r\n\r\n\t\tfloat cot_half_fov = tan(radians( 90.0 - fov * 0.5 ));\t\r\n\t\tfloat z = size.y * 0.5 * cot_half_fov;\r\n\t\r\n\t\treturn normalize( vec3( xy, z ) );\r\n\t}\r\n\r\n\r\n\tvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\t\t\t\r\n\t\tvec3 rd = ray_dir(50.0, iResolution.xy, fragCoord.xy );\r\n\t\tvec3 eye = vec3( .0, .0, -3.5);\r\n\t\tvec3 l = vec3(2., 0.45, 0.15);\r\n\t\tvec3 color = vec3(0.);\r\n\r\n\t\tvec3 data = ray_marching( eye, rd, 0.0, clip_far );\r\n\t\tif ( data.x < clip_far ) {\r\n\t\t\t\r\n\t\t\tvec3 pos = eye + rd * data.x;\r\n\t\t\tvec3 n = gradient( pos );\r\n\t\t\tvec3 lightColor =  shading( pos, n, eye, l) * 2.0;\r\n\t\t\tvec3 mainColor = vec3(80., 170., 180.) * lightColor / 190.;\r\n\t\t\t\r\n\t\t\tmainColor *= (0.2 + 1.3 * pow(noise(2. * pos * rotY(rotationY + 180.)), 0.7));\t\t\t\r\n\t\t\t\r\n\t\t\tcolor = mainColor * step(data.y, 0.5) * step(-data.y, 0.5);\r\n\t\t\tcolor += vec3(0.8) * lightColor * step(data.y, 1.5) * step(-data.y, -.5);\t\r\n\t\t\tcolor += 0.6 * mainColor * step(data.y, 2.5) * step(-data.y, -1.5);\t\r\n\t\t\tcolor += vec3(0.1) * lightColor * step(data.y, 3.5) * step(-data.y, -2.5);\r\n\t\t\tcolor += 0.7 * vec3(0.5, 0.7, 0.9) * (0.01 + 0.99 * abs(cos(data.z + 1.3))) * lightColor * step(data.y, 4.5) * step(-data.y, -3.5);\t\t\r\n\t\t\t\r\n\t\t\t/*\r\n\t\t\t* If there\u00c2\u00b4s a point to render from the distance field\r\n\t\t\t* a second ray marching occurs if the material requires so.\r\n\t\t\t* if not, the pixel is renderer with the base distance function information.\r\n\t\t\t*/\r\n\t\t\t\r\n\t\t\tif(data.y <= 1.) {\r\n\t\t\t\tvec4 c = vec4(0.);\r\n\t\t\t\tvec4 sampleCol;\r\n\t\t\t\tvec3 dp = vec3(0.);\r\n\t\t\t\tfor(int i=0; i<furLayers; i++) {\r\n\t\t\t\t\tsampleCol.a = furDensity(pos, dp);\r\n\t\t\t\t\tif (sampleCol.a > 0.) {\r\n\t\t\t\t\t\tsampleCol.rgb = sampleCol.a * color * clamp((length(dp) - (1.0 - 0.4)) / 0.4, 0.55, 1.);\t\t\t\t\t\t\t\r\n\t\t\t\t\t\tc +=  sampleCol * (1.0 - c.a);\r\n\t\t\t\t\t}\r\nif( c.a>0.99 ) break;\t\t\t\t\tpos += rd * 0.016;\t\t\r\n\t\t\t\t}\r\n\t\t\t\r\n\t\t\t\tcolor = c.xyz;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\t\r\n\t\tfragColor = vec4(color, 1.0 );\r\n\t} ","name":"","description":"","type":"image"}]}