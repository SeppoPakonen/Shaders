{"ver": "0.1", "info": {"id": "NsSSRW", "date": "1625939958", "viewed": 172, "name": "Class I Goldberg Polyhedron ", "username": "Lichtso", "description": "UV-mapped hexagonal tiling on an icosahedron, See: https://en.wikipedia.org/wiki/Goldberg_polyhedron\n\nInstead of mesh tessellation this shader uses voronoi cells.\nThis way the performance is independent of the number of tiles.", "likes": 7, "published": 3, "flags": 0, "usePreview": 0, "tags": [], "requires": ["imagebuf"]}, "renderpass": [{"inputs": [], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "const vec3 ICOSAHEDRON_VERTICES[12] = vec3[](\n    vec3(0.0, -1.0, 0.0),\n    vec3(-0.27639320492744446, -0.4472135901451111, -0.8506507873535156),\n    vec3(-0.8944271802902222, -0.4472135901451111, -1.6430361299034693e-16),\n    vec3(-0.27639320492744446, -0.4472135901451111, 0.8506507873535156),\n    vec3(0.7236068248748779, -0.4472135901451111, 0.525731086730957),\n    vec3(0.7236068248748779, -0.4472135901451111, -0.525731086730957),\n    vec3(0.27639320492744446, 0.4472135901451111, -0.8506507873535156),\n    vec3(-0.7236068248748779, 0.4472135901451111, -0.525731086730957),\n    vec3(-0.7236068248748779, 0.4472135901451111, 0.525731086730957),\n    vec3(0.27639320492744446, 0.4472135901451111, 0.8506507873535156),\n    vec3(0.8944271802902222, 0.4472135901451111, 1.6430361299034693e-16),\n    vec3(0.0, 1.0, 0.0)\n);\n\nconst float M_PI = radians(180.0);\nconst float icosahedron_radius_by_edge_length = sin(M_PI*2.0/5.0);\nconst float blending_region = 0.1;\n\nbool side_of_half_plane(vec3 direction, int pole_index_a, int pole_index_b) {\n    vec3 aux_a = cross(ICOSAHEDRON_VERTICES[pole_index_a], ICOSAHEDRON_VERTICES[pole_index_b]);\n    return dot(direction, aux_a) > 0.0;\n}\n\nfloat line_plane_intersection(vec3 origin, vec3 direction, vec3 point_on_plane, vec3 plane_normal) {\n    float determinant = dot(direction, plane_normal);\n    float zero = 0.0;\n    if(determinant == 0.0)\n        return zero/zero;\n    float parallel_distance = dot(point_on_plane-origin, plane_normal)/determinant;\n    return parallel_distance;\n}\n\nfloat line_sphere_intersection(vec3 origin, vec3 direction, vec3 center, float radius, out vec3 intersections[2]) {\n    vec3 diagonal = origin-center;\n\tvec3 parallel = dot(diagonal, direction)*direction;\n    vec3 orthogonal = diagonal-parallel;\n    float orthogonal_distance = length(orthogonal);\n    if(orthogonal_distance > radius)\n        return 0.0;\n   \tfloat parallel_distance = sin(acos(orthogonal_distance/radius))*radius;\n    intersections[0] = origin-parallel-direction*parallel_distance;\n    intersections[1] = origin-parallel+direction*parallel_distance;\n    return parallel_distance*2.0;\n}\n\nvec3 bary_to_cart(vec3 barycentric, ivec3 pole_indices, bool angular_interpolation) {\n    if(angular_interpolation)\n        barycentric = sin(sin(barycentric));\n        // barycentric = (vec3(1.0)-pow(barycentric*2.0/M_PI-vec3(1.0), vec3(2.0)))*sin(sin(M_PI*0.5));\n        // barycentric = log(barycentric+vec3(1.0));\n    mat3 mat = mat3(\n        ICOSAHEDRON_VERTICES[pole_indices[0]],\n        ICOSAHEDRON_VERTICES[pole_indices[1]],\n        ICOSAHEDRON_VERTICES[pole_indices[2]]\n    );\n    return normalize(mat*barycentric);\n}\n\nvec3 cart_to_bary(vec3 direction, ivec3 pole_indices, bool angular_interpolation) {\n    /*mat3 mat = inverse(mat3(\n        ICOSAHEDRON_VERTICES[pole_indices[0]],\n        ICOSAHEDRON_VERTICES[pole_indices[1]],\n        ICOSAHEDRON_VERTICES[pole_indices[2]]\n    ));\n    vec3 barycentric = mat*direction;\n    barycentric = asin(barycentric);\n    return barycentric/dot(barycentric, vec3(1.0));*/\n    vec3 barycentric = vec3(0.0);\n    for(int i = 0; i < 3; ++i)\n        barycentric[i] = dot(cross(ICOSAHEDRON_VERTICES[pole_indices[(i+1)%3]], ICOSAHEDRON_VERTICES[pole_indices[(i+2)%3]]), direction);\n    if(angular_interpolation)\n        barycentric = asin(asin(barycentric));\n        // barycentric = (vec3(1.0)-sqrt(vec3(1.0)-barycentric*1.19))/sin(sin(M_PI*0.5));\n        // barycentric = exp(barycentric)-vec3(1.0);\n    return barycentric/dot(barycentric, vec3(1.0));\n}\n\nvec2 bary_to_texcoord(vec3 barycentric) {\n    return vec2(0.5)+0.75*vec2(barycentric.z, (barycentric.x-barycentric.y)/sqrt(3.0));\n}\n\nfloat checker_texture(vec2 texcoord) {\n    vec2 repeated = mod(texcoord, vec2(1.0));\n    vec2 chequer = smoothstep(0.4, 0.5, repeated) * smoothstep(1.0, 0.95, repeated);\n    return abs(1.0-chequer.x-chequer.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float planet_radius = 9.0;\n    int gp_index = int(planet_radius/icosahedron_radius_by_edge_length);\n    vec3 planet_position = vec3(0.0);\n    \n    // Ray tracing of the sphere\n    vec3 view_ray_origin = vec3(0.0, 0.0, planet_radius*10.0);\n    vec3 view_ray_hit = vec3(fragCoord/iResolution.xy*2.0-vec2(1.0), 0.0);\n    view_ray_hit.x *= iResolution.x/iResolution.y;\n    view_ray_hit.xy *= planet_radius*1.2;\n    vec3 view_ray_direction = normalize(view_ray_hit-view_ray_origin);\n\n    vec3 intersections[2];\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    if(line_sphere_intersection(view_ray_origin, view_ray_direction, planet_position, planet_radius, intersections) == 0.0)\n        return;\n    vec3 surface_normal = normalize(intersections[0]-planet_position);\n    \n    float rotate_y = (iMouse.x/iResolution.x-0.5+iTime*0.02)*M_PI*2.0;\n    float rotate_x = (iMouse.y/iResolution.y-0.5)*M_PI;\n    surface_normal = (mat4(\n        cos(rotate_y), 0.0, sin(rotate_y), 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        -sin(rotate_y), 0.0, cos(rotate_y), 0.0,\n        0.0, 0.0, 0.0, 1.0\n    )*mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, cos(rotate_x), sin(rotate_x), 0.0,\n        0.0, -sin(rotate_x), cos(rotate_x), 0.0,\n        0.0, 0.0, 0.0, 1.0\n    )*vec4(surface_normal, 1.0)).xyz;\n\n    vec3 spherical = surface_normal;\n    ivec3 pole_indices;\n    int triangle_longitude;\n    int triangle_latitude;\n    {\n        // Icosahedron triangles\n        float longitude = 1.0-acos(spherical[1])/M_PI;\n        float latitude = atan(spherical[0], spherical[2])/M_PI;\n        int triangle_latitude_south = int(mod((2.9+latitude)*2.5, 5.0));\n        int triangle_latitude_north = int(mod((3.1+latitude)*2.5, 5.0));\n        if(side_of_half_plane(spherical, 1+(triangle_latitude_south+1)%5, 1+triangle_latitude_south)) {\n            pole_indices = ivec3(1+(triangle_latitude_south+1)%5, 1+triangle_latitude_south, 0);\n            triangle_longitude = 0;\n            triangle_latitude = triangle_latitude_south;\n        } else if(side_of_half_plane(spherical, 6+triangle_latitude_north, 6+(triangle_latitude_north+1)%5)) {\n            pole_indices = ivec3(6+triangle_latitude_north, 6+(triangle_latitude_north+1)%5, 11);\n            triangle_longitude = 3;\n            triangle_latitude = triangle_latitude_north;\n        } else if(side_of_half_plane(spherical, 6+triangle_latitude_north, 1+triangle_latitude_north) &&\n                  side_of_half_plane(spherical, 1+triangle_latitude_north, 6+(triangle_latitude_north+1)%5)) {\n            pole_indices = ivec3(6+(triangle_latitude_north+1)%5, 6+triangle_latitude_north, 1+triangle_latitude_north);\n            triangle_longitude = 2;\n            triangle_latitude = triangle_latitude_north;\n        } else {\n            pole_indices = ivec3(1+triangle_latitude_south, 1+(triangle_latitude_south+1)%5, 6+(triangle_latitude_south+1)%5);\n            triangle_longitude = 1;\n            triangle_latitude = triangle_latitude_south;\n        }\n    }\n    \n    vec3 barycentric = cart_to_bary(spherical, pole_indices, true);\n    ivec3 cell;\n    float distance_to_edge = 100.0;\n    vec3 blending_weights = vec3(0.0);\n    {\n        // Barycentric rounding\n        ivec3 rounded = ivec3(barycentric*float(gp_index));\n        int step_dir = (rounded.x+rounded.y+rounded.z)%2 == gp_index%2 ? 1 : -1;\n        ivec3 center = rounded*3+ivec3(3+step_dir)/2;\n\n        // Voronoi cells\n        for(int i = 0; i < 3; ++i) {\n            ivec3 neighbor = ivec3(step_dir);\n            neighbor[i] *= -2;\n            neighbor += center;\n            neighbor /= 3;\n            vec3 diff = (bary_to_cart(vec3(neighbor)/float(gp_index), pole_indices, true)-spherical)*float(gp_index);\n            float value = dot(diff, diff);\n            blending_weights[i] = smoothstep(0.6, 0.0, value);\n            if(distance_to_edge > value) {\n                distance_to_edge = value;\n                cell = neighbor;\n            }\n            value = smoothstep(0.6, 0.0, value);\n        }\n    }\n\n    // Patch triangle edges\n    if(triangle_longitude == 2 && cell.y == 0 && cell.z > 0) {\n        cell.xz = cell.zx;\n        barycentric = vec3(1.0-barycentric.x, -barycentric.y, 1.0-barycentric.z);\n        triangle_longitude = 1; // 3-triangle_longitude;\n    } else if(triangle_longitude == 1 && cell.x == 0 && cell.z > 0) {\n        cell.yz = cell.zy;\n        barycentric = vec3(-barycentric.x, 1.0-barycentric.y, 1.0-barycentric.z);\n        triangle_latitude = (triangle_latitude+1)%5;\n        triangle_longitude = 2; // 3-triangle_longitude;\n    }\n    if(triangle_longitude == 1 && cell.z == 0) {\n        cell.yx = cell.xy;\n        barycentric = vec3(barycentric.y, barycentric.x, -barycentric.z);\n        triangle_longitude = 0; // triangle_longitude*3-3;\n    } else if(triangle_longitude == 2 && cell.z == 0) {\n        cell.yx = cell.xy;\n        barycentric = vec3(barycentric.y, barycentric.x, -barycentric.z);\n        triangle_longitude = 3; // triangle_longitude*3-3;\n    }\n    if(triangle_longitude == 0) {\n        if(cell.y == 0 && cell.z < gp_index) {\n            cell.yx = cell.xy;\n            if(barycentric.z > 0.0)\n                barycentric = vec3(-barycentric.y, 1.0-barycentric.z, 1.0-barycentric.x);\n            else\n                barycentric = vec3(barycentric.x-1.0, 1.0-barycentric.z, barycentric.y);\n            triangle_latitude = (triangle_latitude+1)%5; // (triangle_latitude+1+triangle_longitude)%5;\n        } else if(triangle_latitude > 0 && cell.z == gp_index) {\n            for(int i = 5; i > triangle_latitude; --i)\n                barycentric = vec3(-barycentric.y, 1.0-barycentric.z, 1.0-barycentric.x);\n            triangle_latitude = 0;\n        }\n    } else if(triangle_longitude == 3) {\n        if(cell.x == 0 && cell.z < gp_index) {\n            cell.yx = cell.xy;\n            if(barycentric.z > 0.0)\n                barycentric = vec3(1.0-barycentric.z, -barycentric.x, 1.0-barycentric.y);\n            else\n                barycentric = vec3(1.0-barycentric.z, barycentric.y-1.0, barycentric.x);\n            triangle_latitude = (triangle_latitude+1)%5; // (triangle_latitude+4-triangle_longitude)%5;\n        } else if(triangle_latitude > 0 && cell.z == gp_index) {\n            for(int i = 5; i > triangle_latitude; --i)\n                barycentric = vec3(1.0-barycentric.z, -barycentric.x, 1.0-barycentric.y);\n            triangle_latitude = 0;\n        }\n    }\n    \n    // Texture\n    ivec2 rectified_coords = triangle_longitude%2 == 1 ? ivec2(gp_index)-cell.xy : cell.xy;\n    rectified_coords += gp_index*ivec2(triangle_latitude, triangle_longitude/2);\n    // fragColor.r = float(triangle_latitude)/5.0;\n    // fragColor.g = float(triangle_longitude)/4.0;\n    // fragColor.rgb = vec3(rectified_coords, 0.0)/float(5*gp_index);\n    fragColor.rgb = vec3(cell)/float(gp_index)-vec3(1.0/3.0);\n    vec2 texcoord = bary_to_texcoord((triangle_longitude%2 == 1) ? -barycentric : barycentric);\n    fragColor.rgb = mix(vec3(0.8), fragColor.rgb, 0.5+0.5*checker_texture(texcoord*40.0));\n    \n    // Hexagonal outline\n    fragColor.rgb *= vec3(smoothstep(1.0, 0.0, distance_to_edge));\n}\n", "name": "Image", "description": "", "type": "image"}]}