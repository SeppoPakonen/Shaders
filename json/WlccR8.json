{"ver": "0.1", "info": {"id": "WlccR8", "date": "1608420055", "viewed": 274, "name": "Wythoff Polyhedra with Exact SDF", "username": "mla", "description": "Exact SDF for Wythoff construction so rounding etc. works. Does uniform polyhedron & dual, also edges and vertices, but all together is slow to compile, so lots of conditional compilation. Code tries to be simple & comprehensible, with no fancy stuff.", "likes": 14, "published": 3, "flags": 16, "usePreview": 0, "tags": [], "requires": ["library", "texturebuf", "keyboardbuf", "cubemap", "imagebuf", "texture"]}, "renderpass": [{"inputs": [{"id": "XdfGRn", "filepath": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "type": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "XsfGzn", "filepath": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "previewfilepath": "/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "type": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "4dXGRr", "filepath": "/presets/tex00.jpg", "previewfilepath": "/presets/tex00.jpg", "type": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Wythoff construction for convex polyhedra, with an exact SDF.\n// Matthew Arcus, mla, 2020\n//\n// https://en.wikipedia.org/wiki/Wythoff_construction\n//\n// Controls:\n// Mouse changes orientation\n// m: mirror faces\n// r: rotation\n//\n// Uses exact distance to triangular faces (or subdivisions of faces) \n// rather than distance to face planes, enabling, eg. SDF rounding\n// to work.\n//\n// See macros below for other features - also draws vertices and edges\n// Snubs can be done in the same way, but omitted here as this\n// considerably complicates the code.\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// Any P,Q,R with 1/P + 1/Q + 1/R > 1, which means:\n// 2:2:2, 3:2:2, 4:2:2, ...\n// 3:3:2, 4:3:2, 5:3:2\n\nint P = 4, Q = 3, R = 2;\n\n// Having everything on at once makes for a slow compilation so\n// enable features with macros.\n#define DRAWDUAL\n//#define DRAWUNIFORM\n#define DRAWFACES\n//#define DRAWEDGES\n//#define DRAWVERTICES\n//#define INEXACT // For comparison\n\nfloat roundness = 0.5;\nbool alledges = false; // Always draw all edges of the duals\n\n// Trilinear coordinates of vertex point (ie. proportional distance\n// from sides of fundamental region).\nvec3 trilinear = vec3(1,1,1);\n\n// Number of iterations of folding loop\n// 5 iterations is enough to get up to (5 3 2) or (10 2 2)\nint NFOLDS = 5;\n\n// Types of feature\nint FACE0 = 1;\nint FACE1 = 2;\nint FACE2 = 3;\nint DFACE0 = 4;\nint DFACE1 = 5;\nint EDGE = 6;\nint DEDGE = 7;\nint VERTEX = 8;\nint DVERTEX = 9;\n\n// 3 mirror planes (passing through origin) define a fundamental\n// region, which intersects the unit sphere in a spherical\n// triangle with angles PI/P, PI/Q, PI/R.\n// The normal polyhedron has a vertex in the fundamental region,\n// edges from the vertex perpendicular to the mirror planes, and\n// faces perpendicular to the lines of intersection of the mirror\n// planes.\n// The dual polyhedron has faces perpendicular to the vector to\n// the region vertex, and vertices on the mirror plane intersections.\n\nvec3 A,B,C;    // normal vectors for mirror planes\nvec3 vertex;   // the vertex point & face centre of dual\nvec3 vertex1;  // vertex with roundness\nfloat vertexlength;\nvec3 a,b,c;    // face normals\nvec3 ca,cb,cc; // face centres of normal faces\nvec3 da,db,dc; // vertices of the dual\nvec3 da1,db1,dc1; // vertices of the dual, with roundness\nvec3 ea,eb,ec; // edge centres (ea on edge A, etc)\n\nvoid initgeometry() {\n  // Setup folding planes\n  float p = PI/float(P);\n  float q = PI/float(Q);\n  float r = PI/float(R);\n  // |A| = |B| = |C| = 1\n  // A.B = -cos(p)\n  // A.C = -cos(r)\n  // B.C = -cos(q) = cos(p)cos(r) + y sin(p)\n  A = vec3(1,0,0);\n  B = vec3(-cos(p),sin(p),0);\n  float x = -cos(r);\n  float y = -(cos(p)*cos(r)+cos(q))/sin(p);\n  float z = sqrt(1.0-x*x-y*y);\n  C = vec3(x,y,z);\n\n  // Intersections of mirror planes.\n  a = cross(B,C);\n  b = cross(C,A);\n  c = cross(A,B);\n\n  // Convert trilinear to normal coordinates\n  vertex = mat3(a,b,c)*trilinear;\n\n  // Scale so edge centres (for both normal and dual) are on unit sphere.\n  float scale = min3(edgedistance(vertex,A),\n                     edgedistance(vertex,B),\n                     edgedistance(vertex,C));\n  vertex /= scale;\n  vertexlength = length(vertex);\n  vertex1 = vertex+roundness*vertex/length(vertex);\n  \n  a = normalize(a);\n  b = normalize(b);\n  c = normalize(c);\n\n  float va = dot(vertex,a);\n  float vb = dot(vertex,b);\n  float vc = dot(vertex,c);\n  \n  // Face centres\n  ca = a*va;\n  cb = b*vb;\n  cc = c*vc;\n\n  // Dual vertices\n  da = a/va;\n  db = b/vb;\n  dc = c/vc;\n\n  // Dual vertices moved out to roundness level\n  da1 = da * (1.0 + roundness*va);\n  db1 = db * (1.0 + roundness*vb);\n  dc1 = dc * (1.0 + roundness*vc);\n\n  // Edge centres\n  ea = vertex-dot(vertex,A)*A;\n  eb = vertex-dot(vertex,B)*B;\n  ec = vertex-dot(vertex,C)*C;\n}\n\nfloat faces(vec3 pos, out int facenumber) {\n#if defined INEXACT\n  float d = -1e8, d0;\n  d0 = d;\n  d = max(d,dot(pos,a)-dot(vertex,a));\n  if (d > d0) facenumber = 0;\n  d0 = d;\n  d = max(d,dot(pos,b)-dot(vertex,b));\n  if (d > d0) facenumber = 1;\n  d0 = d;\n  d = max(d,dot(pos,c)-dot(vertex,c));\n  if (d > d0) facenumber = 2;\n#else\n  float d = 1e8, d0;\n  // Need 6 triangles for the fundamental region.\n  // There is probably a better way to do this!\n  d0 = d;\n  d = min(d, triangleDistance(pos,vertex,ca,eb));\n  d = min(d, triangleDistance(pos,vertex,ca,ec));\n  if (d < d0) facenumber = 0;\n  d0 = d;\n  d = min(d, triangleDistance(pos,vertex,cb,ec));\n  d = min(d, triangleDistance(pos,vertex,cb,ea));\n  if (d < d0) facenumber = 1;\n  d0 = d;\n  d = min(d, triangleDistance(pos,vertex,cc,ea));\n  d = min(d, triangleDistance(pos,vertex,cc,eb));\n  if (d < d0) facenumber = 2;\n#endif\n  return d;\n}\n\nfloat scene(vec3 pos, int parity, out int type) {\n  float edgeradius = 0.02;\n  float vertexradius = 0.05;\n  float d = 1e8, d0;\n  type = 0;\n#if defined DRAWDUAL\n  {\n#if defined DRAWFACES\n    d0 = d;\n#if defined INEXACT\n    d = min(d, (dot(pos,vertex)-1.0)/vertexlength-roundness); // vertex is face centre\n#else\n    d = min(d, triangleDistance(pos,da,db,dc)-roundness);\n#endif    \n    if (d < d0) type = parity%2 == 0 ? DFACE0 : DFACE1;\n#endif\n    // Draw an edge in the dual if the vertex isn't on that edge\n    bool ba = bool(trilinear[0]);\n    bool bb = bool(trilinear[1]);\n    bool bc = bool(trilinear[2]);\n#if defined DRAWEDGES\n    d0 = d;\n    if (alledges || ba) d = min(d,segment(pos,db1,dc1)-edgeradius);\n    if (alledges || bb) d = min(d,segment(pos,dc1,da1)-edgeradius);\n    if (alledges || bc) d = min(d,segment(pos,da1,db1)-edgeradius);\n    if (d < d0) type = DEDGE;\n#endif\n#if defined DRAWVERTICES\n    d0 = d;\n    // The rules for vertex display are subtle, this works\n    // with R = 2 (ie. angle between A and C is PI/2)\n    // (Display a vertex if at least 1 edge to that vertex is\n    // displayed, unless the angle at that vertex is PI/2, in\n    // which case both edges must be displayed).\n    if (alledges || bb || bc) d = min(d,distance(pos,da1)-vertexradius);\n    if (alledges || (bc && ba)) d = min(d,distance(pos,db1)-vertexradius);\n    if (alledges || ba || bb) d = min(d,distance(pos,dc1)-vertexradius);\n    if (d < d0) type = DVERTEX;\n#endif\n  }\n#endif\n#if defined DRAWUNIFORM\n  {\n#if defined DRAWFACES\n    d0 = d;\n    int facenumber;\n    d = min(d,faces(pos,facenumber)-roundness);\n    if (d < d0) type = FACE0+facenumber;\n#endif\n#if defined DRAWEDGES\n    d0 = d;\n    d = min(d,segment(pos,vertex1,reflect(vertex1,A))-edgeradius);\n    d = min(d,segment(pos,vertex1,reflect(vertex1,B))-edgeradius);\n    d = min(d,segment(pos,vertex1,reflect(vertex1,C))-edgeradius);\n    if (d < d0) type = EDGE;\n#endif\n#if defined DRAWVERTICES\n    d0 = d;\n    d = min(d,distance(pos,vertex1)-vertexradius);\n    if (d < d0) type = VERTEX;\n#endif\n  }\n#endif\n  return d;\n}\n\nvec3 fold(vec3 pos,out int parity) {\n  parity = 0;\n  for (int i = 0; i < NFOLDS; i++) {\n    float k;\n    k = dot(pos,A);\n    parity += int(k < 0.0);\n    pos -= 2.0*min(0.0,k)*A;\n    k = dot(pos,B);\n    parity += int(k < 0.0);\n    pos -= 2.0*min(0.0,k)*B;\n    k = dot(pos,C);\n    parity += int(k < 0.0);\n    pos -= 2.0*min(0.0,k)*C;\n  }\n  return pos;\n}\n\nfloat map(vec3 pos, out int type) {\n  int parity;\n  pos = fold(pos,parity);\n  return scene(pos,parity,type);\n}\n\nfloat map(vec3 pos) {\n  int type;\n  return map(pos,type);\n}\n\nvec3 calcNormal0(in vec3 p) {\n  const vec2 e = vec2(0.0001, 0.0);\n  return normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n                        map(p + e.yxy) - map(p - e.yxy),\n                        map(p + e.yyx) - map(p - e.yyx)));\n}\n\n// Tetrahedron technique, from:\n// https://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal(vec3 p) {\n  float h = 0.0001;\n  vec2 k = vec2(1,-1);\n  return normalize( k.xyy*map( p + k.xyy*h ) + \n                    k.yyx*map( p + k.yyx*h ) + \n                    k.yxy*map( p + k.yxy*h ) + \n                    k.xxx*map( p + k.xxx*h ) );\n}\n\nfloat march(in vec3 ro, in vec3 rd) {\n  const float maxd = 5.0;\n  const float precis = 0.001;\n  float t = 0.0;\n  float res = -1.0;\n  for (int i = 0; i < 200; i++) {\n    //assert(i < 30);\n    if (t > maxd) return -1.0;\n    float h = map(ro+rd*t);\n    t += h;\n    if (h < precis) return t;\n  }\n  return t;\n}\n\nvec3 transform(in vec3 p) {\n  if (iMouse.x > 0.0) {\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    p.yz = rotate(p.yz,-theta);\n    p.zx = rotate(p.zx,phi);\n  }\n  if (!key(CHAR_R)) {\n    p.yz = rotate(p.yz,iTime * 0.125);\n    p.zx = rotate(p.zx,iTime * 0.2);\n  }\n  return p;\n}\n\nvec3 circuit[] = vec3[]\n  (vec3(1,1,1),vec3(1,1,1),vec3(1,0,0),vec3(1,0,0),\n   vec3(1,1,0),vec3(1,1,0),vec3(0,1,0),vec3(0,1,0),\n   vec3(0,1,1),vec3(0,1,1),vec3(0,0,1),vec3(0,0,1),\n   vec3(1,0,1),vec3(1,0,1),vec3(1,0,0),vec3(1,0,0),\n\n   vec3(1,1,1),vec3(1,1,0),vec3(1,1,1),vec3(0,1,0),\n   vec3(1,1,1),vec3(0,1,1),vec3(1,1,1),vec3(0,0,1),\n   vec3(1,1,1),vec3(1,0,1),\n\n   vec3(1,1,1),vec3(1,0,0),vec3(1,1,0),vec3(0,1,0),\n   vec3(0,1,1),vec3(0,0,1),vec3(1,0,1),vec3(1,0,0));\n\nconst int nsteps = circuit.length();\n\nvec3 gettrilinear(float t) {\n  int i = int(floor(t))%nsteps;\n  return mix(circuit[i],circuit[(i+1)%nsteps],mod(t,1.0));\n}\n\nvec3 basecolor(int type) {\n  if (type == FACE0) return vec3(1,0,0);\n  if (type == FACE1) return vec3(1,1,0);\n  if (type == FACE2) return vec3(0,0,1);\n  if (type == DFACE0) return vec3(1,1,0.5);\n  if (type == DFACE1) return vec3(0,0,0.5);\n  if (type == EDGE) return vec3(0.2);\n  if (type == DEDGE) return vec3(0.2);\n  if (type == VERTEX) return vec3(0.1);\n  if (type == DVERTEX) return vec3(0.1);\n  return vec3(1,0,1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (2.0*fragCoord.xy - iResolution.xy) / iResolution.y;\n  vec3 ro = vec3(0,0,-3);\n  vec3 rd = vec3(uv, 2);\n  vec3 light = vec3(0.5, 0.8, -3.0);\n  ro = transform(ro);\n  rd = transform(rd);\n  light = transform(light);\n  light = normalize(light);\n  rd = normalize(rd);\n  trilinear = gettrilinear(0.5*iTime);\n  initgeometry();\n  vec3 col = texture(iChannel1,uv).xyz;\n  col = pow(col,vec3(2.2));\n  float t = march(ro, rd);\n  if (t > 0.0 && t < 1e8) {\n    vec3 pos = ro + t * rd;\n    vec3 n = calcNormal(pos);\n    int type;\n    map(pos,type);\n    col = basecolor(type);\n    if (!key(CHAR_M) && type <= DFACE1) {\n      col = texture(iChannel0,reflect(rd,n)).xyz;\n    } else {\n      float diffuse = clamp(dot(n, light), 0.0, 1.0);\n      col *= 0.2 + 0.8*diffuse;\n      float specular = pow(max(0.0,dot(reflect(light,n),rd)),10.0);\n      col += 0.3*specular*vec3(1);\n    }\n  }\n  col = pow(col,vec3(0.4545));\n  if (alert) col.x = 1.0;\n  fragColor = vec4(col, 1.0);\n}", "name": "Image", "description": "", "type": "image"}, {"inputs": [], "outputs": [], "code": "#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n\nconst int CHAR_0 = 48;\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_X = 88;\nconst int CHAR_Z = 90; // rotation\n\nconst float PI\t= 3.14159265359;\n\nbool alert = false;\nvoid assert(bool test) {\n  if (!test) alert = true;\n}\n\n// Approximate equality. Used for assertion checks.\nbool eq(float a, float b) {\n  return abs(a-b) < 1e-4;\n}\n\nfloat edgedistance(vec3 pos, vec3 X) {\n  return length(pos-dot(pos,X)*X);\n}\n\n// Perpendicular distance from p to segment ab\nfloat segment(vec3 p, vec3 a, vec3 b) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  float d = length(pa - ba * h);\n  return d;\n}\n\nfloat min3(float a, float b, float c) {\n  return min(a,min(b,c));\n}\n\n//-------------------------------------------------\n//From https://www.shadertoy.com/view/XtXGRS#\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\n// Function by iq: https://www.shadertoy.com/view/ttfGWl\nvec3 closestTriangle(vec3 p, vec3 v0, vec3 v1, vec3 v2)\n{\n    vec3 v10 = v1 - v0; vec3 p0 = p - v0;\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v02 = v0 - v2; vec3 p2 = p - v2;\n    vec3 nor = cross(v10,v02);\n\n    // method 1, in 3D space\n    if( dot(cross(v10,nor),p0)<0.0 ) return v0 + v10*clamp( dot(p0,v10)/dot2(v10), 0.0, 1.0 );\n    if( dot(cross(v21,nor),p1)<0.0 ) return v1 + v21*clamp( dot(p1,v21)/dot2(v21), 0.0, 1.0 );\n    if( dot(cross(v02,nor),p2)<0.0 ) return v2 + v02*clamp( dot(p2,v02)/dot2(v02), 0.0, 1.0 );\n    return p - nor*dot(nor,p0)/dot2(nor);\n}\n\nfloat triangleDistance(vec3 p, vec3 v0, vec3 v1, vec3 v2) {\n  return distance(p,closestTriangle(p,v0,v1,v2));\n}", "name": "Common", "description": "", "type": "common"}]}