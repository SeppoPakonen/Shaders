{"ver":"0.1","info":{"id":"4scfR2","date":"1525866410","viewed":13442,"name":"Mobius trans in hyper 3-space","username":"neozhaoliang","description":"This shader is a rewritten of Roice Nelson's work at https://www.shadertoy.com/view/MstcWr\nFeel free to ask questions if you have any problem with the math behind the scene!","likes":33,"published":3,"flags":16,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Isometries of Hyperbolic 3-Space.\n// Adapted from Roice Nelson's code at: https://www.shadertoy.com/view/ld3GWS\n// license: Creative Commons Attribution-Share Alike 4.0 International license.\n\n// Keyboard control\n// Key 1    toggle on/off applying the Mobius transformation\n// Key 2    toggle on/off applying the elliptic rotation\n// Key 3    toggle on/off applying the hyperbolic scaling\n\n#define AA 1     // antialiasing level\n\n\nMobius iMobius;\nbool apply = true;\nbool hyperbolic = true;\nbool elliptic = true;\n\nbool parabolic;\nbool loxodromic;\n\n\n// Change the grid size here\nconst float modPhase = 7.0;\nconst float modModulus = 0.4;\n\n\n// Adjust the speed of the animation here\nconst float time_unit = 1.0;\nconst float hue_time_unit = 0.3;\n\n\n// Angle of the cone\nconst vec2 coneAngle = normalize(vec2(1.5, 1.0));\n\n\nfloat applyMobius(inout vec3 p)\n{\n    if(!apply)\n        return 1.0;\n\n    p = M_Apply(iMobius, vec4(p, 0)).xyz;\n    float scale = length(p);\n    if(scale > 1.0)\n        scale = 1.0 / scale;\n    return scale;\n}\n\n\n\n// A Mobius transformation of hyperblic type is\n// conjugate to a pure scaling\nvoid isometryHyperbolic(inout vec2 p)\n{\n    float mag = length(p);\n    mag = UHStoH(mag) - iTime * time_unit * modModulus;\n    Mod(mag, modModulus);\n    p = normalize(p) * HtoUHS(mag);\n}\n\n\n\n// A Mobius transformation of elliptic type is\n// conjugate to a pure rotation\nvoid isometryElliptic(inout vec2 p)\n{\n    p = Rotate2d(p, iTime * time_unit * PI / modPhase);\n}\n\n\n\n// A Mobius transformation of parabolic type is\n// conjugate to a pure translation\nvoid isometryParabolic(inout vec2 p)\n{\n    p += vec2(iTime * modModulus / 3.0, 0.0);\n}\n\n\n\n// This is almost the same with the usual cone distance function\n// except that we firstly scaled p so that it has length 1, then\n// compute its distance to the cone and finally scaled back to get\n// the right distance. This is for floating accuracy reason because\n// when p approaches infinity the cone distance function behaves badly\n// and Dupin cyclide looks bad at one horn.\nfloat coneSdf(vec3 p)\n{\n    float t = 1.0;\n    if(apply)\n    {\n        t = applyMobius(p);\n        p = normalize(p);\n    }\n    float q = length(p.xy);\n    return dot(coneAngle, vec2(q, -p.z)) * t;\n}\n\n\n\n// Scene distance function for parabolic case (one fixed point)\nfloat sceneSdf1(vec3 p)\n{\n    float horosphereEuclideanRadius = 0.9;\n    if(!apply)\n    {\n        // The horosphere as a plane will be at the height of\n        // its north pole inverted in the unit sphere.\n        float height = 1.0 / ( 2.0 * horosphereEuclideanRadius );\n        return planeSdf(p, height);\n    }\n\n    float plane_dist = planeSdf(p);\n    float sphere_dist = sphereSdf(p, horosphereEuclideanRadius);\n    return min(plane_dist, sphere_dist);\n}\n\n\n\n// Scene distance function for elliptic and hyperbolic case (two fixed points)\nfloat sceneSdf2(vec3 p)\n{\n    float plane_dist = planeSdf(p);\n    float cone_dist = coneSdf(p);\n    return min(plane_dist, cone_dist);\n}\n\n\n\n// Intensity constants\nconst float intensity_divisor = 40000.0;\nconst float intensity_factor_max = 7.2;\nconst float center_intensity = 12.0;\nconst float dist_factor = 3.0;\nconst float ppow = 1.9;\n\n\n// Color constants\nconst float center_hue = 0.5;\nconst float center_saturation = 0.18;\n\n\n// Shape constants\nconst float strong_factor = 0.25;\nconst float weak_factor = 0.19;\nconst vec2 star_hv_factor = vec2(9.0, 0.3);\nconst vec2 star_diag_factor = vec2(12.0, 0.6);\n\n// Raymarching constants\nconst int   MAX_TRACE_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.00001;\n\n\n\n// intensity function for the parabolic case\nfloat getIntensity1(vec2 p)\n{\n    // Horizontal and vertical branches\n    float dist = length(p);\n    float disth = length(p * star_hv_factor);\n    float distv = length(p * star_hv_factor.yx);\n\n    // Diagonal branches\n    vec2 q = 0.7071 * vec2(dot(p, vec2(1.0, 1.0)), dot(p, vec2(1.0, -1.0)));\n    float dist1 = length(q * star_diag_factor);\n    float dist2 = length(q * star_diag_factor.yx);\n\n    // Middle point star intensity\n    float pint1 = 1.0 / (dist * dist_factor + 0.015)\n                + strong_factor / (disth * dist_factor + 0.01)\n                + strong_factor / (distv * dist_factor + 0.01)\n                + weak_factor / (dist1 * dist_factor + 0.01)\n                + weak_factor / (dist2 * dist_factor + 0.01);\n\n    if(pint1 * intensity_factor_max > 6.0)\n        return center_intensity * intensity_factor_max * pow(pint1, ppow) / intensity_divisor;\n\n    return 0.0;\n}\n\n\n\n// intensity function for the hyperbolic and elliptic case\nfloat getIntensity2(vec2 p)\n{\n    float angle = atan(modModulus, PI / modPhase);\n    float dist = length(p);\n    float disth = length(p * star_hv_factor);\n    float distv = length(p * star_hv_factor.yx);\n\n    vec2 q1 = Rotate2d(p, angle);\n    float dist1 = length(q1 * star_diag_factor);\n    vec2 q2 = Rotate2d(p, -angle);\n    float dist2 = length(q2 * star_diag_factor);\n\n    float pint1 = 1.0 / (dist * dist_factor + 0.015)\n                + strong_factor / (disth * dist_factor + 0.01)\n                + strong_factor / (distv * dist_factor + 0.01)\n                + weak_factor / (dist1 * dist_factor + 0.01)\n                + weak_factor / (dist2 * dist_factor + 0.01);\n    if(pint1 * intensity_factor_max > 6.0)\n        return intensity_factor_max * pow(pint1, ppow) / intensity_divisor * center_intensity * 3.0;\n\n    return 0.0;\n}\n\n\n// color a point by its xy position and intensity\nvec3 getColor(vec2 p, float pint)\n{\n    float saturation = 0.75 / pow(pint, 2.5) + center_saturation;\n    float time2 = parabolic ?\n                  hue_time_unit * iTime - length(p.y) / 5.0 :\n    \t          hue_time_unit * iTime - UHStoH(length(p)) / 7.0;\n    float hue = center_hue + time2;\n    // Really a hack of magic code to make the stars work well\n    return hsv2rgb(vec3(hue, saturation, pint)) + pint / 3.0;\n}\n\n\nfloat trace(vec3 eye, vec3 marchingDir, float start, float end, out vec2 p, out float pint)\n{\n    float depth = start;\n    vec3 current;\n    float dist;\n    for(int i=0; i < MAX_TRACE_STEPS; i++)\n    {\n        current = eye + depth * marchingDir;\n        dist = parabolic ?\n               sceneSdf1(current) :\n               sceneSdf2(current);\n        if(dist < EPSILON)\n            break;\n        depth += dist;\n        if(depth >= end)\n            return -1.0;\n    }\n    vec3 hitPoint = current;\n    if(parabolic)\n    {\n        float t = 1.0;\n        if(apply)\n        {\n            t = dot(hitPoint, hitPoint);\n            hitPoint /= t;\n        }\n        p = hitPoint.xy;\n        isometryParabolic(hitPoint.xy);\n        float spacing = modModulus / 2.0;\n        Mod2d(hitPoint.xy, vec2(spacing, spacing));\n        pint = getIntensity1(hitPoint.xy);\n    }\n    else\n    {\n        applyMobius(hitPoint);\n        p = hitPoint.xy;\n        if(hyperbolic)\n            isometryHyperbolic(hitPoint.xy);\n        if(elliptic)\n            isometryElliptic(hitPoint.xy);\n        Mod2dPolar(hitPoint.xy, vec2(modModulus, PI / modPhase));\n        pint = getIntensity2(hitPoint.xy);\n    }\n    return depth;\n}\n\n\nconst int CHAR_1 = 49;\nconst int CHAR_2 = 50;\nconst int CHAR_3 = 51;\n\n\n// https://www.shadertoy.com/view/lsXGzf\nbool keypress(int code) \n{\n\treturn texelFetch(iChannel0, ivec2(code,2), 0).x != 0.0;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    iMobius.A = vec2(-1.0, 0.0);\n    iMobius.B = vec2( 1.0, 0.0);\n    iMobius.C = vec2(-1.0, 0.0);\n    iMobius.D = vec2(-1.0, 0.0);\n    \n    apply = !keypress(CHAR_1);\n    elliptic = !keypress(CHAR_2);\n    hyperbolic = !keypress(CHAR_3);\n\n    parabolic = !(elliptic || hyperbolic);\n    loxodromic = elliptic && hyperbolic;\n    \n    vec2 pixelSize = vec2(1.0);\n    pixelSize.y *= iResolution.y / iResolution.x;\n    vec3 eye = vec3(-4.0, -6.0, 4.0);\n    vec3 lookat = vec3(0.0, 0.0, 0.6);\n    vec3 up = vec3(0.0, 0.0, 1.0);\n    mat3 viewToWorld = viewMatrix(eye, lookat, up);\n    vec3 color = vec3(0.1);\n    for(int ii=0; ii < AA; ++ii)\n    {\n        for(int jj=0; jj < AA; ++jj)\n        {\n            vec2 sampleCoord = fragCoord + vec2(float(ii)/float(AA), float(jj)/float(AA)) * pixelSize;\n            vec3 viewDir = rayDirection(45.0, iResolution.xy, sampleCoord);\n            vec3 worldDir = viewToWorld * viewDir;\n            vec2 p;\n            float pint;\n            float dist = trace(eye, worldDir, MIN_DIST, MAX_DIST, p, pint);\n            if(dist >= 0.0)\n                color += tonemap(4.0 * getColor(p, pint));\n        }\n    }\n    fragColor = vec4(color / (float(AA * AA)), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n    Complex operations\n*/\n\nvec2 C_Conj(vec2 z)\n{\n    return vec2(z.x, -z.y);\n}\n\nvec2 C_Mult(vec2 z, vec2 w)\n{\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nfloat C_MagSquared(vec2 z)\n{\n    return z.x * z.x + z.y * z.y;\n}\n\nvec2 C_Div(vec2 z, vec2 w)\n{\n    return C_Mult(z, C_Conj(w)) / C_MagSquared(w);\n}\n\nvec2 C_Inv(vec2 z)\n{\n    return C_Conj(z) / C_MagSquared(z);\n}\n\nvec2 C_Sqrt(vec2 z)\n{\n    float r2 = C_MagSquared(z);\n    float r = sqrt(sqrt(r2));\n    float angle = atan(z.y, z.x);\n    return r * vec2(cos(angle / 2.0), sin(angle / 2.0));\n}\n\n\n/*\n    Quaternion operations\n*/\n\nfloat Q_MagSquared(vec4 q)\n{\n    return dot(q, q);\n}\n\nvec4 Q_Mult(vec4 p, vec4 q)\n{\n    return vec4(p.x * q.x - dot(p.yzw, q.yzw),\n                p.x * q.yzw + q.x * p.yzw + cross(p.yzw, q.yzw));\n}\n\nvec4 Q_Div(vec4 p, vec4 q)\n{\n    float mag = Q_MagSquared(q);\n    vec4 q_inv = vec4(q.x, -q.yzw) / mag;\n    return Q_Mult(p, q_inv);\n}\n\n\n/*\n    Mobius transformations\n*/\n\nstruct Mobius\n{\n    vec2 A;\n    vec2 B;\n    vec2 C;\n    vec2 D;\n};\n\nMobius M_Scale(Mobius m, vec2 s)\n{\n    Mobius result;\n    result.A = C_Mult(m.A, s);\n    result.B = C_Mult(m.B, s);\n    result.C = C_Mult(m.C, s);\n    result.D = C_Mult(m.D, s);\n    return result;\n}\n\nMobius M_Normalize(Mobius m)\n{\n    vec2 k = C_Inv(C_Sqrt(m.A * m.D - m.B * m.C));\n    return M_Scale(m, k);\n}\n\nMobius M_Mult(Mobius a, Mobius b)\n{\n    Mobius result;\n    result.A = C_Mult(a.A, b.A) + C_Mult(a.B, b.C);\n    result.B = C_Mult(a.A, b.B) + C_Mult(a.B, b.D);\n    result.C = C_Mult(a.C, b.A) + C_Mult(a.D, b.C);\n    result.D = C_Mult(a.C, b.B) + C_Mult(a.D, b.D);\n    return M_Normalize(result);\n}\n\nvec2 M_Apply(Mobius m, vec2 z)\n{\n    return C_Div(C_Mult(m.A, z) + m.B, C_Mult(m.C, z) + m.D);\n}\n\nvec4 M_Apply(Mobius m, vec4 q)\n{\n    vec4 a = vec4(m.A, 0.0, 0.0);\n    vec4 b = vec4(m.B, 0.0, 0.0);\n    vec4 c = vec4(m.C, 0.0, 0.0);\n    vec4 d = vec4(m.D, 0.0, 0.0);\n    return Q_Div(Q_Mult(a, q) + b, Q_Mult(c, q) + d);\n}\n\n\n/*\n    Convert between Euclidean distance and\n    hyperbolic distance in upper halfspace\n*/\n\n# define e_ 2.71828182846\n\nfloat UHStoH(float e)\n{\n    return log(e);\n}\n\nfloat HtoUHS(float h)\n{\n    return pow(e_, h);\n}\n\n\n/*\n    Rotation in the 2D plane\n*/\n\nvec2 Rotate2d(vec2 p, float t)\n{\n    return vec2(p.x * cos(t) - p.y * sin(t),\n                p.y * cos(t) + p.x * sin(t));\n}\n\n\n/*\n    1d and 2d grid\n*/\n\nvoid Mod(inout float x, float size)\n{\n    x = mod(x + 0.5 * size, size) - 0.5 * size;\n}\n\nvoid Mod2d(inout vec2 p, vec2 size)\n{\n    p = mod(p + 0.5 * size, size) - 0.5 * size;\n}\n\n\n/*\n    Spherical grid in two dimensions\n*/\n\nvoid Mod2dPolar(inout vec2 p, vec2 size)\n{\n    float phase = atan(p.y, p.x);\n    float modulus = UHStoH(length(p));\n    Mod(phase, size.y);\n    Mod(modulus, size.x);\n    p = vec2(modulus, phase);\n}\n\n\n#define PI 3.141592653\n#define TWOPI (2.0 * PI)\n\n\n\n/*\n  Convert hsv color to rgb color\n*/\n\nvec3 hsv2rgb(vec3 hsv)\n{\n    const vec3 K = vec3(0.0, 2.0/3.0, 1.0/3.0);\n    hsv.yz = clamp(hsv.yz, 0.0, 1.0);\n    return hsv.z * (0.63 * hsv.y * (cos(TWOPI *(hsv.x + K)) - 1.0) + 1.0);\n}\n\n\n/*\n  Transform objects in view space to model space\n*/\n\nmat3 viewMatrix(vec3 eye, vec3 lookat, vec3 up)\n{\n    vec3 f = normalize(lookat - eye);\n    vec3 r = normalize(cross(f, up));\n    vec3 u = normalize(cross(r, f));\n    return mat3(r, u, -f);\n}\n\n\n/*\n    Get ray directions\n*/\n\nvec3 rayDirection(float fov, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\n/*\n    Constructive solid geometry union operation on SDF-calculated distances.\n*/\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\n\n/*\n  Signed distance function for a sphere kissing the origin with radius r.\n*/\n\nfloat sphereSdf(vec3 p, float r)\n{\n    p.z -= r;\n    return length(p) - r;\n}\n\n\n/*\n  Signed distance functions for the z=0 and z=c planes\n*/\n\nfloat planeSdf(vec3 p)\n{\n    return length(p.z);\n}\n\nfloat planeSdf(vec3 p, float planeOffset)\n{\n    return length(p.z) - planeOffset;\n}\n\n\n// ACES tone mapping\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 tonemap(vec3 color)\n{\n   const float A = 2.51;\n   const float B = 0.03;\n   const float C = 2.43;\n   const float D = 0.59;\n   const float E = 0.14;\n   return (color * (A * color + B)) / (color * (C * color + D) + E);\n}","name":"Common","description":"","type":"common"}]}