{"ver": "0.1", "info": {"id": "tlcGWX", "date": "1579887489", "viewed": 239, "name": "ROOF OF THE WORLD", "username": "alro", "description": "Ray marched textured terrain, outdoor lighting and fog. Use mouse to look around.", "likes": 9, "published": 1, "flags": 32, "tags": ["mountain", "outdoor"], "requires": ["texture", "imagebuf", "texturebuf"]}, "renderpass": [{"inputs": [{"id": "4dXGzn", "filepath": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "type": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "4dXGR8", "filepath": "/media/previz/buffer00.png", "previewfilepath": "/media/previz/buffer00.png", "type": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "//Ray marching terrain based on several examples: \n//https://iquilezles.org/www/articles/terrainmarching/terrainmarching.htm\n//http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n//https://iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n//https://iquilezles.org/www/articles/fog/fog.htm\n//https://www.shadertoy.com/view/lslfRN\n//https://www.shadertoy.com/view/MdX3Rr\n//http://www.kevs3d.co.uk/dev/shaders/\n//https://www.decarpentier.nl/scape-procedural-basics\n\n//Terrain:\tFBM of noise with some octaves inverted. Amplitude and frequency changes are from \n//\t\t\texperimenting and examples. A rotation each iteration gives more variety\n//\t\t\tas seen in multiple examples. Normals are found by sampling around the \n//\t\t\tintersection point. The Y component is set to 2.0*eps. \n//\t\t\tThe normal sampling uses more FBM iterations to get sharper looking results and \n//\t\t\tthe sampling offset depends on the ray distance\n//Marching:\tSteps are limited by number and maximum distance. The step size is a fraction\n//\t\t\tof the difference between the last sample point height and the terrain height\n//\t\t\tat those coordinates. The fraction can be changed to better capture ridges \n//\t\t\tdepending on the terrain parameters. Once a sample point is under the terrain,\n//\t\t\ta bisection method is used to move the sample backwards and forwards to find\n//\t\t\tthe 0 crossing in a binary search. Return value within EPSILON of surface or\n//\t\t\tbest approximation after a set number of iterations.\n//Textures:\tThe rock texture is noise FBM with offset height-based stripes. Close range rock\n//\t\t\talso has fine noise texture. Snow is a plain white colour on slopes facing \n//\t\t\tupward. The snow boundary is offset by noise to avoid straight lines.\n//Lighting:\tThree lights based on iq article. Strong white light from the sun. Soft shadows\n//\t\t\tusing ray marching. Sky light is a blueish light directly from above. A third\n//\t\t\twhite light is used to simulate indirect lighting in a very bright environment.\n//\t\t\tIncludes tinted fog to give a sense of scale.\n\n\n\nconst int MAX_STEPS = 250;\nconst float MAX_DIST = 3000.0;\nconst float EPSILON = 1e-4;\nconst float PI = 3.1415;\nconst int SHADOW_STEPS = 64;\n//e.g. 8.0: soft, 128: hard\nconst float SHADOW_SHARPNESS = 16.0;\nconst float HEIGHT = 200.0;\nconst float SCALE = 0.005;\n\nconst int terrainLimit = 5;\nconst int normalLimit = 9;\nconst int cameraLimit = 2;\n\nconst vec3 skyColour = 0.65 * vec3(0.09, 0.33, 0.81);\nconst vec3 sunLightColour = vec3(1);\nconst vec3 sunColour = vec3(1.0, 1.0, 0.8);\nconst vec3 specularColour = vec3(1);\n\nconst float speed = 10.0;\n\n//In a circle of 2*PI\nconst float sunLocation = 1.633;\n//0: horizon, 1: zenith\nconst float sunHeight = 0.2;\n\nvec3 rayDirection(float fieldOfView, vec2 fragCoord) {\n    vec2 xy = fragCoord - iResolution.xy / 2.0;\n    float z = (0.5 * iResolution.y) / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n//https://www.geertarien.com/blog/2017/07/30/breakdown-of-the-lookAt-function-in-OpenGL/\nmat3 lookAt(vec3 camera, vec3 targetDir, vec3 up){\n  vec3 zaxis = normalize(targetDir);    \n  vec3 xaxis = normalize(cross(zaxis, up));\n  vec3 yaxis = cross(xaxis, zaxis);\n\n  return mat3(xaxis, yaxis, -zaxis);\n}\n\n//Darken sky when looking up\nvec3 getSkyColour(vec3 rayDir){\n    return mix(skyColour, 0.2*skyColour, rayDir.y);\n}\n\n//By iq\nfloat noised( in vec2 x ){\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n  \n    vec2 p = floor(x);\n\tfloat a = textureLod( iChannel0, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\n\tfloat b = textureLod( iChannel0, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\n\tfloat c = textureLod( iChannel0, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\n\tfloat d = textureLod( iChannel0, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\n    \n\tfloat res = (a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y);\n    res = res - 0.5;\n    return res;\n}\n\nfloat fbm(vec3 pos, int limit){\n    float res = 0.0;\n    float freq = 1.72;\n    float amp = 0.5;\n    for(int i = 0; i < 9; i++){ \n        if(i == limit){break;}\n        if(i < 3){\n        \tres += (1.0-abs(noised(freq*0.5*pos.xz)))*amp*2.5;\n        }else{ \n        \tres += noised(freq*pos.xz)*amp;\n        }\n        freq *= 2.5;\n        amp *= 0.25;\n        pos.xz *= mat2(1, -.75, .75, 1);\n    }\n\treturn res;\n}\n\n//Get height of terrain at xz coordinates\nfloat getHeight(vec3 pos, int limit){\n    return HEIGHT*fbm(SCALE*pos, limit);\n}\n\n//Binary search for 0 crossing given two points on either side of the surface\nfloat bisection(vec3 start, vec3 rayDir, float near_, float far_){\n    float midpoint = (far_ + near_) * 0.5;\n    //Sample point\n    vec3 p = vec3(0);\n    float near = near_;\n    float far = far_;\n    float height = 0.0;\n    //Difference between sample point and terrain heights\n    float diff = 0.0;\n    \n    for(int i = 0; i < 8; i++){\n        p = start + rayDir * midpoint;\n        height = getHeight(p, terrainLimit);\n        diff = p.y - height;\n        \n        if(abs(diff) < EPSILON){\n        \tbreak;\n        }else{\n            \n            if(diff < EPSILON){\n                //Point is below terrain\n                //Search first half\n                far = midpoint;\n            }else{\n                //Point is above terrain\n                //Search second half\n                near = midpoint;\n            }\n            midpoint = (far + near) * 0.5;\n        }\n    }\n    return midpoint;\n}\n\nfloat getIntersection(vec3 start, vec3 rayDir, float maxDist){\n\t//Distance between sample points. Set according to previous sample\n    float stepSize = 0.0;\n    //Height of the terrain\n    float height = 0.0;\n    //Length of the ray\n    float dist = 0.0;\n    //Difference between sample point and terrain heights\n    float diff = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++){\n        //Sample point\n        vec3 p = start + rayDir * dist;\n        \n        //The height of the terrain at the xz coordinates of the sample point\n        height = getHeight(p, terrainLimit);\n        diff = abs(p.y - height);\n        //If sample point is close enough to the terrain, return distance\n        if(diff < EPSILON){\n            return dist;\n        }\n        //If height of sample point is less than the height of the terrain,\n        //the ray has hit the terrain. Use bisection to find the 0 crossing\n        if(p.y < height){\n        \tdist = bisection(start, rayDir, dist - stepSize, dist);\n            return dist;\n        }\n        \n        //Static step size misses features and leads to banding. \n        //Set the step size to a fraction of the distance above the terrain.\n        //Could also have a small step size which increases with distance, giving \n        //detailed results close to the camera and reaching far. However, \n        //this approach is used in many shaders and seems to give best results\n        stepSize = diff * 0.5;\n        \n        //Increment ray\n        dist += stepSize;\n        \n        if(dist > MAX_DIST){\n        \treturn MAX_DIST;\n        }\n    }\n    return dist;\n}\n\n//http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n//Making the normal sample distance depend on the ray length leads to less noise\nvec3 getNormal(vec3 p, float t){\n    float eps = 0.001 * t;\n\n    return normalize(vec3( \n        getHeight(vec3(p.x-eps, p.y, p.z), normalLimit) \n        - getHeight(vec3(p.x+eps, p.y, p.z), normalLimit),\n        \n        2.0*eps,\n        \n        getHeight(vec3(p.x, p.y, p.z-eps), normalLimit) \n        - getHeight(vec3(p.x, p.y, p.z+eps), normalLimit) \n    ));\n}\n\n//https://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat softShadow(vec3 pos, vec3 rayDir){\n    float res = 1.0;\n    float t = 1.0;\n    //float ph = 1e10;\n    //Start some small distance away from the surface to avoid artifacts\n    pos += rayDir * 5.0 * t;\n\tfor(int i = 0; i < SHADOW_STEPS; i++){\n\t    vec3 p = pos + t * rayDir;\n        if(p.y > 2.0*HEIGHT){\n        \tbreak;\n        }\n        float h = p.y - getHeight(p, terrainLimit);\n\t\tres = min(res, SHADOW_SHARPNESS * h / t );\n        /*\n\t\t//An improved shadow approach that didn't quite work\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, SHADOW_SHARPNESS*d/max(0.0,t-y) );\n        ph = h;\n\t\t*/\n\t\tt += h;\n        if(res < EPSILON){\n            break;\n        }\n\t}\n\treturn clamp(res, 0.0, 1.0);\n}\n\nfloat rockFbm(vec3 p, vec3 normal, float dist){\n    \n    float res = 0.0;\n    float freq = 0.005;\n    float amp = 0.5;\n    \n    //When close to the rock, add fine detail. \n    //Showing it at all distances introduces noise and shimmering.\n    if(dist < 80.0){\n    \tfloat detail = smoothstep(75.0, 0.0, dist);\n    \tres += detail*noised(40.0*p.xz);\n    }\n    \n    //Offset position height in a large wavy pattern\n    p.y += noised(0.02*p.xz) * 150.0;\n    \n    //Add several horizontal lines (offset by the above) for layers\n    for(int i = 0; i < 4; i++){\n    \tres += texture(iChannel0, freq * p.yy).r * amp;\n        freq *= 1.5;\n        amp *= 0.5;\n    }    \n    \n    return clamp(res, 0.0, 1.0);\n}\n//Return colour of surface fragment based on light information\nvec3 shading(vec3 position, vec3 normal, vec3 rayDir, float dist, vec3 lightDirection){\n    \n    float ambientStrength = 0.15;\n    \n    float specularStrength = 0.0;\n    float shininess = 32.0;\n    \n    vec3 ambientColour = vec3(0);\n    vec3 diffuseColour = vec3(0);\n    \n    //Offset the height of the position to give snow line a more organic border.\n    float height = position.y + noised( 0.2 * position.xz) * 14.0;\n\tbool snow = false;\n    //Snow occurs on horizontal enough areas\n    if(((normal.y > 0.65)) || ((height > HEIGHT*1.55) && (normal.y > 0.5))){\n        snow = true;\n    \tambientColour = vec3(1);\n        diffuseColour = vec3(1);\n        //Make snow subtly specular\n        specularStrength = 0.2;\n    }\n    \n    if(!snow){\n        //Colour rock by layering noise. \n    \t//Add dark brown and grey lines and finer detail in close proximity\n    \tvec3 rockColour = mix(0.25*vec3(0.3, 0.2, 0.1), vec3(0.8), \n                              0.5 * rockFbm(position, normal, dist));\n    \trockColour = mix(0.5*rockColour, vec3(0.3), 0.5);\n    \n        //Add darker blotches \n        if(normal.y < 0.5){\n            rockColour *= 0.8;\n        } \n\n        //Ambient colour slightly darker than diffuse\n        ambientColour = 0.75*rockColour;\n        diffuseColour = rockColour;\n    }\n    \n\tvec3 halfwayDir = normalize(lightDirection - rayDir);  \n\tfloat spec = pow(max(dot(normal, halfwayDir), 0.0), shininess);\n\n\t//Colour of light sharply reflected into the camera\n\tvec3 specular = spec * specularColour * sunLightColour; \n\t\n  \t//Path to light blocked     \n    float shadow = softShadow(position, lightDirection);\n    \n    //No specular reflections in shadow\n    if(shadow < 0.75){\n    \tspecularStrength = 0.0;\n    }\n    \n\tvec3 result = vec3(0.0); \n    \n\t//How much a fragment faces the sun\n\tfloat sun = max(dot(normal, lightDirection), 0.0);\n    //Main sun\n    vec3 sunLight = shadow * sun * sunLightColour;\n    \n    //How much the fragment faces up\n    float sky = max(dot(normal, vec3(0,1,0)), 0.0);\n    //Sky light. A blue light from directly above. A lighter blue than the sky.\n\tvec3 skyLight = sky * vec3(0.12, 0.29, 0.55);\n    \n    //Indirect light. A white light opposite to the sun direction simulates global \n    //illumination. Snow is very diffusely reflective and so valleys are not as dark. \n    //Also gives a nice scattering look to large snow banks.\n    float indirect = max(dot(normal, normalize(vec3(-1.0, 0.0, -1.0) * lightDirection)), 0.0);\n   \tvec3 indirectLight = indirect * vec3(1.0);\n    \n    //Combine light\n    result += 1.2 * sunLight;\n    result += 0.2 * skyLight;\n\tresult += 0.3 * indirectLight;\n    \n    //Light and material interaction\n    result *= diffuseColour;\n    result += ambientStrength * ambientColour + specularStrength * specular;\n\n    return  result;\n}\n\n//https://iquilezles.org/www/articles/fog/fog.htm\nvec3 applyFog(vec3  rgb, float dist, vec3 rayOri, vec3 rayDir, vec3 sunDir){\n    //Make horizon more hazy\n    if(dist == MAX_DIST){dist = 4000.0;}\n    if(abs(rayDir.y) < 0.0001){rayDir.y = 0.0001;}\n    //Rate of fade\n    float b = 0.012;\n    float fogAmount = 1.0 * exp(-rayOri.y*b) * (1.0-exp(-dist*rayDir.y*b))/rayDir.y;\n    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n    vec3  fogColor  = mix( vec3(0.5,0.6,0.7), vec3(1.0), pow(sunAmount, 8.0) );\n    return mix(rgb, fogColor, clamp(fogAmount, 0.0, 1.0));\n}\n\nfloat getGlow(float dist, float radius, float intensity){\n    dist = max(dist, 1e-6);\n\treturn pow(radius/dist, intensity);\t\n}\n\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n//Thanks for the suggestion loicvdb\nvec3 ACESFilm(vec3 x){\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    //Get the default direction of the ray (along the negative Z direction)\n    vec3 rayDir = rayDirection(40.0, fragCoord);\n\tbool resolutionChanged = (texelFetch(iChannel1, ivec2(0.5, 2.5), 0).x == 1.0);\n    \n    //----------------- Define a camera -----------------\n    \n    vec3 cameraPos = vec3(120.0, 40.0, -400.0-iTime * speed);\n    cameraPos.y = getHeight(cameraPos, cameraLimit) + 30.0;\n\t\n    vec3 targetDir = texelFetch(iChannel1, ivec2(0.5, 1.5), 0).xyz;\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    //Get the view matrix from the camera orientation\n    mat3 viewMatrix = lookAt(cameraPos, targetDir, up);\n    \n    //Transform the ray to point in the correct direction\n    rayDir = normalize(viewMatrix * rayDir);\n    \n    //---------------------------------------------------\n    \n    \n    vec3 lightDirection = normalize(vec3(sin(sunLocation), sunHeight, cos(sunLocation)));\n    \n    //Find the distance to where the ray stops\n    float dist = getIntersection(cameraPos, rayDir, MAX_DIST);\n    vec3 col;\n    \n    bool skyVisible = false;\n    if(dist == MAX_DIST){\n        skyVisible = true;\n    \tcol = getSkyColour(rayDir);\n    }else{\n    \tvec3 position = cameraPos + rayDir * dist;\n    \tvec3 normal = getNormal(position, dist);\n\t\tcol = shading(position, normal, rayDir, dist, lightDirection);\n    }\n    \n    col = applyFog(col, dist, cameraPos, rayDir, lightDirection);\n    \n    //Display the sun as a glow in the light direction\n    if(skyVisible){\n    \tfloat mu = dot(rayDir, lightDirection);\n    \tcol += sunColour*getGlow(1.0-mu, 0.00015, 0.9);\n    }\n   \n    //Tonemapping\n    col = ACESFilm(col);\n\n    //Gamma correction 1.0/2.2 = 0.4545...\n    col = pow(col, vec3(0.4545));\n    \n    //Output to screen\n    fragColor = vec4(col, 1.0);\n}", "name": "Image", "description": "", "type": "image"}, {"inputs": [{"id": "4dXGR8", "filepath": "/media/previz/buffer00.png", "previewfilepath": "/media/previz/buffer00.png", "type": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dXGR8", "channel": 0}], "code": "//Track mouse movement and resolution change between frames and set view direction\n\n#define PI 3.14159\n#define EPS 1e-4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    //Work with just the first four pixels\n    if((fragCoord.x == 0.5) && (fragCoord.y < 4.0)){\n        \n        vec4 oldMouse = texelFetch(iChannel0, ivec2(0.5), 0).xyzw;\n        vec4 mouse = (iMouse / iResolution.xyxy); \n        vec4 newMouse = vec4(0);\n\n        float mouseDownLastFrame = texelFetch(iChannel0, ivec2(0.5, 3.5), 0).x;\n        \n        //If mouse button is down and was down last frame\n        if(iMouse.z > 0.0 && mouseDownLastFrame > 0.0){\n            \n            //Difference between mouse position last frame and now\n            vec2 mouseMove = mouse.xy-oldMouse.zw;\n            if((length(mouseMove) > EPS)){\n                newMouse = vec4(oldMouse.xy+vec2(0.1, 0.05)*normalize(mouseMove), mouse.xy);\n            }else{\n                newMouse = vec4(oldMouse.xy, mouse.xy);\n            }\n        }else{\n            newMouse = vec4(oldMouse.xy, mouse.xy);\n        }\n        newMouse.x = mod(newMouse.x, 2.0*PI);\n        newMouse.y = max(-0.9, min(0.9, newMouse.y));\n\n        //Store mouse data in the first pixel of Buffer A\n        if(fragCoord == vec2(0.5, 0.5)){\n            //Set value at first frames\n            if(iFrame <= 2){\n                newMouse = vec4(0);\n                \n            }\n            fragColor = vec4(newMouse);\n        }\n\n        //Store view direction in the second pixel of Buffer A\n        if(fragCoord == vec2(0.5, 1.5)){\n            //Set camera position from mouse information\n            vec3 targetDir = vec3(sin(newMouse.x), newMouse.y, -cos(newMouse.x));\n            fragColor = vec4(targetDir, 1.0);\n        }\n        \n        //Store resolution change data in the third pixel of Buffer A\n        if(fragCoord == vec2(0.5, 2.5)){\n            float resolutionChangeFlag = 0.0;\n            //The resolution last frame\n            vec2 oldResolution = texelFetch(iChannel0, ivec2(0.5, 2.5), 0).yz;\n            \n            if(iResolution.xy != oldResolution){\n            \tresolutionChangeFlag = 1.0;\n            }\n            \n        \tfragColor = vec4(resolutionChangeFlag, iResolution.xy, 1.0);\n        }\n        \n        //Store whether the mouse button is down in the fourth pixel of Buffer A\n        if(fragCoord == vec2(0.5, 3.5)){\n            if(iMouse.z > 0.0){\n            \tfragColor = vec4(vec3(1.0), 1.0);\n            }else{\n            \tfragColor = vec4(vec3(0.0), 1.0);\n            }\n        }\n        \n    }\n}", "name": "Buffer A", "description": "", "type": "buffer"}]}