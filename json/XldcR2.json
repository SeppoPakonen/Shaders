{"ver": "0.1", "info": {"id": "XldcR2", "date": "1533355381", "viewed": 271, "name": "[SH18] Open Up", "username": "shau", "description": "First attempt at modelling a more organic face in CG.  It's still a bit robot like and the movement is a bit stiff", "likes": 17, "published": 1, "flags": 32, "tags": ["human"], "requires": ["texture", "imagebuf"]}, "renderpass": [{"inputs": [{"id": "4dXGR8", "filepath": "/media/previz/buffer00.png", "previewfilepath": "/media/previz/buffer00.png", "type": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "// Created by SHAU - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n//Competition entry for Human SH18 - Inspired by work of Adam Jones and Tool \n\nconst float GA = 2.399; \nconst mat2 rt = mat2(cos(GA), sin(GA), -sin(GA), cos(GA));\n\n//simplified version of Dave Hoskins blur borrowed from Virgill\nvec3 dof(sampler2D tex,vec2 uv,float rad) {\n\tvec3 acc = vec3(0.0);\n    vec2 pixel = vec2(0.002 * iResolution.y / iResolution.x, 0.002), angle = vec2(0.0, rad);;\n    rad=1.;\n\tfor (int j = 0; j < 80; j++) {  \n        rad += 1.0 / rad;\n\t    angle *= rt;\n        vec4 col = texture(tex, uv + pixel * (rad - 1.) * angle);\n\t\tacc += col.xyz;\n\t}\n\treturn acc / 80.;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 sc = vec4(dof(iChannel0, uv, texture(iChannel0, uv).w), 1.0).xyz;\n    fragColor = vec4(sc, 1.);\n}", "name": "Image", "description": "", "type": "image"}, {"inputs": [], "outputs": [{"id": "4dXGR8", "channel": 0}], "code": "// Created by SHAU - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define FAR 20.\n#define EPS 0.001\n#define PI 3.141593\n#define T 4. + iTime\n#define AT mod(T, 30.)\n#define SKIN 1.\n#define LEYE 2.\n#define REYE 3.\n#define TEYE 4.\n#define PIN 5.\n#define LE vec4(-0.5, -0.1, -0.27, 0.61)\n#define RE vec4(0.5, -0.1, -0.27, 0.61)\n#define TE vec4(0., 1.2, -0.9, 0.42)  \n\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\nvec3 rotOrigin(vec3 origin, vec3 pos, float a) {\n    pos -= origin;\n    pos.xz *= rot(a);\n    return pos += origin;\n}\n\nvec3 faceRotation(vec3 p) {\n    float a = clamp((AT - 8.) * 0.1, 0., 0.26) \n              - clamp((AT - 14.) * 0.05, 0., 0.20) \n              - clamp((AT - 25.) * 0.05, 0., 0.06);    \n    float ab = clamp((AT - 12.) * 0.5, 0., PI * 2.0);\n    p.yz *= rot(-0.1 + a);\n    p = rotOrigin(vec3(0., 0., 1.6), p, sin(ab) * 0.34);\n    return p;\n}\n\n//Distance function IQ and Shane\n\nfloat sdEqTriangle(vec2 p) {\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0 / k;\n    if (p.x + k * p.y > 0.0) p = vec2(p.x - k * p.y, - k * p.x - p.y) / 2.0;\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sign(p.y);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa, ba) / dot(ba, ba), 0., 1.);\n    return length(pa - ba * h) - r;\n}\n\nfloat sdEllipsoid(vec3 p, vec3 r) {\n    return (length(p / r) - 1.) * min(min(r.x, r.y), r.z);\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) {\n\tfloat h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n\treturn mix(a, b, h) + k * h * (1.0 - h);\n}\n\nvec2 nearest(vec2 a, vec2 b){ \n    float s = step(a.x, b.x);\n    return s * a + (1. - s) * b;\n}\n\n//Model\n\nfloat dfThirdEyeLid(vec3 p) {\n    float a = clamp((AT - 11.) * 0.2, 0., 0.2) - clamp((AT - 23.) * 0.1, 0., 0.2);\n    float t = max(sdSphere(p, 0.45), -sdSphere(p, 0.43));\n    p.x = abs(p.x);\n    p.xy *= rot(-PI/3.);\n    return smax(t, -sdBox(p - vec3(0.48 - a, 0., 0.), vec3(0.5)), 0.01);\n}\n\nfloat dfThirdEyeLids(vec3 p) {\n    float t = dfThirdEyeLid(p);\n    p.xy *= rot(PI/1.5);\n    t = min(t, dfThirdEyeLid(p));\n    p.xy *= rot(PI/1.5);\n    return min(t, dfThirdEyeLid(p));\n}\n\nfloat dfEyeLid(vec3 p) {\n    float t = sdSphere(p, 0.65);\n    float a = clamp((AT - 10.) * 0.5, 0., 0.4) - clamp((AT - 25.) * 0.3, 0., 0.4);\n    p.yz *= rot(-0.4 + a);\n    return smax(t, -sdEllipsoid(p - vec3(0.1, 0., -0.63), vec3(0.5, 0.04 + a * 0.3, 0.6)), 0.02);\n}\n\nfloat dfFace(vec3 p) {\n    \n    vec3 q = p;\n    float a = clamp((AT - 11.0) * 0.05, 0., 0.1) - clamp((AT - 15.) * 0.02, 0., 0.1);\n    \n    float f = sdEllipsoid(p, vec3(1.4, 2.6, 1.3)); \n    f = smin(f, sdEllipsoid(p - vec3(0., 0., 0.5), vec3(1.8, 2.0, 1.3)), 0.4);\n    f = smin(f, sdSphere(p - vec3(0., 1.2, 0.6), 1.6), 0.1);\n    f = smin(f, sdSphere(p - vec3(0., 0.9, 1.1), 2.14), 0.1);\n    q.x = abs(q.x);\n    f = smax(f, -sdBox(p - vec3(0., -1., -2.0), vec3(1., 1., 1.)), 0.8); \n    f = smax(f, -sdEllipsoid(q - vec3(0.8, -0.2, -0.9), vec3(0.6, 0.4, 0.2)), 0.3); \n    float eyeLid = sdSphere(q - vec3(0.5, -0.1, -0.27), 0.65);\n    eyeLid = smax(eyeLid, -sdEllipsoid(q - vec3(0.6, -0.1, -1.0), vec3(0.5, 0.04, 0.6)), 0.02);\n    float eyeLids = dfEyeLid(q - vec3(0.5, -0.1, -0.27));\n    f = smin(f, eyeLids, 0.1);\n    f = smax(f, -sdEllipsoid(p - vec3(0., -2.7, -0.84), vec3(1.2, 2.0, 0.16)), 0.04);\n    f = max(f, -sdBox(p - vec3(0.0, -1.5, -0.6), vec3(0.4, 0.12, 0.3)));\n    float topLip = sdEllipsoid(p - vec3(0., -1.3, -0.7), vec3(0.6, 0.4, 0.3));\n    topLip = smax(topLip, -sdCapsule(p, vec3(0., -1.0, -1.0), vec3(0., -1.6, -1.1), 0.06), 0.08);\n    topLip = smax(topLip, -sdEllipsoid(q - vec3(0., -1.8 + a, -0.7), vec3(0.8, 0.3, 1.0)), 0.01);\n    f = smin(f, topLip, 0.08);\n    float bottomLip = sdEllipsoid(p - vec3(0., -1.4, -0.65), vec3(0.6, 0.5, 0.2));\n    bottomLip = smax(bottomLip, -sdEllipsoid(q - vec3(0., -1.1 - a, -0.7), vec3(0.7, 0.4, 1.0)), 0.01);\n    f = smin(f, bottomLip, 0.06);\n    float nostrilHole = sdCapsule(q, vec3(0.2, -1.2, -1.1), vec3(0.1, -0.9, -1.0), 0.08);\n    q.yz *= rot(-0.2);\n    f = smin(f, sdEllipsoid(q - vec3(0.0, -0.7, -1.1), vec3(0.26, 0.18, 0.4)), 0.06);\n    f = smin(f, sdCapsule(p, vec3(0.0, -0.8, -1.1), vec3(0.0, 0.4, -0.9), 0.11), 0.14); \n    f = smax(f, -nostrilHole, 0.08);\n    q = p;\n    q.x = abs(q.x); \n    f = smax(f, -sdSphere(q - vec3(2.3, -1.5, -1.2), 1.4), 0.3); \n\tf = smin(f, dfThirdEyeLids(p - vec3(0., 1.2, -0.9)), 0.2);    \n\n    return f;\n}\n\nfloat dfEye(vec3 p, vec4 eye) {\n    p -= eye.xyz;\n    float a = clamp((AT - 10.) * 0.1, 0., 0.2)\n              - clamp((AT - 15.) * 0.1, 0., 0.15)\n              - clamp((AT - 24.) * 0.2, 0., 0.25);\n    p.yz *= rot(-0.1 + a);\n    return max(sdSphere(p, eye.w), -sdSphere(p - vec3(0., 0., -0.6), 0.16));\n}\n\nvec3 map(vec3 p) {\n    \n    vec3 q = p;\n    \n    float body = sdCapsule(p, vec3(0., 1., 0.8), vec3(0., -7., 3.), 1.);\n    body = smin(body, sdEllipsoid(p - vec3(0., -3.0, 1.1), vec3(0.2, 0.3, 0.3)) , 0.3);\n    q.x = abs(q.x);\n    body = smin(body, sdCapsule(q, vec3(0.6, 1., 0.4), vec3(1.0, -7., 2.6), 0.2), 0.2);\n    body = smin(body, sdEllipsoid(p - vec3(0., -5.0, 2.4), vec3(4.0, 1.8, 1.6)), 0.4);\n    body = smin(body, sdSphere(q - vec3(3.4, -5.0, 2.4), 1.2), 0.4);\n    body = smin(body, sdEllipsoid(p - vec3(0., -3.0, 1.4), vec3(1.16, 0.2, 0.2)), 0.06);\n    body = smin(body, sdEllipsoid(p - vec3(0., -2.6, 1.3), vec3(1.16, 0.2, 0.2)), 0.06);\n    body = smin(body, sdEllipsoid(p - vec3(0., -2.2, 1.2), vec3(1.16, 0.2, 0.2)), 0.06);\n\n    float pins = sdEllipsoid(p - vec3(0., -3.0, 1.4), vec3(2.4, 0.06, 0.06));\n    pins = min(pins, sdEllipsoid(p - vec3(0., -2.6, 1.3), vec3(2.0, 0.06, 0.06)));\n    pins = min(pins, sdEllipsoid(p - vec3(0., -2.2, 1.2), vec3(1.6, 0.06, 0.06)));\n    \n    q = faceRotation(p);    \n    float f = dfFace(q);\n\n    float leftEye = dfEye(q, LE);\n    float rightEye = dfEye(q, RE);\n\tfloat thirdEye = sdSphere(q - TE.xyz, TE.w);    \n\n    vec2 near = nearest(vec2(smin(f, body, 0.3), SKIN), vec2(leftEye, LEYE));\n    near = nearest(near, vec2(rightEye, REYE));\n    near = nearest(near, vec2(thirdEye, TEYE));\n    near = nearest(near, vec2(pins, PIN));\n   \n    return vec3(near, f);\n}\n\nvec3 normal(vec3 p) {  \n    vec2 e = vec2(-1., 1.) * EPS;   \n\treturn normalize(e.yxx * map(p + e.yxx).x + e.xxy * map(p + e.xxy).x + \n\t\t\t\t\t e.xyx * map(p + e.xyx).x + e.yyy * map(p + e.yyy).x);   \n}\n\nfloat tattoo(vec2 uv) {\n    float t = 1.0 - sign(sdEqTriangle(uv * 0.5)) * sign(sdEqTriangle(uv * 0.6));\n    return uv.x > 0. ? 1. - clamp(t, 0., 0.5) : 0.2 + (t * 0.2);    \n}\n\n//noise and environment mapping from Terrain Lattice by Shane\n//Shader of the week at the moment :)\nfloat n3D(vec3 p) {    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); \n    p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p * p * (3. - 2. * p);\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\nvec3 envMap(vec3 p){    \n    p *= 2.;\n    p.xz += T * .5;\n    float n3D2 = n3D(p * 2.);\n    float c = n3D(p) * .57 + n3D2 * .28 + n3D(p * 4.) * .15;\n    c = smoothstep(0.5, 1., c);    \n    p = vec3(c * .8, c * .9, c);\n    return mix(p.zxy, p, n3D2 * .34 + .665);\n}\n\n//IQ - http://www.iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm\nfloat AO(vec3 rp, vec3 n) {\n\n    float r = 0.0;\n    float w = 1.0;\n    float d = 0.0;\n\n    for (float i = 1.0; i < 5.0; i += 1.0){\n        d = i / 5.0;\n        r += w * (d - map(rp + n * d).x);\n        w *= 0.5;\n    }\n\n    return 1.0 - clamp(r, 0.0, 1.0);\n}\n\n//IQ - https://www.shadertoy.com/view/lsKcDD\nfloat softShadow(vec3 ro, vec3 rd, float mint, float tmax) {\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10;\n    \n    for (int i = 0; i < 32; i++) {\n\t\tfloat h = map(ro + rd * t).x;\n        float y = h * h / (2.0 * ph);\n        float d = sqrt(h * h - y * y);\n        res = min(res, 10.0 * d / max(0.0, t-y));\n        ph = h;        \n        t += h;\n        if (res < 0.0001 || t > tmax) break;\n    }\n    \n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 vMarch(vec3 ro, vec3 rd, vec4 eye) {\n    \n    vec3 pc = vec3(0.0);\n    float t = 0.0;\n    float a = clamp((AT - 14.) * 0.3, 0., 0.3) - clamp((AT - 22.) * 0.3, 0., 0.3);\n    ro.xyz = faceRotation(ro.xyz);\n    \n    for (int i = 0; i < 64; i++) {\n        vec3 rp = ro + t * rd;\n        float c = length(rp - eye.xyz);\n        if (c > eye.w + EPS) break;\n        t += 0.05;\n        pc += vec3(1., 0., 0.) / (1.0 + c * c * 1000.1);\n        pc += (0.06 + a) * vec3(1., 0.8, 0.) / (1.0 + c * c * c * 1000.1);\n    } \n    \n    return pc;\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n    \n    float t = 0.;\n    float id = 0.;\n    float f = 0.;\n    for (int i = 0; i < 98; i++) {\n        vec3 ns = map(ro + rd * t);\n        if (ns.x < EPS || t > FAR) {\n            id = ns.y;\n            f = ns.z;\n            break;\n        }\n        t += ns.x * 0.8;\n    }\n    \n    return vec3(t, id, f);\n}\n\nvoid setupCamera(vec2 fragCoord, inout vec3 ro, inout vec3 rd) {\n\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    vec3 lookAt = vec3(0.0, -0.5, 0.0);\n    ro = lookAt + vec3(0.0, -2.0 - sin(T * 0.3), -6.6 + sin(T * 0.06) * 0.3);\n    ro.xz *= rot(sin(T * 0.14) * 0.6);    \n    float FOV = PI / 3.0;\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0.0, -forward.x)); \n    vec3 up = cross(forward, right);\n\n    rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec3 ro, rd;\n    vec3 lp = vec3(8., 15., -12.);\n    float mint = FAR;\n    \n    setupCamera(fragCoord, ro, rd);\n    \n    vec3 pc = vec3(0., 0.3, 0.1) * n3D(8. * rd + T * 0.1) * max(0., rd.y) * 0.6;\n    \n    vec3 t = march(ro, rd);\n    if (t.x > 0. && t.x < mint) {\n        mint = t.x;\n        vec3 rp = ro + rd * t.x;\n        vec3 n = normal(rp);\n        vec3 ld = normalize(lp - rp);\n        float lt = length(lp - rp);\n        float atten = 1. / (1. + lt * lt * 0.003);\n        float diff = max(dot(ld, n), 0.05);\n\t    float spec = pow(max(dot(reflect(-ld, n), -rd), 0.0), 64.); \n        float sspec = pow(max(dot(reflect(-ld, n), -rd), 0.0), 2.); \n        float fre = pow(clamp(dot(n, rd) + 1., .0, 1.), 4.) * 0.5;\n        vec3 env = envMap(reflect(rd, n)) * 2.;\n\t\tfloat ao = AO(rp, n);\n        float sh = softShadow(rp, ld, 0.01, 3.0);\n        vec3 sc = vec3(1.);\n        \n        if (t.y == LEYE) {\n            \n            sc = vec3(1., 0., 0.) * 0.3;\n            sc *= diff;\n            sc += vMarch(rp, rd, LE);\n            sc += vec3(1.) * spec;\n            sc += vec3(1.) * fre;\n        \n        } else if (t.y == REYE) {\n        \n            sc = vec3(1., 0., 0.) * 0.3;    \n            sc *= diff;\n            sc += vMarch(rp, rd, RE);\n            sc += vec3(1.) * spec;\n            sc += vec3(1.) * fre;\n        \n        } else if (t.y == TEYE) {\n            \n            sc = vec3(1., 0., 0.) * 0.3;    \n            sc *= diff;\n            sc += vMarch(rp, rd, TE);\n            sc += vec3(1.) * spec;\n            sc += vec3(1.) * fre;\n        \n        } else if (t.y == PIN) {  \n            \n            sc = vec3(0.1);\n            sc *= diff;\n            sc += env;\n            sc += vec3(1.0) * spec;\n        \n        } else {\n            \n            if (t.z < EPS) rp = faceRotation(rp);\n            float tat = tattoo(rp.xy);\n\t\t    sc = vec3(1.) * tat;\n            sc *= diff;\n            sc += vec3(0.4) * sspec;\n            sc *= atten;\n            \n        }\n        \n        sc += 0.1 * vec3(0., 0.3, 0.1) * clamp(n.x * -1., 0., 1.);\n        sc *= 0.4 + sh * 0.6;\n        \n        pc = sc * ao;\n    }\n            \n    fragColor = vec4(pc, mint / FAR * 0.3);\n}", "name": "Buffer A", "description": "", "type": "buffer"}]}