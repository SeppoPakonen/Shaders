{"ver":"0.1","info":{"id":"wsGcDh","date":"1602699311","viewed":92,"name":"Chromatic Aberration RayMarch","username":"DoubleRedGaming","description":" Something","likes":5,"published":3,"flags":32,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n    vec2 uv = fragCoord / res;\n    vec4 col = vec4(0.0);\n    \n    float modif = 0.5 + (0.5 * cos(radians(iTime * 180.0)));\n    \n    vec4 col1 = texture(iChannel0, uv - (vec2(0.03, 0.0) * modif)); // Chromatic aberration\n    vec4 col2 = texture(iChannel0, uv);\n    vec4 col3 = texture(iChannel0, uv + (vec2(0.03, 0.0) * modif));\n    \n    vec4 colm = (col1 * vec4(1.0, 0.0, 0.0, 1.0)) + (col2 * vec4(0.0, 1.0, 0.0, 1.0)) + (col3 * vec4(0.0, 0.0, 1.0, 1.0));\n    \n    fragColor = mix(col2, colm, modif);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"mat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0.0, 1.0);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p-c)-r;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    //t = clamp(t, 0.0, 1.0);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-0.5)-0.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n    return e+i;\n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s) {\n    return length(max(abs(p)-s, 0.0));\n}\n\nfloat GetDist(vec3 p) {\n    float pd = p.y;\n    \n    vec3 bp1 = p-vec3(5, 1.5, 0.0);\n    vec3 bp2 = p-vec3(4, 1.5, 0.0);\n    vec3 bp3 = p-vec3(0, 1.5, 0.0);\n    vec3 bp4 = p-vec3(-4.5, 1.5, 0.0);\n    bp1.yz *= rot(iTime*3.141*0.5);\n    bp2.yz *= rot((iTime*3.141*0.5)+(3.141*0.5));\n    bp3.xz *= rot((-iTime*3.141*0.125));\n    \n    float bd1 = sdTorus(bp1, vec2(1, 0.5));\n    float bd2 = sdTorus(bp2, vec2(1, 0.5));\n    float bd3 = dBox(bp3, vec3(1.0, 0.5, 1.0));\n    float bd4 = sdCapsule(bp4, vec3(1.5, sin(iTime*3.141*0.25), 2.0), vec3(0.5, cos(iTime*3.141*0.25), -2.0), 0.5);\n    float d = min(bd1, bd2);\n    d = min(d, bd3);\n    d = min(d, bd4);\n    d = min(d, pd);\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p);\n    vec2 e = vec2(0.01, 0.0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx)\n    );\n    \n    return normalize(n);\n}\n\nvec4 GetLight(vec3 p) {\n    vec3 lightPos[3];\n    lightPos[0] = vec3(5, 6, 0);\n    lightPos[1] = vec3(-2, 5, 1);\n    lightPos[2] = vec3(-4, 10, 10);\n    \n    vec3 lightCol[3];\n    lightCol[0] = vec3(0.1, 0.3, 0.05);\n    lightCol[1] = vec3(0.4, 0.2, 0.2);\n    lightCol[2] = vec3(0.1, 0.1, 0.3);\n    \n    vec4 col = vec4(0.0);\n    \n    for(int i; i<3; i++) {\n        vec3 l = normalize(lightPos[i]-p);\n        vec3 n = GetNormal(p);\n        \n        float dif = clamp(dot(n, l), 0.0, 1.0);\n        float d = RayMarch(p+n*SURF_DIST*2.0, l);\n        if(d<length(lightPos[i]-p)) dif *= 0.1;\n        \n        col += dif * vec4(lightCol[i], 1.0);\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n    vec2 uv = (fragCoord - (0.5 * res)) / res.y;\n    vec4 col = vec4(0.0);\n    \n    vec3 ro = vec3(0.0, 4.0, -10.0);\n    vec3 rd = normalize(vec3(uv.xy, 1));\n    \n    ro.zx *= rot(radians((iTime * 22.5) + 180.0)); //Origin rotation\n    \n    rd.xy *= rot(radians(sin(radians(iTime * 10.0))));\n    rd.zy *= rot(radians(sin(-radians(iTime * 180.0)) - 10.0)); //Direction rotation, this line makes the camera go up and down\n    rd.zx *= rot(radians((iTime*22.5) + 180.0)); //This one makes the camera rotate along the center\n    \n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    vec4 dif = GetLight(p);\n    dif *= (1.0 / d) * 8.0; //Multiply some smoothness to the lighting, semi shading, just a distance modifier\n    col = dif;\n    col += (d * 0.005 * vec4(0.1, 0.5, 0.8, 0.0)); //Add a little lovely fog effect in the background\n    \n    fragColor = col;\n}","name":"Buf A","description":"","type":"buffer"}]}