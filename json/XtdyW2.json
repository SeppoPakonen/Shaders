{"ver": "0.1", "info": {"id": "XtdyW2", "date": "1534142612", "viewed": 26173, "name": "Blue Noise Generator", "username": "paniq", "description": "generates a new blue noise texture every 60 * 60 frames and then continues to optimize out low frequency noise. Still needs some work, but it's a good start. ", "likes": 26, "published": 3, "flags": 32, "tags": ["noise"], "requires": ["texture", "texturebuf", "library", "imagebuf"]}, "renderpass": [{"inputs": [{"id": "4dXGR8", "filepath": "/media/previz/buffer00.png", "previewfilepath": "/media/previz/buffer00.png", "type": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "XsXGR8", "filepath": "/media/previz/buffer01.png", "previewfilepath": "/media/previz/buffer01.png", "type": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "XsBSR3", "filepath": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "type": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    ivec2 sz = ivec2(iResolution.xy);\n    ivec2 px = ivec2(fragCoord);\n   \tfloat v_ref = texelFetch(iChannel1, ivec2(fragCoord)/1 % ivec2(iChannelResolution[1].xy), 0).r;\n#if 0\n    float v = texelFetch(iChannel0, px, 0).r;    \n    float v_old = texelFetch(iChannel2, px, 0).r;\n    if (uv.x > 0.5) {\n        fragColor = vec4(v_ref,v_ref,v_ref,1.0);\n    } else if (v != v_old) {\n        fragColor = vec4(1.0,0.0,0.0,1.0);\n    } else {\n\t\tfragColor = vec4(v,v,v,1.0);\n    }\n#else\n    float v = texelFetch(iChannel0, px, 0).r;    \n#if 0\n    vec2 s0_x0 = quantify_error(iChannel0, px, sz, v, v);\n    if (uv.x > 0.5) {\n    v = s0_x0.x * 1.0;\n    }\n#endif\n\n#if 0\n    if (uv.x > 0.5) {\n        v = v_ref; \n    }\n    v = step(v, uv.y);\n#endif\n    //v = step(0.999/255.0, v);\n    //v = step(v, 0.0);\n    fragColor = vec4(v, v, v, 1.0);\n#endif\n}", "name": "Image", "description": "", "type": "image"}, {"inputs": [{"id": "XsXGR8", "filepath": "/media/previz/buffer01.png", "previewfilepath": "/media/previz/buffer01.png", "type": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dXGR8", "channel": 0}], "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 sz = ivec2(iChannelResolution[0].xy);\n    ivec2 p0 = ivec2(fragCoord);\n    \n    vec4 c = texelFetch(iChannel0, p0, 0);\n    fragColor = vec4(c);        \n\n}", "name": "Buffer A", "description": "", "type": "buffer"}, {"inputs": [], "outputs": [], "code": "vec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n#define R2 19\n\n#define SIGMA 1.414\n#define M_PI 3.14159265359\n\nfloat gaussian (float x, float sigma) {\n    float h0 = x / sigma;\n    float h = h0 * h0 * -0.5;\n    float a = 1.0 / (sigma * sqrt(2.0 * M_PI));\n    return a * exp(h);\n}\n\nfloat distf(float v, float x) {\n    return 1.0 - x;\n}\n\nvec2 quantify_error (sampler2D channel, ivec2 p, ivec2 sz, float val0, float val1) {\n    float Rf = float(R2) / 2.0;\n    int R = int(Rf);\n    float has0 = 0.0;\n    float has1 = 0.0;\n    float w = 0.0;\n    \n    for (int sy = -R; sy <= R; ++sy) {\n        for (int sx = -R; sx <= R; ++sx) {\n            float d = length(vec2(sx,sy));\n            if ((d > Rf) || ((sx == 0) && (sy == 0)))\n                continue;\n            ivec2 t = (p + ivec2(sx,sy) + sz) % sz;            \n\t\t\tfloat v = texelFetch(channel, t, 0).r;\n\n            float dist0 = abs(v - val0);\n            float dist1 = abs(v - val1);\n\n            float q = gaussian(d, SIGMA);\n\n            w += q;            \n            has0 += distf(val0, dist0) * q;\n            has1 += distf(val1, dist1) * q;\n            \n        }\n    }\n\n    vec2 result = vec2(has0 / w, has1 / w);\n    //result = result * result;\n    return result;\n}\n", "name": "Common", "description": "", "type": "common"}, {"inputs": [{"id": "XsXGR8", "filepath": "/media/previz/buffer01.png", "previewfilepath": "/media/previz/buffer01.png", "type": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "XsXGR8", "channel": 0}], "code": "                        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 sz = ivec2(iChannelResolution[0].xy);\n    ivec2 p0 = ivec2(fragCoord);\n    vec2 maskf = hash21(float(iFrame));\n    int M = 60 * 60;\n    int F = (iFrame % M);\n    float framef = float(F) / float(M);\n    float chance_limit = 0.5;\n    float force_limit = 1.0 - clamp(framef * 8.0, 0.0, 1.0);\n    force_limit = force_limit * force_limit;\n    force_limit = force_limit * force_limit;\n    if (F == 0) {\n        int c = (p0.x * 61 + p0.y) % 256;\n        fragColor = vec4(float(c) / 255.0, 0.0, 0.0, 1.0);\n    } else {\n        ivec2 mask = ivec2(maskf * vec2(sz) + maskf * vec2(sz) * framef);\n        ivec2 p1 = (p0 ^ mask) % sz;       \n        ivec2 pp0 = (p1 ^ mask) % sz;  \n\n        float chance0 = hash13(vec3(p0, float(iFrame)));\n        float chance1 = hash13(vec3(p1, float(iFrame)));\n        float chance = max(chance0, chance1);\n        \n        float v0 = texelFetch(iChannel0, p0, 0).r;\n        float v1 = texelFetch(iChannel0, p1, 0).r;\n        \n        vec2 s0_x0 = quantify_error(iChannel0, p0, sz, v0, v1);\n        vec2 s1_x1 = quantify_error(iChannel0, p1, sz, v1, v0);\n        \n        float err_s = s0_x0.x + s1_x1.x;\n        float err_x = s0_x0.y + s1_x1.y;\n        \n        float p = v0;\n        if (pp0 == p0) {\n            if ((chance < force_limit) || ((chance < chance_limit) && (err_x < err_s))) {\n                p = v1;\n            }\n        }\n        fragColor = vec4(p, 0.0, 0.0, 1.0);\n    }\n}                        \n", "name": "Buffer B", "description": "", "type": "buffer"}]}