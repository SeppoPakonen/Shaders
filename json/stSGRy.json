{"ver": "0.1", "info": {"id": "stSGRy", "date": "1624109650", "viewed": 373, "name": "Yet Another Atmosphere", "username": "LVutner", "description": " Check \"Common\" tab for more information!", "likes": 30, "published": 1, "flags": 0, "usePreview": 0, "tags": [], "requires": ["library", "imagebuf"]}, "renderpass": [{"inputs": [], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "/*\n    Calculates transmittance for light ray\n*/\nvec3 calculate_light_transmittance(vec3 position, vec3 light_direction, as_data atmosphere)\n{\n    // Calculate the step size of the secondary (light) ray.\n    float step_size = rsi(position, light_direction, atmosphere.rAtmos).y / float(AS_JSTEPS);\n\n    // Ray increment\n    vec3 ray_increment = light_direction * step_size;\n\n    // Initial ray position (we start from the centre)\n    vec3 ray_position = position + ray_increment * 0.5;\n\n    // Initialize transmittance accumulators for the secondary (light) ray.\n    vec3 transmittance = vec3(1.0);\n    \n    // Sample the secondary ray.\n    for (int i = 0; i < AS_JSTEPS; i++) \n    {\n        // Calculate the height of the sample.\n        float height = length(ray_position) - atmosphere.rPlanet;\n\n        // Get densities.\n        vec3 density = get_densities(height, atmosphere);\n        \n        // Calculate transmittance.\n        transmittance *= exp(-atmosphere.kExtinction * density * step_size);\n\n        // Increment the secondary ray time.\n        ray_position += ray_increment;\n    }\n    return transmittance;\n}\n\n/*\n    Atmospheric scattering function.\n    Look into \"Common\" tab for more info.\n*/\nvec3 atmospheric_scattering(vec3 ray_origin, vec3 ray_direction, vec3 light_direction, as_data atmosphere) \n{\n    //Intersection\n    vec2 atmosphereDists = rsi(ray_origin, ray_direction, atmosphere.rAtmos);\n    vec2 planetDists = rsi(ray_origin, ray_direction, atmosphere.rPlanet+2e3); //Check that later\n\n    //Logic\n    bool planetIntersected = planetDists.y >= 0.0;\n    bool atmosphereIntersected = atmosphereDists.y >= 0.0;\n    vec2 sd = vec2((planetIntersected && planetDists.x < 0.0) ? planetDists.y : max(atmosphereDists.x, 0.0), (planetIntersected && planetDists.x > 0.0) ? planetDists.x : atmosphereDists.y);\n\n    //Calculate step size\n    float step_size = length(sd.y - sd.x) / float(AS_ISTEPS);\n\n    // Ray increment\n    vec3 ray_increment = ray_direction * step_size;\n\n    // Initial ray position (we start from the centre)\n    vec3 ray_position = ray_origin + ray_increment * 0.5;\n\n    // Initialize accumulators for scattering and transmittance.\n    vec3 totalScattering = vec3(0.0);\n    vec3 totalTransmittance = vec3(1.0);\n    \n    // Initialize optical depth accumulator for the primary ray.\n    vec3 iOpticalDepth = vec3(0.0);\n\n    // Calculate the Rayleigh and Mie phases.\n    float VL = dot(ray_direction, light_direction);\n    vec2 phase = vec2(phase_rayleigh(VL), phase_cs_mie(VL, atmosphere.gMie));\n    \n    // Sample the primary (view) ray.\n    for (int i = 0; i < AS_ISTEPS; i++) \n\t{\n        // Calculate the height of the sample.\n        float height = length(ray_position) - atmosphere.rPlanet;\n\n        // Get densities\n        vec3 density = get_densities(height, atmosphere);\n        \n        // Calculate the optical depth of the Rayleigh, Mie scattering and Ozone for this step.\n        iOpticalDepth += density * step_size;\n\n        // Calculate transmittance.\n        vec3 iTransmittance = exp(-(atmosphere.kExtinction * iOpticalDepth));\n        \n        // Calculate transmittance for secondary ray.\n        vec3 jTransmittance = calculate_light_transmittance(ray_position, light_direction, atmosphere);\n\n        //Calculate scattering.\n        vec3 scattering = atmosphere.kScattering * (step_size * density.xy * phase);\n        \n        // Apply light transmittance.\n        scattering *= jTransmittance;\n\n        // Accumulate scattering and transmittance.\n        totalScattering += scattering * iTransmittance;\n        totalTransmittance *= iTransmittance;\n\n        // Increment the primary ray time.\n        ray_position += ray_increment;\n    }\n\n    // Calculate and return the final color.\n    return atmosphere.iSun * totalScattering;\n}\n\n/*\n    You can make different function like this one\n    for example a new one to simulate Mars atmosphere\n*/\nvec3 get_sky_color(vec3 ray_origin, vec3 ray_direction, vec3 light_direction)\n{\n    //Initialize data struct\n    as_data atmosphere;\n    \n    //Planet\n    atmosphere.rPlanet = 6371e3; //Planet radius\n    atmosphere.rAtmos = 6471e3; //Atmosphere radius\n\n    //Rayleigh\n    atmosphere.kRlh = vec3(5.8e-6, 13.3e-6, 33.31e-6); //Rayleigh coefficient\n    atmosphere.shRlh = 8e3; //Rayleigh height\n    \n    //Mie\n    atmosphere.kMie = vec3(2.1e-6); //Mie coefficient\n    atmosphere.aMie = 0.9; //Mie albedo\n    atmosphere.shMie = 1.2e3; //Mie height\n    atmosphere.gMie = 0.8; //Mie 'g' term\n    \n    //Ozone\n    atmosphere.kOzo = vec3(3.426e-7, 8.298e-7, 0.356e-7); //Ozone absorption coefficient\n    \n    //Scattering matrix\n    atmosphere.kScattering = mat2x3(atmosphere.kRlh, atmosphere.kMie);\n    \n    //Extinction matrix\n    atmosphere.kExtinction[0] = atmosphere.kRlh; //Rayleigh\n    atmosphere.kExtinction[1] = atmosphere.kMie / atmosphere.aMie; //Mie\n    atmosphere.kExtinction[2] = atmosphere.kOzo; //Ozone\n        \n    //Sun intensity\n    atmosphere.iSun = 22.0; //Just sun intensity\n   \n    //Output\n\treturn atmospheric_scattering(ray_origin, ray_direction, light_direction, atmosphere);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //texcoord\n    vec2 texcoord = fragCoord / iResolution.xy;\n    \n    //UV for cubemap texture\n    vec2 uv_cube = texcoord * 2.0 - 1.0;\n    uv_cube.x *= iResolution.x / iResolution.y; //Fixed aspect ratio\n\n    //Ray origin\n    vec3 ray_origin = vec3(0.0, 6371e3, 0.0);    \n\n    //Ray direction\n    vec3 ray_direction = equirectangular(fragCoord, iResolution.xy);\n    \n    //A bit dynamic light direction\n    vec3 light_direction = normalize(vec3(0.0, 0.02, 1.0));\n\n    //Get atmosphere\n    vec3 color = get_sky_color(ray_origin, ray_direction, light_direction);\n\n    //Apply tonemapping\n    color = color * ACESInputMat;    \n    color = RRTAndODTFit(color);    \n    color = color * ACESOutputMat;\n    color = clamp(color, 0.0, 1.0);\n\n    //Convert from linear to sRGB space\n    color = pow(color, vec3(1.0 / 2.2));\n    \n    //Output\n    fragColor = vec4(color, 1.0);\n}", "name": "Image", "description": "", "type": "image"}, {"inputs": [], "outputs": [], "code": "/*\n    Atmospheric scattering\n\n    I'm not saying it's the most accurate atmosphere in the world, but I'm pretty sure it can be good resource for someone who just\n    started working on atmospheric scattering.\n    There's still plenty of room for optimization, improvments.\n\n\n    Feel free to fork this shader, if you do so - send a link to your work in comments!\n    \n    References:\n    https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-16-accurate-atmospheric-scattering\n    https://www.alanzucconi.com/2017/10/10/atmospheric-scattering-1/\n    https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky/simulating-colors-of-the-sky\n    https://github.com/wwwtyro/glsl-atmosphere\n\n    Credits:\n    @wwwtyro - For basic implementation of atmospheric scattering!\n    @Jessie - For Cornette-Shank phase function, and ozone density approximation!\n    @Zabidon - For equirectangular projection function!\n    \n    Edits: \n    13.10.2021 - small refactor of the code, fixed phase function names\n    15.10.2021 - refactored code, added equirectangular projection, added small opt...\n    18.10.2021 - some tweaks\n    22.10.2021 - fixed extinction matrix... gosh\n    01.11.2021 - added Jessie's step size method\n    05.11.2021 - fixed issue with raymarch\n    \n    DISCLAIMER:\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, \n    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. \n    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, \n    DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE\n*/\n\n#define PI 3.141592\n#define AS_ISTEPS 128 //Scattering steps\n#define AS_JSTEPS 128 //Transmittance steps\n\n/*\n    Struct with data used in atmosphere scattering function\n*/\nstruct as_data\n{\n\tfloat rPlanet; //Planet radius\n    float rAtmos; //Atmosphere radius\n\n\tvec3 kRlh; //Rayleigh coefficient\n    float shRlh; //Rayleigh scattering height\n    \n    vec3 kMie; //Mie coefficients\n    float aMie; //Mie albedo\n    float shMie; //Mie scattering height\n    float gMie; //g for Mie phase\n    \n\tvec3 kOzo; //Ozone extinction coefficient\n\n    mat2x3 kScattering; //Scattering coeff matrix\n    mat3x3 kExtinction; //Extinction coeff matrix\n\n    float iSun; //Sun luminance\n};\n\n/*\n    Rayleigh phase\n*/\nfloat phase_rayleigh(float VL)\n{\n    return 3.0 * (1.0 + VL * VL) / (16.0 * PI);\n}\n\n/*\n    Cornette-Shank Mie phase\n    Thanks Jessie!\n*/\nfloat phase_cs_mie(float VL, float g_coeff) \n{\n\tfloat g_coeff_sqr = g_coeff * g_coeff;\n\tfloat p1 = 3.0 * (1.0 - g_coeff_sqr) * (1.0 / (PI * (2.0 + g_coeff_sqr)));\n\tfloat p2 = (1.0 + (VL * VL)) * (1.0/pow((1.0 + g_coeff_sqr - 2.0 * g_coeff * VL), 1.5));\n    \n\tfloat phase = (p1 * p2);\n\tphase *= 1.0 / (PI * 9.0);\n    \n\treturn max(phase, 0.0);\n}\n\n/*\n    Returns density of mie/rlh/ozo\n*/\nvec3 get_densities(float height, as_data atmosphere)\n{\n    //Rayleigh density\n    float densityRlh = exp(-height / atmosphere.shRlh);\n    \n    //Mie density\n    float densityMie = exp(-height / atmosphere.shMie);\n    \n    //Ozone density\n    float densityOzo = exp(-max(0.0, (35e3 - height) - atmosphere.rAtmos) / 5e3) * exp(-max(0.0, (height - 35e3) - atmosphere.rAtmos) / 15e3); \n    \n    //Output\n    return vec3(densityRlh, densityMie, densityOzo);\n}\n\n\n/*\n    Ray sphere intersection function\n*/\nvec2 rsi( vec3 p, vec3 dir, float r ) \n{\n\tfloat b = dot( p, dir );\n\tfloat c = dot( p, p ) - r * r;\n\t\n\tfloat d = b * b - c;\n\tif ( d < 0.0 ) {\n\t\treturn vec2( 10000.0, -10000.0 );\n\t}\n\td = sqrt( d );\n\t\n\treturn vec2( -b - d, -b + d );\n}\n\n/*\n    ACES approximation\n*/\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\nconst mat3 ACESOutputMat = mat3(\n    1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit( in vec3 v ) \n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\n/*\n    Equirectangular projection\n    Thanks @Zabidon\n*/\nvec3 equirectangular(vec2 fragcoord, vec2 resolution)\n{\n    vec2 o = (fragcoord / resolution - 0.5) * PI * 2.0;\n    o.y *= 0.5;\n    return vec3(cos(o.x), tan(o.y), sin(o.x)) * cos(o.y);\n}", "name": "Common", "description": "", "type": "common"}]}