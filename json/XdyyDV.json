{"ver": "0.1", "info": {"id": "XdyyDV", "date": "1523332261", "viewed": 3437, "name": "Shuto Highway 83", "username": "blackjero", "description": "An attempt at a city shader. Mouse to look around, 7 cameras, a bit more than a couple of minutes. The roof top coffee break (?) camera has a special look down camera control when standing next to the roof border.", "likes": 100, "published": 1, "flags": 0, "tags": ["city", "line", "ai", "ui"], "requires": ["imagebuf"]}, "renderpass": [{"inputs": [], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "// Shuto Highway 83 by Jerome Liard, April 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/XdyyDV\n// This shader is manually preprocessed in hope to increase its chances of going past the webgl timeouts...\n// Might link the non preprocessed version later.\n//\n// An attempt at a city shader. Mouse to look around, 7 cameras, a bit more than a couple of minutes. \n// The roof top coffee break (?) camera has a special look down camera control when standing next to the roof border.\n//\n// I tried to go for a Japanese urban look with a mix of modern buildings and traditional tiled houses.\n// Building arrangements within a grid cell use this https://www.shadertoy.com/view/4tXcRl (that's what they were designed for in the first place)\n// But this time they are dda+raytraced instead of ray marched, which lifts limitation on height and perf constraints (no need to evaluate neighbors etc.).\n//\n// Tracing is a nested and composited dda/raytrace/raymarch hybrid;\n//\n//   1) raytrace ground infinite plane and highway drivable surface to reduce sdf melting on streets and highway vanishing point\n//   2) 3d DDA trace a regular grid [traceBuildings()]\n//      for each cell entered\n//         partition the cell with a random split arrangements of 4 bounding boxes, 1 per building (or house)\n//         raytrace all 4 bounding boxes (some calculations can be factorized, so it is not quite as bad as it sounds) [rayMarchCellObjects()]\n//            when we hit a box, ray march a house or a building inside [rayMarchParametricBuilding()]\n//            if there was a hit, calculate its normal and ray march for AO there\n//   3) independently of DDA (except for occlusion early return), ray march highways, street lamps, z=0 ground, and march for AO there too (most of this is culled by buildings)\n//   -> composite all the hits above as we go, early return everywhere we can etc. Note AO is not global (but it's ok enough)\n//   4) trace the scene again for shadows (ouch) and lit\n//\n// Other:\n//\n//   - The sky probe function might be of interest to some (uncomment the test_sky() line to see).\n//     It is a careful manual match of a reference hosek sky probe (see get_sky()) so that we don't have to do atmosphere calculations.\n//     I used a radial gradient curve picking UI (make one in 30 minutes with your favorite imgui), \n//     and found that biexponentials are able to match the r,g,b sky gradients pretty well.\n//   - The distance to curve algorithm (important for the highway and surrounding geom clip planes) might be of interest too, see evalHighway()\n//   - Unhandled divide by zeros occasionally create buggy horizontal lines mid screen, sorry...\n//   - I didn't want to rely on textures too much and was interested in volumetric detail, so it ended up flat-ish look overall\n//   - Building windows use the old trick of tracing a ray past the window, assuming constant floor heights, and return an infinite neon plane on the ceiling. From outside, the infinite neon planes sometimes \"leak\" past real walls, we don't care\n//   - If you look up there are airliners in the sky. \n//     Their silhouette is a pretty close match of and airbus as350 although in the final shader it's just some far away pixel vomit\n//   - No AA so can be a bit flickery... sorry\n//\n// -------------------------------------------------------- lib stuff\nvec3 zset( vec3 p, float v ) { return vec3( p.x, p.y, v );}\nfloat saturate( float x ) { return clamp( x, float(0.0), float(1.0) ); }\nvec4 saturate( vec4 x ) { return clamp( x, vec4(0.0), vec4(1.0) ); }\nfloat exp_decay( float x ) { return 1. - exp( -x ); }\n// for rcp_decay, max x with something < 0 to prevent infinity and cull the other side\nfloat rcp_decay( float x ) { return x / ( 1. + x ); }\nfloat smoothstep_unchecked( float x ) { return ( x * x ) * ( 3.0 - x * 2.0 ); }\nfloat linearstep( float a, float b, float x ) { return saturate( ( x - a ) / ( b - a ) ); }\nfloat exp_bell( float x, float r ) { x *= ( 1. / r ); return exp( -x * x ); }\nfloat smoothbump( float a, float r, float x ) { return 1.0 - smoothstep_unchecked( min( abs( x - a ), r ) / r ); }\nfloat smoothbump( float x, float s1, float e1, float s2, float e2 ) { return smoothstep( s1, e1, x ) * smoothstep( e2, s2, x ); }\nfloat cosbump( float x, float x0, float r ) { return ( 1. + cos( min( abs( ( x - x0 ) / r ), 1. ) * 3.141592654 ) ) * 0.5; }\n// like smoothstep, but takes a center and a radius instead\nfloat smoothstep_c( float x, float c, float r ) { return smoothstep( c - r, c + r, x ); }\n// band, centered at 0... like smoothstep_c but different semantics\nfloat smoothband( float x, float r, float raa ) { return 1. - smoothstep_c( abs( x ), r, raa ); }\n// range start,end\nfloat smoothband( float x, float s, float e, float raa ) { return smoothband( x - ( e + s ) * 0.5, ( e - s ) * 0.5, raa ); }\nvec2 perp( vec2 v ) { return vec2( -v.y, v.x ); }\n// return range -pi,pi\nfloat calc_angle( vec2 v ) { return atan( v.y, v.x ); }\nfloat calc_angle( vec2 a, vec2 b ) { return calc_angle( vec2( dot( a, b ), dot( perp( a ), b ) ) ); }\nvec3 contrast( vec3 x, vec3 s ) { return ( x - 0.5 ) * s + 0.5; }\nfloat pow2( float x ) { return x * x; }\nvec3 pow2( vec3 x ) { return x * x; }\nvec4 pow2( vec4 x ) { return x * x; }\nfloat pow5( float x ) { float x2 = x * x; return x2 * x2 * x; }\n// in soft min don't go too crazy with small values of k\n// those are not real min/max (returned values can exceed input values)\nfloat soft_min2( float a, float b, float k ) { return -log2( exp2( -k * a ) + exp2( -k * b ) ) / k; }\nfloat soft_max2( float a, float b, float k ) { return -soft_min2( -a, -b, k ); }\nfloat powerful_scurve( float x, float p1, float p2 ) { return pow( 1.0 - pow( 1.0 - clamp( x, 0.0, 1.0 ), p2 ), p1 ); }\nfloat maxcomp( float x ) { return x; }\nfloat maxcomp( vec2 v ) { return max( v.x, v.y ); }\nfloat maxcomp( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat mincomp( float x ) { return x; }\nfloat mincomp( vec2 v ) { return min( v.x, v.y ); }\nfloat mincomp( vec3 v ) { return min( min( v.x, v.y ), v.z ); }\nvec3 luminance( vec3 c ) { return vec3( dot( vec3( 0.2989, 0.5866, 0.1145 ), c ) ); }\nfloat sum( vec3 v ) { return v.x + v.y + v.z; }\n// symmetrize/mirror x around a\nfloat fold( float x, float a ) { return x + 2. * min( 0., a - x ); }\nvec2 fold( vec2 p, vec2 o, vec2 n ) { float a = dot( p - o, n ); return p - 2. * min( a, 0. ) * n; }\n// acos overflow bugs (subtle ot not) are the worse\nfloat safe_acos( float x ) { return acos( clamp( x, -1., 1. ) ); }\nvec4 safe_acos( vec4 x ) { return acos( clamp( x, vec4(-1.), vec4(1.) ) ); }\n// http://iquilezles.org/www/articles/smin/smin.htm\n// polynomial smooth min (k = 0.1);\nfloat smin_pol( float a, float b, float k )\n{\n float h = clamp( 0.5 + 0.5 * ( b - a ) / k, 0.0, 1.0 );\n return mix( b, a, h ) - k * h * ( 1.0 - h );\n}\n// https://mynameismjp.wordpress.com/2016/10/09/sg-series-part-2-spherical-gaussians-101/\n// v is the eval direction, v and axis assumed normalized and cos_v_axis = dot(v,axis)\nfloat spherical_gaussian( float cos_v_axis, float amplitude, float sharpness ) { return amplitude * exp( ( cos_v_axis - 1. ) * sharpness ); }\nvec3 spherical_gaussian( float cos_v_axis, vec3 amplitude, vec3 sharpness ) { return amplitude * exp( ( cos_v_axis - 1. ) * sharpness ); }\nvec3 spherical_gaussian( float cos_v_axis, vec3 amplitude, float sharpness ) { return amplitude * exp( ( cos_v_axis - 1. ) * sharpness ); }\n// http://www.iquilezles.org/www/articles/functions/functions.htm\nfloat impulse( float a, float x ) { float ax = a * x; return ax * exp( 1. - ax ); }\nvec2 impulse( vec2 a, vec2 x ) { vec2 ax = a * x; return ax * exp( vec2( 1. ) - ax ); }\nfloat biexp2( float x, float a, float b ) { return ( ( a * b ) / ( a - b ) ) * ( exp2( -b * x ) - exp2( -a * x ) ); }\nvec3 biexp2( vec3 x, vec3 a, vec3 b ) { return ( ( a * b ) / ( a - b ) ) * ( exp2( -b * x ) - exp2( -a * x ) ); }\n//https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c )\n{\n vec3 rgb = clamp( abs( mod( c.x * 6.0 + vec3( 0.0, 4.0, 2.0 ), 6.0 ) - 3.0 ) - 1.0, 0.0, 1.0 );\n return c.z * mix( vec3( 1.0 ), rgb, c.y );\n}\nstruct bounds1 { float pmin; float pmax; }; bounds1 mkbounds_unchecked( float amin, float amax ) { bounds1 ret; ret.pmin = amin; ret.pmax = amax; return ret; } float size( bounds1 b ) { return b.pmax - b.pmin; } float center( bounds1 b ) { return 0.5 * ( b.pmax + b.pmin ); } /* grid multiplier range */ /* bounds b is cell \"0,0\" */ /* min_xs is pmin offset (in multiples of bounds size) */ /* max_xs is pmax offset (in multiples of bounds size) */ bounds1 mkbounds_unchecked_gx( bounds1 b, float min_xs, float max_xs ) { float s = size( b ); bounds1 ret = b; ret.pmin += s * min_xs; ret.pmax += s * max_xs; return ret; }\nstruct bounds2 { vec2 pmin; vec2 pmax; }; bounds2 mkbounds_unchecked( vec2 amin, vec2 amax ) { bounds2 ret; ret.pmin = amin; ret.pmax = amax; return ret; } vec2 size( bounds2 b ) { return b.pmax - b.pmin; } vec2 center( bounds2 b ) { return 0.5 * ( b.pmax + b.pmin ); } /* grid multiplier range */ /* bounds b is cell \"0,0\" */ /* min_xs is pmin offset (in multiples of bounds size) */ /* max_xs is pmax offset (in multiples of bounds size) */ bounds2 mkbounds_unchecked_gx( bounds2 b, vec2 min_xs, vec2 max_xs ) { vec2 s = size( b ); bounds2 ret = b; ret.pmin += s * min_xs; ret.pmax += s * max_xs; return ret; }\nstruct bounds3 { vec3 pmin; vec3 pmax; }; bounds3 mkbounds_unchecked( vec3 amin, vec3 amax ) { bounds3 ret; ret.pmin = amin; ret.pmax = amax; return ret; } vec3 size( bounds3 b ) { return b.pmax - b.pmin; } vec3 center( bounds3 b ) { return 0.5 * ( b.pmax + b.pmin ); } /* grid multiplier range */ /* bounds b is cell \"0,0\" */ /* min_xs is pmin offset (in multiples of bounds size) */ /* max_xs is pmax offset (in multiples of bounds size) */ bounds3 mkbounds_unchecked_gx( bounds3 b, vec3 min_xs, vec3 max_xs ) { vec3 s = size( b ); bounds3 ret = b; ret.pmin += s * min_xs; ret.pmax += s * max_xs; return ret; }\nfloat repeat( float x, float len ) { return len * fract( x * ( float( 1.0 ) / len ) ); }float repeat_mirror( float x, float len ) { return len * abs( float( -1.0 ) + 2.0 * fract( ( ( x * ( float( 1.0 ) / len ) ) - float( -1.0 ) ) * 0.5 ) ); }/* return identity in range start,start+len, and repeat mirror elsewhere */float repeat_mirror_l( float x, float start, float len ) { return start + repeat_mirror( x - start, len ); }float repeat_mirror_e( float x, float start, float end ) { return start + repeat_mirror( x - start, end - start ); }/* return identity in range start,start+len, and repeat elsewhere */float repeat_e( float x, float start, float end ) { return start + repeat( x - start, end - start ); }float repeat_b( float x, bounds1 b ) { return b.pmin + repeat( x - b.pmin, b.pmax - b.pmin ); }\nvec2 repeat( vec2 x, vec2 len ) { return len * fract( x * ( vec2( 1.0 ) / len ) ); }vec2 repeat_mirror( vec2 x, vec2 len ) { return len * abs( vec2( -1.0 ) + 2.0 * fract( ( ( x * ( vec2( 1.0 ) / len ) ) - vec2( -1.0 ) ) * 0.5 ) ); }/* return identity in range start,start+len, and repeat mirror elsewhere */vec2 repeat_mirror_l( vec2 x, vec2 start, vec2 len ) { return start + repeat_mirror( x - start, len ); }vec2 repeat_mirror_e( vec2 x, vec2 start, vec2 end ) { return start + repeat_mirror( x - start, end - start ); }/* return identity in range start,start+len, and repeat elsewhere */vec2 repeat_e( vec2 x, vec2 start, vec2 end ) { return start + repeat( x - start, end - start ); }vec2 repeat_b( vec2 x, bounds2 b ) { return b.pmin + repeat( x - b.pmin, b.pmax - b.pmin ); }\nvec3 repeat( vec3 x, vec3 len ) { return len * fract( x * ( vec3( 1.0 ) / len ) ); }vec3 repeat_mirror( vec3 x, vec3 len ) { return len * abs( vec3( -1.0 ) + 2.0 * fract( ( ( x * ( vec3( 1.0 ) / len ) ) - vec3( -1.0 ) ) * 0.5 ) ); }/* return identity in range start,start+len, and repeat mirror elsewhere */vec3 repeat_mirror_l( vec3 x, vec3 start, vec3 len ) { return start + repeat_mirror( x - start, len ); }vec3 repeat_mirror_e( vec3 x, vec3 start, vec3 end ) { return start + repeat_mirror( x - start, end - start ); }/* return identity in range start,start+len, and repeat elsewhere */vec3 repeat_e( vec3 x, vec3 start, vec3 end ) { return start + repeat( x - start, end - start ); }vec3 repeat_b( vec3 x, bounds3 b ) { return b.pmin + repeat( x - b.pmin, b.pmax - b.pmin ); }\n/* function returns 0 at x = half_width */ float tri_p( float x, float half_width, float half_period ) { return half_width - repeat_mirror( x, half_period ); } /* function returns 0 at x = half_width */ float tri_s( float x, float half_width, float half_spacing ) { return half_width - repeat_mirror( x, half_width + half_spacing ); } /* tri_b repeats bounds1 [s1,e1] inside a repeated bounds0 [s0,e0] */ /* be careful, it is *not* equivalent to using repeat_b on b0 and sd_bounds b1 inside that, unless b1 is centered */ /* use tri_b or sd_bounds_repeat_* to correctly repeat bounds sdf */ float tri_b( float p, float s0, float e0, float s1, float e1) { float c = s0 + ( e1 + s1 ) * 0.5; return -tri_p( p - c, ( e1 - s1 ) * 0.5, ( e0 - s0 ) * 0.5 ); } /* same as above but with bounds */ float tri_b( float p, bounds1 b0, bounds1 b1) { return tri_b( p, b0.pmin, b0.pmax, b1.pmin, b1.pmax ); }\n/* function returns 0 at x = half_width */ vec2 tri_p( vec2 x, vec2 half_width, vec2 half_period ) { return half_width - repeat_mirror( x, half_period ); } /* function returns 0 at x = half_width */ vec2 tri_s( vec2 x, vec2 half_width, vec2 half_spacing ) { return half_width - repeat_mirror( x, half_width + half_spacing ); } /* tri_b repeats bounds1 [s1,e1] inside a repeated bounds0 [s0,e0] */ /* be careful, it is *not* equivalent to using repeat_b on b0 and sd_bounds b1 inside that, unless b1 is centered */ /* use tri_b or sd_bounds_repeat_* to correctly repeat bounds sdf */ vec2 tri_b( vec2 p, vec2 s0, vec2 e0, vec2 s1, vec2 e1) { vec2 c = s0 + ( e1 + s1 ) * 0.5; return -tri_p( p - c, ( e1 - s1 ) * 0.5, ( e0 - s0 ) * 0.5 ); } /* same as above but with bounds */ vec2 tri_b( vec2 p, bounds2 b0, bounds2 b1) { return tri_b( p, b0.pmin, b0.pmax, b1.pmin, b1.pmax ); }\n/* function returns 0 at x = half_width */ vec3 tri_p( vec3 x, vec3 half_width, vec3 half_period ) { return half_width - repeat_mirror( x, half_period ); } /* function returns 0 at x = half_width */ vec3 tri_s( vec3 x, vec3 half_width, vec3 half_spacing ) { return half_width - repeat_mirror( x, half_width + half_spacing ); } /* tri_b repeats bounds1 [s1,e1] inside a repeated bounds0 [s0,e0] */ /* be careful, it is *not* equivalent to using repeat_b on b0 and sd_bounds b1 inside that, unless b1 is centered */ /* use tri_b or sd_bounds_repeat_* to correctly repeat bounds sdf */ vec3 tri_b( vec3 p, vec3 s0, vec3 e0, vec3 s1, vec3 e1) { vec3 c = s0 + ( e1 + s1 ) * 0.5; return -tri_p( p - c, ( e1 - s1 ) * 0.5, ( e0 - s0 ) * 0.5 ); } /* same as above but with bounds */ vec3 tri_b( vec3 p, bounds3 b0, bounds3 b1) { return tri_b( p, b0.pmin, b0.pmax, b1.pmin, b1.pmax ); }\n// like smoothband() but repeated, using smoothstep as poor AA\n// - r is the half width of the stripes\n// - raa is the half size of the edge/aa smoothstep (ex: pixel_size)\n// - period is the distance between 2 consecutive stripes\nfloat stripes( float x, float period, float r, float raa ) { return smoothstep( r + raa, r - raa, repeat_mirror( x, period * 0.5 ) ); }\nvec2 stripes( vec2 x, vec2 period, vec2 r, vec2 raa ) { return smoothstep( r + raa, r - raa, repeat_mirror( x, period * 0.5 ) ); }\n// variation of stripes where multiple period overlap (stripes not centered on 0)\nfloat stripes2( float x, float period, float r, float raa ) { return smoothstep( r + raa, r - raa, repeat_mirror( x - r, period * 0.5 ) ); }\n// hash functions from David Hoskins's https://www.shadertoy.com/view/4djSRW using \"integer stepped ranges\" settings\nfloat hash11( float p ) { vec3 p3 = fract( vec3( p ) * .1031 ); p3 += dot( p3, p3.yzx + 19.19 ); return fract( ( p3.x + p3.y ) * p3.z ); }\nvec3 hash32( vec2 p ) { vec3 p3 = fract( vec3( p.xyx ) * vec3(.1031, .1030, .0973) ); p3 += dot( p3, p3.yxz + 19.19 ); return fract( ( p3.xxy + p3.yzz ) * p3.zyx ); }\n// hopefully stable hash (across gpus and/or webgl) functions, munged from iq's version https://www.shadertoy.com/view/XlXcW\nvec4 hash44_( ivec4 x0 )\n{\n uint k = 1103515245U; // GLIB C\n uvec4 x = uvec4( x0 );\n x = (( x >> 13U ) ^ x.yzwx ) * k;\n x = (( x >> 13U ) ^ x.zwxy ) * k;\n//\tx = (( x >> 13U ) ^ x.wxyz ) * k; // can't really tell the difference \n return vec4( x ) * ( 1.0 / float( 0xffffffffU ));\n}\nvec4 hash42_( ivec2 x0 )\n{\n uint k = 1103515245U; // GLIB C\n uvec4 x = uvec4( x0, x0 * 0x8da6b343 );\n x = (( x >> 13U ) ^ x.yzwx ) * k;\n x = (( x >> 13U ) ^ x.zwxy ) * k;\n//\tx = (( x >> 13U ) ^ x.wxyz ) * k; // can't really tell the difference \n return vec4( x ) * ( 1.0 / float( 0xffffffffU ));\n}\nvec2 hash22_( ivec2 p ) { return hash42_( p ).xy; }\nvec2 hash24_( ivec4 p ) { return hash44_( p ).xy; }\n// return a unit vector, or an angle (it's the same thing)\nvec2 unit_vector2( float angle ) { return vec2( cos( angle ), sin( angle ) ); }\n// note that if point p is also a unit vector, rotate_with_unit_vector returns the same as doing unit_vector2 on the sum of the angles (obvious but)\nvec2 rotate_with_unit_vector( vec2 p, vec2 cs ) { return vec2( cs.x * p.x - cs.y * p.y, cs.y * p.x + cs.x * p.y ); }\nvec2 rotate_with_unit_vector_neg( vec2 p, vec2 cs ) { return vec2( cs.x * p.x + cs.y * p.y, -cs.y * p.x + cs.x * p.y ); }\nvec2 rotate_with_angle( vec2 p, float a_angle ) { return rotate_with_unit_vector( p, unit_vector2( a_angle ) ); }\n// theta is the angle with the z axis, range [0,pi]\n// phi is the angle with x vectors on z=0 plane, range [0,2pi]\nvec3 zup_spherical_coords_to_vector( float theta, float phi ) { vec2 theta_vec = unit_vector2( theta ); return vec3( theta_vec.y * unit_vector2( phi ), theta_vec.x ); }\nvec3 yup_spherical_coords_to_vector( float theta, float phi ) { return zup_spherical_coords_to_vector( theta, phi ).yzx; }\nmat4 yup_spherical_coords_to_matrix( float theta, float phi )\n{\n vec3 y = yup_spherical_coords_to_vector( theta, phi );\n vec3 z = yup_spherical_coords_to_vector( theta + 3.141592654 * 0.5, phi );\n vec3 x = cross( y, z );\n return mat4( vec4( x, 0.0 ), vec4( y, 0.0 ), vec4( z, 0.0 ), vec4( 0, 0, 0, 1 ) );\n}\nmat4 z_rotation( float angle ) { vec2 v = unit_vector2( angle ); return mat4( vec4( v.x, v.y, 0.0, 0.0 ), vec4( -v.y, v.x, 0.0, 0.0 ), vec4( 0, 0, 1, 0 ), vec4( 0, 0, 0, 1 ) ); }\nstruct Ray { vec3 o; vec3 d; };\nRay mkray( vec3 o, vec3 d ) { Ray tmp; tmp.o = o; tmp.d = d; return tmp; }\nRay get_view_ray( vec2 normalized_pos, float z, float aspect, float tan_half_fovy ) { vec3 p = vec3( normalized_pos * vec2( aspect, 1.0 ) * tan_half_fovy, -1.0 ) * z; return mkray( p, normalize( p ) ); }\nmat4 lookat( vec3 eye, vec3 center, vec3 up ) { vec3 z = normalize( eye - center ); vec3 x = normalize( cross( up, z ) ); vec3 y = cross( z, x ); return mat4( vec4( x, 0.0 ), vec4( y, 0.0 ), vec4( z, 0.0 ), vec4( eye, 1.0 ) ); }\nfloat plane_trace_z( Ray ray, float base, float epsilon ) { return abs( ray.d.z ) > epsilon ? ( base - ray.o.z ) / ray.d.z : /* FLT_MAX */1000000.; }\n// build a little quadric so that y'(0)=0, y(r)=r, y'(r)=1 here\nfloat her2( float x, float r ) { return 0.5 * ( ( 1.0 / r ) * x * x + r ); }\n// customize max of f(x)=0 and f(x)=x in the x in [ -r,r] interval\nfloat curved_max_vfunc_hard_bevel( float x, float r ) { return max( r, abs( x ) ); }\nfloat curved_max_vfunc_weld_quadric( float x, float r ) { x = abs( x ); if ( x > r ) return x; return her2( x, r ); }\n// rr in 0,1, set < 1 if you want to see a flat bit\n// rr == 1 gives a soft bevel, slightly different shape and a bit more expensive than curved_max_vfunc_weld_quadric\nfloat curved_max_vfunc_round_bevel( float x, float r, float rr )\n{\n x = abs( x );\n if ( x > r ) return x;\n float a = rr * r; // make bevel radius relative to r (so rr is a 0,1 value, if you go above 1 yo get a discontinuity at 0)\n float cr = a * 1.414213562; // this is the radius of the circle used to make the round bevel\n vec2 c = vec2( r - a, r + a ); // center of round bevel is at (r-a,r+a) (on a y=1-x line that emanates from (r,r))\n return c.y - sqrt( cr * cr - pow2( max( 0.0, x - c.x ) ) );\n}\n// max\nfloat opI( float d1, float d2 ) { return max( d1, d2 ); }\nfloat opI_soft2( float a, float b, float k ) { return soft_max2( a, b, k ); }\nfloat opI_hard_bevel( float a, float b, float r ) { float c = ( a + b ) * 0.5; return c + curved_max_vfunc_hard_bevel( a - c, r ); }\nfloat opI_round_bevel( float a, float b, float r, float rr ) { float c = ( a + b ) * 0.5; return c + curved_max_vfunc_round_bevel( a - c, r, rr ); }\nfloat opU( float d1, float d2 ) { return -max( -d1, -d2 ); }\nfloat opU_hard_bevel( float a, float b, float r ) { return -opI_hard_bevel( -a, -b, r ); }\nfloat opS( float d1, float d2 ) { return max( -d2, d1 ); }\nfloat opS_hard_bevel( float a, float b, float r ) { return opI_hard_bevel( -b, a, r ); }\nfloat opI( float d1, float d2, float d3 ) { return max( max( d1, d2 ), d3 ); }\n// Band/border operations (extract a band from an sdf)\n// band c-r,c+r\nfloat opB_rc( float d, float r, float c ) { return abs( d - c ) - r; }\n// band -w,0\nfloat opB_inside( float d, float w ) { float r = w * 0.5; return opB_rc( d, r, -r ); }\n// band 0,w\nfloat opB_outside( float d, float w ) { float r = w * 0.5; return opB_rc( d, r, r ); }\n// band mi,ma\n// should be same as sd_bounds_range(d,mi,ma)\nfloat opB_range( float d, float mi, float ma ) { return opB_rc( d, ( ma - mi ) * 0.5, ( mi + ma ) * 0.5 ); }\n// trying many apis to see what sticks.\nfloat sd_bounds_range_round( vec2 p, vec2 mi, vec2 ma, float r )\n{\n vec2 h = ( ma - mi ) * 0.5;\n p = abs( p - ( mi + ma ) * 0.5 );\n vec2 c = h - r;\n float mask = max( step( c.x, p.x ), step( c.y, p.y ) );\n return mix( -r + max( ( p - c ).x, ( p - c ).y ), length( max( p - c, 0.0 ) ) - r, mask );\n}\nfloat sd_bounds_half_size( float p, float h ) { p = abs( p ) - h; return p; }\nfloat sd_bounds_half_size( vec2 p, vec2 h ) { p = abs( p ) - h; return opI( p.x, p.y ); }\nfloat sd_bounds_half_size( vec3 p, vec3 h ) { p = abs( p ) - h; return opI( p.x, p.y, p.z ); }\nfloat sd_bounds_range( vec2 p, vec2 mi, vec2 ma ) { vec2 hmi = mi * 0.5; vec2 hma = ma * 0.5; return sd_bounds_half_size( p - ( hma + hmi ), hma - hmi ); }\n// those bounds repeat might be good after all, since they centering and lead to a correct repeat...\nfloat sd_bounds_range( float p, float mi, float ma ) { return sd_bounds_half_size( p - ( ( ma + mi ) * 0.5 ), ( ma - mi ) * 0.5 ); }\nfloat sd_bounds_range( vec3 p, vec3 mi, vec3 ma ) { return sd_bounds_half_size( p - ( ( ma + mi ) * 0.5 ), ( ma - mi ) * 0.5 ); }\nfloat sd_bounds( vec2 p, bounds2 b ) { return sd_bounds_range( p, b.pmin, b.pmax ); }\nfloat sd_bounds( vec3 p, bounds3 b ) { return sd_bounds_range( p, b.pmin, b.pmax ); }\n// see sd_bounds_repeat_range_range instead of sd_bounds_repeat_size_margin\nfloat sd_bounds_repeat_size_margin( float p, float size, float margin ) { return sd_bounds_range( repeat( p, size ), margin, size - margin ); }\nfloat sd_bounds_repeat_size_margin( vec2 p, vec2 size, vec2 margin ) { return sd_bounds_range( repeat( p, size ), margin, size - margin ); }\nfloat sd_bounds_repeat_size_margin( vec3 p, vec3 size, vec3 margin ) { return sd_bounds_range( repeat( p, size ), margin, size - margin ); }\n// repeat bounds with margin, (mi1,ma1) is included inside (mi,ma)\nfloat sd_bounds_repeat_range_range( float p, float mi, float ma, float mi1, float ma1 ) { return maxcomp( tri_b( p, mi, ma, mi1, ma1 ) ); }\nfloat sd_bounds_repeat_range_range( vec2 p, vec2 mi, vec2 ma, vec2 mi1, vec2 ma1 ) { return maxcomp( tri_b( p, mi, ma, mi1, ma1 ) ); }\n// https://learnopengl.com/#!PBR/Theory\n// http://graphicrants.blogspot.jp/\n// alpha = roughness*roughness and \"m stands for the microfacet normal... in practice you input the half vector for m\"\n// Trowbridge-Reitz\nfloat D_GGX( float m_dot_n, float alpha ) { float alpha_sqr = alpha * alpha; return alpha_sqr / ( 3.141592654 * pow2( pow2( m_dot_n ) * ( alpha_sqr - 1. ) + 1. ) ); }\nfloat G_kelemen( float n_dot_l, float n_dot_v, float v_dot_h ) { return n_dot_l * n_dot_v / pow2( v_dot_h ); }\nfloat F_none( float v_dot_h, float F0 ) { return F0; }\nfloat F_schlick( float v_dot_h, float F0 ) { return F0 + ( 1. - F0 ) * pow5( 1. - v_dot_h ); }\n// I am not going to pretend anything is physically realistic here, but at least try to use standardized functions\n// v = wi\nvec3 add_light_contrib( vec3 albedo, vec3 l, vec3 n, vec3 v, vec3 Li, float dwi, float kdiffuse, float kspecular, float roughness )\n{\n float F0 = 0.08;\n float alpha = roughness * roughness;\n vec3 h = normalize( l + v );\n float eps = 1e-4; // else divides by zero\n float n_dot_l = max( eps, dot( n, l ) );\n float n_dot_v = max( eps, dot( n, v ) );\n float n_dot_h = max( eps, dot( n, h ) );\n float v_dot_h = max( eps, dot( h, v ) );\n float D = D_GGX( n_dot_h, alpha ); // n_dot_h should probably be clamped to >=0\n float G = G_kelemen( n_dot_l, n_dot_v, v_dot_h );\n//\tfloat F = F_none( n_dot_v, F0 );\n float F = F_schlick( n_dot_v, F0 );\n//\tfloat F = F_schlick( n_dot_h, F0 ); // can't be right\n return ( ( kdiffuse * albedo * ( 1. / 3.141592654 )\n      + kspecular * ( D * F * G ) / ( 4. * n_dot_l * n_dot_v ) ) ) * Li * n_dot_l * dwi;\n}\n//http://www.cs.utah.edu/~reinhard/cdrom/tonemap.pdf\nvec3 tonemap_reinhard( vec3 x ) { return x / ( 1. + x ); }\nvec3 gamma_correction( vec3 L ) { return pow( L, vec3( 0.45 ) ); }\n// mentioned in http://resources.mpi-inf.mpg.de/tmo/logmap/ , more dark tones friendly than just pow(L,0.45)\nvec3 gamma_correction_itu( vec3 L ) { return mix( 4.5061986 * L, 1.099 * pow( L, vec3( 0.45 ) ) - 0.099, step( vec3( 0.018 ), L ) ); }\n// returns 0 if v component is zero, rcp else, pass s = sign( v ) (values for s are -1, 0, 1)\nvec3 zrcp( vec3 v, vec3 s ) { s = abs( s ); return s / ( ( s - vec3( 1. ) ) + v ); }\n// encapsulate dda iteration a little bit for readability\nstruct DDA3\n{\n vec3 start, v; // v = end - start\n vec3 s; // sign(v)\n vec3 f1; // spacing (as a fraction of v, not distance) between 2 grid lines, to be multiplied by v to get a vector\n vec3 f; // segment intersects unit grid at points i = dda.start + ( dda.t[k] + i * dda.t1[k] ) * dda.v\n vec3 c; // cell index we entered (coords of bottom left corner)\n int done; // iteration end condition\n vec3 am; // argmin used during iteration\n vec3 p; // which point we entered the cell from, or start, or end\n};\n// iterate on p = dda.start + ( dda.end - dda.start ) * dda.alpha such that p intersect canonical dda.a\n// supporting arbitrary cell size is not much more expensive so we do it\nDDA3 dda_init( vec3 a_start, vec3 a_end, vec3 a_size, bool a_finite )\n{\n DDA3 dda;\n dda.start = a_start;\n dda.v = a_end - a_start;\n dda.s = sign( dda.v ); // -1, 0, 1\n vec3 v_zrcp = vec3( 1. ) / dda.v; // divide by zero\n vec3 cell_size_rcp = vec3( 1. ) / a_size;\n dda.c = floor( a_start * cell_size_rcp ); // start cell\n dda.f = ( ( dda.c + ( dda.s + vec3( 1. ) ) * 0.5 ) * a_size - a_start ) * v_zrcp; // go positive or negative direction, initial fractional t\n // do this only for dda_step_segment\n if ( a_finite ) dda.f = min( vec3( 1. ), dda.f + 1. - abs( dda.s ) ); // if the sign is 0, set t to 1, meaning we are done on this axis\n dda.f1 = dda.s * v_zrcp * a_size; // per axis grid steping as a fraction of v\n dda.done = 0;\n dda.am = vec3( 0. );\n dda.p = dda.start;\n return dda;\n}\n// returns 1,0,0 if x is the min, 0,1,0 if y is the min, 0,0,1 if z is the min (function code is from iq's shader)\n// very good for shader because we don't have to use random access which is sometimes borked in surprising ways\nvec3 argminv( vec3 v ) { return step( v.xyz, v.yxy ) * step( v.xyz, v.zzx ); }\n// iterate on all cells intersecting the input segment\n// make sure you called dda_init with a_finite = true\n// dda.done == 1 is the loop exit condition\n//void dda_step_segment( inout DDA3 dda )\n//{\n//\tif ( sum( dda.f ) == 3. ) ++dda.done; // all 1. means we covered v and we should be at the end point\n//\telse\n//\t{\n//\t\tdda.am = argminv( dda.f );\n//\t\tdda.p = dda.start + sum( dda.am * dda.f ) * dda.v;\n//\t\tdda.c += dda.am * dda.s;\n//\t\tdda.f = min( dda.f + dda.am * dda.f1, vec3( 1. ) ); // next dda.f\n//\t}\n//}\n// iterate forever - if you don't care about iterating exactly the segment length, a bunch of things can be skipped\n// make sure you called dda_init with a_finite = false\nvoid dda_step_infinite( inout DDA3 dda )\n{\n dda.am = argminv( dda.f );\n dda.p = dda.start + sum( dda.am * dda.f ) * dda.v;\n dda.c += dda.am * dda.s;\n dda.f = dda.f + dda.am * dda.f1; // next dda.f\n}\nvec3 dda_point( in DDA3 dda, float f ) { return dda.start + dda.v * f; }\n// t0, t1 are t ranges along rays on each dimension, returns (union min, union max) range, ray intersects iff .y > .x\nvec2 intersect_ranges( vec3 t0, vec3 t1 )\n{\n return vec2( maxcomp( vec3( min( t0.x, t1.x ), min( t0.y, t1.y ), min( t0.z, t1.z ) ) ),\n     mincomp( vec3( max( t0.x, t1.x ), max( t0.y, t1.y ), max( t0.z, t1.z ) ) ) );\n}\nstruct Ranges_x4\n{\n vec2 rA, rB, rC, rD; // ranges along the ray, for each bound b[i]\n bounds3 bA, bB, bC, bD; // we could store bounds2 + height\n};\n// factorize and pack a few terms used in raytracing of 4 children bounds\nstruct Split4bSetup\n{\n vec3 drcp;\n float dz;\n vec3 dmargin;\n vec2 dmin, dmax;\n};\nSplit4bSetup setup_Split4b( Ray ray, vec2 amin, vec2 amax, vec2 margin )\n{\n Split4bSetup set;\n set.drcp = vec3( 1. ) / ray.d; // divide by zero\n set.dmin = ( amin - ray.o.xy ) * set.drcp.xy;\n set.dmax = ( amax - ray.o.xy ) * set.drcp.xy;\n set.dz = ray.o.z * set.drcp.z;\n set.dmargin = vec3( margin * set.drcp.xy, 0. );\n return set;\n}\n// --------------\n// |   |   | D  |\n// | A | B |----| amix.z\n// |   |   | C  |\n// --------------\n//   amix.x amix.y\nvoid trace_Split4b_xxy( inout Ranges_x4 ret, Ray ray, in Split4bSetup set, vec3 amix, vec4 h )\n{\n vec3 set_dmix = ( amix - ray.o.xxy ) * set.drcp.xxy; // split axis described in amix are x,x,y\n ret.rA = intersect_ranges( vec3( set.dmin.x, set.dmin.y, -set.dz ) + set.dmargin, vec3( set_dmix.x, set.dmax.y, h.x * set.drcp.z - set.dz ) - set.dmargin );\n ret.rB = intersect_ranges( vec3( set_dmix.x, set.dmin.y, -set.dz ) + set.dmargin, vec3( set_dmix.y, set.dmax.y, h.y * set.drcp.z - set.dz ) - set.dmargin );\n ret.rC = intersect_ranges( vec3( set_dmix.y, set.dmin.y, -set.dz ) + set.dmargin, vec3( set.dmax.x, set_dmix.z, h.z * set.drcp.z - set.dz ) - set.dmargin );\n ret.rD = intersect_ranges( vec3( set_dmix.y, set_dmix.z, -set.dz ) + set.dmargin, vec3( set.dmax.x, set.dmax.y, h.w * set.drcp.z - set.dz ) - set.dmargin );\n}\nvoid bound_Split4b_xxy( inout Ranges_x4 ret, Ray ray, vec2 amin, vec2 amax, vec3 amix, vec4 h, vec2 margin )\n{\n vec3 m = vec3( margin, 0. );\n ret.bA = mkbounds_unchecked( vec3( amin.x, amin.y, 0. ) + m, vec3( amix.x, amax.y, h.x ) - m );\n ret.bB = mkbounds_unchecked( vec3( amix.x, amin.y, 0. ) + m, vec3( amix.y, amax.y, h.y ) - m );\n ret.bC = mkbounds_unchecked( vec3( amix.y, amin.y, 0. ) + m, vec3( amax.x, amix.z, h.z ) - m );\n ret.bD = mkbounds_unchecked( vec3( amix.y, amix.z, 0. ) + m, vec3( amax.x, amax.y, h.w ) - m );\n}\n// -----------------\n// |   |   |   |   |\n// | A | B | C | D |\n// |   |   |   |   |\n// -----------------\n//   amix.x amix.y amix.z\nvoid trace_Split4b_xxx( inout Ranges_x4 ret, Ray ray, in Split4bSetup set, vec3 amix, vec4 h )\n{\n vec3 set_dmix = ( amix - ray.o.xxx ) * set.drcp.xxx; // split axis described in amix are x,x,x\n ret.rA = intersect_ranges( vec3( set.dmin.x, set.dmin.y, -set.dz ) + set.dmargin, vec3( set_dmix.x, set.dmax.y, h.x * set.drcp.z - set.dz ) - set.dmargin );\n ret.rB = intersect_ranges( vec3( set_dmix.x, set.dmin.y, -set.dz ) + set.dmargin, vec3( set_dmix.y, set.dmax.y, h.y * set.drcp.z - set.dz ) - set.dmargin );\n ret.rC = intersect_ranges( vec3( set_dmix.y, set.dmin.y, -set.dz ) + set.dmargin, vec3( set_dmix.z, set.dmax.y, h.z * set.drcp.z - set.dz ) - set.dmargin );\n ret.rD = intersect_ranges( vec3( set_dmix.z, set.dmin.y, -set.dz ) + set.dmargin, vec3( set.dmax.x, set.dmax.y, h.w * set.drcp.z - set.dz ) - set.dmargin );\n}\nvoid bound_Split4b_xxx( inout Ranges_x4 ret, Ray ray, vec2 amin, vec2 amax, vec3 amix, vec4 h, vec2 margin )\n{\n vec3 m = vec3( margin, 0. );\n ret.bA = mkbounds_unchecked( vec3( amin.x, amin.y, 0. ) + m, vec3( amix.x, amax.y, h.x ) - m );\n ret.bB = mkbounds_unchecked( vec3( amix.x, amin.y, 0. ) + m, vec3( amix.y, amax.y, h.y ) - m );\n ret.bC = mkbounds_unchecked( vec3( amix.y, amin.y, 0. ) + m, vec3( amix.z, amax.y, h.z ) - m );\n ret.bD = mkbounds_unchecked( vec3( amix.z, amin.y, 0. ) + m, vec3( amax.x, amax.y, h.w ) - m );\n}\n//        -----------\n//        |  C |    |\n// amix.y |----| D  |\n//        |  A |----| amix.z\n//        |    | B  |\n//        -----------\n//           amix.x\nvoid trace_Split4b_xyy( inout Ranges_x4 ret, Ray ray, in Split4bSetup set, vec3 amix, vec4 h )\n{\n vec3 set_dmix = ( amix - ray.o.xyy ) * set.drcp.xyy; // split axis described in amix are x,x,y\n ret.rA = intersect_ranges( vec3( set.dmin.x, set.dmin.y, -set.dz ) + set.dmargin, vec3( set_dmix.x, set_dmix.y, h.x * set.drcp.z - set.dz ) - set.dmargin );\n ret.rB = intersect_ranges( vec3( set_dmix.x, set.dmin.y, -set.dz ) + set.dmargin, vec3( set.dmax.x, set_dmix.z, h.y * set.drcp.z - set.dz ) - set.dmargin );\n ret.rC = intersect_ranges( vec3( set.dmin.x, set_dmix.y, -set.dz ) + set.dmargin, vec3( set_dmix.x, set.dmax.y, h.z * set.drcp.z - set.dz ) - set.dmargin );\n ret.rD = intersect_ranges( vec3( set_dmix.x, set_dmix.z, -set.dz ) + set.dmargin, vec3( set.dmax.x, set.dmax.y, h.w * set.drcp.z - set.dz ) - set.dmargin );\n}\nvoid bound_Split4b_xyy( inout Ranges_x4 ret, Ray ray, vec2 amin, vec2 amax, vec3 amix, vec4 h, vec2 margin )\n{\n vec3 m = vec3( margin, 0. );\n ret.bA = mkbounds_unchecked( vec3( amin.x, amin.y, 0. ) + m, vec3( amix.x, amix.y, h.x ) - m );\n ret.bB = mkbounds_unchecked( vec3( amix.x, amin.y, 0. ) + m, vec3( amax.x, amix.z, h.y ) - m );\n ret.bC = mkbounds_unchecked( vec3( amin.x, amix.y, 0. ) + m, vec3( amix.x, amax.y, h.z ) - m );\n ret.bD = mkbounds_unchecked( vec3( amix.x, amix.z, 0. ) + m, vec3( amax.x, amax.y, h.w ) - m );\n}\n//  -------------\n//  |   | D |   |\n//  |   |   |   |\n//  | A |---| C | amix.y\n//  |   | B |   |\n//  -------------\n//  amix.x amix.z\nvoid trace_Split4b_xyx( inout Ranges_x4 ret, Ray ray, in Split4bSetup set, vec3 amix, vec4 h )\n{\n vec3 set_dmix = ( amix - ray.o.xyx ) * set.drcp.xyx; // split axis described in amix are x,x,y\n ret.rA = intersect_ranges( vec3( set.dmin.x, set.dmin.y, -set.dz ) + set.dmargin, vec3( set_dmix.x, set.dmax.y, h.x * set.drcp.z - set.dz ) - set.dmargin );\n ret.rB = intersect_ranges( vec3( set_dmix.x, set.dmin.y, -set.dz ) + set.dmargin, vec3( set_dmix.z, set_dmix.y, h.y * set.drcp.z - set.dz ) - set.dmargin );\n ret.rC = intersect_ranges( vec3( set_dmix.z, set.dmin.y, -set.dz ) + set.dmargin, vec3( set.dmax.x, set.dmax.y, h.z * set.drcp.z - set.dz ) - set.dmargin );\n ret.rD = intersect_ranges( vec3( set_dmix.x, set_dmix.y, -set.dz ) + set.dmargin, vec3( set_dmix.z, set.dmax.y, h.w * set.drcp.z - set.dz ) - set.dmargin );\n}\nvoid bound_Split4b_xyx( inout Ranges_x4 ret, Ray ray, vec2 amin, vec2 amax, vec3 amix, vec4 h, vec2 margin )\n{\n vec3 m = vec3( margin, 0. );\n ret.bA = mkbounds_unchecked( vec3( amin.x, amin.y, 0. ) + m, vec3( amix.x, amax.y, h.x ) - m );\n ret.bB = mkbounds_unchecked( vec3( amix.x, amin.y, 0. ) + m, vec3( amix.z, amix.y, h.y ) - m );\n ret.bC = mkbounds_unchecked( vec3( amix.z, amin.y, 0. ) + m, vec3( amax.x, amax.y, h.z ) - m );\n ret.bD = mkbounds_unchecked( vec3( amix.x, amix.y, 0. ) + m, vec3( amix.z, amax.y, h.w ) - m );\n}\n// turn n relative sizes (unit don't matter, only respective sizes do) into n-1 unit size offsets\nvec2 fractions( vec3 r ) { float sum_f_xy = r.x + r.y; float sum_f_xyz = sum_f_xy + r.z; return vec2( r.x, sum_f_xy ) / sum_f_xyz; }\nvec3 fractions( vec4 r ) { float sum_f_xy = r.x + r.y; float sum_f_xyz = sum_f_xy + r.z; float sum_f_xyzw = sum_f_xyz + r.w; return vec3( r.x, sum_f_xy, sum_f_xyz ) / sum_f_xyzw; }\n// -------------------------------------------------------- shader begin\nfloat sd_SurfaceFacade7( vec3 p, float dAll )\n{\n dAll -= -0.142857149;\n vec3 _p1 = p; vec2 _ci1 = vec2( 0.649999976, 0.375 ); vec2 _hp1 = vec2( 0.625, 0.300000011 ); vec2 _hw1 = vec2( 0.150000005, 0.074999988 ); vec2 _2hp1_rcp = vec2( 0.800000011, 1.666666626 ); _p1.xy -= _ci1; _p1.xy = -tri_p( _p1.xy, _hw1, _hp1 ); float _d1 = maxcomp( _p1.xy ); _d1 = opI( _d1, opB_range( p.z, -0.171428576, 0. ) );\n vec3 _p2 = p; vec2 _ci2 = vec2( 0.400000005, 0.234999999 ); vec2 _hp2 = vec2( 0.5, 0.300000011 ); vec2 _hw2 = vec2( 0.400000005, 0.015 ); vec2 _2hp2_rcp = vec2( 1, 1.666666626 ); _p2.xy -= _ci2; float _d2 = -tri_p( _p2.y, 0.015, 0.300000011 ); _d2 = opI( _d2, opB_range( p.z, -0.142857149, -0.128571435 ) );\n dAll = opS_hard_bevel( dAll, _d1, 0.007805752 );\n dAll = opU( dAll, _d2 );\n return dAll;\n}\nfloat sd_SurfaceFacade10( vec3 p, float dAll )\n{\n vec3 _p1 = p; vec2 _ci1 = vec2( 0.570779979, 0.031555999 ); vec2 _hp1 = vec2( 0.569999992, 0.029999999 ); vec2 _hw1 = vec2( 0.560779988, 0.021556001 ); vec2 _2hp1_rcp = vec2( 0.877192974, 16.666667938 ); _p1.xy -= _ci1; _p1.xy = -tri_p( _p1.xy, _hw1, _hp1 ); float _d1 = maxcomp( _p1.xy ); _d1 = opI( _d1, opB_range( p.z, -0.028571428, 0.100000001 ) );\n dAll = opS_hard_bevel( dAll, _d1, 0.003604186 );\n return dAll; // return vec3(dAll,-0.028571428,0.100000001);\n}\nvec2 sd_SurfaceFacade0( vec3 p, float dAll )\n{\n dAll -= -0.100000001;\n vec3 _p2 = p; vec2 _ci2 = vec2( 0.25, 0.362500011 ); vec2 _hp2 = vec2( 1., 0.300000011 ); vec2 _hw2 = vec2( 0.75, 0.137500002 ); vec2 _2hp2_rcp = vec2( 0.5, 1.666666626 ); _p2.xy -= _ci2; _p2.xy = -tri_p( _p2.xy, _hw2, _hp2 ); float _d2 = maxcomp( _p2.xy ); _d2 = opI( _d2, opB_range( p.z, -0.200000002, 0. ) );\n vec3 _p3 = p; vec2 _ci3 = vec2( -0.75, 0.300000011 ); vec2 _hp3 = vec2( 1., 0.300000011 ); vec2 _hw3 = vec2( 0.112500011, 0.300000011 ); vec2 _2hp3_rcp = vec2( 0.5, 1.666666626 ); _p3.xy -= _ci3; float _d3 = -tri_p( _p3.x, 0.112500011, 1. ); _d3 = opI( _d3, opB_range( p.z, -0.200000002, 0. ) );\n vec3 _p1 = p; vec2 _ci1 = vec2( 0.75, 0.362499982 ); vec2 _hp1 = vec2( 0.25, 0.300000011 ); vec2 _hw1 = vec2( 0.25, 0.147500008 ); vec2 _2hp1_rcp = vec2( 2, 1.666666626 ); _p1.xy -= _ci1; _p1.xy = -tri_p( _p1.xy, _hw1, _hp1 ); float _d1 = maxcomp( _p1.xy ); /*band*/_d1 = opB_rc( _d1, 0.008236314, 0.0 ); _d1 = opI( _d1, opB_range( p.z, -0.200000002, -0.19428572 ) );\n dAll = opS_hard_bevel( dAll, _d2, 0.007714285 );\n dAll = opU_hard_bevel( dAll, _d3, 0.009999996 );\n dAll = opU_hard_bevel( dAll, _d1, 0.005900437 );\n return vec2( dAll, p.z + 0.200000002 ); // return vec3(dAll,0,0.200000002);\n}\nvec2 sd_SurfaceFacade8( vec3 p, float dAll )\n{\n vec3 _p3 = p; vec2 _ci3 = vec2( 0.200000002, 0.685000002 ); vec2 _hp3 = vec2( 0.354999989, 0.459999978 ); vec2 _hw3 = vec2( 0.149999991, 0.115000009 ); vec2 _2hp3_rcp = vec2( 1.408450722, 1.08695662 ); _p3.xy -= _ci3; _p3.xy = -tri_p( _p3.xy, _hw3, _hp3 ); float _d3 = maxcomp( _p3.xy ); _d3 = opI( _d3, opB_range( p.z, -0.057142857, 0.014285714 ) );\n vec3 _p1 = p; vec2 _ci1 = vec2( 0.200000002, 0.685000002 ); vec2 _hp1 = vec2( 0.354999989, 0.459999978 ); vec2 _hw1 = vec2( 0.149999991, 0.115000009 ); vec2 _2hp1_rcp = vec2( 1.408450722, 1.08695662 ); _p1.xy -= _ci1; _p1.xy = -tri_p( _p1.xy, _hw1, _hp1 ); float _d1 = maxcomp( _p1.xy ); /*band*/_d1 = opB_rc( _d1, 0.002559998, 0.0 ); _d1 = opI( _d1, opB_range( p.z, -0.071428574, 0. ) );\n vec3 _p2 = p; vec2 _ci2 = vec2( 0.287499994, 0.684999942 ); vec2 _hp2 = vec2( 0.354999989, 0.459999978 ); vec2 _hw2 = vec2( 0.057500004, 0.109999984 ); vec2 _2hp2_rcp = vec2( 1.408450722, 1.08695662 ); _p2.xy -= _ci2; _p2.xy = -tri_p( _p2.xy, _hw2, _hp2 ); float _d2 = maxcomp( _p2.xy ); /*band*/_d2 = opB_rc( _d2, 0.003154247, 0.0 ); _d2 = opI( _d2, opB_range( p.z, -0.085714288, -0.028571428 ) );\n dAll = opS_hard_bevel( dAll, _d3, 0.000975659 );\n dAll = opU_hard_bevel( dAll, _d1, 0.000975659 );\n dAll = opU_hard_bevel( dAll, _d2, 0.000138338 );\n return vec2( dAll, p.z + 0.057142857 ); // return vec3(dAll,-0.085714288,0.014285714);\n}\n// function used to make roof tiles\n// a1 is the slope of curve going up (1.)\n// a2 is the slope of curve going down (-2.)\n// p is the period\nfloat hard_waves( float x, float a1, float a2, float p ) { x = repeat( x, p ); x = min( a1 * x, a2 * x - a2 * p ); return x; }\n// roof tiles height field (hf)\nfloat hf_SurfaceRoofTiles( vec2 p ) { return ( 0.4 * hard_waves( p.y, 0.3, -1.6, 0.19 ) + 0.02 * abs( sin( p.x * 30. ) ) ); }\n// build diagonal scopes on the top edges of a bounds b \"extruded\" by h\n// they can be used as support planes for roof surface\n// return value is a 3d point local to those symetrized diagonal plane spaces, that can be used to map the roof surface\n// return value's .z is the distance to plane\n// slope_ctrl controls the steepness of the roof planes, 1. for identity\n// h is height of base house walls\n// b is base/ground 2d scope bounds\n// p is input world pos\n// we don't return a scope because we are mirroring things here, Scope's .b and .dcc would have no sense\nvec3 getRoofLocalX( vec3 p, float slope_ctrl, bounds2 b, float h )\n{\n // gable roof with tiled surface\n float hw = ( b.pmax.x - b.pmin.x ) * 0.5; // half width\n float cx = ( b.pmax.x + b.pmin.x ) * 0.5; // center\n float h2 = hw * slope_ctrl; // roof height\n vec2 v = vec2( abs( p.x - cx ), p.z - ( h + h2 ) );\n vec2 yy = normalize( vec2( hw, -h2 ) );\n return vec3( p.y, dot( v, yy ), dot( v, perp( yy ) ) );\n}\nvec3 getRoofLocalY( vec3 p, float slope_ctrl, bounds2 b, float h )\n{\n // gable roof with tiled surface\n float hw = ( b.pmax.y - b.pmin.y ) * 0.5; // half width\n float cy = ( b.pmax.y + b.pmin.y ) * 0.5; // center\n float h2 = hw * slope_ctrl; // roof height\n vec2 v = vec2( abs( p.y - cy ), p.z - ( h + h2 ) );\n vec2 yy = normalize( vec2( hw, -h2 ) );\n return vec3( p.x, dot( v, yy ), dot( v, perp( yy ) ) );\n}\n// rudimentary concept of \"scope\" for facade, roof surfaces etc.\nstruct Scope\n{\n vec3 p; // point in scope space, plane at p.z = 0\n bounds2 b; // bounds of scope shape, for clipping/shape cast\n float dcc; // df of scope shape (\"cookie cutter\"), for clipping/shape cast, should be included in .b for consistancy\n float t; // marching distance, used for error thresholds, \"inflating\" detail etc.\n};\nScope getScopeFacadeX( Scope base, float h, int select_side )\n{\n Scope facade;\n facade.b = mkbounds_unchecked( vec2( base.b.pmin.y, 0.0 ), vec2( base.b.pmax.y, h ) );\n // note: we just flip the sign of p.x for the other side, it will horizontally flip the content but most often we don't care\n if ( select_side == ( 1 | 2 ) ) facade.p = vec3( base.p.y, base.p.z, abs( base.p.x - center( base.b ).x ) - size( base.b ).x * 0.5 );\n else if ( select_side == 1 ) facade.p = vec3( base.p.y, base.p.z, base.p.x - base.b.pmax.x );\n else if ( select_side == 2 ) facade.p = vec3( base.p.y, base.p.z, -base.p.x + base.b.pmin.x );\n facade.dcc = sd_bounds( facade.p.xy, facade.b );\n return facade;\n}\nScope getScopeFacadeY( Scope base, float h, int select_side )\n{\n Scope facade;\n facade.b = mkbounds_unchecked( vec2( base.b.pmin.x, 0.0 ), vec2( base.b.pmax.x, h ) );\n // note: we just flip the sign of p.x for the other side, it will horizontally flip the content but most often we don't care\n if ( select_side == ( 1 | 2 ) ) facade.p = vec3( base.p.x, base.p.z, abs( base.p.y - center( base.b ).y ) - size( base.b ).y * 0.5 );\n else if ( select_side == 1 ) facade.p = vec3( base.p.x, base.p.z, base.p.y - base.b.pmax.y );\n else if ( select_side == 2 ) facade.p = vec3( base.p.x, base.p.z, -base.p.y + base.b.pmin.y );\n facade.dcc = sd_bounds( facade.p.xy, facade.b );\n return facade;\n}\nfloat sd_RoofTopObject2( float dsofar, Scope roof, float h, vec3 rnd )\n{\n h *= 0.6 + 0.4 * mod( rnd.y, 4. ) * ( 1. / 3.333 );\n float roof_geom_max_height = 0.025; // a rough but conservative estimate of roof geometry height\n h = max( 0., h - roof_geom_max_height ); // fixme: hack: make sure h is bounding height instead\n // select a small bounds b0 as a fraction of b, that we are going to repeat\n bounds2 b0 = mkbounds_unchecked_gx( roof.b, vec2( 0.1, 0.1 ), vec2( -0.7, -0.7 ) );\n // select a subgrid, range of b0 we want to keep, store range in b3\n vec2 gridsize = vec2( 1. + mod( rnd.x, 4. ), 1. );\n bounds2 b3 = mkbounds_unchecked_gx( b0, vec2( 0., 0. ), gridsize - vec2( 1. ) );\n//\tif ( dsofar < sd_bounds_range( roof.p, vec3( b3.pmin, 0. ), vec3( b3.pmax, h ) ) || roof.p.z < 0. ) return dsofar; // early return if the roof object is further than dsofar, not necesserarily a win...\n // inside that select a centered bounds b1\n bounds2 b1 = mkbounds_unchecked_gx( b0, vec2( 0.1, 0.1 ), vec2( -0.1, -0.1 ) );\n vec3 p2 = roof.p;\n p2.xy = repeat_b( p2.xy, b0 ); // remember: b1 must be centered inside b0!\n Scope base = roof;\n base.p = p2;\n base.b = b1;\n base.dcc = sd_bounds( base.p.xy, base.b );\n base.dcc = opI( base.dcc, sd_bounds( roof.p.xy, b3 ) ); // only keep b3 area\n // select a subgrid (clip against)\n float d = opI( base.p.z - h, base.dcc );\n d = opI( -base.p.z, d );\n//\td = opI( d, sd_bounds( roof.p.xy, mkbounds_unchecked_gx( b0, vec2( 0, 0 ), vec2( 2, 1 ) ) ) );\n {\n  // facade\n  Scope facade = getScopeFacadeY( base, h, 3 );\n  vec3 p3 = facade.p;\n  p3.xy *= 2.; float d2 = sd_SurfaceFacade10( p3, facade.p.z );\n  d = opI( d2, d );\n }\n {\n  // roof small border wall on top of object\n  Scope roof2 = base;\n  roof2.p.z -= h;\n  float small_roof_border = opB_inside( roof2.dcc, 0.01 );\n  small_roof_border = opI( small_roof_border, opB_inside( -roof2.p.z, roof_geom_max_height ) );\n  d = opU( d, small_roof_border );\n }\n return opI( d, roof.dcc );\n}\nfloat sd_JPBuildingRoofTopWithObjects( float d, Scope roof, float roof_geom_max_height, bool enable_objects, vec3 rnd )\n{\n // roof small border wall\n float dborder = opB_inside( roof.dcc, 0.02 );\n dborder = opI( dborder, opB_inside( -roof.p.z, 0.05 ) );\n // roof ground tiles, perhaps this should be textured but never mind. we get more detail\n float tile_size = 0.05;\n float dtiles = -mincomp( tri_s( roof.p.xy, vec2( tile_size * 0.5 ), vec2( 0.005 ) ) );\n dtiles = opI( roof.dcc + 0.05, dtiles ) + roof.t * 0.004; // add t in spacing so we can see it from far away\n dtiles = opI_round_bevel( dtiles, opB_range( roof.p.z, -0.001, 0.0025 ), 0.00125, 0.75 );\n d = opU( d, opU( dtiles, dborder ) );\n if ( enable_objects )\n {\n  // parametric model for small features on roof\n  Scope roof_object_scope = roof;\n  float droof_object = /* FLT_MAX */1000000.;\n  droof_object = sd_RoofTopObject2( d, roof_object_scope, roof_geom_max_height, rnd );\n//\t\tdroof_object = opI( droof_object, -roof.p.z ); // cut all the bits below roof object level\n  d = opU( d, droof_object );\n }\n return d;\n}\n// distance to highway center line requires special care in this shader\nstruct NearestHighwayRetval\n{\n vec2 p; // query point\n vec2 pr; // query point in y repeat space\n float d; // distance to center line == length(d2f.xy)\n vec4 d2f; // .xy is vector to closest point, .zw is the tangent at closest point\n vec2 o_clip, n_clip; // clip plane so we can build clean clip facades for buildings in contact with the highway\n};\n// building sdf eval return value\nstruct ParametricBuildingRetval\n{\n float d, droof; // distance to building and distance to closest roof point for coloring\n vec3 windr; // distance to window in .x, windows 2d orientation in .zw (orientation is for better categorizing of pixels)\n};\n// modern buildings, most often square but can be clipped by nearby highways\nParametricBuildingRetval sd_Building( float t, vec3 p, bounds2 b, float h, NearestHighwayRetval nh, vec3 rnd )\n{\n float roof_geom_max_height = 0.3; // a rough but conservative estimate of roof geometry height\n h -= roof_geom_max_height; // fixme: hack: make sure h is bounding height instead\n // some building base scope\n Scope base;\n base.p = p;\n base.b = b;\n base.dcc = sd_bounds( base.p.xy, base.b );\n base.t = t;\n float d = -/* FLT_MAX */1000000.; // opI( base.p.z - h, base.dcc ) is the base block, if you want to visualize it for debug\n vec3 windr = vec3( /* FLT_MAX */1000000. );\n {\n  // front facade\n  Scope facade = getScopeFacadeX( base, h, 3 );\n  vec2 d1 = sd_SurfaceFacade0( facade.p, facade.p.z );\n  d = opI( d1.x, d );\n  windr = vec3( d1.y, vec2( 1., 0. ) );\n }\n {\n  // back facade with flat windows\n  Scope facade = getScopeFacadeY( base, h, 3 );\n  float d2 = sd_SurfaceFacade7( facade.p, facade.p.z );\n  d = opI( d2, d );\n }\n if ( nh.d != /* FLT_MAX */1000000. )\n {\n  // highway facing facade using nearest highway clip plane\n  float d10 = dot( p.xy - nh.o_clip, nh.n_clip ) - (1.) * 1.3;\n  vec3 pr = vec3( dot( p.xy, perp( nh.n_clip ) ), p.z, -d10 ); // pr is the point in 2d facade space\n  vec2 d3 = sd_SurfaceFacade0( pr, pr.z );\n  d = opI( d3.x, d );\n  // pick this window if it's closest\n  windr = mix( windr, vec3( d3.y, nh.n_clip ), step( abs( d3.y ), abs( windr.x ) ) );\n }\n float droof = d; // save d before we clamped base on h, that will give us a consistent base dcc to build the roof on\n d = opI( d, base.p.z - h );\n {\n  Scope roof = base;\n  roof.p.z -= h;\n  roof.dcc = droof;\n  d = sd_JPBuildingRoofTopWithObjects( d, roof, roof_geom_max_height, true, rnd ); // roof with border + objects on it\n }\n ParametricBuildingRetval ret;\n ret.d = d;\n ret.windr = windr;\n ret.droof = /* FLT_MAX */1000000.;\n return ret;\n}\n// house with a tiled roof (Kyoto has lots of those, though the roof type is different and here is just a super crude abstracted version)\nParametricBuildingRetval sd_House( vec3 p, float t, bounds2 b, float h, NearestHighwayRetval nh )\n{\n h -= 1.4; // fixme: hack: make sure h is bounding height instead\n vec2 inset = size( b ) * 0.01; // b is conservative, the house must be included inside it\n b.pmin += inset; // we want roof to hang over a bit so shrink the base a bit\n b.pmax -= inset;\n // some building base scope\n Scope base;\n base.p = p;\n base.b = b;\n base.dcc = sd_bounds( base.p.xy, base.b );\n base.t = t;\n // the base block, if you want to visualize it for debug\n//\tfloat d = opI( base.p.z - h, base.dcc );\n // highway facing facade clipped using nearest highway clip plane\n float d10 = nh.d != /* FLT_MAX */1000000. ? dot( p.xy - nh.o_clip, nh.n_clip ) - (1.) * 0.6 : /* FLT_MAX */1000000.;\n base.dcc = opI( -d10, base.dcc ); // clip the base shape so that we still get a bit of roof hang over\n ParametricBuildingRetval ret;\n float slope_ctrl = 0.7;\n // hip roof with tiled surface\n vec3 prfx = getRoofLocalX( p, slope_ctrl, base.b, h );\n float rfxd = opS( prfx.z - hf_SurfaceRoofTiles( prfx.xy ), prfx.z - ( -0.03 ) );\n rfxd = opI( base.dcc - 0.15, rfxd ); // vertical cookie cut, wider for roof geom\n vec3 prfy = getRoofLocalY( p, slope_ctrl, base.b, h );\n float rfyd = opS( prfy.z - hf_SurfaceRoofTiles( prfy.xy ), prfy.z - ( -0.03 ) );\n rfyd = opI( base.dcc - 0.15, rfyd ); // vertical cookie cut, wider for roof geom\n // add windows\n float dbottom = opI( base.dcc, opI( prfx.z, prfy.z ) );\n Scope wall_s = getScopeFacadeY( base, h, 3 );\n vec3 pf = vec3( wall_s.p.xy * 1.0 - vec2( 0., -0.28 ), wall_s.p.z * 2. );\n vec2 df8 = sd_SurfaceFacade8( pf, dbottom );\n dbottom = opI( wall_s.dcc, df8.x ); // base + window carved in\n dbottom = opI( -d10, dbottom ); // clip the base shape so that we still get a bit of roof hang over\n ret.windr = vec3( df8.y, vec2( 0., 1. ) );\n // hip roof + roof surface\n ret.droof = opU( opI( rfyd, prfx.z ), opI( rfxd, prfy.z ) ); // just roof surface\n ret.d = opU( ret.droof, dbottom );\n // fill the empty bit under the roof (due to hang hover modeling),\n // which is visible when we did a highway clip\n float dz = ( p.z - h ) / slope_ctrl;\n ret.d = opU( ret.d, opI( base.dcc + max( dz, 0. ), -dz ) );\n return ret;\n}\n// highway curve as seem from above... wanted to do more complicated but stuck to the test curve instead\nvec2 sd_HighwayCurveXY( float x ) { float xt = repeat_mirror_e( x, -20., 20. ); return vec2( x, smoothstep( 0., 15., xt ) * 8. ); }\nvec3 sd_CameraCurveXY( float x ) { return vec3( x, sd_HighwayCurveXY( x ).y, 2.18 ); }\n// highways are repeated on y axis\nNearestHighwayRetval evalHighwaySetup( vec2 p )\n{\n NearestHighwayRetval hret;\n hret.p = p.xy;\n hret.pr = p.xy;\n hret.pr.y = repeat_e( hret.pr.y, -35., 35. ); // note: mirror repeat wouldn't work\n return hret;\n}\n// do the actual distance to highway evaluation\nNearestHighwayRetval evalHighway( vec2 p )\n{\n NearestHighwayRetval hret = evalHighwaySetup( p );\n vec4 ret;\n { /* we use this method for distance to curve: http://www.geometrie.tugraz.at/wallner/sproj.pdf */ /* it is a bit different from http://www.iquilezles.org/www/articles/distance/distance.htm in that since it is iterative there is a potential quality/perf trade off */ vec2 _p = hret.pr.xy, _c, _dc; float _epsilon = 0.001 * p.x; float _t = _p.x; /* t0, could be a parameter if the user knows better */ for ( int _i = 0; _i < 2; ++_i ) { _c = sd_HighwayCurveXY( _t ); _dc = ( sd_HighwayCurveXY( _t + _epsilon ) - _c ) * ( 1. / _epsilon ); _t += dot( _p.xy - _c, _dc ) / dot( _dc, _dc ); /* simplification of _t += dot( _dc, _q - _c ) / dot( _dc, _dc ); where _q is _p.xy projected on (_c,_dc) line */ } ret = vec4( _c - _p, _dc ); };\n hret.d = length( ret.xy ); // distance to center line, used in several places so cache\n hret.d2f = ret;\n return hret;\n}\n// used for lamp top silhouette\nfloat crochet( float x, float s2, float s1, float a, float b, float ym ) { return max( min( 0., ( -( x - b ) ) * s1 ), ym ) + min( 0., ( x - a ) * s2 ); }\n// street lamp object\n// hw is the road half width\n// p2.xy is cross section along u\n// p2.y is already symmetric (distance to center)\nvec2 sd_Lamps( float u, vec2 p2, float hw, float lw, float lamp_height, float period )\n{\n vec2 p3 = p2.xy - vec2( hw, lamp_height ); // center to lamp corner\n float dline = opI( -dot( p3.xy, -vec2( 0.5, 0.866025403 ) ), p3.x ); // lamp line\n float width = 0.04; // pole width\n float dslice = sd_bounds_repeat_range_range( u, 0., period, 0., width ); // slice\n dslice = opI( dslice, -p2.y ); // keep upper bit only\n float dpolebit = opB_outside( dline, 0.015 ); // only keep outside band\n dpolebit = opI( dpolebit, -p3.x - lw ); // subtract center bit\n float shrink = 0.004;\n float dlampbit = opB_inside( dline - shrink, 0.02 ); // only keep outside band, offset by shrink to ensure lamp geom stays in contact\n dlampbit = opI( dlampbit, -p3.x - lw ); // subtract center bit\n dlampbit = opI( dlampbit, -p2.y + lamp_height * 1.025 ); // only keep bit the top lamp bit (cut bottom)\n dlampbit += shrink; // make lamp geom smaller\n float d = opU( dpolebit, dlampbit );\n d = opI( d, dslice - crochet( p3.x, 0.1, 0.75, -0.1, -0.05, -0.01 ) ); // extract a slice, and also make the slice slightly triangular\n return vec2( d, dlampbit );\n}\n// there will be SIGN_N-1 signs visible per period (because of clipping in curvy bits)\n// pick a periodicity that doesn't expose the dodginess of the sdf in curvy sections\n// highway signs (LCD screens)\nvec2 sd_HighwaySigns( float u, vec2 p2, float hw )\n{\n u = repeat_mirror_e( u, -20., 20. ); // same repeat as sd_HighwayCurveXY\n float period = (2.*20./(3.));\n u += period * 0.5;\n float width = 0.04;\n float h2 = 1.2; // sign start h\n float h3 = 0.3; // sign end h\n float dslice = sd_bounds_repeat_range_range( u, 0., period, 0., width ); // slice\n dslice = opI( dslice, -p2.y ); // keep upper bit only\n vec2 p3 = p2.xy - vec2( hw, h2 ); // center to lamp corner\n float d8 = opB_outside( p3.x, 0.015 ); // only keep outside band\n d8 = opI( d8, p3.y );\n d8 = opU( d8, sd_bounds_range( p3, vec2( -hw, 0. ), vec2( 0.05, h3 ) ) );\n return vec2( opI( d8, dslice ), /* FLT_MAX */1000000. );\n}\n// ray marched city bits, this is global and has nothing to do with the dda\n// return value: .x closest distance, .y closest distance to light emitter material\nvec3 sd_RayMarchedCityBits( vec3 p, int lod )\n{\n float d = p.z - 0.; // zero ground\n NearestHighwayRetval hret = evalHighway( p.xy );\n float hw = (1.); // r1 is the half width\n float h = 2.;\n vec3 crvp = vec3( hret.d, p.z, ( hret.pr + hret.d2f.xy ).x ); // curve 3d pos\n float d2 = sd_bounds_range( crvp.xy, vec2( 0.0, h - 0.05 ), vec2( hw, h ) ); // highway cross section main block\n float d3 = sd_bounds_range( crvp.xy, vec2( hw * 0.9, h - 0.01 ), vec2( hw * 1.01, h + 0.2 * 1.4 ) ); // highway cross section border bit\n d = opU( d, opU_hard_bevel( d3, d2, 0.05 ) );\n // supporting column\n vec2 ppp = vec2( h - p.z, hret.d );\n float d4 = ppp.y - ( 0.2 + 0.2 * pow( 1. - saturate( ppp.x * 2. ), 4. ) );\n d4 = opI( -h + p.z, d4 );\n d4 = opI( d4, sd_bounds_repeat_range_range( crvp.z, 0., 2., 0.5, 0.9 ) ); // subtract space between supporting columns\n d = opU( d, d4 );\n vec2 dlamps = vec2( /* FLT_MAX */1000000. );\n vec2 dlamps2 = vec2( /* FLT_MAX */1000000. );\n dlamps = sd_Lamps( crvp.z, vec2( hret.d, p.z - h ), hw, 0.25, 1.2, 3.2 );\n d = opU( d, dlamps.x );\n // add billboard signs on highways\n vec2 dsigns = sd_HighwaySigns( crvp.z, vec2( hret.d, p.z - h ), hw );\n d = opU( d, dsigns.x );\n // add ground and pavements\n vec3 pp = p;\n pp.xy = repeat_mirror_l( p.xy, vec2( 0., 0. ), /* CELL_SIZE */vec3( 8., 8., 100. ).xy );\n vec2 extra = -vec2( 0.15 ); // expand pavement a bit\n // for pavement we just repeat a round box with left, bottom side using wide road width and top, right sides using small road width\n float dpavement = sd_bounds_range_round( pp.xy, /* CELL_SPACING */vec2( 0.47, 1.3 ).yy * 0.5 + extra, /* CELL_SIZE */vec3( 8., 8., 100. ).xy - /* CELL_SPACING */vec2( 0.47, 1.3 ).xx - extra, 0.075 );\n dpavement = opS( dpavement, ( hret.d - (1.) * 0.5 ) ); // empty the bit below the highway... that makes roadmarkings worse\n dpavement = opI_hard_bevel( dpavement, pp.z - 0.025, 0.02 ); // hard bevel to create border, clip with pavement top plane\n d = opU( dpavement, d ); // add pavement\n // add lamps on wide roads\n float period = /* CELL_SIZE */vec3( 8., 8., 100. ).x / 5.;\n // offset by peroid/2 to avoid putting lamps on crossing road (so we don't have to mask)\n dlamps2 = sd_Lamps( p.y + period * 0.5, vec2( repeat_mirror_l( p.x, 0., /* CELL_SIZE */vec3( 8., 8., 100. ).x ), p.z )\n      , /* CELL_SPACING */vec2( 0.47, 1.3 ).x * 1.3 // go on the pavement a bit\n      , 0.08, 0.65, period );\n d = opU( d, dlamps2.x );\n return vec3( d, opU( dlamps.y, dlamps2.y ), dsigns.x );\n}\nvec3 l2g( vec3 v ) { return pow( v, vec3( 1. / 2.22 ) ); }\nvec3 g2l( vec3 v ) { return pow( v, vec3( 2.22 ) ); }\nvec3 biexp2( float x, vec4 r, vec4 g, vec4 b ) { return biexp2( x * vec3( r.x, g.x, b.x ), vec3( r.y, g.y, b.y ), vec3( r.z, g.z, b.z ) ) * vec3( r.w, g.w, b.w ); }\n// manual match of one of the probes at http://cgg.mff.cuni.cz/projects/SkylightModelling/HosekWilkie_SkylightModel_SIGGRAPH2012_Supplement.pdf\nvec3 get_sky( vec3 v, float sun_cos_theta, float cheat_glow_scale )\n{\n vec3 l = vec3( sqrt( 1. - sun_cos_theta * sun_cos_theta ), 0., sun_cos_theta );\n float theta = safe_acos( v.z ); // in theory we don't need safe on normalized value, in practice you just never know\n float sd = dot( v, l );\n vec3 sky_top_color = vec3( 0.0182, 0.040, 0.076 ) * 0.95; // top sky color in linear space\n vec3 sky_top = sky_top_color;\n//\treturn ref - sky_top; // show remnant signal to match\n float x = ( 1. - theta / ( 3.141592654 * 0.5 ) ) * 0.5;\n vec3 sky_radial = biexp2( x, vec4( 7.5, 15., 2., 0.1 ), vec4( 7.5, 10., 1.7, 0.14 ), vec4( 4., 5., 5.5, 0.075 ) ); // south curve\n//\treturn ref - sky_top - sky_radial; // show remnant signal to match\n // maching the sun glow is more awkward\n vec3 sun_glow = // note: this affects lighting a lot as we sample sun center color for the main light\n  spherical_gaussian( sd, vec3( 0.8, 0.6, 0.3 ) * 1., 27. ) +\n  spherical_gaussian( sd, vec3( 0.8, 0.4, 0.1 ) * 0.3, 8. );\n sun_glow *= cheat_glow_scale;\n//\treturn sun_glow;\n//\treturn ref - sky_top - sky_radial - sun_glow; // show remnant signal to match... should be black excepy for sun glow\n return max( vec3( 0. ), ( sky_top + sky_radial + sun_glow ) ) * 1.;\n}\n// align sky probe with l direction\nvec3 get_sky( vec3 v, vec3 l, float cheat_glow_scale )\n{\n if ( l.z != 0. ) v.xy = rotate_with_unit_vector_neg( v.xy, normalize( l.xy ) );\n return get_sky( v, l.z, cheat_glow_scale );\n}\nvec3 test_sky( vec2 fragCoord, vec3 l )\n{\n vec2 u = fragCoord.xy / min( iResolution.x, iResolution.y );\n float theta = length( u - vec2( 0.5 ) ) * 3.141592654;\n float phi = calc_angle( u - vec2( 0.5 ) );\n vec3 v = zup_spherical_coords_to_vector( theta, phi );\n if ( theta > 3.141592654 * 0.5 ) return vec3( 1, 0, 1 );\n return l2g( get_sky( v, l, 1. ) );\n}\n// tentative japanese city building palette\nvec3 get_building_palette( vec2 h )\n{\n vec3 ivory = vec3( 1, 0.85, 0.7 ); // c11\n vec3 white = vec3( 1., 1., 1. ); // c01\n vec3 c = mix( mix( vec3( 0.32, 0.38, 0.47 ), vec3( 0.35, 0.36, 0.41 ) * 0.5, h.x ), mix( white, ivory, h.x ), h.y );\n//\tvec3 c = mix( mix( c00, c10, h.x ), mix( c01, c11, h.x ), h.y );\n return c = mix( c, vec3( 0.6, 0.2, 0.2 ), smoothband( h.y - 0.5, 0.045, 0.01 ) * h.x * h.x * h.x ); // add rare reddish colors for occasional red tiles building\n}\nstruct NumberArg { float h; vec2 s; float r; float w; float m; };\n// only works with 3 and 8 because those are easy :-)\nfloat sd_Number3or8( vec2 p, int num, NumberArg a )\n{\n a.s *= 0.5;\n p.y = abs( p.y );\n float d = sd_bounds_range_round( p, vec2( -a.s.x + a.w + a.m, a.w * 0. ), a.s - a.w - a.m, a.r );\n d = opB_range( d, -a.w, a.w );\n if ( num == 3 ) d = opS( d, sd_bounds_range( p, vec2( -a.s.x - a.w, -a.w ), vec2( 0., a.s.y * a.h ) ) );\n return d;\n}\n// http://www.airbus.com/aircraft/passenger-aircraft/a350xwb-family/a350-900.html\n// -10,10 -> 64m\n// the silhouette is pretty accurate, modeled on top of blueprint\n// in this shader it just becomes pixel vomit covering a few pixels but I couldn't let go\nfloat sd_airliner_a350( vec2 p )\n{\n p.y = abs( p.y ); // vertical symmetry\n float db1 = p.y - 0.98 * rcp_decay( max( -0.666, -( p.x - 10. ) ) ); // fuselage front\n float db2 = p.y - 0.98 * rcp_decay( max( -0.666, p.x - -7.8 ) ); // fuselage back\n float db = opI( db1, db2 ); // fuselage\n float dw1 = -( curved_max_vfunc_weld_quadric( p.x + 3.85, 0.85 ) * 2.3 - ( 9.7 - p.y ) ); // back wing curve\n float dw2 = curved_max_vfunc_weld_quadric( p.x + 3.45, 0.85 ) * 1.26 - ( 9.2 - p.y ); // front wing curve\n float d3 = -( p.x - ( -0.8 ) ); // back wing curve flat bit\n dw1 = opU( dw1, d3 );\n float dw = opI( opI( dw1, dw2 ), -( p.x + 4. ) ); // wing\n float ds = -( ( smoothstep( -6.5, -9.8, p.x ) ) * 2.55 - p.y ); // stabilizer\n ds = opI( ds, ( p.x + 6.5 ) );\n ds = opS( ds, ( p.x + 8.94 + p.y * 0.4 ) ); // final tail bit\n float dt = opI( p.x + 8., p.y - 0.45 * rcp_decay( max( -0.666, ( p.x - -9.75 ) * 1. ) ) );\n ds = opU( dt, ds ); // cut garbage\n vec2 pe = p - vec2( 1.5, 2.77 ); // engine pos\n float de = abs( pe.y ) - 0.8 * min( powerful_scurve( pe.x, 0.5, 4. ), powerful_scurve( 1. - ( pe.x - 1. ), 0.1, 4. ) ) + 0.3; // engine\n return opU( de, opU( ds, opU( dw, db ) ) );\n}\n// another blob of stuff, yey\nstruct TraceCityRetval\n{\n float t; // fixme: t or p. pick one? they might not be consistent\n vec3 p, n; // position, normal\n float ao;\n vec2 tile_index; // mostly for debug purpose\n float split_case; // split case [0,3] for coloring and randomization\n float sub_id; // children id in the 4 split\n int type;\n};\nvoid pack_info( inout TraceCityRetval ct, vec2 tile_index, float split_case, float sub_id ) { ct.tile_index = tile_index; ct.split_case = split_case; ct.sub_id = sub_id; }\nvoid pack_info1( inout TraceCityRetval ct, float t, vec3 p, vec3 n, float ao, int type ) { ct.t = t; ct.p = p; ct.n = n; ct.ao = ao; ct.type = type; }\n// to easily make a polar coords heart, draw the heart you want, lay out r(theta) in cartesian space, and manual curve match it\nfloat heart( float x ) { x = abs( repeat_e( x, -3.141592654, 3.141592654 ) ); return exp_decay( x * 1.2 ) * 0.7 + pow( max( x - 3.141592654 * 0.5, 0. ) / ( 3.141592654 * 0.5 ), 10. ) * 0.3; }\nfloat heart_grid( vec2 sp, vec2 c )\n{\n vec3 h = hash32( floor( sp / c ) );\n float s = 12. - 5. + 10. * h.z;\n vec2 sp3 = repeat( sp, c ) - c * 0.2 * h.xy;\n vec2 beat = impulse( vec2( 10. ), repeat( vec2( iTime, iTime + 0.08 ), vec2( 1.2 ) ) );\n float r = length( ( sp3 - c * 0.5 ) / ( 1. + beat * vec2( 0.3, 0.4 ) ) );\n float l = heart( calc_angle( sp3 - c * 0.5 ) );\n return step( r, l * s );\n}\n// ika is japanese for squid\nfloat ika( vec2 p, float anim )\n{\n vec2 p2 = p.xy;\n p2.y += 0.25;\n p2.x = abs( p.x );\n float d = opI_soft2( dot( p2 - vec2( 0., 1. ), vec2( 0.707106781, 0.707106781 ) ), -p2.y - 0.1, 6. );\n d = opI_soft2( d, p2.y - 1., 10. );\n float a = calc_angle( p.xy );\n float r = length( p.xy );\n a = abs( repeat_e( a, -3.141592654 * 0.5, 3.141592654 * 0.5 ) );\n float d3 = r - ( 0.3 + spherical_gaussian( cos( a - 3.141592654 * mix( 0.4, 0.5, anim ) ), 0.8, 40. )\n      + spherical_gaussian( cos( a - 3.141592654 * mix( 0.1, 0.4, anim ) ), 1.1, 40. ) );\n d3 = opI_soft2( p2.y, d3, 8. );\n d = opU( d, d3 );\n d = opS( d, length( ( p2 - vec2( 0.2 - anim * 0.075, 0.15 ) ) * vec2( 1. + anim * 0.5, 1. ) ) - 0.16 * ( 1. + anim * 0.4 ) ); // eyes\n return d;\n}\nfloat ika_grid( vec2 sp, float anim, vec2 c ) { return ika( repeat_e( sp, -c, c ) * 0.1, 1. - anim ); }\nfloat star( vec2 p )\n{\n vec2 n = normalize( vec2( 1., 0.4 ) ); // slope controls\n p.x = abs( p.x );\n p = fold( p, vec2( 0. ), vec2( -0.309016994, 0.951056516 ) ); // perp(90-72=18)\n p = fold( p, vec2( 0. ), vec2( -0.809016994, 0.587785252 ) ); // perp(90-72/2=54)\n vec2 v = p - vec2( 0., 1 );\n return opI( dot( v, n ), dot( v, vec2( -n.x, n.y ) ) );\n}\nfloat star_trail( vec2 p, out vec2 uv )\n{\n p = rotate_with_angle( p, radians( -25. ) * p.x );\n p.y *= exp( p.x * 2. );\n p.x *= exp( p.y * 1. );\n vec2 pmin = vec2( -0.4, -0.1 );\n vec2 pmax = vec2( 0.4, 0.1 );\n uv = ( p - pmin ) / ( pmax - pmin );\n return sd_bounds_range( p, pmin, pmax );\n}\nvoid surfaceColor( TraceCityRetval ct, inout vec3 albedo, inout vec3 emitter, inout float road_marking_material )\n{\n if ( ct.type == 8 ) albedo = max( vec3( 0. ), contrast( albedo, vec3( 1.75 ) ) ); // enhance disparity of roof colors\n float aa = 0.003; // sorry...\n NearestHighwayRetval nh;\n float is_highway_columns_zone = 0.; // just columns\n float d_pavement_below_highway = /* FLT_MAX */1000000.;\n float d_highway_columns_zone = /* FLT_MAX */1000000.;\n if ( ( ct.sub_id == /* TYPE_HIGHWAY */8. ) || ( ct.sub_id == /* TYPE_ROAD */9. ) )\n {\n  nh = evalHighway( ct.p.xy );\n  d_pavement_below_highway = nh.d - (1.) * 0.5;\n  d_highway_columns_zone = nh.d - (1.) * 0.25;\n  is_highway_columns_zone = smoothstep_c( -d_highway_columns_zone, 0., 0.005 ); // account for the bevel (mask of road flat bit)\n }\n vec3 road_base_color0 = vec3( 0.5, 0.53, 0.65 );\n if ( ( ct.sub_id == /* TYPE_HIGHWAY */8. ) && true )\n {\n  // roadmarkings on top of highway\n  float hd = nh.d - (1.);\n  float highway_road_bit_mask = 1. - smoothstep_c( nh.d, (1.) - 0.2, 0.005 ); // account for the bevel (mask of road flat bit)\n  vec2 u = ( nh.pr + nh.d2f.xy ); // works better\n  u.y = nh.d;\n  float snhd = nh.d * sign( nh.d2f.y ); // signed distance accross road when we need to distinguish ledft/right\n  float curvature = smin_pol( abs( nh.d2f.w ) * 1.2, 1., 0.5 );\n  float diagstripes0 = step( ( (1.) * 0.9 - nh.d ) * sign( nh.d2f.y ), curvature );\n  float diagstripes = diagstripes0 * smoothband( snhd, (1.) * 0.1, (1.) * 0.7, 0.005 ); // select road v band, sign( nh.d2f.y ) tells us which side of the road we are on\n  vec3 road_marking_color_white = vec3( 1. ) * 3.;\n  vec3 road_marking_color_yellow = vec3( 1., 1., 0. ) * 2.;\n  vec3 albedo_markings = vec3( 0. );\n  albedo_markings = mix( albedo_markings, road_marking_color_white, ( smoothband( abs( u.y ) - ((1.)*2.) * 0.18, 0.016, aa ) ) * ( stripes2( u.x, 0.4, 0.1, aa ) ) * ( 1. - diagstripes ) );\n  albedo_markings = mix( albedo_markings, mix( road_marking_color_yellow, road_marking_color_white, 1. ), highway_road_bit_mask * ( stripes( u.y, 0.75, 0.016, aa ) ) * ( 1. - diagstripes ) );\n  // the wide warning stripes\n  albedo_markings = mix( albedo_markings, road_marking_color_white, diagstripes * ( stripes( u.x + hd * sign( nh.d2f.y ) * 1.5, 0.15 * 1.8,0.05, aa ) ) );\n  albedo_markings = mix( albedo_markings, road_marking_color_white, ( ( stripes2( u.x - fold(snhd, ((1.)*2.)*(-0.28))*(0.5), 0.4 * 16.,0.1 * 12., aa ) ) * smoothband( snhd- ((1.)*2.)*(-0.28), (0.24)*0.5, aa ) ) * ( ( stripes2( u.x - fold(snhd, ((1.)*2.)*(-0.28))*(0.5), 0.4,0.1, aa ) ) * smoothband( snhd- ((1.)*2.)*(-0.28), (0.24)*0.5, aa ) ) * ( 1. - diagstripes ) );\n  {\n   // highway road marking number\n   vec2 np = ( ct.p.xy ); // vec2( u.x, nh.d2f.y );\n   np.x = repeat_e( np.x, -20., 20. );\n   np = ( perp( np ) + vec2( 0.25, 9. ) ) * vec2( 3.5, 0.75 );\n   NumberArg args;\n   args.h = 0.7;\n   args.s = vec2( 1., 2. ) * 0.5;\n   args.r = 0.1;\n   args.w = 0.045;\n   args.m = 0.025;\n   float dn = sd_Number3or8( np, 8, args );\n   dn = opU( dn, sd_Number3or8( np + vec2( -args.s.x * 1., 0. ), 3, args ) );\n   if ( sign( nh.d2f.y ) > 0. ) dn = /* FLT_MAX */1000000.;\n   albedo_markings = mix( albedo_markings, road_marking_color_yellow, smoothstep( aa, -aa, dn ) );\n  }\n  // make sure roadmarkings are only on top highway surface\n  float space_filter = step( 2., ct.p.z ) // must be above highway height\n   * step( 0., ct.n.z ) // surface must be pointing up\n   * step( ct.p.z, 2. + 0.5 ); // not higher than highway border walls\n  {\n   float blend = maxcomp( albedo_markings ) * space_filter;\n   albedo = mix( albedo, min( albedo_markings + road_base_color0 * 0.70, vec3( 1. ) ), blend );\n   road_marking_material = max( road_marking_material, blend );\n  }\n  if ( ct.type == 2 )\n  {\n   // render stuff on LCD panels... shadertoy within shadertoy, hehe\n   albedo_markings = vec3( 0. );\n   float h2 = 1.2; // sign start h\n   float h3 = 0.3; // sign end h\n   if ( ct.p.z > 2. + h2 - 0.0 )\n   {\n    float screenpixel = 0.01; // highway panel pizel size, in world size\n    vec2 gp = ct.p.yz;\n    gp.x = snhd;\n    gp.y -= ( 2. + h2 ); // make botton line be pixel coord y=0\n    float d = sd_bounds_repeat_size_margin( gp, vec2( screenpixel ), vec2( 0.001 ) );\n    float margin = step( d, 0. );\n    // I don't AA properly because I suck, but at least tone the grid down\n    margin = mix( margin, 1., ( 1. - exp( -max( ct.t - 6., 0. ) ) * 0.7 ) );\n    vec2 sp = floor( gp / screenpixel ); // screen pixel\n    // bottom margin x top margin x sides component\n    float is_ldc_surface = step( 1., sp.y ) * step( sp.y, floor( 0.3 / screenpixel ) - 2. ) * step( 0.5, abs( ct.n.x ) );\n    margin *= is_ldc_surface;\n    float index = floor( u.x / (2.*20./(3.)) ); // same repeat as sd_HighwaySigns\n    index = mod( index, 4. );\n    if ( index == 0. )\n    {\n     // airliners\n     vec2 c = vec2( 110., 110. );\n     vec2 sp3 = rotate_with_unit_vector( sp, -vec2( 0.5, 0.866025403 ) ) + vec2( -iTime * 100., 0. );\n     sp3 = repeat( sp3, c );\n     float d3 = sd_airliner_a350( ( sp3 - c * 0.5 ) * 0.2 );\n     emitter+=(vec3( 1. ))*(step( d3, 0. ))*margin*1.;;\n    }\n    else if ( index == 1. )\n    {\n     // hearts\n     float hg = heart_grid( -perp( sp ) + vec2( sin( iTime * 3. ) * 8., 6. + iTime * 40. ), vec2( 32., 40. ) );\n     emitter+=(vec3( 1., 0., 0. ))*(hg)*margin*1.;;\n     float hg2 = heart_grid( ( rotate_with_unit_vector( -sp, vec2( 0.707106781, 0.707106781 ) ) * 2. ) + vec2( -iTime * 18., 6. ), vec2( 30., 30. ) );\n     emitter+=(vec3( 0., 1., 1. ))*(hg2 * ( 1. - hg ))*margin*1.;;\n    }\n    else if ( index == 2. )\n    {\n     // rainbow stars\n     vec2 sp3 = sp;\n     sp3 *= 1.;\n     sp3.y -= 100.;\n     sp3 = rotate_with_angle( sp3, iTime );\n     float a = calc_angle( sp3 );\n     float r = length( sp3 );\n     float r0 = 30.;\n     float arclen0 = r0 * 2.; // use a rough sie ratio\n     float ri = floor( r / r0 );\n     float R = ri * r0;\n     float numarc = floor( 2. * 3.141592654 * R / arclen0 );\n     float da = ( 2. * 3.141592654 / numarc );\n     float dai = floor( a / da );\n     vec2 y = unit_vector2( da * ( dai + 0.5 ) );\n     vec2 x = -perp( y );\n     vec2 c = y * ( ri + 0.5 ) * r0;\n     sp3 = vec2( dot( x, sp3 - c ), dot( y, sp3 - c ) );\n     sp3 *= 0.025;\n     sp3.y = -sp3.y;\n     float d1 = star( sp3.xy * 3. );\n     vec2 trail_uv;\n     float d2 = star_trail( sp3.xy - vec2( -0.6, -0.1 ), trail_uv );\n     vec3 rainbow = hsv2rgb( vec3( trail_uv.y, 1., 1. ) );\n     vec3 c2 = vec3( 0. );\n     if ( d2 < 0. ) c2 = rainbow;\n     if ( d1 < 0. ) c2 = vec3( 1., 1., 0. );\n     emitter+=(c2)*(max( step( d1, 0. ), step( d2, 0. ) ))*margin*1.;;\n    }\n    else if ( index == 3. )\n    {\n     // 2 layers of swimming squids or something\n     float anim1 = ( sin( iTime * 8. ) + 1. ) * 0.5;\n     vec2 sp1 = rotate_with_unit_vector( sp, -vec2( 0.707106781, 0.707106781 ) ) + vec2( 0., 18. - iTime * 20. + anim1 * 4. );\n     float l1 = step( ika_grid( sp1, anim1, vec2( 15., 15. ) ), 0. );\n     emitter+=(vec3( 0., 1., 1. ))*(l1)*margin*1.;;\n     float anim2 = ( sin( iTime * 9. ) + 1. ) * 0.5;\n     vec2 sp2 = rotate_with_unit_vector( sp, -vec2( 0.707106781, 0.707106781 ) ) + vec2( 5., 9. - iTime * 35. + anim1 * 4. );\n     float l2 = step( ika_grid( sp2, anim2, vec2( 40., 40. ) ), 0. );\n     emitter+=(vec3( 1., 0., 0. ))*(l2 * ( 1. - l1 ))*margin*1.;;\n    }\n    albedo = mix( albedo, albedo * 0.3, is_ldc_surface );\n   }\n  }\n }\n if ( ( ct.sub_id == /* TYPE_ROAD */9. ) && true )\n {\n  // regular streets road markings\n  NearestHighwayRetval nh = evalHighway( ct.p.xy );\n  vec2 pp = repeat_mirror_l( ct.p.xy, vec2( 0., 0. ), /* CELL_SIZE */vec3( 8., 8., 100. ).xy ); // road cells\n  vec2 extra = -vec2( 0.15 );\n  vec2 mina = /* CELL_SPACING */vec2( 0.47, 1.3 ).yy * 0.5 + extra;\n  vec2 minb = /* CELL_SIZE */vec3( 8., 8., 100. ).xy - /* CELL_SPACING */vec2( 0.47, 1.3 ).xx - extra;\n  float d1 = sd_bounds_range_round( pp, mina, minb, 0.075 );\n  float is_pure_road = step( 0., d1 );\n  d1 = opS( d1, d_pavement_below_highway ); // empty the bit below the highway\n  float is_road_or_below_highway_road = step( 0., d1 );\n  vec2 is_wide_road = step( pp, mina );\n  vec2 is_small_road = step( minb, pp );\n  float is_wide_road_crossing = is_wide_road.x * is_wide_road.y;\n  float is_small_road_crossing = is_small_road.x * is_small_road.y;\n  float is_small_wide_road_crossing = min( is_wide_road.x * is_small_road.y + is_wide_road.y * is_small_road.x, 1. );\n  float crossing = min( is_small_road_crossing + is_wide_road_crossing + is_small_wide_road_crossing, 1. );\n  vec3 road_marking_color_white = vec3( 1. ) * 2.;\n  vec3 road_marking_color_yellow = vec3( 1., 1., 0. ) * 2.;\n  vec3 albedo_markings = vec3( 0. );\n  // white lines all around\n  albedo_markings = mix( albedo_markings, road_marking_color_white, smoothband( d1, 0.05, 0.05 + 0.02, aa ) );\n  // wide roads markings\n  albedo_markings = mix( albedo_markings, road_marking_color_white, smoothband( pp.x, 0.01, aa ) * is_wide_road.x * ( 1. - crossing ) ); //DOTTEDLINE\n  albedo_markings = mix( albedo_markings, road_marking_color_white, smoothband( pp.y, 0.01, aa ) * is_wide_road.y * ( 1. - crossing ) ); //DOTTEDLINE\n  // small road markings\n  albedo_markings = mix( albedo_markings, road_marking_color_white, smoothband( pp.x - /* CELL_SIZE */vec3( 8., 8., 100. ).x, 0.01, aa ) * stripes( pp.y - /* CELL_SIZE */vec3( 8., 8., 100. ).y, 0.2, 0.05, aa ) * ( 1. - crossing ) ); //DOTTEDLINE\n  albedo_markings = mix( albedo_markings, road_marking_color_white, smoothband( pp.y - /* CELL_SIZE */vec3( 8., 8., 100. ).y, 0.01, aa ) * stripes( pp.x - /* CELL_SIZE */vec3( 8., 8., 100. ).x, 0.2, 0.05, aa ) * ( 1. - crossing ) ); //DOTTEDLINE\n  // yellow strips alongside highway columns\n  albedo_markings = mix( albedo_markings, road_marking_color_yellow, smoothband( d_highway_columns_zone, 0.05, aa )* ( 1. - is_wide_road.x ) * ( 1. - is_small_road.x ) );\n  {\n   // pedestrian crossings on large roads\n   float crossing_width = 0.24;\n   float dd = 0.5; // where do start crossing from\n   vec2 pedestrian_crossingmask = stripes( pp - ( mina + vec2( dd ) ), minb - mina - vec2( dd ) * 2., vec2( crossing_width ), vec2( aa ) );\n   vec2 pedestrian_crossingmask2 = stripes( pp - ( mina + vec2( dd ) ), minb - mina - vec2( dd ) * 2., vec2( crossing_width * 1.2 ), vec2( aa ) );\n   pedestrian_crossingmask *= is_pure_road * ( 1. - is_highway_columns_zone );\n   pedestrian_crossingmask2 *= is_pure_road * ( 1. - is_highway_columns_zone );\n   albedo_markings *= ( 1. - pedestrian_crossingmask2.x ) * ( 1. - pedestrian_crossingmask2.y );\n   albedo_markings = mix( albedo_markings, road_marking_color_white, stripes( pp.y, 0.1, 0.025, aa ) * pedestrian_crossingmask.x );\n   albedo_markings = mix( albedo_markings, road_marking_color_white, stripes( pp.x, 0.1, 0.025, aa ) * pedestrian_crossingmask.y );\n  }\n  float blend = maxcomp( albedo_markings ) * is_road_or_below_highway_road * ( 1. - is_highway_columns_zone );\n  albedo = mix( albedo, min( albedo_markings + road_base_color0 * 0.75, vec3( 1. ) ), blend );\n  road_marking_material = max( road_marking_material, blend );\n }\n}\nvec3 shadeCity( TraceCityRetval ct, vec3 e, vec3 v, vec3 l, float shadow\n    , float airliner, float a_contrast, vec2 uv, float aspect, float ground_ao )\n{\n vec3 col = vec3( 0. );\n vec3 emitter = vec3( 0. );\n float is_sky = (((ct.sub_id)!=(/* TYPE_SKY */10.))?0.:1.);\n // hack stretch sky horizon so it matches our trace horizon (means the sun position won't quite match with real sun position)\n float gamma = -e.z / /* MAX_DDA_TRACE */640.; //=cos(PI/2.+beta)=sin(beta), beta is the extra angle that goes into the ground\n float alpha = -1. / ( gamma - 1. );\n vec3 v_hacked = vec3( v.xy, 1. + ( v.z - 1. ) * mix( alpha, 1., 0. ) ); // mix control how much hack correction (alpha) we want on horizon\n vec3 skycol_view = get_sky( normalize( v_hacked ), l, 0.4 );\n//\tif ( ct.t > MAX_DDA_TRACE ) return GREEN;\n // sun disk\n float sun0 = dot( l, v );\n if ( ct.sub_id == /* TYPE_SKY */10. )\n {\n  col = skycol_view;\n  // we don't need to add a disk... let get_sky do it (also we messed with horizon and therefore sun position)\n//\t\tcol += vec3( pow( sun, 20. ) * is_sky * 100. ); // sun disk (not flare/not glow, just the sun disk)\n  float d_airliners = 1. - pow( max( 0., sun0 ), 8. ); // airliners\n  col = mix( col, vec3( airliner ) + d_airliners * skycol_view * 2., airliner * 0.5 );\n }\n else\n {\n  ivec4 ch = ivec4( ct.split_case, ct.sub_id, ct.tile_index );\n  vec3 albedo = get_building_palette( hash24_( ch ) * mix( 1., 0.2, (((ct.type)!=(8))?0.:1.) ) ); // roof tiles use bottom left part of the 2d palette (ardoise)\n  float road_marking_material = 0.;\n  surfaceColor( ct, albedo, emitter, road_marking_material );\n  float kdiffuse = mix( 0.75, 1., road_marking_material );\n  float kspecular = mix( 0.15, 0.8, road_marking_material ) * shadow;\n  float roughness = mix( 0.62, 0.1, road_marking_material );\n  if ( ct.type == 8 ) { kspecular = 0.7; roughness = 0.2; }\n  float Li_sky_color_saturation = 0.65; // how much we blend sky color in\n  vec3 skycol_top = get_sky( vec3( 0., 0., 1. ), l, 1. );\n  vec3 skycol_sun = get_sky( l, l, 1. );\n  vec3 lr = vec3( -l.xy, l.z ); // sun light reflected from buildings from behind (\"1 bounce\")\n  vec3 l2 = vec3( perp( l.xy ), l.z );\n  vec3 l3 = vec3( -l2.xy, l.z );\n  vec3 Li_sky_top = mix( skycol_top, vec3( luminance( skycol_top ) ), Li_sky_color_saturation );\n  float s2 = mix( 0.8, 1., shadow );\n  // only add ambient on shadows\n  col += 0.005 * ( 1. - shadow );\n  // skydome top light (highlights rooftops, too)\n  col += s2 * add_light_contrib( albedo, vec3( 0., 0., 1. ), ct.n, -v, Li_sky_top, 5., kdiffuse, kspecular, roughness );\n  // a couple of lateral directions, pretend Li_sky_top, this works well for our axis aligned scene...\n  col += s2 * add_light_contrib( albedo, l2, ct.n, -v, Li_sky_top, 1., kdiffuse, 0., roughness );\n  col += s2 * add_light_contrib( albedo, l3, ct.n, -v, Li_sky_top, 1., kdiffuse, 0., roughness );\n  // sun light reflected by \"buildings from behind\" (1 bounce-ish) tip from iq's http://iquilezles.org/www/articles/outdoorslighting/outdoorslighting.htm\n  vec3 Li_sky_sun_back = 0.2 * mix( skycol_sun, vec3( luminance( skycol_sun ) ), Li_sky_color_saturation );\n  // fade the highest positions as they don't get that much reflected light as there are no taller buildings, also that gives a bit of gradient\n  Li_sky_sun_back *= 1. - min( ct.p.z / ( /* MAX_BUILDING_HEIGHT */14.3 * 0.8 ), 1. );\n  col += s2 * add_light_contrib( albedo, lr, ct.n, -v, Li_sky_sun_back, 0.5, kdiffuse, .0, roughness );\n  col *= ct.ao * ct.ao * ct.ao * mix( ground_ao, 1., exp_decay( ct.p.z * 0.5 ) ); // we add a simple vertical occlusion term in addition to he marched ao\n  // direct sun light (post ao!)\n  vec3 Li_sky_sun_front = mix( skycol_sun, vec3( luminance( skycol_sun ) ), Li_sky_color_saturation );\n  col += shadow * add_light_contrib( albedo, l, ct.n, -v, Li_sky_sun_front, 1., kdiffuse, kspecular, roughness );\n//\t\tcol = mix( vec3( 1., 0., 0. ), col, shadow );\n  if ( ct.type == 4 )\n  {\n   vec3 vr = reflect( v, ct.n );\n    // windows sky reflections, assumes sky fades to black in lower hemisphere\n   col += get_sky( vr, l, 1. ) * mix( 0.5, 1., shadow );\n   // make windows a bit reflective in bottom hemisphere too\n   // just reflect a constant \"ground color\", fading with distance\n   if ( v.z < 0. )\n   {\n    float wt = plane_trace_z( mkray( e, vr ), 0., 1.e-6 );\n    if ( wt > 0. && wt != /* FLT_MAX */1000000. )\n    {\n//\t\t\t\t\tcol += RED * exp( -wt * 0.09 ); // red is kind of cool too :-)\n     col += vec3( 0.32, 0.38, 0.47 ) * exp( -wt * 0.09 ) * 0.25; // reflect a city ground color, maybe this gradient could be a function of building height\n    }\n   }\n   // upper hemisphere window reflections (sky and office neon)\n   if ( v.z > 0. )\n   {\n    // cheap but efficient neon hack\n    Ray vr = mkray( e, v );\n    float wt = plane_trace_z( vr, ceil( ct.p.z / /*FLOOR_HEIGHT*/0.6 ) * /*FLOOR_HEIGHT*/0.6, 1.e-6 ); // infinite neon plane\n    if ( wt > 0. && wt != /* FLT_MAX */1000000. )\n    {\n     vec3 wp = vr.o + vr.d * wt;\n     float neondepth = dot( ct.p - wp, ct.n );\n     vec2 y = normalize( ct.n.xy );\n     vec2 x = -perp( y );\n     float dneon = sd_bounds_repeat_range_range( wp.x * x + wp.y * y, vec2( 0., 0. ), vec2( 0.8, 0.3 ) // neon periodicity\n                , vec2( 0., 0. ), vec2( 0.34, 0.05 ) ); // neon size\n     col += step( dneon, 0. ) * exp2( -neondepth * 2.8 );\n    }\n   }\n  }\n  col += (((ct.type)!=(1))?0.:1.) * 0.9;\n  col += emitter;\n//\t\tvec3 fog_color = mix( RED, GREEN, pow( ( sun0 + 1. ) * 0.5, mix( 7., 40., shadow ) ) );\n  vec3 fog_color = mix( skycol_top * 1.5, skycol_sun, pow( ( sun0 + 1. ) * 0.5, mix( 7., 5., shadow ) ) ); // skycol_top color is a bit weak so boost it a bit\n  col += fog_color * 0.55 * exp_decay( ct.t * 0.002 + ct.p.z * 0.007 ); // some kind of inscatter (so we add), along view distance and world height\n  col = mix( col, skycol_view, smoothstep( /* FADE_START */480., /* MAX_DDA_TRACE */640., ct.t ) ); // fade with background\n//\t\tif ( ct.t > FADE_START ) return RED;\n//\t\treturn skycol_view;\n//\t\treturn skycol_top * 8.;\n//\t\treturn skycol_sun;\n//\t\treturn col;\n }\n col = 3.5 * tonemap_reinhard( col ); // expose\n//\tcol = max( vec3( 0. ), contrast( col, vec3( a_contrast ) ) ); // post process\n col *= .2 + 0.8 * pow( 20. * uv.x * uv.y * ( 1. - uv.x ) * ( 1. - uv.y ), 0.075 ); // vignette\n col = gamma_correction_itu( col );\n//\tif ( v.z < 0. ) col = RED; // view real horizon\n return col;\n}\n// building heights distribution function\nvec4 icdf( vec4 x ) { return mix( saturate( safe_acos( vec4( 1. ) - 4. * x ) / 3.141592654 ), (x - vec4( 0.5 )) * 0.1, step( 0.5, x ) ); }\nParametricBuildingRetval sd_ParametricBuilding( float t, vec3 p, float building_type, bounds2 b2, float height, NearestHighwayRetval nh, vec3 rnd )\n{\n if ( building_type == 0. ) return sd_House( p, t, b2, min( height, 2. ), nh );\n return sd_Building( t, p, b2, height, nh, rnd );\n}\nstruct ParametricBuildingHit\n{\n float t;\n float tile_child_index;\n float building_type; // 0:house 1:building (could use 0. and 4. instead)\n float height;\n bounds2 b2;\n float d;\n vec3 windr;\n float is_roof;\n Ray ray2; // potentially permuted ray\n bool permuted;\n NearestHighwayRetval nh;\n vec3 rnd;\n};\nvoid rayMarchParametricBuilding( Ray ray2, bool permuted, vec2 ri, bounds3 bi, float kk, inout ParametricBuildingHit hit, vec2 cell_index )\n{\n if ( ri.y <= ri.x || ri.y < 0. ) return; // no hit\n ri.x = max( ri.x, 0. );\n // warning: if you fiddle with early return here, check what happens to the shadow term!\n bounds2 b2 = mkbounds_unchecked( bi.pmin.xy, bi.pmax.xy ); // b2 is in maybe permuted space and contains the object\n vec2 base_size = size( b2 ); // this is the base size with x and y maybe permuted\n//\tif ( base_size.x <= 0. || base_size.y <= 0. ) return; // doesn't seem to contribute to the image... and is slower?\n NearestHighwayRetval nh;\n nh.d = /* FLT_MAX */1000000.; // disable the clip plane\n {\n  // some basic layout intersection tests outside marching loop... tedious block of code\n  vec2 b2c = center( b2 );\n  vec2 b2s = base_size; // size( b2 )\n  if ( permuted ) // remember: b2 is in permuted space, dont use it in calculations below\n  {\n   b2c = b2c.yx; // back to world\n   b2s = b2s.yx;\n  }\n  nh = evalHighway( b2c );\n  nh.o_clip = nh.p + nh.d2f.xy; // closest highway center line point (b2c==nh.p)\n  nh.n_clip = normalize( perp( nh.d2f.zw ) ); // can't use hret2.d2f.xy as it may be null\n//\t\tfloat b2cd = dot( b2c - nh.o_clip, nh.n_clip ); // distance to higway center line, signed\n  float b2cd = dot( -nh.d2f.xy, nh.n_clip ); // should be same as above, saves a sub (lol)\n  nh.n_clip *= sign( b2cd ); // orient the clip normal so we can build a facade (box center is on positive side)\n  b2cd = abs( b2cd ); // now we are on the positive side\n  float ml = length( b2s );\n  if ( b2cd > ( ml + ((1.)*2.) ) * 0.5 ) nh.d = /* FLT_MAX */1000000.; // building far away enough regardless of rotation, disable the clip plane\n  else\n  {\n   float l = b2s.y; // (fixme: corrected with slope) if we can assume horizonal ish roads\n   float clipped_l = ( b2cd + l * 0.5 ) - max( b2cd - l * 0.5, (1.) ); // size left after clipping\n   base_size = b2s;\n   base_size.y = clipped_l;\n   // if the building was ultra thin to begin with, clipping is not going to make things any better\n   // that filters out some garbage thin buildings\n   if ( maxcomp( base_size ) > 10. * mincomp( base_size ) ) return;\n  }\n//\t\tnh.d = FLT_MAX; // uncomment to check actual size of building if they weren't clipped\n  if ( permuted )\n  {\n   // back to permuted space\n   nh.p = nh.p.yx;\n   nh.pr = nh.pr.yx;\n   nh.d2f = nh.d2f.yxwz;\n   nh.n_clip = nh.n_clip.yx;\n   nh.o_clip = nh.o_clip.yx;\n  }\n }\n float height = bi.pmax.z; // pmax.z awkward?\n // make height not bigger than n times the smallest dimension on the 2d base, not that base_size may be permuted, we only care about the min dimension\n height = min( height, 8. * mincomp( base_size ) );\n float building_type = height < 3.4 ? 0. : 1.;\n if ( building_type == 1. ) height = ( 0.5 + floor( height / /*FLOOR_HEIGHT*/0.6 - 0.5 ) ) * /*FLOOR_HEIGHT*/0.6; // make building height a multiple of floor height\n float t = ri.x; // start marching from first hit point\n vec3 rnd = vec3( cell_index, kk );\n for ( int j = 0; j < 70 /*FORCE_LOOP*/+min(0,iFrame); ++j )\n {\n  // no need to trace further than max cell size == massive win\n  // we then have to pick a max trace distance, for that cell 2d diagonal size would be a start\n  // but since cell height is higher than max building height, we use max building height instead\n  if ( t - ri.x > /* MAX_BUILDING_HEIGHT */14.3 ) break;\n  vec3 p = ray2.o + t * ray2.d;\n  ParametricBuildingRetval ddd = sd_ParametricBuilding( t, p, building_type, b2, height, nh, rnd );\n  float d = ddd.d;\n  if ( abs( d ) <= 0.001 * t )\n  {\n   if ( t < hit.t ) // we need to check vs other objects in the cell\n   {\n    // record a few things we need to do extra evals deriving from the final hit\n    hit.t = t;\n    hit.tile_child_index = kk;\n    hit.building_type = building_type;\n    hit.b2 = b2;\n    hit.height = height;\n    hit.d = d;\n    hit.windr = ddd.windr;\n    hit.is_roof = step( abs( d - ddd.droof ), 0.001 );\n    hit.ray2 = ray2;\n    hit.permuted = permuted;\n    hit.nh = nh;\n    hit.rnd = rnd;\n   }\n   break; // \"return\" is slower on radeon: 29ms -> 31ms (ancient wip timings)\n  }\n  float dt = d;\n//\t\tfloat dt = d * TFRAC; // shadows a bit better with this\n//\t\tfloat dt = abs( d ); // *TFRAC // only move forward (see inside of buildings...)\n  t += dt;\n//\t\tp += dt * ray2.d; // do not do this, instead increment t and reevaluate p fully (loss of precision else)\n }\n}\nvoid rayMarchCellObjects( Ray ray2, Ranges_x4 iv, bool permuted, inout ParametricBuildingHit hit, vec2 cell_index, bool shadow_trace )\n{\n vec2 ranges[4] = vec2[4]( iv.rA, iv.rB, iv.rC, iv.rD );\n bounds3 b4s[4] = bounds3[4]( iv.bA, iv.bB, iv.bC, iv.bD );\n for ( int i = 0; i< ( 4 /*FORCE_LOOP*/+min(0,iFrame) ); ++i )\n {\n  rayMarchParametricBuilding( ray2, permuted, ranges[i], b4s[i], float( i ), hit, cell_index );\n }\n}\n// ray march buildings in a cell\nvoid traceBuildings( Ray a_ray, inout TraceCityRetval ct, float split_cells_spacing, bool shadow_trace )\n{\n float maxh = /* MAX_BUILDING_HEIGHT */14.3;\n float minh = 2.;\n float rmin = -0.1;\n float rmax = max( 1., maxh );\n // we only dda trace the rmin, rmax z range\n float tbottom = plane_trace_z( a_ray, rmin, 1e-6 );\n float ttop = plane_trace_z( a_ray, rmax, 1e-6 );\n vec2 r0 = vec2( 0., /* MAX_DDA_TRACE */640. );\n vec2 r1 = vec2( min( ttop, tbottom ), max( ttop, tbottom ) );\n vec2 r2 = vec2( max( r0.x, r1.x ), min( r0.y, r1.y ) ); // intersection of r0 and r1\n//\tif ( r2.y <= r2.x ) return; // non sensical per drop if we return...\n r2 *= step( r2.x, r2.y ); // ...so instead do a zero length iteration\n float start_t = r2.x; // remember initial jump to return something along a_ray\n Ray ray = mkray( a_ray.o + a_ray.d * start_t, a_ray.d ); // warp to tmin\n vec3 ray_end = a_ray.o + a_ray.d * r2.y;\n DDA3 dda = dda_init( ray.o, ray_end, /* CELL_SIZE */vec3( 8., 8., 100. ), false );\n // trace within dda traversed cell\n ParametricBuildingHit hit;\n hit.t = /* FLT_MAX */1000000.;\n float split_case = -1.;\n // dda traverse\n for ( int i = 0; i < ( 37 /*FORCE_LOOP*/+min(0,iFrame) )\n    && dot( dda.p - a_ray.o, dda.p - a_ray.o ) < r2.y * r2.y; ++i )\n {\n  // raytrace 4 boxes inside each cell\n  bounds2 b = mkbounds_unchecked( dda.c.xy * /* CELL_SIZE */vec3( 8., 8., 100. ).xy, ( dda.c.xy + vec2( 1., 1. ) ) * /* CELL_SIZE */vec3( 8., 8., 100. ).xy ); // cell bounds\n  ivec2 index = ivec2( dda.c.xy );\n  vec4 a; a.xy = /* CELL_SPACING */vec2( 0.47, 1.3 ).xy * 0.5; a.zw = a.xy;\n  if ( ( index.x & 1 ) == 0 ) a.xy = a.yx;\n  if ( ( index.y & 1 ) == 0 ) a.zw = a.wz;\n  b.pmin.xy += a.xz; // shrink cell bounds according to street margins (we alternate wide and narrow streets hence logic above)\n  b.pmax.xy -= a.yw;\n  vec2 margin = vec2( split_cells_spacing * 0.5 + 0.2 );\n  vec2 r55 = hash22_( index ); // split type, permute\n  Ray ray2 = ray;\n  bool permuted = false;\n  if ( r55.y > 0.5 )\n  {\n   // random permutations, else default patterns look more or less all aligned\n   ray2.o.xyz = ray.o.yxz;\n   ray2.d.xyz = ray.d.yxz;\n   b.pmin.xy = b.pmin.yx;\n   b.pmax.xy = b.pmax.yx;\n   permuted = true;\n  }\n  vec4 r4 = icdf( hash42_( index * 0x8da6b343 ) ); // heights hash\n  vec4 rheights = mix( vec4( minh ), vec4( maxh ), r4 );\n  vec4 r3 = hash42_( index * 0xb68f63e4 ); // split hash\n  vec4 r3_0 = r3;\n  r3.xyw = mix( vec3( 1. ), vec3( 5. ), r3.xyw ); // ratio of smallest to largest size\n  r3.xy = fractions( r3.xyw ); // use r3.xyw as relative unit sizes\n  r3.z = mix( 0.2, 0.8, r3.z );\n  Ranges_x4 iv;\n  Split4bSetup s4su = setup_Split4b( ray2, b.pmin.xy, b.pmax.xy, margin );\n  // select a tile split pattern\n  if ( r55.x > 0.75 )\n  {\n   bound_Split4b_xxy( iv, ray2, b.pmin.xy, b.pmax.xy, mix( b.pmin.xxy, b.pmax.xxy, r3.xyz ), rheights, margin );\n   trace_Split4b_xxy( iv, ray2, s4su, mix( b.pmin.xxy, b.pmax.xxy, r3.xyz ), rheights );\n   split_case = 0.;\n  }\n  else if ( r55.x > 0.5 )\n  {\n   r3.xyz = fractions( mix( vec4( 2. ), vec4( 3. ), r3_0 ) );\n   bound_Split4b_xxx( iv, ray2, b.pmin.xy, b.pmax.xy, mix( b.pmin.xxx, b.pmax.xxx, r3.xyz ), rheights, margin );\n   trace_Split4b_xxx( iv, ray2, s4su, mix( b.pmin.xxx, b.pmax.xxx, r3.xyz ), rheights );\n   split_case = 1.;\n  }\n  else if ( r55.x > 0.25 )\n  {\n   bound_Split4b_xyy( iv, ray2, b.pmin.xy, b.pmax.xy, mix( b.pmin.xyy, b.pmax.xyy, r3.zxy ), rheights, margin );\n   trace_Split4b_xyy( iv, ray2, s4su, mix( b.pmin.xyy, b.pmax.xyy, r3.zxy ), rheights );\n   split_case = 2.;\n  }\n  else\n  {\n   bound_Split4b_xyx( iv, ray2, b.pmin.xy, b.pmax.xy, mix( b.pmin.xyx, b.pmax.xyx, r3.xzy ), rheights, margin );\n   trace_Split4b_xyx( iv, ray2, s4su, mix( b.pmin.xyx, b.pmax.xyx, r3.xzy ), rheights );\n   split_case = 3.;\n  }\n  hit.t = /* FLT_MAX */1000000.;\n  hit.tile_child_index = -1.; // no hit\n  rayMarchCellObjects( ray2, iv, permuted, hit, dda.c.xy, shadow_trace );\n  if ( hit.t != /* FLT_MAX */1000000. ) break; // we have hit, gtfo and fill other extra bits out of the loop\n//\t\tif ( hit.t > ct.t ) return; // fixme: no point in continuing, but we should just set dda end point instead\n  dda_step_infinite( dda ); // make sure you set a_finite to false in dda_init when calling this version\n }\n if ( hit.t >= ct.t ) return; // ct.t might be FLT_MAX so >= is important here\n // we hit a building\n ct.p = ray.o + hit.t * ray.d;\n ct.t = start_t + hit.t; // remember that we jumped at start\n if ( shadow_trace ) return; // we don't need normal, ao, material... gtfo\n // house type will use type index [0,3], building type will use index [4,7]\n pack_info( ct, dda.c.xy, split_case, hit.tile_child_index + hit.building_type * 4. );\n vec3 p = hit.ray2.o + hit.t * hit.ray2.d;\n vec3 h = vec3( 0.01, 0., 0. ); // h.x *= hit.t; // grainy normals tweak\n ct.n = normalize( vec3( sd_ParametricBuilding( hit.t, p + h.xyz, hit.building_type, hit.b2, hit.height, hit.nh, hit.rnd ).d,\n       sd_ParametricBuilding( hit.t, p + h.zxy, hit.building_type, hit.b2, hit.height, hit.nh, hit.rnd ).d,\n       sd_ParametricBuilding( hit.t, p + h.yzx, hit.building_type, hit.b2, hit.height, hit.nh, hit.rnd ).d )\n       - hit.d ); // hit.d should be equal to sd_ParametricBuilding( hit.t, p, hit.building_type, hit.b2, hit.height, hit.nh, hit.rnd ).d\n // do ao in permuted space\n {\n  Ray ao_ray = mkray( p, ct.n );\n  { /* ao algo from http://www.iquilezles.org/www/material/nvscene2008/rwwtt.pdf macrofified to avoid repetition */ float _delta = 0.1, _a = 0.0, _b = 1.0; for ( int _i = 0; _i < 5 /*FORCE_LOOP*/+min(0,iFrame); _i++ ) { float _fi = float( _i ); float _ao_t = _delta * _fi;\n   float d = sd_ParametricBuilding( _ao_t, ao_ray.o + _ao_t * ao_ray.d, hit.building_type, hit.b2, hit.height, hit.nh, hit.rnd ).d;\n  _a += ( _ao_t - d ) * _b; _b *= 0.5; } ct.ao = max( 1.0 - 1.2 * _a, 0.0 ); }\n }\n if ( hit.is_roof > 0. ) ct.type = 8;\n if ( ( abs( hit.d - hit.windr.x ) < 0.001 ) // distance must be close to windows plane, stored in hit.windr.x\n   && ( 0.01 < abs( dot( hit.windr.yz, ct.n.xy ) ) ) // normal must match window orientation\n   // normal must be vertical\n   && ( abs( ct.n.z ) < 0.005 ) ) ct.type = 4;\n if ( hit.permuted ) ct.n.xy = ct.n.yx;\n}\nTraceCityRetval traceCity( Ray ray, bool shadow_trace )\n{\n TraceCityRetval ct;\n pack_info1( ct, /* FLT_MAX */1000000., vec3( 0. ), vec3( 0. ), 1., 0 );\n pack_info( ct, vec2( 0. ), 0., /* TYPE_SKY */10. );\n float split_cells_spacing = 0.025;\n {\n  // raytrace ground to close the horizon, only matters at street level (in bird view buildings occlude everything so it's useless) and traceBuildings needs its own ground for AO\n  float t = plane_trace_z( ray, 0., 1e-6 );\n  if ( 0. < t && t < ct.t && t < /* MAX_DDA_TRACE */640. ) // use a max distance so the infinite plane doesn't extend beyond buildings horizon\n  {\n   pack_info1( ct, t, vec3( ( ray.o + t * ray.d ).xy, 0. ), vec3( 0., 0., 1. ), 1., 0 );\n   pack_info( ct, vec2( 0. ), 0., /* TYPE_ROAD */9. );\n  }\n }\n if ( !/* SHADOW_EARLY_RET */(shadow_trace&&((ct.t)!=/* FLT_MAX */1000000.)) )\n {\n  // assuming highway is at constant height, we can raytrace that too and close a lot of the sdf marching hole at vanishing point\n  float t = plane_trace_z( ray, 2., 1e-6 );\n  if ( 0. < t && t < ct.t && t < /* MAX_HIGHWAY_TRACE */640. )\n  {\n   vec3 p = ray.o + t * ray.d; // hit point\n   if ( evalHighway( p.xy ).d < (1.) )\n   {\n    pack_info1( ct, t, p, vec3( 0., 0., 1. ), 1., 0 );\n    pack_info( ct, vec2( 0. ), 0., /* TYPE_HIGHWAY */8. );\n   }\n  }\n }\n if ( !/* SHADOW_EARLY_RET */(shadow_trace&&((ct.t)!=/* FLT_MAX */1000000.)) ) traceBuildings( ray, ct, split_cells_spacing, shadow_trace );\n if ( !/* SHADOW_EARLY_RET */(shadow_trace&&((ct.t)!=/* FLT_MAX */1000000.)) )\n {\n  // ray marched scene component\n  float t = 0.;\n  bool hit = false;\n  vec3 p, dd;\n  // narrow fov need 200\n  for ( int j = 0; j < 110 /*FORCE_LOOP*/+min(0,iFrame); ++j )\n  {\n   p = ray.o + t * ray.d;\n   dd = sd_RayMarchedCityBits( p, 0 );\n   bool has_hit = abs( dd.x ) <= 0.001 * t; // no need to trace further than first building hit, or ground hit\n   bool too_far = t > /* MAX_HIGHWAY_TRACE */640. || t > ct.t; // hide glitter artifact in the distance, saves some ms too\n   if ( has_hit || too_far )\n   {\n    hit = has_hit;\n    break;\n   }\n   t += dd.x; // *TFRAC\n  }\n  if ( t < ct.t && hit )\n  {\n   ct.p = p;\n   ct.t = t;\n   if ( !shadow_trace ) // doubt it makes a difference, anyway shadow only need t\n   {\n    pack_info( ct, vec2( 0. ), 0., p.z < 0.004 * t ? /* TYPE_ROAD */9. : /* TYPE_HIGHWAY */8. );\n    vec3 h = vec3( 0.01, 0., 0. );\n  //\t\th.x *= t; // grainy normals tweak => but that inflate pavement edges weirdly\n    ct.n = normalize( vec3( sd_RayMarchedCityBits( ct.p + h.xyz, 0 ).x,\n            sd_RayMarchedCityBits( ct.p + h.zxy, 0 ).x,\n            sd_RayMarchedCityBits( ct.p + h.yzx, 0 ).x )\n         - dd.x );\n    {\n     Ray ao_ray = mkray( ct.p, ct.n );\n     { /* ao algo from http://www.iquilezles.org/www/material/nvscene2008/rwwtt.pdf macrofified to avoid repetition */ float _delta = 0.1, _a = 0.0, _b = 1.0; for ( int _i = 0; _i < 5 /*FORCE_LOOP*/+min(0,iFrame); _i++ ) { float _fi = float( _i ); float _ao_t = _delta * _fi;\n      float d = sd_RayMarchedCityBits( ao_ray.o + _ao_t * ao_ray.d, 0 ).x;\n     _a += ( _ao_t - d ) * _b; _b *= 0.5; } ct.ao = max( 1.0 - 1.2 * _a, 0.0 ); }\n    }\n    ct.type = 0;\n    if ( abs( dd.y - dd.x ) < 0.0000007 ) ct.type = 1;\n    if ( abs( dd.z - dd.x ) < 0.0000007 ) ct.type = 2;\n   }\n  }\n }\n ct.ao = min( ct.ao, 1. ); // apparently this goes above 1 and whitens far away pixel... so clamp\n return ct;\n}\nstruct CameraPosAndTangent { vec3 eye; vec2 tangent; };\nstruct CameraRet { vec3 eye; vec3 target; float roll; float pitch; };\nCameraRet init_cam() { CameraRet cam; cam.roll = 0.; cam.pitch = 0.; return cam; }\nmat4 look_around_mouse_control( mat4 camera, float pitch, float tan_half_fovy, float look_at_the_abyss )\n{\n float mouse_ctrl = 1.0;\n vec2 mm_offset = vec2( 0.0, pitch );\n vec2 mm = vec2( 0.0, 0.0 );\n if ( iMouse.z > 0.0 || false ) mm = ( iMouse.xy - iResolution.xy * 0.5 ) / ( min( iResolution.x, iResolution.y ) * 0.5 );\n float mm_y = mm.y;\n mm.x = -mm.x;\n mm = sign( mm ) * pow( abs( mm ), vec2( 0.9 ) );\n mm *= 3.141592654 * tan_half_fovy * mouse_ctrl;\n mm += mm_offset;\n if ( mm_y < 0. )\n {\n  // very special case camera control for getRoofTopCoffeeBreakCamera\n  vec3 v = camera[2].xyz;\n  v.xy = rotate_with_angle( v.xy, mm.x );\n  camera[3].xyz += v * mm.y * look_at_the_abyss;\n }\n return camera * yup_spherical_coords_to_matrix( mm.y, mm.x );\n}\nCameraPosAndTangent getDriveCameraPosAndTangent( float t, float lateral_move_amplitude )\n{\n//\tt -= 200. * iSlider0;\n float x = t * 4.;\n float e = 1e-2;\n vec3 p1 = sd_CameraCurveXY( x );\n vec3 p2 = sd_CameraCurveXY( x + e );\n vec2 tangent = ( p2.xy - p1.xy ) / e;\n CameraPosAndTangent ret;\n ret.eye = p1;\n ret.tangent = tangent;\n ret.eye.xy += lateral_move_amplitude * perp( tangent ) * sin( 2. * 3.141592654 * t / 5. ) * (1.) * 0.5 * abs( tangent.y );\n return ret;\n}\n// we use those for drive camera vibrations\nfloat noise( float x ) { float xi = floor( x ); return mix( hash11( xi ), hash11( xi + 1. ), smoothstep_unchecked( x - xi ) ); }\nfloat noisem11( float x ) { return 2. * ( noise( x ) - 0.5 ); }\nfloat fbm( float x ) { return noisem11( x ) + noisem11( x * 2. ) * 0.5 + noisem11( x * 4. ) * 0.25 + noisem11( x * 8. ) * 0.125; }\nCameraRet getDriveCamera( float t )\n{\n float lateral_move_amplitude = 1.;\n CameraPosAndTangent cam0 = getDriveCameraPosAndTangent( t, lateral_move_amplitude );\n CameraRet cam = init_cam();\n cam.eye = cam0.eye;\n // those 2 evals are for camera acceleration effects and target eval\n CameraPosAndTangent camnext1 = getDriveCameraPosAndTangent( t - 1.0, lateral_move_amplitude );\n CameraPosAndTangent camnext2 = getDriveCameraPosAndTangent( t + 0.5, lateral_move_amplitude );\n {\n  // for road vibrations we must be close enough to road surface\n  float driving_vibrations = max( smoothbump( 2., 4., cam.eye.z ), smoothbump( 0., 4., cam.eye.z ) );\n  cam.eye.xy += driving_vibrations * perp( cam0.tangent ) * fbm( 100. + t * 0.1 ) * 0.3;\n  cam.eye.z += driving_vibrations * fbm( t ) * 0.015; // road roughness\n }\n cam.roll = ( camnext2.tangent.y - camnext1.tangent.y ) * 0.3; // roll\n cam.target = camnext2.eye;\n // drift logic\n float tr = repeat_e( t, 0., 30. );\n cam.target.xy = cam.eye.xy + rotate_with_unit_vector( cam.target.xy - cam.eye.xy, unit_vector2( 3.141592654 * smoothstep( 5., 10., tr ) + // 180 = flying looking backward for a while\n                         3.141592654 * smoothstep( 15., 20., tr ) ) ); // 360 = back to travel direction\n return cam;\n}\nvec3 getStraightFlightCameraPos( float time )\n{\n time += 200.;\n vec2 v = unit_vector2( -time * 0.05 );\n return vec3( v * 100. + 50. * log( 1. + time ), 15. );\n}\nCameraRet getStraightFlightCamera( float t, inout float tan_half_fovy, float duration )\n{\n float u = t / duration;\n t += 8.;\n CameraRet cam = init_cam();\n cam.eye = getStraightFlightCameraPos( t );\n cam.target = getStraightFlightCameraPos( t + 1. );\n cam.target.xy = cam.eye.xy + rotate_with_unit_vector( cam.target.xy - cam.eye.xy, unit_vector2( -3.141592654 * smoothstep( 1., 0., u ) ) );\n tan_half_fovy = 0.5;\n cam.pitch = radians( -20. );\n return cam;\n}\n// get position of a point that travelled at constant speed a long a log spiral, starting from theta0\nvec2 log_spiral( float d, float theta0, float a, float b )\n{\n//\td( theta ) = integral of a * exp( b * theta ) dtheta = ( exp( b * theta ) - exp( b * theta0 ) ) * a / b;\n float theta = log( d * ( b / a ) + exp( b * theta0 ) ) / b;\n return a * exp( b * theta ) * unit_vector2( theta );\n}\nvec3 getRoofTopCoffeeBreakCameraPos( float u )\n{\n vec2 v = log_spiral( (u)*4.3, 0., 1., 1. );\n v -= normalize( v ) * 1.;\n v.xy *= vec2( 0.51, 0.95 );\n return vec3(v.xy,0.) + vec3(593.983276,-76.936417,8.693137); // add start position\n}\n// walk on a roof top and lookup at airliner\nCameraRet getRoofTopCoffeeBreakCamera( float t, inout float tan_half_fovy, float duration, inout float look_at_the_abyss )\n{\n CameraRet cam = init_cam();\n vec3 start_pos = vec3(593.983276,-76.936417,8.693137);\n float u = saturate( t / duration );\n cam.eye = getRoofTopCoffeeBreakCameraPos( u );\n cam.eye.z += ( ( 1. + sin( u * 95. ) ) * 0.5 ) * 0.001; // walk\n float ra = mix( -radians( 1.5 ), 3.141592654 * 1.17, smoothstep( 0.2, 1., u ) );\n cam.target = cam.eye + vec3( unit_vector2( ra ), 0. );\n cam.pitch = smoothbump( u, 0.6, 0.75, 0.82, 1.01 ) * 3.141592654 * 0.5 * 0.75;\n look_at_the_abyss = 0.2 * smoothstep( 0.8, 0.6, u );\n return cam;\n}\n// ( offset x, offset y, angle, time offset )\n//#define LSFC vec4(iSlider2,iSlider3,iSlider4,iSlider5)\nvec3 getLogSpiralCameraFlyPos( float t, inout float pitch )\n{\n float dz = exp_bell( t -15.5, 5. ) * 0.5;\n pitch = radians( -18. );\n pitch -= dz * radians( 3.5 );\n return vec3( vec2( -100. ) + 200. * vec4(0.,0.35,0.2214,0.0928).xy, 8.3 )\n     + vec3( rotate_with_angle( log_spiral( vec4(0.,0.35,0.2214,0.0928).w * 200. + t * 1.2, 0.1, 1., 1. )\n           , -vec4(0.,0.35,0.2214,0.0928).z * 3.141592654 * 2. ), dz * 3. );\n}\n// fly along a log spiral with constant roll\nCameraRet getLogSpiralCameraFly( float t, inout float tan_half_fovy )\n{\n CameraRet cam = init_cam();\n cam.eye = getLogSpiralCameraFlyPos( t, cam.pitch );\n cam.target = getLogSpiralCameraFlyPos( t + 1., cam.pitch );\n cam.roll = radians( 10. );\n tan_half_fovy = 0.53;\n return cam;\n}\n// goes through p1,p2\nvoid catmullrom( out vec3 point, out vec3 derivative, float t, vec3 p0, vec3 p1, vec3 p2, vec3 p3 )\n{\n float t2 = t * t;\n float t3 = t2 * t;\n vec3 a1 = -p0 + p2;\n vec3 a2 = 2. * p0 - 5. * p1 + 4. * p2 - p3;\n vec3 a3 = -p0 + 3. * p1 - 3. * p2 + p3;\n point = 0.5 * ( ( 2. * p1 ) + a1 * t + a2 * t2 + a3 * t3 );\n derivative = 0.5 * ( a1 + a2 * 2. * t + a3 * 3. * t2 ); // whilst we are at it\n}\n// goes through p1,p2,p3\nvoid catmullrom( out vec3 point, out vec3 derivative, float t, vec3 p0, vec3 p1, vec3 p2, vec3 p3, vec3 p4 )\n{\n if ( t < 0.5 ) catmullrom( point, derivative, t * 2., p0, p1, p2, p3 );\n else catmullrom( point, derivative, 2. * ( t - 0.5 ), p1, p2, p3, p4 );\n}\n//#define UTBSC vec2(iSlider0,iSlider1)\n//#define UTBSC vec2(0.585714,0.35)\nCameraRet getUnderTheBridgeStreetCamera( float t, inout float tan_half_fovy, float duration )\n{\n CameraRet cam = init_cam();\n float u = saturate( t / duration );\n vec3 o = vec3( floor( vec2(0.585714,0.707143) /* best*/.x * 100. ) * 80. * 2.,\n       floor( vec2(0.585714,0.707143) /* best*/.y * 100. ) * /* CELL_SIZE */vec3( 8., 8., 100. ).y, 0. );\n vec3 p0 = o + vec3( -80.457870, -10.903438, 0.591591 );\n vec3 p1 = o + vec3( -80.274940, -3.2, 0.517319 );\n vec3 p2 = o + vec3( -79.289925, 2.674706, 1.934119 );\n vec3 p3 = o + vec3( -74.650077819, 3.327467679, 3.193379163 );\n vec3 p4 = o + vec3( -71.289779663, 4.606474399, 3.521366834 );\n vec3 derivative;\n catmullrom( cam.eye, derivative, u, p0, p1, p2, p3, p4 );\n cam.target = cam.eye + derivative;\n cam.pitch = mix( radians( -22. ), 0., u );\n cam.roll = mix( radians( 0. ), radians( -8. ), smoothstep( 0.2, 0.8, u ) );\n return cam;\n}\n//#define IFC vec3(iSlider0,iSlider1,iSlider2)\nCameraRet getIsoFlyCamera( float t, inout float tan_half_fovy, float duration )\n{\n CameraRet cam = init_cam();\n vec2 travel_dir = normalize( vec2( -1.8, 1.4 ) );\n cam.eye = vec3( travel_dir * t * 4., 65. );\n cam.eye += vec3( vec3(0.6,0.62,0.328).x * 200., vec3(0.6,0.62,0.328).y * 200., 0. );\n cam.target = cam.eye + vec3( perp( travel_dir ), 0. );\n cam.pitch = radians( -60. * vec3(0.6,0.62,0.328).z );\n tan_half_fovy = 0.1;\n return cam;\n}\n// get close to a LCD panel that shows the squid invaders things\nCameraRet getLCDScreenCloseUpCamera( float t, inout float tan_half_fovy, float duration )\n{\n CameraRet cam = init_cam();\n cam.eye = vec3( -5.514656066, -0.541317582, 2.770161151 );\n cam.target = cam.eye + vec3( -1., 0., 0. );\n vec3 a = vec3( -6.56, -0.8, 3.3 );\n vec3 b = vec3( -6.56, 0.8, 3.3 );\n cam.eye.x += 1.5;\n cam.eye.z -= 0.5;\n float u = saturate( t / duration );\n vec3 c = mix( a, b, u );\n c.x += 0.8;\n cam.eye = mix( cam.eye, c - vec3( 0., 0., 0.5 ), u );\n cam.target = mix( cam.target, mix( a, b, 0.8 ), pow( u, 2. ) );\n tan_half_fovy = mix( 0.47, 0.4, u );\n return cam;\n}\nmat4 getCamera( inout float tan_half_fovy, inout float fade, inout float a_contrast, vec3 l, inout float time, inout float ground_ao )\n{\n float total = 0.;\n // per camera time range: array of start, duration (yes I am aware of the syntax that pretends we can have arrays)\n vec2 r1 = vec2( total, 41. ); total += r1.y;\n vec2 r2 = vec2( total, 20. ); total += r2.y;\n vec2 r3 = vec2( total, 20. ); total += r3.y;\n vec2 r4 = vec2( total, 8.5 ); total += r4.y;\n vec2 r5 = vec2( total, 12. ); total += r5.y;\n vec2 r6 = vec2( total, 8. ); total += r6.y;\n vec2 r7 = vec2( total, 22. ); total += r7.y;\n time = mod( time, total ); // cycle through all cameras\n//\tvec2 r = r2; // <= select a specific camera to test here\n//\ttime = r.x + mod( time, r.y );\n//  time = r.x + 1.;\n float tr = 0.7; // fade half durations\n fade *= 1. -( max( cosbump( time, 0., tr ), cosbump( time, total, tr )) // those 2 overlap\n     + cosbump( time, r2.x, tr )+ cosbump( time, r3.x, tr )\n     + cosbump( time, r4.x, tr )+ cosbump( time, r5.x, tr )\n     + cosbump( time, r6.x, tr )+ cosbump( time, r7.x, tr ));\n float look_at_the_abyss = 0.;\n CameraRet cam;\n      if ( time < r1.x + r1.y ) { time -= r1.x; cam = getDriveCamera( time ); }\n else if ( time < r2.x + r2.y ) { time -= r2.x; cam = getLogSpiralCameraFly( time, tan_half_fovy ); ground_ao = 0.7; }\n else if ( time < r3.x + r3.y ) { time -= r3.x; cam = getRoofTopCoffeeBreakCamera( time, tan_half_fovy, r3.y, look_at_the_abyss ); ground_ao = 0.375; }\n else if ( time < r4.x + r4.y ) { time -= r4.x; cam = getUnderTheBridgeStreetCamera( time, tan_half_fovy, r4.y ); }\n else if ( time < r5.x + r5.y ) { time -= r5.x; cam = getStraightFlightCamera( time, tan_half_fovy, r5.y ); ground_ao = 0.7; }\n else if ( time < r6.x + r6.y ) { time -= r6.x; cam = getLCDScreenCloseUpCamera( time, tan_half_fovy, r6.y ); }\n else { time -= r7.x; cam = getIsoFlyCamera( time, tan_half_fovy, r7.y ); ground_ao = 0.375; }\n mat4 camera = lookat( cam.eye, cam.target, vec3( 0., 0., 1. ) ) * z_rotation( cam.roll );\n return look_around_mouse_control( camera, cam.pitch, tan_half_fovy, look_at_the_abyss );\n}\n// trace the silhouette of an a350 airliner, alt = 10000 at cruising altitude\nfloat get_airliner( Ray view_ray, float alt, float cruising_speed_fraction, float d, vec2 mv // normalized please\n     , float tan_half_fovy, float time_offset, float direction, float trail_fade, float time )\n{\n//\tcruising_speed_fraction *= 5.; // DEBUG\n float airliner_cruising_speed = cruising_speed_fraction * ( 950000. / ( 60. * 60. ) ); // m/s\n float R1 = 5. * alt * tan_half_fovy; // make all trajectory disks roughly same radius from ground\n float R2 = R1 * 1.4;\n float fade_time = 1.;\n float h1 = sqrt( R1 * R1 - d * d );\n float h2 = sqrt( R2 * R2 - d * d );\n vec2 O = vec2( 0., 0 );\n vec2 c = O + mv * d;\n vec2 travel_direction = perp( mv ) * direction;\n float looptime = 2. * h2 / airliner_cruising_speed;\n float rt = mod( time + time_offset, looptime );\n float u = rt * airliner_cruising_speed;\n vec3 plane_pos = vec3( c + travel_direction * ( u - h2 ), alt );\n float t = plane_trace_z( view_ray, alt, 0. ); // epsilon zero, we don't care it's in the sky\n vec3 it = view_ray.o + view_ray.d * t;\n float dd = length( it.xy );\n float x = dot( it.xy - plane_pos.xy, -travel_direction ) - 47.;\n float y = abs( dot( it.xy - plane_pos.xy, perp( travel_direction ) ) );\n float fade = smoothstep( h2, h1, abs( u - h2 ) );\n float trail_disk_fade = smoothstep( R2, R1, dd );\n // note: y is already symmetrized\n float trail_half_spacing = 9.;\n float dc = exp_decay( x * 0.02 );\n float engine_trail = ( x < 0. ? 0. : smoothstep( 2., -1., abs( y - trail_half_spacing ) - dc * 4. ) )\n // trail distance decay\n  * exp( -x * 0.00175 );\n float trail = engine_trail * fade * trail_disk_fade * trail_fade;\n float debug = 0.;\n vec2 uv = ( it - plane_pos ).xy * ( 20. / 64. ); // plane outline sdf to scale\n if ( length( uv ) > 12. ) return debug + trail + 0.; // outside plane sdf's disk\n return debug + trail + fade * smoothstep( 0.1, -0.1, sd_airliner_a350( rotate_with_unit_vector( uv, vec2( travel_direction.x, -travel_direction.y ) ) ) ); // plane\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n float aspect = iResolution.x / iResolution.y;\n vec2 u = fragCoord.xy / iResolution.xy;\n fragColor.a = 1.;\n float a_contrast = 1.;\n float fade = 1.;\n float ground_ao = 1.; // 1. == no ground ao... a bit of ground ao helps in flight cameras\n vec3 l = normalize( vec3( 0.8, 0.025, 0.125 ) ); // sun direction\n//\tfragColor.rgb = test_sky( fragCoord, l ); return; // contemplate sky probe, for the interested reader\n//\tfragColor.rgb = get_building_palette( fragCoord.xy / min( iResolution.x, iResolution.y ) ); return; // for the curious\n float time = iTime + 20.;\n float tan_half_fovy = 0.6; // fovy 61 deg\n mat4 camera = getCamera( tan_half_fovy, fade, a_contrast, l, time, ground_ao );\n Ray view_ray = get_view_ray( ( u - vec2( 0.5 )) * 2.0, 0.1, aspect, tan_half_fovy );\n view_ray = mkray( camera[3].xyz, ( camera * vec4( view_ray.d, 0.0 )).xyz );\n view_ray.d.z += 1e-5; // divide by zero quick workaround\n // do view ray and shadow ray in a loop in hope to reduce chance of hitting webgl crashes\n Ray r = view_ray;\n TraceCityRetval ct;\n float shadow = 1.;\n for ( int i = 0; i < 2 /*FORCE_LOOP*/+min(0,iFrame) ; ++i )\n {\n  TraceCityRetval ctr = traceCity( r, i == 1 );\n  r = mkray( ctr.p + ctr.n * 0.0025 * ctr.t, l ); // set shadow ray for second pass\n  if ( i == 0 ) ct = ctr;\n  shadow = step( /* FLT_MAX */1000000., ctr.t ); // only relevant at end of second pass\n }\n // unrolling is cleaner than this horrible mess but I wanted the option to try force a loop\n float airliner = 0.;\n for ( int i = 0; i < 3 /*FORCE_LOOP*/+min(0,iFrame); ++i )\n {\n  float airliner_alt = 1000. + (i == 1 ? 4000. : 0.) + (i == 2 ? 500. : 0.);\n  float airliner_cruising_speed_fraction = 0.3 + (i == 1 ? 0.5 : 0.) + (i == 2 ? 0.1 : 0.);\n  float airliner_d = float(2-i) * 500. + (i == 0 ? 1000. : 0.);\n  vec2 mv = (i == 0 ? vec2( 0.707106781, 0.707106781 ) : vec2( 0. )) + (i == 1 ? vec2( 1., 0. ) : vec2( 0. )) + (i == 2 ? vec2( -1., 0. ) : vec2( 0. ));\n  float time_offset = 15. + (i == 1 ? 30. : 0.) + (i == 2 ? 25. : 0.);\n  float direction = (i == 0 ? 1. : -1.);\n  float trail_fade = (i == 2 ? 0.7 : 1.);\n  airliner = max( airliner, get_airliner( view_ray, airliner_alt, airliner_cruising_speed_fraction, airliner_d, mv, tan_half_fovy, time_offset, direction, trail_fade, time ) );\n }\n fragColor.rgb = fade * shadeCity( ct, view_ray.o, view_ray.d, l, shadow, airliner, a_contrast, u, aspect, ground_ao );\n}\n", "name": "Image", "description": "", "type": "image"}]}