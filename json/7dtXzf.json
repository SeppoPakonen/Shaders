{"ver": "0.1", "info": {"id": "7dtXzf", "date": "1633673853", "viewed": 82, "name": "Volume Rendering + Isosurface ", "username": "OSevenC", "description": "Combine Iso Surface with Volume Rendering", "likes": 5, "published": 1, "flags": 0, "usePreview": 0, "tags": [], "requires": ["texture", "volumebuf", "imagebuf"]}, "renderpass": [{"inputs": [{"id": "4sfGRr", "filepath": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "previewfilepath": "/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "type": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "#define LARGE_NUMBER 1e20\n#define MAX_VOLUME_MARCH_STEPS 240//\u5728Volume\u4e2d\u5149\u7ebf\u6b65\u8fdb\u7684\u6700\u5927\u6b21\u6570\n#define MAX_SDF_DETECT_STEPS 15//\u6700\u5927\u63a2\u6d4b\u6b21\u6570\uff0c\u7528\u4e8e\u786e\u5b9a\u7269\u4f53\u8fb9\u754c\n#define MARCH_STRIDE 0.15//\u56fa\u5b9a\u7684\u5149\u7ebf\u6b65\u957f\uff08\u5728Volume\u4e2d\uff09\n#define ABSORPTION_COEFFICIENT 0.5\n#define ABSORPTION_CUTOFF 0.25\n\n#define GAMMA_CORRECT\n#define ANIMATION\n#define BOUNDARY 0.5\n#define VOLUME_RENDERING\n\nvec3[] colors = vec3[](\n    vec3(1., 206. / 255., 1. / 255.),\n    vec3(1., 205. / 255., 51. / 255.),\n    vec3(1., 204. / 255., 102. / 255.),\n    vec3(1., 203. / 255., 153. / 255.),\n    vec3(1., 1., 1.),\n    vec3(204. / 255., 237. / 255., 1.),\n    vec3(153. / 255., 205. / 255., 1.),\n    vec3(101. / 255., 173. / 255., 1.),\n    vec3(50. / 255., 141. / 255., 1.)\n    );\nvec3 GetColor(float v)\n{\n    int iv = int(v  * 9.);\n    return colors[iv];\n}\n\nstruct Box {\n    vec3 Position;\n    vec3 Vertex;\n};\n\nBox mBox = Box(\n    vec3(0, 0, 0),\n    vec3(16.0)\n);\n\nstruct Camera\n{\n    vec3 Position;//\n    vec3 LookAt;\n\n    float ImageHeight;//\u6210\u50cf\u9ad8\u5ea6//\u6839\u636e\u5c4f\u5e55\u957f\u5bbd\u6bd4\u53ef\u6c42\u5bbd\u5ea6\n    float FocalDistance;//\u7126\u8ddd\n};\nCamera mCamera = Camera(\n    vec3(120, 20, -165),\n    vec3(0, 0, 0),\n    2.0,\n    7.0\n);\n\n//https://www.shadertoy.com/view/MlsGW8\nbool IntersectBox(vec3 rayOrigin, vec3 rayDirection, vec3 boxEdgeLength, \n    out float tN, out float tF, out vec3 normal)\n{\n    vec3 m = 1. / rayDirection,\n        k = abs(m) * boxEdgeLength,\n        a = -m * rayOrigin - k * .5,\n        b = a + k;\n    normal = -sign(rayDirection) * step(a.yzx, a.xyz) * step(a.zxy, a.xyz);\n    tN = max(max(a.x, a.y), a.z);\n    tF = min(min(b.x, b.y), b.z);\n    return tN < tF;\n}\n\nvec3 CameraOrbit(float speedRatio)//\u76f8\u673a\u5728\u8f68\u9053\u4e0a\u65cb\u8f6c\n{\n    float theta = iTime * speedRatio;\n    float radius = 165.0;\n\n    return vec3(radius * cos(theta), mCamera.Position.y + 50.0 /** sin(theta*4.0)*/, radius * sin(theta));\n}\n\nvoid SetCamera(in vec2 _uv, in float _aspectRatio, out vec3 _rayOrigin, out vec3 _rayDirection)\n{\n    float ImageWidth = mCamera.ImageHeight * _aspectRatio;\n\n    //vec3 ImagePosition = mCamera.Position;\n    vec3 ImagePosition = CameraOrbit(0.3);\n    vec3 CameraView = mCamera.LookAt - ImagePosition;\n    float ViewLength = length(CameraView);\n    vec3 CameraViewDir = CameraView / ViewLength;\n\n    vec3 CameraRight = cross(CameraViewDir, vec3(0, 1, 0));\n    vec3 CameraUp = cross(CameraRight, CameraViewDir);\n\n    vec3 focalPoint = ImagePosition - mCamera.FocalDistance * CameraViewDir;//\u7126\u70b9\u4f4d\u7f6e\n\n    vec3 ImagePoint = ImagePosition;//\u7528Image\u7684\u4e2d\u5fc3\u70b9\u521d\u59cb\u5316\u6210\u50cf\u70b9\n    //\u6839\u636euv\u5750\u6807\u504f\u79fb\u6210\u50cf\u70b9\n    ImagePoint += CameraRight * (_uv.x * 2.0 - 1.0) * ImageWidth * .5;\n    ImagePoint += CameraUp * (_uv.y * 2.0 - 1.0) * mCamera.ImageHeight * .5;\n\n    _rayOrigin = focalPoint;\n    _rayDirection = normalize(ImagePoint - focalPoint);\n}\n\nvec3 GetAmbientLight()\n{\n    return vec3(0.4);\n}\n\n//https://www.shadertoy.com/view/wssBR8\nfloat BeerLambert(float absorption, float dist)\n{\n    return exp(-absorption * dist);\n}\n\nfloat GetVolumeValue(vec3 pos)\n{\n    float scale = 96.;//32.0*(2.0+sin(iTime));\n    vec3 conner = mBox.Position - mBox.Vertex;\n    float value = texture(iChannel0, (pos - conner) / scale).x;//\u9009\u53d63D\u7eb9\u7406\u7684\u4e00\u90e8\u5206\u8fdb\u884c\u91c7\u6837\n    return value;\n}\n\n//https://www.shadertoy.com/view/MlsGW8\nvec3 GetBoundaryNormal(vec3 ro, vec3 rd, vec3 sz) {\n    vec3 m = 1. / rd,\n        k = abs(m) * sz,\n        a = -m * ro - k * .5, b = a + k;\n    return -sign(rd) * step(a.yzx, a.xyz) * step(a.zxy, a.xyz);\n}\n\n//https://www.shadertoy.com/view/MlsGW8\nvec3 GetNormal(in vec3 p) {\n    vec2 e = vec2(0.5, -0.5);\n    return normalize(\n        e.xyy * GetVolumeValue(p + e.xyy)\n        + e.yyx * GetVolumeValue(p + e.yyx)\n        + e.yxy * GetVolumeValue(p + e.yxy)\n        + e.xxx * GetVolumeValue(p + e.xxx)\n    );\n}\n\n//https://www.shadertoy.com/view/wssBR8\nvec3 Diffuse(in vec3 normal, in vec3 lightVec, in vec3 diffuse)\n{\n    float nDotL = dot(normal, lightVec);\n    return clamp(nDotL * diffuse, 0.0, 1.0);\n}\n\nvoid CalculateLighting(vec3 position, vec3 normal, vec3 reflectionDirection, inout vec3 color)\n{\n    vec3 lightDirection = vec3(-1.0, 1.0, -1.0);//\u65b9\u5411\u5149\n    float lightDistance = length(lightDirection);\n    lightDirection /= lightDistance;//normalize\n\n    vec3 lightColor = vec3(1.0, 1.0, 1.0)*0.5 ;\n    vec3 albedo = color;\n    color *= GetAmbientLight();\n    color += lightColor * pow(max(dot(reflectionDirection, lightDirection), 0.0), 4.0);\n    color += lightColor * Diffuse(normal, lightDirection, albedo);\n    //color += GetAmbientLight() * albedo;\n}\n\nvec3 Render(in vec3 rayOrigin, in vec3 rayDirection)\n{\n    vec3 opaquePosition, opaqueNormal;\n    float opaqueDepth = -1.0;\n    float dMin = -1.0;\n    float dMax = LARGE_NUMBER;\n\n    vec3 volumetricColor = vec3(0.0f);\n    vec3 opaqueColor = vec3(0.0f);\n    float opaqueVisiblity = 1.0f;\n    \n    float boundary = BOUNDARY;\n#ifdef ANIMATION\n    boundary +=0.1*sin(iTime);\n#endif\n\n    if (IntersectBox(rayOrigin, rayDirection, mBox.Vertex * 2., dMin, dMax, opaqueNormal) && dMin > 0.0)\n    {\n        vec3 position = rayOrigin + dMin * rayDirection;\n        float value = GetVolumeValue(position);\n        if (value > boundary)//\u5927\u4e8e\u8fd9\u4e2a\u503c\u7684\u90e8\u5206\u53d8\u6210isosurface\n        {\n            opaqueDepth = dMin;\n            opaquePosition = position;\n            opaqueColor = GetColor(value);\n        }\n        else\n        {\n            float volumeDepth = dMin;\n            for (int i = 0; i < MAX_VOLUME_MARCH_STEPS; i++)\n            {\n                volumeDepth += MARCH_STRIDE;\n                if (volumeDepth > dMax)\n                    break;\n                vec3 position = rayOrigin + volumeDepth * rayDirection;\n\n                float value = GetVolumeValue(position);\n\n                if (value > boundary)//\u5927\u4e8e\u8fd9\u4e2a\u503c\u7684\u90e8\u5206\u53d8\u6210isosurface\n                {\n                    opaqueDepth = volumeDepth;\n                    opaquePosition = position;\n                    opaqueNormal = GetNormal(position);\n                    opaqueColor = GetColor(value);\n                    break;\n                }\n                float lastVisibility = opaqueVisiblity;\n\n                opaqueVisiblity *= BeerLambert(ABSORPTION_COEFFICIENT * value, MARCH_STRIDE);\n\n                float absorbtion = lastVisibility - opaqueVisiblity;\n\n                volumetricColor += value * GetColor(value) * GetAmbientLight() * absorbtion * 5.0;\n\n            }\n        }\n    }\n    if (opaqueDepth > .0 )//&& opaqueVisiblity > ABSORPTION_CUTOFF)\n    {\n        vec3 reflectionDirection = reflect(rayDirection, opaqueNormal);\n\n        CalculateLighting(opaquePosition, opaqueNormal, reflectionDirection, opaqueColor);\n    }\n#ifdef VOLUME_RENDERING\n    return min(volumetricColor, 1.0f) + opaqueVisiblity * opaqueColor;\n#else\n    return opaqueColor;\n#endif\n}\n\n//https://www.shadertoy.com/view/wssBR8\nvec3 GammaCorrect(vec3 color)\n{\n    return pow(color, vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    vec3 rayOrigin, rayDirection;\n\n    SetCamera(\n        uv, aspectRatio, //\u8f93\u5165\n        rayOrigin, rayDirection//\u8f93\u51fa\n    );\n\n    vec3 color = Render(rayOrigin, rayDirection);\n    \n#ifdef GAMMA_CORRECT\n    fragColor = vec4(GammaCorrect(clamp(color, 0.0, 1.0)), 1.0);\n#else\n    fragColor=vec4( color, 1.0 );\n    \n#endif\n}", "name": "Image", "description": "", "type": "image"}]}