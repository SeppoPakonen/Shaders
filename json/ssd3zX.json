{"ver": "0.1", "info": {"id": "ssd3zX", "date": "1630446375", "viewed": 121, "name": "Movable Hyperbolic Tessellation", "username": "diabolix17", "description": "Click to move the origin to any point. You can set COLOR_SCHEME to 0,...,3 and adjust P,Q,R to be any Schwarz triangle, i.e. 1/P + 1/Q + 1/R < 1", "likes": 10, "published": 1, "flags": 32, "usePreview": 0, "tags": [], "requires": ["texture", "imagebuf"]}, "renderpass": [{"inputs": [{"id": "4dXGR8", "filepath": "/media/previz/buffer00.png", "previewfilepath": "/media/previz/buffer00.png", "type": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "// You can change the texture generated by Buffer A to get all kinds of nice patterns\n#define COLOR_SCHEME 3\n\n#define P 2.0\n#define Q 3.0\n#define R 7.0\n\n#define PI 3.141592653\n#define MAX_ITER 100\n\n\n// Complex number functions\nvec2 conj(vec2 a){\n    return vec2(a.x,-a.y);\n}\n\nvec2 comp_mul(vec2 a, vec2 b){\n    return vec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);\n}\n\nvec2 comp_inv(vec2 a){\n    return vec2(a.x, -a.y) / dot(a,a);\n}\n\nvec2 comp_div(vec2 a, vec2 b){\n    return vec2((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y), (a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y));\n}\n\n\n// There is a unique hyperbolic reflection mapping a to the origin (if a != origin). This function applies that reflection to p.\nvec2 map_to_origin(vec2 a, vec2 p){\n    if(a == vec2(0.0)){\n        return p;\n    } else {\n        return comp_div(comp_mul(a, conj(a)-conj(p)), comp_mul(conj(a), comp_mul(a, conj(p)) - vec2(1.0, 0.0)));\n    }\n}\n\nfloat euclidean_line_dist(vec2 p, vec2 a, vec2 b){\n    vec2 n = vec2(-(b-a).y, (b-a).x);\n    return dot(n,p-a);\n}\n\nfloat hyperbolic_line_dist(vec2 p, vec2 a, vec2 b){\n    if(a == vec2(0.0)){\n        return euclidean_line_dist(p,b,vec2(0.0,0.0));\n    }\n    vec2 p2 = map_to_origin(a, p);\n    vec2 b2 = map_to_origin(a, b);\n    return euclidean_line_dist(p2,vec2(0.0,0.0),b2);\n}\n\nvec2 line_intersection(vec2 P1, vec2 d1, vec2 P2, vec2 d2){\n    \n    float det = d2.x*d1.y - d1.x*d2.y;\n    if(det == 0.0){\n        return vec2(0.0);\n    }\n    float det1 = (P2-P1).y*d2.x - d2.y*(P2-P1).x;\n    float l1 = det1 / det;\n    return P1 + l1*d1;\n}\n\n// compute the circle (center and radius) corresponding to the hyperbolic line through a and b\nvec3 hyp_line_circle(vec2 a, vec2 b){\n    vec2 a1 = comp_inv(conj(a));\n    vec2 b1 = comp_inv(conj(b));\n    \n    vec2 p1 = 0.5*(a+a1);\n    vec2 p2 = 0.5*(b+b1);\n    \n    vec2 c = line_intersection(p1,vec2(-a1.y,a1.x),p2,vec2(-b1.y,b1.x));\n    float r = length(a - c);\n    return vec3(c,r);\n}\n\nvec2 circle_inversion(vec2 p, vec2 c, float r){\n    return r*r*comp_inv(conj(p-c)) + c;\n}\n\nvec2 euclidean_reflection(vec2 p, vec2 a, vec2 b){\n    vec2 n = vec2(-(b-a).y, (b-a).x);\n    n = normalize(n);\n    return p - 2.0*dot(p-a,n)*n;\n}\n\nfloat rand(int seed){\n    return fract(sin(float(seed)*12.9898) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 coords = 2.0*uv-vec2(1.0);\n    coords.x *= iResolution.x / iResolution.y;\n\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = 2.0*mouse - vec2(1.0);\n    mouse.x *= iResolution.x / iResolution.y;\n    \n    if(length(mouse) < 1.0){\n        coords = map_to_origin(mouse,coords);\n    }\n\n    if(length(coords) >= 1.0){\n        fragColor = vec4(0.2, 0.2, 0.2, 1.0);\n        return;\n    }\n\n    // compute two side lengths of the fundamental triangle using the hyperbolic law of cosines\n    float s1 = tanh(0.5*acosh((cos(PI/P) + cos(PI/Q)*cos(PI/R)) / (sin(PI/Q)*sin(PI/R))));\n    float s2 = tanh(0.5*acosh((cos(PI/Q) + cos(PI/P)*cos(PI/R)) / (sin(PI/P)*sin(PI/R))));\n    \n    // one vertex of the triangle is always set to be the origin, so that two of the sides are straight lines\n    vec2 a = vec2(0.0, 0.0);\n    vec2 b = vec2(s1, 0.0);\n    mat2 rot = mat2(vec2(cos(PI/R), sin(PI/R)), vec2(-sin(PI/R), cos(PI/R)));\n    vec2 c = rot*vec2(s2, 0.0);\n    \n    bool inside;\n    int iter = 0;\n    \n    vec3 circle = hyp_line_circle(b, c);    \n    \n    // use this to later assign a \"unique\" random color to every triangle\n    int fingerprint = 31;\n    \n    while(true){\n    \n        inside = true;\n\n        if(hyperbolic_line_dist(coords, c,b) <= 0.0){\n            coords = circle_inversion(coords, circle.xy, circle.z);\n            inside = false;\n            iter++;\n            fingerprint *= 5;\n        }\n        \n        \n        if(euclidean_line_dist(coords, c,a) <= 0.0){\n            coords = euclidean_reflection(coords, c,a);\n            inside = false;\n            iter++;\n            fingerprint *= 2;\n        }\n        \n        if(euclidean_line_dist(coords, a,b) <= 0.0){\n            coords = euclidean_reflection(coords, a,b);\n            inside = false;\n            iter++;\n            fingerprint *= 3;\n        }\n        \n      \n        if(inside || iter > MAX_ITER){\n            break;\n        }\n        \n    }\n    \n    if(COLOR_SCHEME == 0){\n        if( euclidean_line_dist(coords, c,a) <= 0.004\n            || euclidean_line_dist(coords, c,a) <= 0.004\n            || hyperbolic_line_dist(coords, c,b) <= 0.004){\n            fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n            return;\n        }\n    \n        fragColor = vec4(1.0);\n        return;\n    }\n    \n    if(COLOR_SCHEME == 1){\n        fragColor = vec4((rand(fingerprint % 137)), (rand(fingerprint % 131)), (rand(fingerprint % 127)), 1.0);\n        return;\n    }\n    \n    if(COLOR_SCHEME == 2){\n        if((iter % 2) == 1){\n            fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n        } else {\n            fragColor = vec4(1.0);\n        }\n        return;\n    }\n    \n    if(COLOR_SCHEME == 3){\n        fragColor = texture(iChannel0, coords);\n        return;\n    }\n    \n}", "name": "Image", "description": "", "type": "image"}, {"inputs": [], "outputs": [{"id": "4dXGR8", "channel": 0}], "code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    uv *= 3.5;\n    \n    fragColor = vec4(0.5,1.0,0.5,1.0);\n    \n    if(length(uv - vec2(0.5, -0.3)) <= 0.58){\n        fragColor = vec4(0.0,0.0,0.0,1.0);\n    }\n    \n    if(length(uv - vec2(0.5, -0.3)) <= 0.54){\n        fragColor = vec4(1.0,0.0,0.0,1.0);\n    }\n    /*\n    if(length(uv - vec2(0.2, 0.5)) <= 0.5){\n        fragColor = vec4(0.0,0.0,1.0,1.0);\n    }\n    */\n    if(length(uv) <= 0.15){\n        fragColor = vec4(1.0, 1.0, 0.0, 1.0);\n    }\n    \n}", "name": "Buffer A", "description": "", "type": "buffer"}]}