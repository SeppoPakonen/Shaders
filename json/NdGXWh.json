{"ver": "0.1", "info": {"id": "NdGXWh", "date": "1634534596", "viewed": 242, "name": "Octree Lightly Styld [Commented]", "username": "Yusef28", "description": "Still fairly barebones. No shadow, ambient occlusion or bump mapping going on here.\nMore issues arose while implementing the lighting so that is explained in comments at the top of the shader.\nBasic Commented version: https://www.shadertoy.com/view/fdyXDR", "likes": 22, "published": 3, "flags": 0, "usePreview": 0, "tags": [], "requires": ["texture", "imagebuf", "texturebuf"]}, "renderpass": [{"inputs": [{"id": "4sXGRn", "filepath": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "type": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "Xsf3Rr", "filepath": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "type": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "//////////////////////////////////////////////////////\n// Simplified Octree By Yusef28\n// Purpose: Demonstrates A simplified Octree Shader Implentation\n// Well commented and fit for some educational purposes\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n/*\n\n//Based on my basic version: https://www.shadertoy.com/view/fdyXDR\n\nNotably, the first octree shaders I stumbled on were from abje\nalthough it seems they are using a different approach.\nHere is the main one: https://www.shadertoy.com/view/4sVfWw\nHere is one with lighting and shadow: https://www.shadertoy.com/view/XdyfRy\n\nMy version is \"stackless\" there is no bidiretional movement\nbetween levels of the tree. We always start at the top and\nwe get spit out somewhere along the way down. \n\nSo for each step in our traversal we have to jump into the tree\nfrom the top again and work down to get the next cell scale factor.\n\nWith a stack and with bidirectional movement I'm guessing\nyou don't have to leave the tree between steps, you just swing\nfrom vine to vine. Not completely sure yet though.\n\n\nIssues I ran into while writing this where I had to just\nuse intuition and play around with things until things worked out\n\nInitially:\nI found the ray origin needed to be shifter by epsilon\nto avoid really bad artifacts\n\nCurrently:\nI found the t value returned from tCalc() need to have epsilon\nadded to it to avoid really bad artifacts\n\nCurrently:\nthe value FAR needs to be atleast 100 or we get some\nweird cloud things that arn't clouds at all.\n\nFixed:\nI needed a way to create a hole where the camera would \nbe with out any octree cells being rendered and\n\nFixed:\nI had to grab the normal backwards to avoid the ray \"catching\"\nmore than one level of cells which was showing up as all the levels\nbeing displayed for some blocks.\n\nso what I do is I step from the position a tiny bit in the ray direction\nso I am inside the box we hit. No confusion this way. Then I need\nto get the normal from inside,  so I pass in negative ray direction\nand calcN will find the closest wall on the way back towards us.\nIt uses that wall as the normal. So I jut flip the sign of the normal \nwhen I return it.\n\nvec3 n = -calcN(pos+rd*0.001, -rd, delta);\n\n\n\n*/\n\n\n#define pi acos(-1.)\n#define eps 1./iResolution.y\n#define MAX_LEVEL 8.\n#define FAR 100.\n\nmat2 rot(float a){\n    float c = cos(a), s = sin(a); return mat2(c,-s,s,c);}\n    \n\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3 = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n\n// SHORTER, NEATER, BRANCHLESS, UNIQUE, SINGULAR PURPOSE\n// This map function returns the largest scaling factor for a given posision\n// the inverse of that is the cell size\nfloat mapQ(vec3 p){\n  float s = 0.5;\n  for(float i = 1.; i < MAX_LEVEL; i++){\n    s *= 2.;\n    \n    //if we don't pass the random check, add max to index so we break\n    i += step( hash13(floor(p * s)), 0.5 ) * MAX_LEVEL;\n  }\n  return s;\n}\n\n\nvec2 rotate2d(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\n\n\n//This get's the distance to the nearest axis [at a given cellsize]\n//This is the main thing and I use it for traversing and for \n//getting the normal\n//The basic idea is well explained in the lodev raycasting tutorial\n//and my version explained in mmy quadtree examples are just\n//a modification of that to allow for traversing different scales.\nvec3 get_t_options(vec3 p, vec3 rd, vec3 delta, float s){\n    \n    vec3 t;\n    \n    t.x = rd.x < 0. ? ((p.x*s - floor(p.x*s))/s)*delta.x\n                    : ((ceil(p.x*s) - p.x*s)/s)*delta.x; \n                    \n    t.y = rd.y < 0. ? ((p.y*s - floor(p.y*s))/s)*delta.y\n                    : ((ceil(p.y*s) - p.y*s)/s)*delta.y; \n    \n    t.z = rd.z < 0. ? ((p.z*s - floor(p.z*s))/s)*delta.z\n                    : ((ceil(p.z*s) - p.z*s)/s)*delta.z; \n    return t;\n}\n\nfloat calcT(vec3 p, vec3 rd, vec3 delta){\n    float s = mapQ(p);\n    vec3 t = get_t_options(p,rd,delta,s);\n\n                    //+0.01 to get rid of a bunch of artifacts\n    return min(t.x,min(t.y,t.z))+0.01/s;\n}\n\nvec3 calcN(vec3 p, vec3 rd, vec3 delta){\n    float s = mapQ(p);\n    vec3 t = get_t_options(p,rd,delta,s);\n    vec3 n;\n             \n    if(t.x<t.y && t.x<t.z) n = vec3(1.,0.,0.)*sign(rd.x);\n    else if(t.y<t.x && t.y<t.z) n = vec3(0.,1.,0.)*sign(rd.y);\n    else n = vec3(0.,0.,1.)*sign(rd.z);\n \n    return n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    vec3 co = vec3(0., iTime/6.,0.);\n    vec3 cd = vec3(0.,0.,1.);\n\n    vec3 up = vec3(0.,1.,0.);\n    vec3 right = normalize(cross(up,cd));\n    up = cross(cd,right);\n    vec3 ro = co;\n    vec3 rd = right*uv.x + up*uv.y + cd;\n    rd = normalize(rd);\n    \n    \n    rd.xz *= rot(iTime/6.);\n    \n\tvec3 delta = 1./max(abs(rd), eps);\n    float t = 0.;\n\n    vec3 pos;\n    for(float i = 0.; i < FAR; i++){\n        pos = ro + rd * t;\n        float ss = mapQ(pos);\n\n        //create the hole / shield so blocks stop\n        //hitting me in the face\n        vec3 shi = abs(floor(pos-ro)) - 1.0;\n        //the hole. Basically a vertical rectangular/square tunnel\n        float hole = max( shi.x, shi.z);\n        \n        //check the hole AND check the random missing squares\n        //if we are out of the hole AND not hitting a missint square\n        //then break!\n        if(hole > 0.001 && hash13(floor((pos)*ss)) > .4) break;\n        \n        //calcT\n        t += calcT(pos, rd, delta);\n    }\n    \n    //calc normal\n    //t += calcT(pos, rd, delta);\n    pos = ro + rd * t;\n    vec3 n = -calcN(pos+rd*0.0001, -rd, delta);\n    vec3 light = co+vec3(0.3);\n    \n    vec3 ld = normalize(light-pos);\n    float diff = max(dot(ld,-n),0.);\n    \n    //This is the scale of the cell in the octree. \n    //No reason it was named sss really.\n    float sss = mapQ(ro+rd*t);\n    \n    //getting an random id for each cell requires knowing it's scale\n    //and throwing the floor of the scaled position into  a hash.\n    float endID = hash13(floor((pos)*sss));\n    //This pallet has become my go to.\n    vec3 cellColor = 0.5+0.5*cos(vec3(1.,2.,4.)/2. + endID*800.);\n    //again to get the fract component of the cell I need to\n    //get the fract of the scaled position. I use abs\n    //so I can cut out squares. And a nice side effect is the texture\n    //calls end up with a sort of converging to center thing.\n    vec3 CF = abs(fract(pos*sss)-0.5)-0.26;\n    \n    //f is a soft border that will simply be shaded darker/lighter\n    //I use the normal to find the components for the texture\n    //which need to be the two components orthonormal to the normal\n    float f = abs(n.x) > 0.5 ? max(CF.y,CF.z) \n            : abs(n.y) > 0.5 ? max(CF.x,CF.z) \n            : max(CF.x,CF.y);\n            \n    float k = smoothstep(0.1,0.4,abs(fract(f*14.)-0.5))/12.;\n    //hackity hack hack\n    f = 1.-f;        \n    f = 1.-smoothstep(0.7,0.9,f);\n    \n    //a hard border that will be gold, based on f\n    float g = smoothstep(0.6,0.64,f);\n    //and perhaps a shador of that border for just underneath?\n    float gshat = smoothstep(0.53,0.64,f);\n    \n    //adjusting specular based on if it's hitting a border which\n    //I want to shine more\n    float spec = pow(max(dot(reflect(-ld,-n), -rd),0.), 2. + (1.-g)*20.);\n    \n    //using the same thing as above, getting the components ortho\n    //to the normal for texture calls.\n    vec3 tex = abs(n.x) > 0.5 ? texture(iChannel0,CF.yz).rgb \n            : abs(n.y) > 0.5 ? texture(iChannel0,CF.xz).rgb \n            : texture(iChannel0,CF.xy).rgb ;\n            \n    vec3 tex2 = abs(n.x) > 0.5 ? texture(iChannel1,CF.yz).rgb \n            : abs(n.y) > 0.5 ? texture(iChannel1,CF.xz).rgb \n            : texture(iChannel1,CF.xy).rgb ;  \n            \n    vec3 rdRefl = reflect(rd, n);\n    //vec3 reflCol = texture(iChannel0,rd).xyz;\n    \n    \n    //adding diffuse lighting with cell color minus f which shades the \n    //outside lightly\n    vec3 col = diff*tex.x*(cellColor+0.2)-f/6.;// + reflCol*0.2;\n    //gshat is the shadow right under the border\n    col = mix(col, vec3(0.), gshat);\n    //g is border, with a texture for a bit more life\n    col = mix(col, vec3(0.8, 0.5, 0.1)/2.-tex2.x/3., g);\n    //add specular at end for the shine\n    col += vec3(.5)*spec + spec*g;// + spec*(k-g/6.)*4.;\n    \n    col += k;//\n    //using the final t to make some fog\n    col = mix(col, vec3(0.), clamp(pow(t/5.,2.), 0., 1.));\n    //hacky gamma correction\n    col = pow(col, vec3(0.7));\n    fragColor = vec4(col,1.);\n}", "name": "Image", "description": "", "type": "image"}]}