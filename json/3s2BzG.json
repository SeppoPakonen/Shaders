{"ver":"0.1","info":{"id":"3s2BzG","date":"1590756482","viewed":343,"name":"Yet another dot matrix webcam","username":"pjkarlik","description":"Dot Matrix / Halftone type video camera - learning mostly, breaking down the screen space and video space took me some time.. want to do multi tap to get circles to overlap...\n\nAlso better at full screen for more pixels!","likes":10,"published":3,"flags":34,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n\tDot Matrix Printer Web Cam\n\tI'm sure this has been done\n\tjust learning how to sample\n\tand chunk up uv space.\n\n\tclick and drag screen door \n\tto see greyscale image.\n\n\ttodo - multi tap so circles\n\tcan overlap..\n*/\n\n#define LOOKUP(COORD) texture(iChannel0,(COORD))\n\n// totally just yanked this curve\n// from the previous shader!\n// https://www.shadertoy.com/view/WdjfDy\nvec2 curve(vec2 uv)\n{\n\tuv = (uv - 0.5) * 2.0;\n\tuv *= 1.1;\t\n\tuv.x *= 1.0 + pow((abs(uv.y) / 5.0), 2.0);\n\tuv.y *= 1.0 + pow((abs(uv.x) / 4.0), 2.0);\n\tuv  = (uv / 2.0) + 0.5;\n\tuv =  uv *0.92 + 0.04;\n\treturn uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\n\tvec2 uv = fragCoord.xy/iResolution.xy;    \n\tuv = curve(uv);\n    vec3 color = LOOKUP(uv).rgb;\n    // effect sample and fade\n    vec3 fgclr = vec3(0.);\n    float f = length(uv  - vec2( .25,0.));\n    fgclr.x = LOOKUP(uv - vec2(f*0.001,.0)).x;\n    fgclr.y = LOOKUP(uv + vec2(f*0.002,.0)).y;\n    fgclr.z = LOOKUP(uv + vec2(f*0.003,.0)).z;\n    // output\n    fragColor = vec4(fgclr,1.);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define PI2 6.28318530718\n#define PI \t3.14159265358\n\n// iChannel1 for video\n// iChannel0 for webcam\n#define video(u,v) texture(iChannel0, vec2(u,v)).rgb\n\n//vec3 colorA = vec3(.9,.4,.1);\n//vec3 colorB = vec3(.9,.2,.1);\n\nvec3 background = vec3(.0);\n\nvec3 colorA = vec3(1.25,.4,.7);\nvec3 colorB = vec3(0.,.8,.9);\n\nconst vec2 pixel = vec2(8.);\nfloat edge = .09;\nfloat threshold = .35;\n\n//@bigWings\nfloat circle(vec2 pt, float r, vec2 center) {\n  vec2 p = pt - center;\n  return 1.-smoothstep(r-edge,r+edge, length(p));\n}\n\nfloat circle(vec2 pt, float r, vec2 center, float lw) {\n  vec2 p = pt - center;\n  float len = length(p);\n  float hlw = lw / 2.;\n  return smoothstep(r-hlw-edge,r-hlw, len)-smoothstep(r+hlw,r+hlw+edge, len);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //id and index for video\n    vec2 id = fragCoord - .5;\n    vec2 cell = vec2( floor(id / pixel)* pixel );\n   \n\t//uv for drawing\n    vec2 uv = vec2(fract(id / pixel));\n    //uv.y += .5*sin(cell.y*.01+iTime*2.);\n    \n    //coors for sample to get base tone\n    vec2 coord = vec2(cell.x/iResolution.x, cell.y/iResolution.y);\n    vec3 videoColor = video(coord.x,coord.y);\n    float colorBase = .3*videoColor.r + .6*videoColor.g + .4*videoColor.b;\n\n    //make led or circle\n    float led; \n    // needs adjusting if you change pixel size? \n    // cant figure the right math...\n    float size = (pixel.x*.034);\n\n    if((colorBase<.48) && id.x > iMouse.x-5.) {\n        led = circle(uv,size,vec2(.5),.01);\n    }else{\n        led = circle(uv,size,vec2(.5));\n    }\n    //color fade\n    vec3 mixColor = mix(colorA,colorB,iResolution.y*.3/id.y) \n        * step(threshold, colorBase);\n    vec3 color = background;\n    color += led * mixColor;\n\n    // screen door - drag mouse to see greyscale\n    float xmouse = iMouse.x-5.;\n    vec3 fgclr = id.x > xmouse ? color : vec3(led)*length(colorBase);\n    if(id.x>xmouse-.001 && id.x<xmouse+.001) fgclr = vec3(1.);\n    \n    // Output to screen\n    fragColor = vec4(fgclr,1.);    \n}","name":"Buffer A","description":"","type":"buffer"}]}