{"ver":"0.1","info":{"id":"WtB3zR","date":"1558189096","viewed":228,"name":"bumpMap experiment","username":"gest","description":"thanks https://www.shadertoy.com/view/ldj3zz","likes":16,"published":1,"flags":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 u_canvas;\nfloat u_time;\nvec3 u_mouse;\n#define textureCube texture\n#define texture2D texture\n\nconst float PI = radians(180.);\nconst float Infinity = 3.402823466e+38;\n\n//\u041a\u0430\u043c\u0435\u0440\u0430\nstruct Camera {\n\t//\u0417\u0430\u0434\u0430\u0432\u0430\u0435\u043c\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b\n\tfloat fov;\n\tfloat aspect;\n\tvec3  origin;\n\tvec3  target;\n\tvec3  up;\n\t//\u0420\u0430\u0441\u0447\u0435\u0442\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b\n\tfloat factor;\n\tvec3  forward;\n\tvec3  right;\n\tvec3  position;\n\tvec3  coord;\n};\n\n//\u0414\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043e\u0431\u044a\u0435\u043a\u0442\u0430\nstruct Object {\n\tfloat   distance;\t//\u041f\u043e\u0441\u043b\u0435\u0434\u043d\u0435\u0435 \u043f\u0440\u0438\u0431\u043b\u0438\u0436\u0435\u043d\u0438\u0435 \u043b\u0443\u0447\u0430 \u043a \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0443 \u0441\u0446\u0435\u043d\u044b (\u0441\u0442\u0440\u0435\u043c\u0438\u0442\u0441\u044f \u043a 0 \u0432 \u0441\u043b\u0443\u0447\u0430\u0435 \u043d\u0430\u0445\u043e\u0436\u0434\u0435\u043d\u0438\u044f \u0442\u043e\u0447\u043a\u0438 \u043f\u0435\u0440\u0435\u0441\u0435\u0447\u0435\u043d\u0438\u044f)\n\tint \tid;\t\t\t//id \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430 \u0441\u0446\u0435\u043d\u044b\n\tvec2\tuv;\n};\n//\u041b\u0443\u0447\nstruct Ray {\n\t//\u0417\u0430\u0434\u0430\u0432\u0430\u0435\u043c\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b\n\tvec3  origin;\t\t//\u041d\u0430\u0447\u0430\u043b\u043e \u043b\u0443\u0447\u0430\n\tvec3  direction;\t//\u041d\u0430\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u043b\u0443\u0447\u0430\n\tfloat near;\t\t\t//\u041c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430\n\tfloat far;\t\t\t//\u041f\u0440\u0435\u0434\u0435\u043b\u044c\u043d\u043e\u0435 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430\n\tfloat epsilon;\t\t//\u0422\u043e\u0447\u043d\u043e\u0441\u0442\u044c\n\tint\t  steps;\t\t//\u041c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u0447\u0438\u0441\u043b\u043e \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0439\n\t//\u0412\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b\n\tfloat distance; \t//\u0420\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0442\u043e\u0447\u043a\u0438 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430 \u0441\u0446\u0435\u043d\u044b \u043e\u0442 ray.origin \u0432 \u043d\u0430\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u0438 ray.direction\n\tvec3  position; \t//\u0422\u0435\u043a\u0443\u0449\u0430\u044f \u0442\u043e\u0447\u043a\u0430 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430 \u0441\u0446\u0435\u043d\u044b ray.origin + ray.direction * ray.distance\n\tbool  hit;\t\t\t//\u0423\u0441\u043f\u0435\u0445 \u043d\u0430\u0445\u043e\u0436\u0434\u0435\u043d\u0438\u044f \u0442\u043e\u0447\u043a\u0438 \u043f\u0435\u0440\u0435\u0441\u0435\u0447\u0435\u043d\u0438\u044f\n\tvec3  normal;\t\t//\u041d\u043e\u0440\u043c\u0430\u043b\u044c \u0432 \u0442\u043e\u0447\u043a\u0435\n\tObject object;\t\t//\u0414\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043e\u0431\u044a\u0435\u043a\u0442\u0430 (\u0444\u043e\u0440\u043c\u0438\u0440\u0443\u044e\u0442\u0441\u044f \u043a\u0430\u0440\u0442\u043e\u0439 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0439)\n};\n//\u0424\u043e\u0440\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u043b\u0443\u0447\u0430 \u043a\u0430\u043c\u0435\u0440\u044b\nRay lookAt (in vec2 uv, inout Camera cam) {\n\t//\u0420\u0430\u0441\u0447\u0435\u0442\u043d\u044b\u0435 \u0445\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u0438\u0441\u0442\u0438\u043a\u0438 \u043a\u0430\u043c\u0435\u0440\u044b\n\tcam.factor \t\t= 1.0/tan(radians(cam.fov/2.));\n\tcam.forward \t= normalize(cam.target-cam.origin); \n\tcam.right \t\t= normalize(cross(cam.up, cam.forward));\n\tcam.up \t\t\t= cross(cam.forward, cam.right);\n\tcam.position \t= cam.origin + cam.factor * cam.forward;\n\tcam.coord \t\t= cam.position + uv.x * cam.right * cam.aspect + uv.y * cam.up;\n\t//\u0424\u043e\u0440\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u043b\u0443\u0447\u0430\n\tRay ray;\n\t{\n\t\tray.origin \t\t= cam.origin;\n\t\tray.direction \t= normalize(cam.coord - cam.origin);\n\t}\n\treturn ray;\n}\n\n/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n*/\n\n//=======================================================================================\nstruct Material {\n\tvec3 \tcolor;\n\tfloat\tambient;\n\tfloat \tdiffuse;\n\tfloat \tspecular;\n\tfloat \tshininess;\n\tvec3 \tcolorEmissive;\n\tfloat \trefractivity;\t\t//0..1\n\tfloat \tindexRefraction;\t//0..1\n\tfloat\tbumpMapSize;\t\t//0..1\n};\nMaterial material_sphere_light \t= Material( vec3(1.0, 1.0, 1.0), 0.0, 0.00, 0.0,  1.0, vec3(1), 0.00, 0.0, 0.0 );\n#if 1\n\tMaterial material_sphere1 \t\t= Material( vec3(0.9, 0.1, 0.1), 0.1, 0.25, 1.0, 20.0, vec3(0), 0.8, 0.9, 0.8 );\n\tMaterial material_sphere2 \t\t= Material( vec3(0.1, 0.1, 0.9), 0.1, 0.25, 1.0, 96.0, vec3(0), 0.8, 0.9, 0.5 );\n\tMaterial material_box1 \t\t\t= Material( vec3(1.0, 1.0, 1.0), 0.1, 0.25, 1.0, 20.0, vec3(0), 0.8, 0.8, 0.7 );\n\tMaterial material_box2 \t\t\t= Material( vec3(1.0, 1.0, 1.0), 0.1, 0.25, 1.0, 20.0, vec3(0), 0.8, 0.9, 0.8 );\n\tMaterial material_cylinder1 \t= Material( vec3(1.0, 1.0, 1.0), 0.1, 0.25, 1.0, 96.0, vec3(0), 0.8, 0.9, 0.8 );\n#else\n\tMaterial material_sphere1 \t\t= Material( vec3(0.9, 0.1, 0.1), 0.5, 1.25, 1.0, 20.0, vec3(0), 0.0, 0.0, 0.8 );\n\tMaterial material_sphere2 \t\t= Material( vec3(0.1, 0.1, 0.9), 0.5, 1.25, 1.0, 20.0, vec3(0), 0.0, 0.0, 0.5 );\n\tMaterial material_box1 \t\t\t= Material( vec3(1.0, 1.0, 1.0), 0.5, 1.25, 1.0, 20.0, vec3(0), 0.0, 0.0, 0.7 );\n\tMaterial material_box2 \t\t\t= Material( vec3(1.0, 1.0, 1.0), 0.5, 1.25, 1.0, 20.0, vec3(0), 0.0, 0.0, 0.8 );\n\tMaterial material_cylinder1 \t= Material( vec3(1.0, 1.0, 1.0), 0.5, 1.25, 1.0, 20.0, vec3(0), 0.0, 0.0, 0.8 );\n#endif\n\nstruct Sphere {\n\tvec3   \tcenter;\n\tfloat  \tradius;\n};\nSphere sphere_light = Sphere ( vec3(0), 0.02);\t\nSphere sphere1 \t\t= Sphere ( vec3(0),  0.4);\nSphere sphere2 \t\t= Sphere ( vec3(0),  0.4);\n\nstruct Box {\n\tvec3\t\tcenter;\n\tvec3\t\tsize;\n};\nBox box1 = Box ( vec3(0), vec3(0.5,0.75,0.5));\nBox box2 = Box ( vec3(0), vec3(0.5,0.75,0.01));    \n\nstruct Cylinder {\n\tvec3  center;\n\tfloat radius;\n\tfloat height;\n};\nCylinder cylinder1 = Cylinder(vec3(0), 0.15, 1.0);\t\n\nstruct Light {\n\tvec3\t\tposition;\n\tvec3\t\tcolor;\n\tfloat \t\tradius; //\u0414\u043b\u044f \u0432\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438\n};\nLight light = Light (vec3(0), vec3(0.9,0.9,0.9), 0.8);\n\n\n//=======================================================================================\nfloat intersectCylinder( in Ray ray, in Cylinder cylinder, out vec3 normal, out vec2 uv ){\n\t//\u0413\u0440\u0430\u043d\u0438\u0446\u044b \u043f\u043e\u0438\u0441\u043a\u0430\n\tfloat t_min = 0.0;\n\tfloat t_max = ray.distance;\n\n\tuv = vec2(0);\n\tnormal = vec3(0);\n\t//\u041f\u0435\u0440\u0435\u0441\u0435\u0447\u0435\u043d\u0438\u0435 \u0441 \u0446\u0438\u043b\u0438\u043d\u0434\u0440\u0438\u0447\u0435\u0441\u043a\u043e\u0439 \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u044c\u044e\n    vec3  ce = vec3( cylinder.center.x, 0.0, cylinder.center.z );\n    vec3  rc = ray.origin - ce;\n    float a = dot( ray.direction.xz, ray.direction.xz );\n    float b = dot( rc.xz, ray.direction.xz );\n    float c = dot( rc.xz, rc.xz ) - cylinder.radius;\n    float h = b*b - a*c;\n    if( h<0.0 ) return ray.far;\n\th = sqrt( h );\n\t//\u0420\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u0438\n\tfloat t1 = (-b - h)/a;\n\tfloat t2 = (-b + h)/a;\n\tfloat t = t1;\n\tbool flag_inside = true;\t//\u0432\u043d\u0443\u0442\u0440\u0438 \n\tif (t<t_min) {\n\t\tt1 = t_min;\n\t\tt = t2;\n\t\tflag_inside = false;\t//\u0441\u043d\u0430\u0440\u0443\u0436\u0438\n\t}\n\tif (t<t_min || t > t_max) return ray.far; \t\t//\u0432\u043d\u0435 \u0434\u0438\u0430\u043f\u0430\u0437\u043e\u043d\u0430\n\tvec3 p1 = ray.origin + t1 * ray.direction;\n\tvec3 p2 = ray.origin + t2 * ray.direction;\n\tif ( abs(p1.y) > cylinder.height && abs(p2.y) > cylinder.height) return ray.far;\n\n\t//\u0417\u0430\u0434\u043d\u044f\u044f \u0441\u0442\u0435\u043d\u043a\u0430\n\tif ( abs(p1.y) > cylinder.height) {\n\t\tflag_inside = false;\n\t\tt = t2;\n\t}\n\t\n\t//\u0422\u043e\u0447\u043a\u0430 \u043f\u0435\u0440\u0435\u0441\u0435\u0447\u0435\u043d\u0438\u044f\n\tvec3 p = ray.origin + t * ray.direction;\n\t//\u041d\u043e\u0440\u043c\u0430\u043b\u044c \u0432 \u0442\u043e\u0447\u043a\u0435 \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u0438\n\tnormal = normalize(vec3(ce.x - p.x, 0., ce.z - p.z)) * (flag_inside ? -1. : 1.);\n\t//normal = normalize(ce - p) * (flag_inside ? -1. : 1.);\n\t//\u041a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b \u0442\u0435\u043a\u0441\u0442\u0443\u0440\u044b\n\tvec3 n = (p - cylinder.center);\n\tuv = vec2 (\n\t\tatan(n.x, n.z) / (2.*PI) + 0.5,\n\t\t(n.y * 0.5 + 0.5)\n\t) * 0.4;\n\n\treturn t;\n}\n\nfloat intersectSphere (in Ray ray, in Sphere sphere, out vec3 normal, out vec2 uv) {\n\t//\u0413\u0440\u0430\u043d\u0438\u0446\u044b \u043f\u043e\u0438\u0441\u043a\u0430\n\tfloat t_min = 0.0;\n\tfloat t_max = ray.distance;\n\t//\u0420\u0430\u0441\u0447\u0435\u0442 \u043f\u0435\u0440\u0435\u0441\u0435\u0447\u0435\u043d\u0438\u0435 \u0441\u043e \u0441\u0444\u0435\u0440\u043e\u0439\n\tvec3 a = ray.origin - sphere.center;\t\t//\u0412\u0435\u043a\u0442\u043e\u0440 \u0438\u0437 \u0446\u0435\u043d\u0442\u0440\u0430 \u0448\u0430\u0440\u0430 \u0432 \u043d\u0430\u0447\u0430\u043b\u043e \u043b\u0443\u0447\u0430\n\tfloat b = dot(a, ray.direction);\n\tfloat c = dot(a, a) - sphere.radius * sphere.radius;\n\tfloat h = b * b - c;\n\tif (h < 0.0) return ray.far; \t\t\t\t//\u043b\u0443\u0447 \u043d\u0435 \u043f\u0435\u0440\u0435\u0441\u0435\u043a\u0430\u0435\u0442 \u0441\u0444\u0435\u0440\u0443\n\th = sqrt(h);\n\tfloat t = -b - h;\n\tbool flag_inside = false; \t\t\t\t\t//\u041b\u0443\u0447 \u0441\u043d\u0430\u0440\u0443\u0436\u0438 \u0441\u0444\u0435\u0440\u044b\n\tif (t < t_min) {\n\t\tt = -b + h;\n\t\tflag_inside = true;\t\t\t\t\t\t//\u041b\u0443\u0447 \u0432\u043d\u0443\u0442\u0440\u0438 \u0441\u0444\u0435\u0440\u044b\n\t}\n\tif (t < t_min || t > t_max) return ray.far; //\u0420\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0448\u0430\u0440\u0430 \u0432\u043d\u0435 \u0433\u0440\u0430\u043d\u0438\u0446 \u043f\u043e\u0438\u0441\u043a\u0430\n\tvec3 p = ray.origin + ray.direction * t;\t//\u0422\u043e\u0447\u043a\u0430 \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u0438\n\t//\u041a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b \u0442\u0435\u043a\u0441\u0442\u0443\u0440\u044b (\u0441\u0444\u0435\u0440\u0438\u0447\u0435\u0441\u043a\u0438\u0435 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b)\n\tvec3 n = p - sphere.center;\n\tuv = vec2(\n\t\tacos(n.y/sphere.radius)/PI,\n\t\t(atan(n.x,n.z)+PI)/(2.*PI)\n\t) * 0.4;\n\t//\u041d\u043e\u0440\u043c\u0430\u043b\u044c \u0432 \u0442\u043e\u0447\u043a\u0435 \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u0438\n\tnormal = normalize(n) * (flag_inside ? -1. : 1.);\n\n\treturn t;\n}\n\nfloat intersectBox (in Ray ray, in Box box, out vec3 normal, out vec2 uv) {\n\t//\u0413\u0440\u0430\u043d\u0438\u0446\u044b \u043f\u043e\u0438\u0441\u043a\u0430\n\tfloat t_min = 0.0;\n\tfloat t_max = ray.distance;\n\t//\u041e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u043c \u0434\u0438\u0441\u0442\u0430\u043d\u0446\u0438\u044e\n\tfor (int i = 0; i < 3; ++i) {\n\t\t//\u0420\u0430\u0441\u0441\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u043c \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u0438 \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043d\u0430 \u043e\u0441\u0438 i\n\t\tfloat t_axis_min = box.center[i] - box.size[i] * 0.5;\n\t\tfloat t_axis_max = t_axis_min + box.size[i];\n\t\t//\u0435\u0441\u043b\u0438 \u043b\u0443\u0447 \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u0435\u043d \u043e\u0441\u0438 i\n\t\tif (abs(ray.direction[i]) < 0.0001) {\n\t\t\t//\u0435\u0441\u043b\u0438 \u043b\u0443\u0447 \u043d\u0435 \u0432\u043d\u0443\u0442\u0440\u0438 - \u043f\u0435\u0440\u0435\u0441\u0435\u0447\u0435\u043d\u0438\u044f \u043d\u0435\u0442\n\t\t\tif (ray.origin[i] < t_axis_min || ray.origin[i] > t_axis_max) return ray.far;\n\t\t} else {\n\t\t\t//\u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0433\u0440\u0430\u043d\u0438\u0446\u044b \u043f\u0435\u0440\u0435\u0440\u0435\u0441\u0435\u0447\u0435\u043d\u0438\u044f \u0441 \u043a\u0430\u0436\u0434\u043e\u0439 \u043e\u0441\u044c\u044e\n\t\t\tfloat t1 = (t_axis_min - ray.origin[i]) / ray.direction[i];\n\t\t\tfloat t2 = (t_axis_max - ray.origin[i]) / ray.direction[i];\n\t\t\t//\u0443\u0431\u0435\u0436\u0434\u0430\u0435\u043c\u0441\u044f \u0447\u0442\u043e min < max\n\t\t\tif (t1 > t2) {\n\t\t\t\tfloat temp = t1;\n\t\t\t\tt1 = t2;\n\t\t\t\tt2 = temp;\n\t\t\t}\n\t\t\t//\u0441\u0443\u0436\u0430\u0435\u043c \u0433\u0440\u0430\u043d\u0438\u0446\u044b \u043f\u043e\u0438\u0441\u043a\u0430\n\t\t\tif(t1 > t_min) t_min = t1;\n\t\t\tif(t2 < t_max) t_max = t2;\n\t\t\tif (t_min > t_max) return ray.far;\t//\u0433\u0440\u0430\u043d\u0438\u0446\u044b \u043f\u043e\u0438\u0441\u043a\u0430 \u043f\u0435\u0440\u0435\u0441\u0435\u043a\u043b\u0438 \u043d\u0443\u043b\u0435\u0432\u0443\u044e \u0434\u0438\u0441\u0442\u0430\u043d\u0446\u0438\u044e\n\t\t}\n\t}\n\t//\u041b\u0443\u0447 \u043f\u0435\u0440\u0435\u0441\u0435\u043a\u0430\u0435\u0442\u0441\u044f\n\tbool flag_inside = (t_min == 0.0); \t\t\t\t//\u041b\u0443\u0447 \u0432\u043d\u0443\u0442\u0440\u0438 \u0438\u043b\u0438 \u0441\u043d\u0430\u0440\u0443\u0436\u0438 \u0441\u0444\u0435\u0440\u044b\n\tfloat t = (flag_inside) ? (t_max) : (t_min);\t//\u0414\u0438\u0441\u0442\u0430\u043d\u0446\u0438\u044f \u0434\u043e \u0442\u043e\u0447\u043a\u0438 \u043f\u0435\u0440\u0435\u0441\u0435\u0447\u0435\u043d\u0438\u044f\n\tvec3 p = ray.origin + ray.direction * t;\t\t//\u0422\u043e\u0447\u043a\u0430 \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u0438\n\t//\u041d\u043e\u0440\u043c\u0430\u043b\u044c \u0432 \u0442\u043e\u0447\u043a\u0435 \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u0438\n\tfloat t_axis = t_max; \t//\u0411\u043b\u0438\u0436\u0430\u0439\u0448\u0430\u044f \u0434\u0438\u0441\u0442\u0430\u043d\u0446\u0438\u044f\n\tint n_axis = 0;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tfloat distFromPos  = abs(box.center[i] - p[i]);\n\t\tfloat distFromEdge = abs(distFromPos - (box.size[i] * 0.5));\n\t\tif (distFromEdge < t_axis) {\n\t\t\tn_axis = i;\n\t\t\tt_axis = distFromEdge;\n\t\t\tnormal = vec3(0);\n\t\t\tnormal[i] = (p[i] < box.center[i]) ? -1.0 : 1.0;\n\t\t}\n\t}\n\tnormal *= (flag_inside ? -1. : 1.);\n\t//\u041a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b \u0442\u0435\u043a\u0441\u0442\u0443\u0440\u044b\n\tvec3 n = p - box.center;\n\tif (n_axis == 0) {\n\t\tuv = vec2 ( n.y, n.z );\n\t} else if (n_axis == 1) {\n\t\tuv = vec2 ( n.x, n.z );\n\t} else if (n_axis == 2) {\n\t\tuv = vec2 ( n.x, n.y );\n\t}\n\tuv *= 0.25;\n\n\treturn t;\t\n}\n\n//=======================================================================================\nvoid rayMarch (inout Ray ray) {\n\t//\u041e\u0442\u0441\u0442\u0443\u043f\n\tray.origin += ray.near * ray.direction;\n\t\n\tray.distance \t= ray.far;\n\tray.normal \t\t= vec3(0);\n\tray.object.uv   = vec2(0);\n\tray.object.id\t= -1;\n\tray.hit \t\t= false;\n\t\n\tfloat d;\n\tvec3 normal;\n\tvec2 uv;\n\t\n\td = intersectSphere(ray, sphere_light, normal, uv);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.normal\t\t= normal;\n\t\tray.object.uv\t= uv;\n\t\tray.object.id\t= 1;\n\t\tray.hit \t\t= true;\n\t}\n\t\n\td = intersectSphere(ray, sphere1, normal, uv);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.normal\t\t= normal;\n\t\tray.object.uv\t= uv;\n\t\tray.object.id\t= 2;\n\t\tray.hit \t\t= true;\n\t}\n\t\n\td = intersectBox(ray, box1, normal, uv);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.normal\t\t= normal;\n\t\tray.object.uv\t= uv;\n\t\tray.object.id\t= 3;\n\t\tray.hit \t\t= true;\n\t}\n\t\n\td = intersectBox(ray, box2, normal, uv);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.normal\t\t= normal;\n\t\tray.object.uv\t= uv;\n\t\tray.object.id\t= 4;\n\t\tray.hit \t\t= true;\n\t}\n\n\td = intersectSphere(ray, sphere2, normal, uv);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.normal\t\t= normal;\n\t\tray.object.uv\t= uv;\n\t\tray.object.id\t= 5;\n\t\tray.hit \t\t= true;\n\t}\n\n\td = intersectCylinder(ray, cylinder1, normal, uv);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.normal\t\t= normal;\n\t\tray.object.uv\t= uv;\n\t\tray.object.id\t= 6;\n\t\tray.hit \t\t= true;\n\t}\n\n\tray.position = ray.origin + ray.direction * ray.distance;\n}\n//\u0414\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u0440\u0435\u043b\u044c\u0435\u0444\u0430\nvoid bumpNormalTexture ( inout Ray ray, in float size, in sampler2D tex, in vec2 texture_size) {\n\tvec3 uaxis = normalize(cross(normalize(abs(ray.direction)), ray.normal));\n\tvec3 vaxis = normalize(cross(uaxis, ray.normal));\n\tmat3 space = mat3( uaxis, vaxis, ray.normal );\n\n\tfloat A = texture2D(tex, ray.object.uv - vec2(0,0) / texture_size).r;\n\tfloat B = texture2D(tex, ray.object.uv - vec2(1,0) / texture_size).r;\n    float C = texture2D(tex, ray.object.uv - vec2(0,1) / texture_size).r;\n\tray.normal = normalize(vec3(B - A, C - A, clamp(1.- size, 0.,1.)));\n\tray.normal = normalize(space * ray.normal);\n}\n//\u041e\u0441\u0432\u0435\u0449\u0435\u043d\u0438\u0435 \u0442\u043e\u0447\u043a\u0438\nvec3 lighting(Ray ray, Light light, Material material) {\n\tvec3 lightDirection = normalize(light.position - ray.position);\n\tvec3 lightDirection_ref = reflect(lightDirection, ray.normal);\n\tfloat diffuse = max(dot(ray.normal, lightDirection), 0.0);\n\tfloat specular = pow(max(dot(ray.direction, lightDirection_ref), 0.0), material.shininess);\n\t\n\tvec3 col = vec3(0);\n\tcol += diffuse * material.diffuse + material.ambient;\n\tcol *= material.color;\n\tcol += specular * material.specular;\n\tcol *= light.color;\n\tcol += material.colorEmissive;\n\treturn col;\n}\n//\u0426\u0432\u0435\u0442 \u0438\u0441\u0442\u043e\u0447\u043d\u0438\u043a\u0430 \u0441\u0432\u0435\u0442\u0430\nvec3  drawLight(vec3 color, Ray ray, Light light){\n    vec3 v = ray.origin - light.position;\n\tvec3 v_proj = dot(v, ray.direction) * ray.direction;\n    float d = length(v - v_proj);\n    if (d < light.radius){\n       \tfloat a = 1.0 - d/light.radius;\n       \tcolor =  mix(color, light.color, pow(a, 4.0));\n    }\n    return color;\n}\n\n\n\nvoid mainImage( out vec4 GL_FragColor, in vec2 GL_FragCoord )\n{\n    u_canvas = iResolution.xy;\n    u_time = iTime;\n    u_mouse = iMouse.xyz;\n    \n    float aspect = u_canvas.x/u_canvas.y;\n    vec2 uv = GL_FragCoord.xy / u_canvas.xy;\n    uv = uv - 0.5;\n\n    //\u041d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432 \u0441\u0446\u0435\u043d\u044b\n    vec2 mouse = u_mouse.xy / u_canvas.xy;\n\n    light.position = vec3(sin(u_time*1.5), sin(u_time*0.5), cos(u_time*1.5));\n    sphere_light.center = light.position;\n    material_sphere_light.colorEmissive = light.color;\n    box1.center = vec3(sin(u_time*1.3),0.0,cos(u_time*1.3));\n    box2.center = vec3(sin(u_time*1.3 + PI),0.0,cos(u_time*1.3 + PI));    \n    sphere1.center = vec3(sin(u_time*1.3 + 3.*PI/2.),0.0,cos(u_time*1.3 + 3.*PI/2.));    \n    sphere2.center = vec3(sin(u_time*1.3 + PI/2.),0.0,cos(u_time*1.3 + PI/2.));    \n\n    Camera cam;\n    {\n        cam.fov     = 45.;\n        cam.aspect  = aspect;\n\n        float angleX = PI + 2.*PI * mouse.x;\n        float angleY = (mouse.y * 3.90) - 0.4;\n        cam.origin  = 4.0 * vec3(\n            sin(angleX)*cos(angleY), \n            sin(angleY), \n            cos(angleX)*cos(angleY)\n        );\n\n        cam.target \t= vec3(0.0, 0.0, 0.0);\n        cam.up \t\t= vec3(0,1,0);\n    }\n\n    Ray ray = lookAt(uv, cam);\n    {\n        ray.near \t= 0.0;\n        ray.far\t\t= 1000.0;\n        ray.epsilon = 0.1;\n        ray.steps\t= 1;\n    }\n    vec3 color = vec3(0);\n    //\u041f\u0440\u0435\u043b\u043e\u043c\u043b\u044f\u044e\u0449\u0430\u044f \u0441\u043f\u043e\u0441\u043e\u0431\u043d\u043e\u0441\u0442\u044c \u043b\u0443\u0447\u0430\n    float refractivity = 1.0;\n    //\u041c\u0430\u043a\u0441\u0438\u043c\u0443\u043c 6 \u043f\u0440\u0435\u043b\u043e\u043c\u043b\u0435\u043d\u0438\u0439 \u043b\u0443\u0447\u0430\n    for (int j = 0; j < 6; ++j) { \n        //\u041f\u043e\u0438\u0441\u043a \u043f\u0435\u0440\u0435\u0441\u0435\u0447\u0435\u043d\u0438\u044f \u043b\u0443\u0447\u0430 \u0441 \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u044c\u044e\n        rayMarch(ray);\n        //\u0412\u044b\u0445\u043e\u0434 \u0435\u0441\u043b\u0438 \u043b\u0443\u0447 \u043d\u0435 \u0434\u043e\u0441\u0442\u0438\u0433 \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u0438\n        if (! ray.hit) {\n            //\u0426\u0432\u0435\u0442 \u0444\u043e\u043d\u0430\n            color += refractivity * textureCube(iChannel3, ray.direction).rgb;\n            break;\n        }\n        //\u041c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u044b \u0438 \u0440\u0435\u043b\u044c\u0435\u0444\n        Material material;\n        if (ray.object.id == 1) {\n            material = material_sphere_light;\n        } else if (ray.object.id == 2) {\n            material = material_sphere1;\n            material.color = material.color * texture2D(iChannel2, ray.object.uv).rgb;\n            bumpNormalTexture(ray, 0.8, iChannel2, iChannelResolution[1].xy);\n        } else if (ray.object.id == 3) {\n            material = material_box1;\n            material.color = material.color * texture2D(iChannel1, ray.object.uv).rgb;\n            bumpNormalTexture(ray, 0.7, iChannel1, iChannelResolution[1].xy);\n        } else if (ray.object.id == 4) {\n            material = material_box2;\n            material.color = material.color * texture2D(iChannel0, ray.object.uv).rgb;\n            bumpNormalTexture(ray, 0.1, iChannel0, iChannelResolution[0].xy);\n        } else if (ray.object.id == 5) {\n            material = material_sphere2;\n            material.color = material.color * texture2D(iChannel1, ray.object.uv).rgb;\n            bumpNormalTexture(ray, 0.0, iChannel0, iChannelResolution[0].xy);\n        } else if (ray.object.id == 6) {\n            material = material_cylinder1;\n            material.color = material.color * texture2D(iChannel2, ray.object.uv).rgb;\n            bumpNormalTexture(ray, 0.8, iChannel2, iChannelResolution[2].xy);\n        }\n        //\u041e\u0441\u0432\u0435\u0449\u0435\u043d\u0438\u0435\n        color += refractivity * lighting(ray, light, material);\t\n        //\u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043f\u0440\u043e\u0434\u043e\u043b\u0436\u0435\u043d\u0438\u044f \u043f\u0440\u0435\u043b\u043e\u043c\u043b\u0435\u043d\u0438\u044f\n        if (material.refractivity == 0.0) break;\t\n        //\u041f\u0440\u0435\u043b\u043e\u043c\u043b\u0435\u043d\u0438\u0435 \u043b\u0443\u0447\u0430\n        {\t\n            ray.origin \t\t= ray.position;\n            ray.direction \t= refract(ray.direction, ray.normal, material.indexRefraction);\n            ray.near\t\t= 0.001; //\u041e\u0442\u0441\u0442\u0443\u043f\n        }\n        //\u0423\u043c\u0435\u043d\u044c\u0448\u0430\u0435\u043c \u043f\u0440\u0435\u043b\u043e\u043c\u043b\u044f\u044e\u0449\u0443\u044e \u0441\u043f\u043e\u0441\u043e\u0431\u043d\u043e\u0441\u0442\u044c \u043b\u0443\u0447\u0430\n        refractivity *= material.refractivity;\n        //\u0412\u044b\u0445\u043e\u0434 \u0435\u0441\u043b\u0438 \u043f\u0440\u0435\u043b\u043e\u043c\u043b\u0435\u043d\u0438\u0435 \u043d\u0435\u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\n        if (refractivity < 0.1) break;\t\n    }\n    //\u0420\u0438\u0441\u0443\u0435\u043c \u0438\u0441\u0442\u043e\u0447\u043d\u0438\u043a \u0441\u0432\u0435\u0442\u0430\n    color = drawLight(color, ray, light);\n\n    GL_FragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 u_canvas;\nfloat u_time;\nvec3 u_mouse;\n#define textureCube texture\n#define texture2D texture\n\nconst float PI = radians(180.);\nconst float Infinity = 3.402823466e+38;\n\n//\u041a\u0430\u043c\u0435\u0440\u0430\nstruct Camera {\n\t//\u0417\u0430\u0434\u0430\u0432\u0430\u0435\u043c\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b\n\tfloat fov;\n\tfloat aspect;\n\tvec3  origin;\n\tvec3  target;\n\tvec3  up;\n\t//\u0420\u0430\u0441\u0447\u0435\u0442\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b\n\tfloat factor;\n\tvec3  forward;\n\tvec3  right;\n\tvec3  position;\n\tvec3  coord;\n};\n\n//\u0414\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043e\u0431\u044a\u0435\u043a\u0442\u0430\nstruct Object {\n\tfloat   distance;\t//\u041f\u043e\u0441\u043b\u0435\u0434\u043d\u0435\u0435 \u043f\u0440\u0438\u0431\u043b\u0438\u0436\u0435\u043d\u0438\u0435 \u043b\u0443\u0447\u0430 \u043a \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0443 \u0441\u0446\u0435\u043d\u044b (\u0441\u0442\u0440\u0435\u043c\u0438\u0442\u0441\u044f \u043a 0 \u0432 \u0441\u043b\u0443\u0447\u0430\u0435 \u043d\u0430\u0445\u043e\u0436\u0434\u0435\u043d\u0438\u044f \u0442\u043e\u0447\u043a\u0438 \u043f\u0435\u0440\u0435\u0441\u0435\u0447\u0435\u043d\u0438\u044f)\n\tint \tid;\t\t\t//id \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430 \u0441\u0446\u0435\u043d\u044b\n\tvec2\tuv;\n};\n//\u041b\u0443\u0447\nstruct Ray {\n\t//\u0417\u0430\u0434\u0430\u0432\u0430\u0435\u043c\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b\n\tvec3  origin;\t\t//\u041d\u0430\u0447\u0430\u043b\u043e \u043b\u0443\u0447\u0430\n\tvec3  direction;\t//\u041d\u0430\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u043b\u0443\u0447\u0430\n\tfloat near;\t\t\t//\u041c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430\n\tfloat far;\t\t\t//\u041f\u0440\u0435\u0434\u0435\u043b\u044c\u043d\u043e\u0435 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430\n\tfloat epsilon;\t\t//\u0422\u043e\u0447\u043d\u043e\u0441\u0442\u044c\n\tint\t  steps;\t\t//\u041c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u0447\u0438\u0441\u043b\u043e \u0438\u0442\u0435\u0440\u0430\u0446\u0438\u0439\n\t//\u0412\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b\n\tfloat distance; \t//\u0420\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0442\u043e\u0447\u043a\u0438 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430 \u0441\u0446\u0435\u043d\u044b \u043e\u0442 ray.origin \u0432 \u043d\u0430\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u0438 ray.direction\n\tvec3  position; \t//\u0422\u0435\u043a\u0443\u0449\u0430\u044f \u0442\u043e\u0447\u043a\u0430 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430 \u0441\u0446\u0435\u043d\u044b ray.origin + ray.direction * ray.distance\n\tbool  hit;\t\t\t//\u0423\u0441\u043f\u0435\u0445 \u043d\u0430\u0445\u043e\u0436\u0434\u0435\u043d\u0438\u044f \u0442\u043e\u0447\u043a\u0438 \u043f\u0435\u0440\u0435\u0441\u0435\u0447\u0435\u043d\u0438\u044f\n\tvec3  normal;\t\t//\u041d\u043e\u0440\u043c\u0430\u043b\u044c \u0432 \u0442\u043e\u0447\u043a\u0435\n\tObject object;\t\t//\u0414\u043e\u043f\u043e\u043b\u043d\u0438\u0442\u0435\u043b\u044c\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u043e\u0431\u044a\u0435\u043a\u0442\u0430 (\u0444\u043e\u0440\u043c\u0438\u0440\u0443\u044e\u0442\u0441\u044f \u043a\u0430\u0440\u0442\u043e\u0439 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0439)\n};\n//\u0424\u043e\u0440\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u043b\u0443\u0447\u0430 \u043a\u0430\u043c\u0435\u0440\u044b\nRay lookAt (in vec2 uv, inout Camera cam) {\n\t//\u0420\u0430\u0441\u0447\u0435\u0442\u043d\u044b\u0435 \u0445\u0430\u0440\u0430\u043a\u0442\u0435\u0440\u0438\u0441\u0442\u0438\u043a\u0438 \u043a\u0430\u043c\u0435\u0440\u044b\n\tcam.factor \t\t= 1.0/tan(radians(cam.fov/2.));\n\tcam.forward \t= normalize(cam.target-cam.origin); \n\tcam.right \t\t= normalize(cross(cam.up, cam.forward));\n\tcam.up \t\t\t= cross(cam.forward, cam.right);\n\tcam.position \t= cam.origin + cam.factor * cam.forward;\n\tcam.coord \t\t= cam.position + uv.x * cam.right * cam.aspect + uv.y * cam.up;\n\t//\u0424\u043e\u0440\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u043b\u0443\u0447\u0430\n\tRay ray;\n\t{\n\t\tray.origin \t\t= cam.origin;\n\t\tray.direction \t= normalize(cam.coord - cam.origin);\n\t}\n\treturn ray;\n}\n\n/*\n  Written by Alan Wolfe\n  http://demofox.org/\n  http://blog.demofox.org/\n*/\n\n//=======================================================================================\nstruct Material {\n\tvec3 \tcolor;\n\tfloat\tambient;\n\tfloat \tdiffuse;\n\tfloat \tspecular;\n\tfloat \tshininess;\n\tvec3 \tcolorEmissive;\n\tfloat \trefractivity;\t\t//0..1\n\tfloat \tindexRefraction;\t//0..1\n};\nMaterial material_sphere_light \t= Material( vec3(1.0, 1.0, 1.0), 0.0, 0.00, 0.0,  1.0, vec3(1), 0.00, 0.0 );\n#if 1\n\tMaterial material_sphere1 \t\t= Material( vec3(0.9, 0.1, 0.1), 0.1, 0.25, 1.0, 20.0, vec3(0), 0.8, 0.9 );\n\tMaterial material_sphere2 \t\t= Material( vec3(0.1, 0.1, 0.9), 0.1, 0.25, 1.0, 96.0, vec3(0), 0.8, 0.9 );\n\tMaterial material_box1 \t\t\t= Material( vec3(1.0, 1.0, 1.0), 0.1, 0.25, 1.0, 20.0, vec3(0), 0.8, 0.8 );\n\tMaterial material_box2 \t\t\t= Material( vec3(1.0, 1.0, 1.0), 0.1, 0.25, 1.0, 20.0, vec3(0), 0.8, 0.9 );\n\tMaterial material_cylinder1 \t= Material( vec3(1.0, 1.0, 1.0), 0.1, 0.25, 1.0, 96.0, vec3(0), 0.8, 0.9 );\n#else\n\tMaterial material_sphere1 \t\t= Material( vec3(0.9, 0.1, 0.1), 0.5, 1.25, 1.0, 20.0, vec3(0), 0.0, 0.0 );\n\tMaterial material_sphere2 \t\t= Material( vec3(0.1, 0.1, 0.9), 0.5, 1.25, 1.0, 20.0, vec3(0), 0.0, 0.0 );\n\tMaterial material_box1 \t\t\t= Material( vec3(1.0, 1.0, 1.0), 0.5, 1.25, 1.0, 20.0, vec3(0), 0.0, 0.0 );\n\tMaterial material_box2 \t\t\t= Material( vec3(1.0, 1.0, 1.0), 0.5, 1.25, 1.0, 20.0, vec3(0), 0.0, 0.0 );\n\tMaterial material_cylinder1 \t= Material( vec3(1.0, 1.0, 1.0), 0.5, 1.25, 1.0, 20.0, vec3(0), 0.0, 0.0 );\n#endif\n\nstruct Sphere {\n\tvec3   \tcenter;\n\tfloat  \tradius;\n};\nSphere sphere_light = Sphere ( vec3(0), 0.02);\t\nSphere sphere1 \t\t= Sphere ( vec3(0),  0.4);\nSphere sphere2 \t\t= Sphere ( vec3(0),  0.4);\n\nstruct Box {\n\tvec3\t\tcenter;\n\tvec3\t\tsize;\n};\nBox box1 = Box ( vec3(0), vec3(0.5,0.75,0.5));\nBox box2 = Box ( vec3(0), vec3(0.5,0.75,0.01));    \n\nstruct Cylinder {\n\tvec3  center;\n\tfloat radius;\n\tfloat height;\n};\nCylinder cylinder1 = Cylinder(vec3(0), 0.15, 1.0);\t\n\nstruct Light {\n\tvec3\t\tposition;\n\tvec3\t\tcolor;\n\tfloat \t\tradius; //\u0414\u043b\u044f \u0432\u0438\u0437\u0443\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438\n};\nLight light = Light (vec3(0), vec3(0.9,0.9,0.9), 0.8);\n\n\n//=======================================================================================\nfloat intersectCylinder( in Ray ray, in Cylinder cylinder, out vec3 normal, out vec2 uv ){\n\t//\u0413\u0440\u0430\u043d\u0438\u0446\u044b \u043f\u043e\u0438\u0441\u043a\u0430\n\tfloat t_min = 0.0;\n\tfloat t_max = ray.distance;\n\n\tuv = vec2(0);\n\tnormal = vec3(0);\n\t//\u041f\u0435\u0440\u0435\u0441\u0435\u0447\u0435\u043d\u0438\u0435 \u0441 \u0446\u0438\u043b\u0438\u043d\u0434\u0440\u0438\u0447\u0435\u0441\u043a\u043e\u0439 \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u044c\u044e\n    vec3  ce = vec3( cylinder.center.x, 0.0, cylinder.center.z );\n    vec3  rc = ray.origin - ce;\n    float a = dot( ray.direction.xz, ray.direction.xz );\n    float b = dot( rc.xz, ray.direction.xz );\n    float c = dot( rc.xz, rc.xz ) - cylinder.radius;\n    float h = b*b - a*c;\n    if( h<0.0 ) return ray.far;\n\th = sqrt( h );\n\t//\u0420\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u0438\n\tfloat t1 = (-b - h)/a;\n\tfloat t2 = (-b + h)/a;\n\tfloat t = t1;\n\tbool flag_inside = true;\t//\u0432\u043d\u0443\u0442\u0440\u0438 \n\tif (t<t_min) {\n\t\tt1 = t_min;\n\t\tt = t2;\n\t\tflag_inside = false;\t//\u0441\u043d\u0430\u0440\u0443\u0436\u0438\n\t}\n\tif (t<t_min || t > t_max) return ray.far; \t\t//\u0432\u043d\u0435 \u0434\u0438\u0430\u043f\u0430\u0437\u043e\u043d\u0430\n\tvec3 p1 = ray.origin + t1 * ray.direction;\n\tvec3 p2 = ray.origin + t2 * ray.direction;\n\tif ( abs(p1.y) > cylinder.height && abs(p2.y) > cylinder.height) return ray.far;\n\n\t//\u0417\u0430\u0434\u043d\u044f\u044f \u0441\u0442\u0435\u043d\u043a\u0430\n\tif ( abs(p1.y) > cylinder.height) {\n\t\tflag_inside = false;\n\t\tt = t2;\n\t}\n\t\n\t//\u0422\u043e\u0447\u043a\u0430 \u043f\u0435\u0440\u0435\u0441\u0435\u0447\u0435\u043d\u0438\u044f\n\tvec3 p = ray.origin + t * ray.direction;\n\t//\u041d\u043e\u0440\u043c\u0430\u043b\u044c \u0432 \u0442\u043e\u0447\u043a\u0435 \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u0438\n\tnormal = normalize(vec3(ce.x - p.x, 0., ce.z - p.z)) * (flag_inside ? -1. : 1.);\n\t//normal = normalize(ce - p) * (flag_inside ? -1. : 1.);\n\t//\u041a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b \u0442\u0435\u043a\u0441\u0442\u0443\u0440\u044b\n\tvec3 n = (p - cylinder.center);\n\tuv = vec2 (\n\t\tatan(n.x, n.z) / (2.*PI) + 0.5,\n\t\t(n.y * 0.5 + 0.5)\n\t) * 0.4;\n\n\treturn t;\n}\n\nfloat intersectSphere (in Ray ray, in Sphere sphere, out vec3 normal, out vec2 uv) {\n\t//\u0413\u0440\u0430\u043d\u0438\u0446\u044b \u043f\u043e\u0438\u0441\u043a\u0430\n\tfloat t_min = 0.0;\n\tfloat t_max = ray.distance;\n\t//\u0420\u0430\u0441\u0447\u0435\u0442 \u043f\u0435\u0440\u0435\u0441\u0435\u0447\u0435\u043d\u0438\u0435 \u0441\u043e \u0441\u0444\u0435\u0440\u043e\u0439\n\tvec3 a = ray.origin - sphere.center;\t\t//\u0412\u0435\u043a\u0442\u043e\u0440 \u0438\u0437 \u0446\u0435\u043d\u0442\u0440\u0430 \u0448\u0430\u0440\u0430 \u0432 \u043d\u0430\u0447\u0430\u043b\u043e \u043b\u0443\u0447\u0430\n\tfloat b = dot(a, ray.direction);\n\tfloat c = dot(a, a) - sphere.radius * sphere.radius;\n\tfloat h = b * b - c;\n\tif (h < 0.0) return ray.far; \t\t\t\t//\u043b\u0443\u0447 \u043d\u0435 \u043f\u0435\u0440\u0435\u0441\u0435\u043a\u0430\u0435\u0442 \u0441\u0444\u0435\u0440\u0443\n\th = sqrt(h);\n\tfloat t = -b - h;\n\tbool flag_inside = false; \t\t\t\t\t//\u041b\u0443\u0447 \u0441\u043d\u0430\u0440\u0443\u0436\u0438 \u0441\u0444\u0435\u0440\u044b\n\tif (t < t_min) {\n\t\tt = -b + h;\n\t\tflag_inside = true;\t\t\t\t\t\t//\u041b\u0443\u0447 \u0432\u043d\u0443\u0442\u0440\u0438 \u0441\u0444\u0435\u0440\u044b\n\t}\n\tif (t < t_min || t > t_max) return ray.far; //\u0420\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0448\u0430\u0440\u0430 \u0432\u043d\u0435 \u0433\u0440\u0430\u043d\u0438\u0446 \u043f\u043e\u0438\u0441\u043a\u0430\n\tvec3 p = ray.origin + ray.direction * t;\t//\u0422\u043e\u0447\u043a\u0430 \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u0438\n\t//\u041a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b \u0442\u0435\u043a\u0441\u0442\u0443\u0440\u044b (\u0441\u0444\u0435\u0440\u0438\u0447\u0435\u0441\u043a\u0438\u0435 \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b)\n\tvec3 n = p - sphere.center;\n\tuv = vec2(\n\t\tacos(n.y/sphere.radius)/PI,\n\t\t(atan(n.x,n.z)+PI)/(2.*PI)\n\t) * 0.4;\n\t//\u041d\u043e\u0440\u043c\u0430\u043b\u044c \u0432 \u0442\u043e\u0447\u043a\u0435 \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u0438\n\tnormal = normalize(n) * (flag_inside ? -1. : 1.);\n\n\treturn t;\n}\n\nfloat intersectBox (in Ray ray, in Box box, out vec3 normal, out vec2 uv) {\n\t//\u0413\u0440\u0430\u043d\u0438\u0446\u044b \u043f\u043e\u0438\u0441\u043a\u0430\n\tfloat t_min = 0.0;\n\tfloat t_max = ray.distance;\n\t//\u041e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0435\u043c \u0434\u0438\u0441\u0442\u0430\u043d\u0446\u0438\u044e\n\tfor (int i = 0; i < 3; ++i) {\n\t\t//\u0420\u0430\u0441\u0441\u0447\u0438\u0442\u044b\u0432\u0430\u0435\u043c \u043c\u0438\u043d\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u0438 \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043d\u0430 \u043e\u0441\u0438 i\n\t\tfloat t_axis_min = box.center[i] - box.size[i] * 0.5;\n\t\tfloat t_axis_max = t_axis_min + box.size[i];\n\t\t//\u0435\u0441\u043b\u0438 \u043b\u0443\u0447 \u043f\u0430\u0440\u0430\u043b\u043b\u0435\u043b\u0435\u043d \u043e\u0441\u0438 i\n\t\tif (abs(ray.direction[i]) < 0.0001) {\n\t\t\t//\u0435\u0441\u043b\u0438 \u043b\u0443\u0447 \u043d\u0435 \u0432\u043d\u0443\u0442\u0440\u0438 - \u043f\u0435\u0440\u0435\u0441\u0435\u0447\u0435\u043d\u0438\u044f \u043d\u0435\u0442\n\t\t\tif (ray.origin[i] < t_axis_min || ray.origin[i] > t_axis_max) return ray.far;\n\t\t} else {\n\t\t\t//\u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0433\u0440\u0430\u043d\u0438\u0446\u044b \u043f\u0435\u0440\u0435\u0440\u0435\u0441\u0435\u0447\u0435\u043d\u0438\u044f \u0441 \u043a\u0430\u0436\u0434\u043e\u0439 \u043e\u0441\u044c\u044e\n\t\t\tfloat t1 = (t_axis_min - ray.origin[i]) / ray.direction[i];\n\t\t\tfloat t2 = (t_axis_max - ray.origin[i]) / ray.direction[i];\n\t\t\t//\u0443\u0431\u0435\u0436\u0434\u0430\u0435\u043c\u0441\u044f \u0447\u0442\u043e min < max\n\t\t\tif (t1 > t2) {\n\t\t\t\tfloat temp = t1;\n\t\t\t\tt1 = t2;\n\t\t\t\tt2 = temp;\n\t\t\t}\n\t\t\t//\u0441\u0443\u0436\u0430\u0435\u043c \u0433\u0440\u0430\u043d\u0438\u0446\u044b \u043f\u043e\u0438\u0441\u043a\u0430\n\t\t\tif(t1 > t_min) t_min = t1;\n\t\t\tif(t2 < t_max) t_max = t2;\n\t\t\tif (t_min > t_max) return ray.far;\t//\u0433\u0440\u0430\u043d\u0438\u0446\u044b \u043f\u043e\u0438\u0441\u043a\u0430 \u043f\u0435\u0440\u0435\u0441\u0435\u043a\u043b\u0438 \u043d\u0443\u043b\u0435\u0432\u0443\u044e \u0434\u0438\u0441\u0442\u0430\u043d\u0446\u0438\u044e\n\t\t}\n\t}\n\t//\u041b\u0443\u0447 \u043f\u0435\u0440\u0435\u0441\u0435\u043a\u0430\u0435\u0442\u0441\u044f\n\tbool flag_inside = (t_min == 0.0); \t\t\t\t//\u041b\u0443\u0447 \u0432\u043d\u0443\u0442\u0440\u0438 \u0438\u043b\u0438 \u0441\u043d\u0430\u0440\u0443\u0436\u0438 \u0441\u0444\u0435\u0440\u044b\n\tfloat t = (flag_inside) ? (t_max) : (t_min);\t//\u0414\u0438\u0441\u0442\u0430\u043d\u0446\u0438\u044f \u0434\u043e \u0442\u043e\u0447\u043a\u0438 \u043f\u0435\u0440\u0435\u0441\u0435\u0447\u0435\u043d\u0438\u044f\n\tvec3 p = ray.origin + ray.direction * t;\t\t//\u0422\u043e\u0447\u043a\u0430 \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u0438\n\t//\u041d\u043e\u0440\u043c\u0430\u043b\u044c \u0432 \u0442\u043e\u0447\u043a\u0435 \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u0438\n\tfloat t_axis = t_max; \t//\u0411\u043b\u0438\u0436\u0430\u0439\u0448\u0430\u044f \u0434\u0438\u0441\u0442\u0430\u043d\u0446\u0438\u044f\n\tint n_axis = 0;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tfloat distFromPos  = abs(box.center[i] - p[i]);\n\t\tfloat distFromEdge = abs(distFromPos - (box.size[i] * 0.5));\n\t\tif (distFromEdge < t_axis) {\n\t\t\tn_axis = i;\n\t\t\tt_axis = distFromEdge;\n\t\t\tnormal = vec3(0);\n\t\t\tnormal[i] = (p[i] < box.center[i]) ? -1.0 : 1.0;\n\t\t}\n\t}\n\tnormal *= (flag_inside ? -1. : 1.);\n\t//\u041a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b \u0442\u0435\u043a\u0441\u0442\u0443\u0440\u044b\n\tvec3 n = p - box.center;\n\tif (n_axis == 0) {\n\t\tuv = vec2 ( n.y, n.z );\n\t} else if (n_axis == 1) {\n\t\tuv = vec2 ( n.x, n.z );\n\t} else if (n_axis == 2) {\n\t\tuv = vec2 ( n.x, n.y );\n\t}\n\tuv *= 0.25;\n\n\treturn t;\t\n}\n\n//=======================================================================================\nvoid rayMarch (inout Ray ray) {\n\t//\u041e\u0442\u0441\u0442\u0443\u043f\n\tray.origin += ray.near * ray.direction;\n\t\n\tray.distance \t= ray.far;\n\tray.normal \t\t= vec3(0);\n\tray.object.uv   = vec2(0);\n\tray.object.id\t= -1;\n\tray.hit \t\t= false;\n\t\n\tfloat d;\n\tvec3 normal;\n\tvec2 uv;\n\t\n\td = intersectSphere(ray, sphere_light, normal, uv);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.normal\t\t= normal;\n\t\tray.object.uv\t= uv;\n\t\tray.object.id\t= 1;\n\t\tray.hit \t\t= true;\n\t}\n\t\n\td = intersectSphere(ray, sphere1, normal, uv);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.normal\t\t= normal;\n\t\tray.object.uv\t= uv;\n\t\tray.object.id\t= 2;\n\t\tray.hit \t\t= true;\n\t}\n\t\n\td = intersectBox(ray, box1, normal, uv);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.normal\t\t= normal;\n\t\tray.object.uv\t= uv;\n\t\tray.object.id\t= 3;\n\t\tray.hit \t\t= true;\n\t}\n\t\n\td = intersectBox(ray, box2, normal, uv);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.normal\t\t= normal;\n\t\tray.object.uv\t= uv;\n\t\tray.object.id\t= 4;\n\t\tray.hit \t\t= true;\n\t}\n\n\td = intersectSphere(ray, sphere2, normal, uv);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.normal\t\t= normal;\n\t\tray.object.uv\t= uv;\n\t\tray.object.id\t= 5;\n\t\tray.hit \t\t= true;\n\t}\n\n\td = intersectCylinder(ray, cylinder1, normal, uv);\n\tif (ray.distance > d) {\n\t\tray.distance \t= d;\n\t\tray.normal\t\t= normal;\n\t\tray.object.uv\t= uv;\n\t\tray.object.id\t= 6;\n\t\tray.hit \t\t= true;\n\t}\n\n\tray.position = ray.origin + ray.direction * ray.distance;\n}\n//\u0414\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u0440\u0435\u043b\u044c\u0435\u0444\u0430\nvoid bumpNormalTexture ( inout Ray ray, in float size, in sampler2D tex, in vec2 texture_size) {\n\tvec3 uaxis = normalize(cross(normalize(abs(ray.direction)), ray.normal));\n\tvec3 vaxis = normalize(cross(uaxis, ray.normal));\n\tmat3 space = mat3( uaxis, vaxis, ray.normal );\n\n\tfloat A = texture2D(tex, ray.object.uv - vec2(0,0) / texture_size).r;\n\tfloat B = texture2D(tex, ray.object.uv - vec2(1,0) / texture_size).r;\n    float C = texture2D(tex, ray.object.uv - vec2(0,1) / texture_size).r;\n\tray.normal = normalize(vec3(B - A, C - A, clamp(1.- size, 0.,1.)));\n\tray.normal = normalize(space * ray.normal);\n}\n//\u041e\u0441\u0432\u0435\u0449\u0435\u043d\u0438\u0435 \u0442\u043e\u0447\u043a\u0438\nvec3 lighting(Ray ray, Light light, Material material) {\n\tvec3 lightDirection = normalize(light.position - ray.position);\n\tvec3 lightDirection_ref = reflect(lightDirection, ray.normal);\n\tfloat diffuse = max(dot(ray.normal, lightDirection), 0.0);\n\tfloat specular = pow(max(dot(ray.direction, lightDirection_ref), 0.0), material.shininess);\n\t\n\tvec3 col = vec3(0);\n\tcol += diffuse * material.diffuse + material.ambient;\n\tcol *= material.color;\n\tcol += specular * material.specular;\n\tcol *= light.color;\n\tcol += material.colorEmissive;\n\treturn col;\n}\n//\u0426\u0432\u0435\u0442 \u0438\u0441\u0442\u043e\u0447\u043d\u0438\u043a\u0430 \u0441\u0432\u0435\u0442\u0430\nvec3  drawLight(vec3 color, Ray ray, Light light){\n    vec3 v = ray.origin - light.position;\n\tvec3 v_proj = dot(v, ray.direction) * ray.direction;\n    float d = length(v - v_proj);\n    if (d < light.radius){\n       \tfloat a = 1.0 - d/light.radius;\n       \tcolor =  mix(color, light.color, pow(a, 4.0));\n    }\n    return color;\n}\n\n\n\nvoid mainImage( out vec4 GL_FragColor, in vec2 GL_FragCoord )\n{\n    u_canvas = iResolution.xy;\n    u_time = iTime;\n    u_mouse = iMouse.xyz;\n    \n    float aspect = u_canvas.x/u_canvas.y;\n    vec2 uv = GL_FragCoord.xy / u_canvas.xy;\n    uv = uv - 0.5;\n\n    //\u041d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 \u043e\u0431\u044a\u0435\u043a\u0442\u043e\u0432 \u0441\u0446\u0435\u043d\u044b\n    vec2 mouse = u_mouse.xy / u_canvas.xy;\n\n    light.position = vec3(sin(u_time*1.5), sin(u_time*0.5), cos(u_time*1.5));\n    sphere_light.center = light.position;\n    material_sphere_light.colorEmissive = light.color;\n    box1.center = vec3(sin(u_time*1.3),0.0,cos(u_time*1.3));\n    box2.center = vec3(sin(u_time*1.3 + PI),0.0,cos(u_time*1.3 + PI));    \n    sphere1.center = vec3(sin(u_time*1.3 + 3.*PI/2.),0.0,cos(u_time*1.3 + 3.*PI/2.));    \n    sphere2.center = vec3(sin(u_time*1.3 + PI/2.),0.0,cos(u_time*1.3 + PI/2.));    \n\n    Camera cam;\n    {\n        cam.fov     = 45.;\n        cam.aspect  = aspect;\n\n        float angleX = PI + 2.*PI * mouse.x;\n        float angleY = (mouse.y * 3.90) - 0.4;\n        cam.origin  = 4.0 * vec3(\n            sin(angleX)*cos(angleY), \n            sin(angleY), \n            cos(angleX)*cos(angleY)\n        );\n\n        cam.target \t= vec3(0.0, 0.0, 0.0);\n        cam.up \t\t= vec3(0,1,0);\n    }\n\n    Ray ray = lookAt(uv, cam);\n    {\n        ray.near \t= 0.0;\n        ray.far\t\t= 1000.0;\n        ray.epsilon = 0.1;\n        ray.steps\t= 1;\n    }\n    vec3 color = vec3(0);\n    //\u041f\u0440\u0435\u043b\u043e\u043c\u043b\u044f\u044e\u0449\u0430\u044f \u0441\u043f\u043e\u0441\u043e\u0431\u043d\u043e\u0441\u0442\u044c \u043b\u0443\u0447\u0430\n    float refractivity = 1.0;\n    //\u041c\u0430\u043a\u0441\u0438\u043c\u0443\u043c 6 \u043f\u0440\u0435\u043b\u043e\u043c\u043b\u0435\u043d\u0438\u0439 \u043b\u0443\u0447\u0430\n    for (int j = 0; j < 6; ++j) { \n        //\u041f\u043e\u0438\u0441\u043a \u043f\u0435\u0440\u0435\u0441\u0435\u0447\u0435\u043d\u0438\u044f \u043b\u0443\u0447\u0430 \u0441 \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u044c\u044e\n        rayMarch(ray);\n        //\u0412\u044b\u0445\u043e\u0434 \u0435\u0441\u043b\u0438 \u043b\u0443\u0447 \u043d\u0435 \u0434\u043e\u0441\u0442\u0438\u0433 \u043f\u043e\u0432\u0435\u0440\u0445\u043d\u043e\u0441\u0442\u0438\n        if (! ray.hit) {\n            //\u0426\u0432\u0435\u0442 \u0444\u043e\u043d\u0430\n            color += refractivity * textureCube(iChannel3, ray.direction).rgb;\n            break;\n        }\n        //\u041c\u0430\u0442\u0435\u0440\u0438\u0430\u043b\u044b \u0438 \u0440\u0435\u043b\u044c\u0435\u0444\n        Material material;\n        if (ray.object.id == 1) {\n            material = material_sphere_light;\n        } else if (ray.object.id == 2) {\n            material = material_sphere1;\n            material.color = material.color * texture2D(iChannel2, ray.object.uv).rgb;\n            bumpNormalTexture(ray, 0.8, iChannel2, iChannelResolution[1].xy);\n        } else if (ray.object.id == 3) {\n            material = material_box1;\n            material.color = material.color * texture2D(iChannel1, ray.object.uv).rgb;\n            bumpNormalTexture(ray, 0.7, iChannel1, iChannelResolution[1].xy);\n        } else if (ray.object.id == 4) {\n            material = material_box2;\n            material.color = material.color * texture2D(iChannel0, ray.object.uv).rgb;\n            bumpNormalTexture(ray, 0.1, iChannel0, iChannelResolution[0].xy);\n        } else if (ray.object.id == 5) {\n            material = material_sphere2;\n            material.color = material.color * texture2D(iChannel1, ray.object.uv).rgb;\n            bumpNormalTexture(ray, 0.0, iChannel0, iChannelResolution[0].xy);\n        } else if (ray.object.id == 6) {\n            material = material_cylinder1;\n            material.color = material.color * texture2D(iChannel2, ray.object.uv).rgb;\n            bumpNormalTexture(ray, 0.8, iChannel2, iChannelResolution[2].xy);\n        }\n        //\u041e\u0441\u0432\u0435\u0449\u0435\u043d\u0438\u0435\n        color += refractivity * lighting(ray, light, material);\t\n        //\u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043f\u0440\u043e\u0434\u043e\u043b\u0436\u0435\u043d\u0438\u044f \u043f\u0440\u0435\u043b\u043e\u043c\u043b\u0435\u043d\u0438\u044f\n        if (material.refractivity == 0.0) break;\t\n        //\u041f\u0440\u0435\u043b\u043e\u043c\u043b\u0435\u043d\u0438\u0435 \u043b\u0443\u0447\u0430\n        {\t\n            ray.origin \t\t= ray.position;\n            ray.direction \t= refract(ray.direction, ray.normal, material.indexRefraction);\n            ray.near\t\t= 0.001; //\u041e\u0442\u0441\u0442\u0443\u043f\n        }\n        //\u0423\u043c\u0435\u043d\u044c\u0448\u0430\u0435\u043c \u043f\u0440\u0435\u043b\u043e\u043c\u043b\u044f\u044e\u0449\u0443\u044e \u0441\u043f\u043e\u0441\u043e\u0431\u043d\u043e\u0441\u0442\u044c \u043b\u0443\u0447\u0430\n        refractivity *= material.refractivity;\n        //\u0412\u044b\u0445\u043e\u0434 \u0435\u0441\u043b\u0438 \u043f\u0440\u0435\u043b\u043e\u043c\u043b\u0435\u043d\u0438\u0435 \u043d\u0435\u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\n        if (refractivity < 0.1) break;\t\n    }\n    //\u0420\u0438\u0441\u0443\u0435\u043c \u0438\u0441\u0442\u043e\u0447\u043d\u0438\u043a \u0441\u0432\u0435\u0442\u0430\n    color = drawLight(color, ray, light);\n\n    GL_FragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}