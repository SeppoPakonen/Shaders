{"ver":"0.1","info":{"id":"wslyzj","date":"1585177107","viewed":168,"name":"Demonstrating Cel Shading","username":"DoubleRedGaming","description":"Cel shading and it's simplicity in design.\n\nCel shading or toon shading is a type of non-photorealistic rendering designed to make 3-D computer graphics appear to be flat by using less shading color instead of a shade gradient or tints and shades.","likes":7,"published":3,"flags":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0.0, 1.0);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p-c)-r;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    //t = clamp(t, 0.0, 1.0);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-0.5)-0.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n    return e+i;\n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s) {\n    return length(max(abs(p)-s, 0.0));\n}\n\nfloat GetDist(vec3 p) {\n    float pd = p.y;\n    \n    vec3 bp1 = p-vec3(5, 1.5, 0.0);\n    vec3 bp2 = p-vec3(4, 1.5, 0.0);\n    vec3 bp3 = p-vec3(0, 1.5, 0.0);\n    vec3 bp4 = p-vec3(-4.5, 1.5, 0.0);\n    bp1.yz *= Rot(iTime*3.141*0.5);\n    bp2.yz *= Rot((iTime*3.141*0.5)+(3.141*0.5));\n    bp3.xz *= Rot((-iTime*3.141*0.125));\n    \n    float bd1 = sdTorus(bp1, vec2(1, 0.5));\n    float bd2 = sdTorus(bp2, vec2(1, 0.5));\n    float bd3 = dBox(bp3, vec3(1.0, 0.5, 1.0));\n    float bd4 = sdCapsule(bp4, vec3(1.5, sin(iTime*3.141*0.25), 2.0), vec3(0.5, cos(iTime*3.141*0.25), -2.0), 0.5);\n    float d = min(bd1, bd2);\n    d = min(d, bd3);\n    d = min(d, bd4);\n    d = min(d, pd);\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p);\n    vec2 e = vec2(0.01, 0.0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx)\n    );\n    \n    return normalize(n);\n}\n\nvec4 GetLight(vec3 p) { //This is probably the most important part about Cel shading\n    vec3 lightPos[3];\n    lightPos[0] = vec3(5, 6, 0);\n    lightPos[1] = vec3(-2, 7, 1);\n    lightPos[2] = vec3(-4, 10, 10);\n    \n    vec3 lightCol[3];\n    lightCol[0] = vec3(0.3, 0.2, 0.05);\n    lightCol[1] = vec3(0.4, 0.2, 0.2);\n    lightCol[2] = vec3(0.1, 0.1, 0.2);\n    \n    vec4 col = vec4(0.0);\n    \n    for(int i; i<3; i++) {\n        vec3 l = normalize(lightPos[i]-p);\n        vec3 n = GetNormal(p);\n        \n        float dif = clamp(dot(n, l), 0.0, 1.0);\n        float d = RayMarch(p+n*SURF_DIST*2.0, l);\n        if(d<length(lightPos[i]-p)) dif *= 0.1;\n        \n        col += floor(dif+0.5)*vec4(lightCol[i], 1.0); //This rounds the lighting value, so it really looks flat.\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-(0.5*iResolution.xy))/iResolution.y;\n    vec4 col = vec4(0);\n    \n    vec3 ro = vec3(0.0, 6.0, -10.0);\n    vec3 rd = normalize(vec3(vec2(uv.x, uv.y-0.46)*Rot(3.141*sin(iTime*3.141*0.2)*0.01), 1.0));\n    \n    ro.zx *= Rot((iTime*3.141*0.125)+3.141); //Origin rotation\n    \n    rd.zy *= Rot(sin(-iTime*3.141*0.5)*3.141*0.01); //Direction rotation, this line makes the camera go up and down\n    rd.zx *= Rot((iTime*3.141*0.125)+3.141); //This one makes the camera rotate along the center\n    \n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    vec4 dif = GetLight(p);\n    dif *= (1.0/d)*8.0; //Multiply some smoothness to the lighting, semi shading, just a distance modifier\n    col = dif;\n    col += (d*0.007*vec4(0.1, 0.56, 0.8, 0.0)); //Add a little lovely fog effect in the background\n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}