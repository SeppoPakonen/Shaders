{"ver": "0.1", "info": {"id": "wdXfRS", "date": "1589195782", "viewed": 94, "name": "simple atmosphere", "username": "w450468524", "description": "implement atmosphere scattering effect", "likes": 0, "published": 1, "flags": 0, "tags": ["mograph"], "requires": ["imagebuf"]}, "renderpass": [{"inputs": [], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "const float g_earthRadius=6360000.0;\nconst float g_atmosphereRadius = 6520000.0;\nconst float MAX = 1000000000.0;\n\nvec2 rayIntersectSphere( vec3 eye, vec3 dir, float r ) {\n\tfloat b = dot(eye, dir);\n    float ac = dot(eye, eye) - r * r;\n    float delta = b * b - ac;\n    if(delta < 0.0)\n        return vec2(MAX, -MAX);\n    delta = sqrt(delta);\n    return vec2(-b - delta, -b + delta);\n}\n\n/////////////////////////////////////\n// generate ray of a fragment\nconst float PI = 3.1415926535897932;\nconst float fov = PI / 2.0;\nconst float near = 1000.0;\n\nvec3 getRay(vec2 uv, vec3 eye, vec3 up, vec3 right)\n{\n    float nearWidth = tan(fov/2.0) * near * 2.0;\n    float nearHeight = iResolution.y/iResolution.x * nearWidth;\n    vec3 front = normalize(cross(up, right));\n    right = normalize(cross(front, up));\n    vec3 p = eye + front * near + right * uv.x * nearWidth + up * uv.y * nearHeight;\n    return normalize(p - eye);\n}\n\n\n//////////////////////////////////////\n// Rayleigh phase function\nconst float rayleighConstant = 0.05968310365946075091333141126469; // 3/(16*PI)\nfloat phaseRayleigh(float cosViewLight)\n{\n    return (1.0 + cosViewLight * cosViewLight) * rayleighConstant;\n}\n\n//////////////////////////////////////\n// Mie phase function\nconst float g = 0.76;\nconst float mieConstant = 0.019560942726378;//3 *(1 -g^2)/(8*PI*(2 + g^2))\nfloat phaseMie(float cosViewLight)\n{\n    return mieConstant* (1.0 + cosViewLight * cosViewLight) / pow((1.0 + g*g - 2.0 * g*cosViewLight), 1.5);\n}\n\nconst vec3 betaMie = vec3(0.000021);\n//const vec3 betaRayleigh = vec3(0.0000231, 0.0000231, 0.0000631);\nconst vec3 betaRayleigh = vec3(0.00000138, 0.0000135, 0.0000331);\n//const vec3 betaMie = vec3(0.0000631, 0.0000531, 0.0000231);\nconst float Hr = 6994.0;\nconst float Hm = 4994.0;\n\nconst float sunIntensity = 40.0;\nvec3 sunDir = normalize(vec3(0.0, 1.0, 0.3));\n\nvec3 scatteringFactor(vec3 p, float H, vec3 beta0)\n{\n    return exp(-(length(p) - g_earthRadius)/H) * beta0;\n}\n\nconst int opticalSampleNumber = 8;\n\nvec3 opticalDepth(vec3 nearPos, vec3 farPos, float H)\n{\n    float sum = 0.0;\n    vec3 deltaDir = (farPos - nearPos) / float(opticalSampleNumber);\n    vec3 p = nearPos;\n    for (int i =0; i < opticalSampleNumber; i++)\n    {\n        float height = length(p) - g_earthRadius;\n        if(height < 0.0)\n            return vec3(-1.0);\n        sum = sum + exp(-(height)/H);\n        p += deltaDir;\n    }\n\n    return vec3(sum) * length(deltaDir);\n}\n\nconst int maxStepNumber = 16;\nvec4 integration(vec3 posNear, vec3 posFar, vec3 dir)\n{\n    float cosViewLight = dot(dir, sunDir);\n    \n    vec3 ret = vec3(0.0);\n    vec3 deltaDir = (posFar - posNear)/float(maxStepNumber);\n    \n    float sampleDist = length(posNear - posFar) / float(maxStepNumber);\n    vec3 p = posNear;\n    vec3 sumR = vec3(0.0);\n    vec3 sumM = vec3(0.0);\n    \n    float densityR = 0.0;\n    float densityM = 0.0;\n    float opticalDepthR = 0.0;\n    float opticalDepthM = 0.0;\n    \n    for(int i = 0; i < maxStepNumber; i++)\n    {\n        float height = length(p) - g_earthRadius;\n        if(height < 0.0)\n            break;\n        densityR = exp(-height/Hr)* sampleDist;\n        densityM = exp(-height/Hm)* sampleDist;\n        opticalDepthR += densityR;\n        opticalDepthM += densityM;\n        \n        vec2 intersect = rayIntersectSphere(p, sunDir, g_atmosphereRadius);\n\n        vec3 lightPosNear = p;\n        vec3 lightPosFar = p + sunDir * intersect.y;\n        \n        float sum = 0.0;\n        vec3 opticalLightDepthR = vec3(0.0);\n        vec3 opticalLightDepthM = vec3(0.0);\n        \n        vec3 deltaLightDir = (lightPosFar - lightPosNear) / float(opticalSampleNumber);\n        float lightStepLength = length(deltaLightDir);\n        \n        vec3 lightPos = lightPosNear;\n        int j =0;\n        for (; j < opticalSampleNumber; j++)\n        {\n            float height = length(lightPos) - g_earthRadius;\n            if(height < 0.0)\n                break;\n            opticalLightDepthM = opticalLightDepthM + exp(-(height)/Hm) * lightStepLength;\n            opticalLightDepthR = opticalLightDepthR + exp(-(height)/Hr) * lightStepLength;\n            lightPos += deltaLightDir;\n        }\n        \n        if(j == opticalSampleNumber)\n        {\n            vec3 odR = opticalLightDepthR + opticalDepthR;\n            vec3 odM = opticalLightDepthM + opticalDepthM;\n            vec3 att = odR * betaRayleigh + 1.1 * odM * betaMie;\n\n            sumR += exp(-att) * densityR;\n            sumM += exp(-att) * densityM;\n        }\n        p += deltaDir;\n    }\n    ret = sumR * phaseRayleigh(cosViewLight) * betaRayleigh + sumM * phaseMie(cosViewLight) * betaMie * 1.1;\n    \n    return vec4(ret * sunIntensity * vec3(1.0, 0.9, 0.9), 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float disRatio = iMouse.x / iResolution.x;\n    float angle = (iTime / 4.0)* PI;\n    \n    sunDir = normalize(vec3(0, cos(angle) , sin(angle)));\n    \n    //vec3 eye = vec3(0, 0, g_earthRadius + 3000000.0);\n    //vec3 up = vec3(0, 1.0, 0);\n    //vec3 right = vec3(1.0, 0, 0);\n    \n    vec3 eye = vec3 (0, 0, g_earthRadius + disRatio * 100000.0);\n    //sunDir = normalize(eye);\n    float viewAngle = (iMouse.y / iResolution.y / 4.0)* PI;\n    vec3 up = normalize(vec3(0, cos(viewAngle + PI / 2.0) , sin(viewAngle+ PI / 2.0)));\n    //vec3 up = vec3(0, 1.0, 0);\n    vec3 right = vec3(1.0, 0, 0);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = uv*2.0 - 1.0;\n    \n    vec3 rayDir = getRay(uv, eye, up, right);\n    vec2 resInner = rayIntersectSphere(eye, rayDir, g_earthRadius);\n    vec2 resOutter = rayIntersectSphere(eye, rayDir, g_atmosphereRadius);\n\n    //float value = 0.0;\n    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n    if(resOutter.x <= resOutter.y)\n    {\n        float nearDist = max(resOutter.x, 0.0);\n        float farDist = resOutter.y;\n\n        if(resInner.x <= resInner.y && resInner.x >= 0.0)\n            farDist = resInner.x;\n        //value = farDist - nearDist;\n        color = integration(eye + rayDir * nearDist, eye + rayDir * farDist, rayDir);\n    }\n    \n    //gl_FragColor = mix(vec4(0.0, 0.0, 0.0, 0.0), vec4(0.5, 0.5, 0.8, 1.0), value/ 2000000.f);\n    fragColor = vec4(pow(color.xyz, vec3(1.0/2.2)), 1.0);\n}\n", "name": "Image", "description": "", "type": "image"}]}