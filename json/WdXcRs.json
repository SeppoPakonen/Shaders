{"ver": "0.1", "info": {"id": "WdXcRs", "date": "1585316430", "viewed": 167, "name": "Closest Point in Tetrahedron", "username": "mla", "description": "Just a test for closest point to tetrahedron function I wanted for something else.", "likes": 1, "published": 3, "flags": 0, "usePreview": 0, "tags": ["closest"], "requires": ["imagebuf"]}, "renderpass": [{"inputs": [], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "////////////////////////////////////////////////////////////////////////////////\n// Just a test for a \"closest point in tetrahedron\" function\n////////////////////////////////////////////////////////////////////////////////\n\nfloat PI = 3.14159;\n\nbool dorotate = true;\nvec3 lightdir = vec3(0,2,1);\nvec3 closest(vec3 p, vec3 A, vec3 B, vec3 C);\n\nvec3 closest(vec3 p, vec3 A, vec3 B, vec3 C, vec3 D) {\n  // Find closest point to in tetrahedron ABCD, return p\n  // if inside tetrahedron.\n  vec3 nA = normalize(cross(B-C,C-D));\n  vec3 nB = -normalize(cross(C-D,D-A));\n  vec3 nC = normalize(cross(D-A,A-B));\n  vec3 nD = -normalize(cross(A-B,B-C));\n  float dA = dot(p,nA)-dot(B,nA);\n  float dB = dot(p,nB)-dot(C,nB);\n  float dC = dot(p,nC)-dot(D,nC);\n  float dD = dot(p,nD)-dot(A,nD);\n  if (dA <= 0.0 && dB <= 0.0 && dC <= 0.0 && dD <= 0.0) return p;\n  if (dA > 0.0) return closest(p,B,C,D);\n  if (dB > 0.0) return closest(p,C,D,A);\n  if (dC > 0.0) return closest(p,D,A,B);\n  if (dD > 0.0) return closest(p,A,B,C);\n  return vec3(0);\n}\n\nfloat eval(vec3 p, out ivec3 id) {\n  p = abs(p);\n  vec3 A = vec3(0), B = vec3(1,0,0), C = vec3(0,1,0), D = vec3(0,0,1);\n  vec3 q = closest(p,A,B,C,D);\n  float N = 5.0;\n  float pwidth = 0.05;\n  q = round(N*q);\n  id = ivec3(q);\n  q /= N;\n  float d = distance(p,q)-pwidth;\n  // Next line eliminates some weird ghost spheres that appear -\n  // don't fully understand what is going on there.\n  d = max(d,(dot(p,vec3(1)) - 1.0)/sqrt(3.0)-pwidth);\n  return d;\n}\n\n// Closest point in a triangle to a point.\n// Function by iq: https://www.shadertoy.com/view/ttfGWl\nfloat dot2( in vec3 v ) { return dot(v,v); }\nvec3 closestTriangle( in vec3 v0, in vec3 v1, in vec3 v2, in vec3 p )\n{\n    vec3 v10 = v1 - v0; vec3 p0 = p - v0;\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v02 = v0 - v2; vec3 p2 = p - v2;\n    vec3 nor = cross( v10, v02 );\n\n#if 0\n    // method 1, in 3D space\n    if( dot(cross(v10,nor),p0)<0.0 ) return v0 + v10*clamp( dot(p0,v10)/dot2(v10), 0.0, 1.0 );\n    if( dot(cross(v21,nor),p1)<0.0 ) return v1 + v21*clamp( dot(p1,v21)/dot2(v21), 0.0, 1.0 );\n    if( dot(cross(v02,nor),p2)<0.0 ) return v2 + v02*clamp( dot(p2,v02)/dot2(v02), 0.0, 1.0 );\n    return p - nor*dot(nor,p0)/dot2(nor);\n    \n#else    \n    // method 2, in barycentric space\n    vec3  q = cross( nor, p0 );\n    float d = 1.0/dot2(nor);\n    float u = d*dot( q, v02 );\n    float v = d*dot( q, v10 );\n    float w = 1.0-u-v;\n    \n         if( u<0.0 ) { w = clamp( dot(p2,v02)/dot2(v02), 0.0, 1.0 ); u = 0.0; v = 1.0-w; }\n    else if( v<0.0 ) { u = clamp( dot(p0,v10)/dot2(v10), 0.0, 1.0 ); v = 0.0; w = 1.0-u; }\n\telse if( w<0.0 ) { v = clamp( dot(p1,v21)/dot2(v21), 0.0, 1.0 ); w = 0.0; u = 1.0-v; }\n    \n    return u*v1 + v*v2 + w*v0;\n#endif    \n}\n\nvec3 closest(vec3 p, vec3 A, vec3 B, vec3 C) {\n  return closestTriangle(A,B,C,p);\n}\n\nfloat eval(vec3 p) {\n  ivec3 id;\n  return eval(p,id);\n}\n\nvec3 getnormal(vec3 p) {\n  vec2 e = vec2(0.001, 0.0);\n  return normalize(vec3(eval(p + e.xyy) - eval(p - e.xyy),\n                        eval(p + e.yxy) - eval(p - e.yxy),\n                        eval(p + e.yyx) - eval(p - e.yyx)));\n}\n\nfloat getdistance(vec3 q, vec3 r) {\n  float t = 0.0;\n  int numsteps = 100;\n  float maxdist = 2.0*length(q);\n  float precis = 1e-3;\n  for (int i = 0; i < numsteps; i++) {\n    vec3 p = q+t*r;\n    float d = eval(p);\n    if (abs(d) < precis) return t;\n    t += 0.8*d;\n    if (t > maxdist) break;\n  }\n  return -1.0;\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 getcolor(vec3 q, vec3 r) {\n  float t = getdistance(q,r);\n  if (t < 0.0) return vec3(0);\n  vec3 p = q+t*r;\n  ivec3 id;\n  eval(p,id);\n  uint h = ihash(uint((id.x << 20) ^ (id.y << 10) ^ (id.z << 0)));\n  float rnd = float(h)/pow(2.0,32.0);\n  vec3 normal = getnormal(p);\n  vec3 color = hsv2rgb(vec3(rnd,0.5,1));\n  float ambient = 0.3;\n  float diffuse = 0.7*clamp(dot(normal,lightdir),0.0,1.0);\n  color *= ambient+diffuse;\n  return pow(color,vec3(0.4545));\n}\n\nvec2 rotate(in vec2 p, in float t) {\n  return p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\nvec3 rotateframe(vec3 p) {\n  if (iMouse.x > 0.0) {\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  if (dorotate) {\n    p.yz = rotate(p.yz,-0.5+iTime * 0.125);\n    p.zx = rotate(p.zx,-0.5+iTime * 0.1);\n  }\n  return p;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n  vec2 z = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  vec3 eye = vec3(0,0,2);\n  vec3 ray = vec3(z,-2);\n  eye = rotateframe(eye);\n  ray = rotateframe(ray);\n  ray = normalize(ray);\n  lightdir = rotateframe(lightdir);\n  lightdir = normalize(lightdir);\n  vec3 col = getcolor(eye,ray);\n  fragColor = vec4(col,1);\n}", "name": "Image", "description": "", "type": "image"}]}