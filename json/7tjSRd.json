{"ver": "0.1", "info": {"id": "7tjSRd", "date": "1629975813", "viewed": 203, "name": "GOD | MONEY", "username": "byt3_m3chanic", "description": "GOD MONEY - I don't know, I listened to NIN too much as a kid. Just wanted to play with something different tonight.. ", "likes": 17, "published": 3, "flags": 0, "usePreview": 0, "tags": [], "requires": ["imagebuf"]}, "renderpass": [{"inputs": [], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Was just was goofing around / text and isometric\n    wasn't really intending to do much - but eh I made\n    something.. \n    \n    GOD | MONEY\n    @byt3_m3chanic | 08/25/21\n\n    God money, I'll do anything for you\n    God money, just tell me what you want me to\n    *Trent Reznor*\n\n*/\n#define R iResolution\n#define M iMouse\n#define T iTime\n\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MIN_DIST .001\n#define MAX_DIST 90.\n\n//linear step timing function - book of shaders\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), 0.0, 1.0); }\n//utils\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21( vec2 p ) { return fract(sin(dot(p,vec2(23.43,84.21))) *4832.3234); }\n//@iq 2Dbox functions and extrude\nfloat box( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat box( in vec2 p, in vec2 b, in vec4 r ){\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\nfloat opx(in float sdf, in float pz, in float h){\n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\n// letters and symbols\nfloat getD(vec2 uv){\n    float letd = box(uv,vec2(1.45,2.5),vec4(1.25,1.25,0,0));\n    letd=abs(letd)-.5;\n    letd=min(box(uv+vec2(1.45, .0),vec2(.5,3.)),letd);\n    return letd;\n}\nfloat getG(vec2 uv){\n    float letg = box(uv,vec2(1.45,2.5),vec4(1.25));\n    letg=abs(letg)-.5;\n    letg = max(letg,-box(uv-vec2(1., .5),vec2(1.25,.5)) );\n    letg = min(box(uv-vec2(.95, -.25),vec2(1.,.5)),letg);\n    return letg;\n}\nfloat getO(vec2 uv){\n    float leto = box(uv,vec2(1.45,2.5),vec4(1.25));\n    leto=abs(leto)-.5;\n    return leto;\n}\nfloat getDl(vec2 uv){\n    uv.x*=-1.;\n    float letd = box(uv-vec2(.25,.75),vec2(1.,1.),vec4(.75,.75,0,0));\n    letd = max(letd,-box(uv+vec2(.2,-.75),vec2(1.,.55),vec4(.35,.35,0,0)) );\n    letd = min(box(uv+vec2(.25,.75),vec2(1.,1.),vec4(0,0,.75,.75)), letd );\n    letd = max(letd,-box(uv+vec2(-.2,.75),vec2(1.,.55),vec4(0,0,.35,.35)) );\n    letd = min(box(vec2(abs(uv.x),uv.y)-vec2(.35,.0),vec2(.15,2.25),vec4(0)), letd );\n    return letd;\n}\nfloat getCr(vec2 uv){\n    float letd = box(uv,vec2(.4,2.25));\n    letd = min(letd,box(uv-vec2(0,.75),vec2(1.35,.4)));\n    return letd;\n}\n//globals\nmat2 r45,r21,turn;\nvec3 hit,hitPoint;\nvec2 gid,cellId;\nfloat tmod=0.,time=0.,ga1=0.,ga2=0.,ga3=0.,ga4=0.,ga5=0.,ga6=0.;\n//size constants\nconst vec2 sc = vec2(.14), hsc = .5/sc; \n\nvec2 map(vec3 p) {\n    vec2 res = vec2(1e5,0);\n    vec3 p2 = p;\n    p2.xz*=r21;\n    p2-=.15*sin(p2.x*.4+T*3.);\n    p2.z=abs(p2.z)-((ga3)*3.);\n    float outline = 1e5;\n    float lo = 1e5;\n    outline = getG(p2.xy+vec2(5.,-.95));\n    lo = min(opx(outline,p2.z,.75),lo);\n    outline = getO(p2.xy-vec2(.0,.95));\n    lo = min(opx(outline,p2.z,.75),lo);\n    outline = getD(p2.xy-vec2(5.,.95));\n    lo = min(opx(outline,p2.z,.75),lo);\n    \n    if(lo<res.x) {\n        res = vec2(lo,3.);\n    \thit=p2;\n        gid=vec2(0);\n    }\n    \n    p.xz*=turn;\n    p.y+=5.5;\n\n    vec2 id = floor(p.xz*sc) + .5;    \n    vec2 r = p.xz - id/(sc);\n\n    float rnd = hash21(id);\n    vec3 q = vec3(r.x,p.y,r.y);\n    q.xz*=rot((ga5+1.)*rnd*PI2);\n    q.xy*=rot((ga2*2.)*rnd*PI2);\n    float b3 = getCr(q.xy);\n    float b2 = getDl(q.xy);\n\n    float b1 = opx(mix(b3,b2,ga5),q.z,.25);\n\n    if(b1<res.x) {\n        res = vec2(b1,2.);\n    \thit=p;\n        gid=id;\n    }\n\n    float d9 = p.y+5.5;\n    if(d9<res.x) {\n        res = vec2(d9,1.);\n    \thit=p;\n        gid=id;\n    }\n    return res;\n}\n// Tetrahedron technique @iq\n// https://www.iquilezles.org/www/articles/normalsSDF\nvec3 normal(vec3 p, float t, float mindist){\n    float e = mindist*t;\n    vec2 h = vec2(1.0,-1.0);\n    return normalize( h.xyy*map( p + h.xyy*e).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e).x );\n}\n//@iq https://iquilezles.org/www/articles/palettes/palettes.htm\nvec3 hue(float t){ \n    vec3 d = vec3(0.220,0.961,0.875);\n    return .75 + .375*cos(.72*T+PI2*t*(vec3(.985,.98,.95)+d)); \n}\n\nvec3 render(vec3 p, vec3 rd, vec3 ro, float d, float m, inout vec3 n){\n    n = normal(p,d,1.01);\n    vec3 lpos =  vec3(-4,20,-4);\n    vec3 l = normalize(lpos-p);\n\n    float diff = clamp(dot(n,l),0.,1.);\n\n    float shdw = 1.;\n    float t=.1;\n    // i still havent found a good\n    // soft shadow I like - or just\n    // havent come across one yet..\n    for( float i=.0; i<30.; i++ )\n    {\n        float h = map(p + l*t).x;\n        if( h<MIN_DIST ) { shdw = 0.; break; }\n        shdw = min(shdw, 12.*h/t);\n        t += h*.8;\n        if( shdw<MIN_DIST || t>55. ) break;\n    }\n    diff = mix(diff,diff*shdw,.35);\n\n    vec3 h = vec3(0.800,0.961,0.929);\n    //quad tree from my previous shader\n    if(m==1.) {\n        hitPoint*=sc.xxx;\n        hitPoint.x+=ga4*2.;\n        hitPoint.z+=ga1*2.;\n        float px = .001;\n        h = vec3(0.902,0.902,0.902);\n        vec3 h3=hue(15.25);\n\n        vec2 i = floor(hitPoint.xz);\n        float rnd = hash21(i+vec2((iDate.z),2.));\n        vec2 f = fract(hitPoint.xz)-.5;\n        h3=hue(rnd*5.);\n        //level 1\n        if(rnd>.5){\n            i = floor(f);\n            rnd = hash21(i+rnd);\n            f = fract(f*2.)-.5;\n            h3=hue(rnd);\n            //level 2\n            if(rnd>.6){\n                i = floor(f);\n                rnd = hash21(i+rnd);\n                f = fract(f*2.)-.5;\n                h3=hue(rnd);\n                //level 3\n                if(rnd>.6){\n                    i = floor(f);\n                    rnd = hash21(i+rnd);\n                    f = fract(f*2.)-.5;\n                    h3=hue(rnd);\n                    //level 4\n                    if(rnd>.7){\n                        i = floor(f);\n                        rnd = hash21(i+rnd);\n                        f = fract(f*2.)-.5;\n                        h3=hue(rnd);\n                    }\n                }\n            }\n        }\n\n        float cirx = length(f)-.485;\n        float b3 = getCr(f.xy*6.);\n        float b2 = getDl(f.xy*6.);\n        float cir = mix(b3,b2,rnd>.35?1.:0.);\n        cir=max(cirx,-cir);\n        if(rnd>.5)cir=abs(cirx+.1)-.05;\n        cir = smoothstep(-px,.01+px,cir);\n        h=mix(h,hue(3.*rnd),1.-cir);\n    } \n        \n    if(m==2.) h = hue(hash21(cellId));\n\n    if(m==3.) h = vec3(0.922,0.957,0.953);\n\n    if(m==4.) h = vec3(0.475,0.824,0.773);\n\n    return (h*diff);\n}\n\nfloat zoom = 16.;\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    // precal all your vars\n    time = T;\n    turn= rot(time*.1);\n    tmod = mod(time, 10.);\n    \n    float t1 = lsp(3.0, 6.0, tmod);\n    float t2 = lsp(7.0, 9.0, tmod);\n    ga2 = (t1-t2);\n    float t3 = lsp(0.0, 1.0, tmod);\n    float t4 = lsp(5.0, 6.0, tmod);\n    ga3 = (t3-t4);\n    float t9 = lsp(1.0, 2.0, tmod);\n    float t0 = lsp(8.0, 9.0, tmod);\n    ga5 = (t9-t0);\n    \n    ga4 = (t4)+floor(time*.1);\n    ga1 = (t1)+floor(time*.1);\n    r21 = rot(ga3*PI2);\n    // precal\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n  \n    //orthographic camera\n    vec3 ro = vec3(uv*zoom,-zoom);\n    vec3 rd = vec3(0,0,1.);\n    \n    //.78539816339 = 45*PI/180\n    mat2 rx = rot(-0.78539816339*ga5);\n    mat2 ry = rot(ga2*0.78539816339);\n    \n    ro.yz *= rx;ro.xz *= ry;\n    rd.yz *= rx;rd.xz *= ry;\n\n    vec3 C = vec3(0);\n    vec3  p = ro + rd;\n    float atten = .85;\n    float k = 1.;\n    float d = 0.;\n    for(int i=0;i<120;i++)\n    {\n        vec2 ray = map(p);\n        vec3 n=vec3(0);\n        float m = ray.y;\n\n        d = ray.x * .85;\n        p += rd * d *k;\n        //@blackle transparent tricks\n        if (d*d < 1e-7) {\n            hitPoint = hit;\n            cellId = gid;\n            \n            C+=render(p,rd,ro,d,ray.y,n)*atten;\n            if(m==2.)break;\n            \n            atten *= .45;\n            p += rd*.015;\n            k = sign(map(p).x);\n\n            vec3 rr = vec3(0);\n            if(m==1.){\n                rd=reflect(-rd,n);\n                p+=n*.1;\n            }else{\n                float fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 9.);\n                fresnel = mix(.01, .9, fresnel);\n                rr = refract(rd,n,.2);\n                rd=mix(rr,rd,1.-fresnel);\n            }\n        } \n       \n        if(distance(p,rd)>45.) { break; }\n    }\n\n    C = mix(C,C+.07,hash21(uv));\n    C = clamp(C,vec3(.03),vec3(1));\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}", "name": "Image", "description": "", "type": "image"}]}