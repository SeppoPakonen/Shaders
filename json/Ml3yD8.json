{"ver":"0.1","info":{"id":"Ml3yD8","date":"1532831965","viewed":285,"name":"[SH18] Once Human","username":"shau","description":"Another Dystopian future for this years competition. Sorry but it needs a quicker GPU to run smoothly","likes":15,"published":1,"flags":32,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n/* \n    Competition entry for 'Human' themed Shadertoy competition\n    Mask inspired by 'Only One Wish' - Fairlight & Black Lotus which in turn looks a bit like\n    the 'Never Say Die' album cover by Black Sabbath\n    I wanted to do a bit more with this but GPU is running out of puff so apologies if it's slow for you\n*/\n\n#define T mod(iTime, LOOP_LENGTH)\n#define CT iTime / 14.0\n#define FAR 50.0\n#define EPS 0.005\n#define R iResolution.xy\n#define BUF(p) texture(iChannel0, p / R).xyz\n\nfloat dfMuscle(vec3 rp, vec3 p1, vec3 p2, vec2 xz) {\n    float l = length(p2 - p1);\n    vec3 d = normalize(p2 - p1);\n    vec3 c = p1 + d * l * 0.5;\n    rp -= c;\n    rp.zy *= rot(-sin((p2.z - p1.z) / l));\n    return sdEllipsoid(rp, vec3(xz.x, l * 0.5, xz.y));\n}\n\nvec3 dfMask(vec3 rp) {\n    float mask = max(sdEllipsoid(rp, vec3(0.6, 1.1, 0.6)), -sdBox(rp - vec3(0., 1., 0.), vec3(1.)));    \n    mask = smin(mask, sdConeSection(rp.xzy - vec3(0., 0.5, -0.5), 0.24, 0.38, 0.16), 0.2);\n    mask = max(mask, -fCylinder(rp.xzy - vec3(0., 0.5, -0.5), 0.15, 0.5));    \n    mask = min(mask, fCylinder(rp.xzy - vec3(0., 0.5, -0.5), 0.15, 0.1));    \n    vec3 q = rp;\n    q.x = abs(q.x);\n    float eyesocket = sdConeSection(q.xzy - vec3(0.3, 0.3, -0.1), 0.3, 0.32, 0.22);\n    eyesocket = max(eyesocket, -fCylinder(q.xzy - vec3(0.3, 0.4, -0.1), 0.17, 0.4));\n    float lens = sdSphere(q - vec3(0.2, -0.1, 0.28), 0.3);\n    q.xz *= rot(-0.5);\n    eyesocket = max(eyesocket, -sdBox(q - vec3(0., 0., 1.15), vec3(0.5)));\n    q = rp;\n    q.yz *= rot(0.8);\n    float mouthpiece = fCylinder(q.xzy - vec3(0., 0.4, -0.2), 0.14, 0.8);\n    mouthpiece = max(mouthpiece, -fCylinder(q.xzy - vec3(0., 0.4, -0.2), 0.12, 1.));\n    q.x = abs(q.x);\n    float crsm = fCylinder(q.yxz - vec3(-0.2, 0.4, 1.1), 0.02, 0.4);\n    mouthpiece = min(mouthpiece, crsm);\n    float light = sdSphere(q - vec3(0.8, -0.2, 1.1), 0.06);\n    mask = smin(mask, eyesocket, 0.1);\n    mask = smin(mask, mouthpiece, 0.3);\n    q = rp;\n    q.yz *= rot(-0.2);\n    mask = max(mask, -sdBox(q - vec3(0., 0., -2.2), vec3(2.)));\n    vec2 maskObject = vec2(mask, MASK);\n    maskObject = nearest(maskObject, vec2(lens, MASK_LENS));\n    maskObject = nearest(maskObject, vec2(light, MASK_LIGHT));\n    \n    return vec3(maskObject, light);\n}\n\nvec3 dfHead(vec3 rp) {\n\n    vec3 maskObject = dfMask(rp);\n    float head = max(sdEllipsoid(rp, vec3(0.55, 1.05, 0.55)), -sdBox(rp - vec3(0., 1., 0.), vec3(1.)));\n    head = min(head, sdSphere(rp, 0.58));\n    head = smin(head, sdSphere(rp - vec3(0., 0., -0.2), 0.72), 0.1);\n    head = max(head, -sdBox(rp - vec3(0., 0., 0.), vec3(1., 0.06, 1.)));\n    vec2 headObject = vec2(head, SKIN);\n    \n    vec2 near = nearest(headObject, maskObject.xy);\n    \n    return vec3(near, maskObject.z);\n}\n\nvec4 map(vec3 rp) {\n    \n    //pull joint positions from buffer\n    vec3 headPos = BUF(HEAD);\n    vec3 spineTopPos = BUF(SPINE_TOP);\n    vec3 spineBottomPos = BUF(SPINE_BOTTOM);\n    vec3 leftShoulderPos = BUF(LEFT_SHOULDER);\n    vec3 leftElbowPos = BUF(LEFT_ELBOW);\n    vec3 leftWristPos = BUF(LEFT_WRIST);\n    vec3 leftFingertipPos = BUF(LEFT_FINGERTIP);\n    vec3 leftHipPos = BUF(LEFT_HIP);\n    vec3 leftKneePos = BUF(LEFT_KNEE);\n    vec3 leftAnklePos = BUF(LEFT_ANKLE);\n    vec3 rightShoulderPos = BUF(RIGHT_SHOULDER);\n    vec3 rightElbowPos = BUF(RIGHT_ELBOW);\n    vec3 rightWristPos = BUF(RIGHT_WRIST);\n    vec3 rightFingertipPos = BUF(RIGHT_FINGERTIP);\n    vec3 rightHipPos = BUF(RIGHT_HIP);\n    vec3 rightKneePos = BUF(RIGHT_KNEE);\n    vec3 rightAnklePos = BUF(RIGHT_ANKLE);\n\n    float joints = sdCapsule(rp, leftShoulderPos, leftElbowPos, 0.2);\n    joints = min(joints, sdCapsule(rp, leftElbowPos, leftWristPos, 0.2));\n    joints = min(joints, sdCapsule(rp, leftWristPos, leftFingertipPos, 0.15));\n    joints = min(joints, sdCapsule(rp, leftHipPos, leftKneePos, 0.3));\n    joints = min(joints, sdCapsule(rp, leftKneePos, leftAnklePos, 0.26));\n    joints = min(joints, sdCapsule(rp, rightShoulderPos, rightElbowPos, 0.2));\n    joints = min(joints, sdCapsule(rp, rightElbowPos, rightWristPos, 0.2));\n    joints = min(joints, sdCapsule(rp, rightWristPos, rightFingertipPos, 0.15));\n    joints = min(joints, sdCapsule(rp, rightHipPos, rightKneePos, 0.3));\n    joints = min(joints, sdCapsule(rp, rightKneePos, rightAnklePos, 0.26));\n    joints = min(joints, sdCapsule(rp, headPos, spineTopPos, 0.4));\n    joints = min(joints, sdCapsule(rp, leftShoulderPos, rightShoulderPos, 0.35));\n    joints = min(joints, sdCapsule(rp, leftHipPos, rightHipPos, 0.55));\n    \n    float lights = sdCapsule(rp, \n                             vec3(leftHipPos.x - 0.4, leftHipPos.y, leftHipPos.z), \n                             vec3(rightHipPos.x + 0.4, rightHipPos.y, rightHipPos.z), \n                             0.2);\n    \n    float leftArm = sdSphere(rp - leftShoulderPos, 0.4);\n    leftArm = smin(leftArm, dfMuscle(rp, leftElbowPos, leftShoulderPos, vec2(0.3, 0.35)), 0.2);\n    leftArm = min(leftArm, dfMuscle(rp, leftWristPos, leftElbowPos, vec2(0.25, 0.3)));\n    leftArm = min(leftArm, dfMuscle(rp, leftWristPos, leftFingertipPos, vec2(0.2, 0.2)));\n    float rightArm = sdSphere(rp - rightShoulderPos, 0.4);\n    rightArm = smin(rightArm, dfMuscle(rp, rightElbowPos, rightShoulderPos, vec2(0.3, 0.35)), 0.2);\n    rightArm = min(rightArm, dfMuscle(rp, rightWristPos, rightElbowPos, vec2(0.25, 0.3)));\n    rightArm = min(rightArm, dfMuscle(rp, rightWristPos, rightFingertipPos, vec2(0.2, 0.2)));    \n    \n    float leftLeg = dfMuscle(rp, leftAnklePos, leftKneePos, vec2(0.3, 0.4));\n    leftLeg = min(leftLeg, dfMuscle(rp, leftKneePos, leftHipPos, vec2(0.35, 0.5)));\n    leftLeg = smin(leftLeg, sdSphere(rp - vec3(leftHipPos.x + 0.1, leftHipPos.y, leftHipPos.z - 0.05), 0.6), 0.2);\n    float rightLeg = dfMuscle(rp, rightAnklePos, rightKneePos, vec2(0.3, 0.4));\n    rightLeg = min(rightLeg, dfMuscle(rp, rightKneePos, rightHipPos, vec2(0.35, 0.5)));\n    rightLeg = smin(rightLeg, sdSphere(rp - vec3(rightHipPos.x - 0.1, rightHipPos.y, rightHipPos.z - 0.05), 0.6), 0.2);\n\n    float torso  = sdEllipsoid(rp - spineTopPos, vec3(1., 2., 0.5));\n    torso = max(torso, -sdBox(rp - vec3(0., spineTopPos.y + 2., 0.), vec3(2., 2., 2.)));\n    torso = min(torso, sdEllipsoid(rp - spineTopPos, vec3(1., 0.5, 0.5)));\n    torso = smin(torso, sdEllipsoid(rp - spineBottomPos, vec3(0.8, 1.4, 0.4)), 0.2);\n    torso = max(torso, -sdBox(rp - vec3(0., spineBottomPos.y - 2., 0.), vec3(2., 2., 2.)));\n\n    float shell = smin(torso, leftLeg, 0.2);\n    shell = smin(shell, rightLeg, 0.2);\n    shell = min(shell, leftArm);\n    shell = min(shell, rightArm);\n    \n    rp.xz *= rot(BUF(HEAD_ROT).x * 0.8);\n    float brain = sdSphere(rp - headPos, 0.53);\n    vec3 head = dfHead(rp - headPos);\n    \n    vec2 near = nearest(vec2(joints, JOINT), vec2(shell, SKIN));\n    near = nearest(near, head.xy);\n    near = nearest(near, vec2(lights, MASK_LIGHT));\n    near = nearest(near, vec2(brain, MASK_LIGHT));\n    \n    return vec4(near, min(head.z, lights), brain);    \n}\n\nvec3 normal(vec3 p) {  \n    vec2 e = vec2(-1., 1.) * EPS;   \n\treturn normalize(e.yxx * map(p + e.yxx).x + e.xxy * map(p + e.xxy).x + \n\t\t\t\t\t e.xyx * map(p + e.xyx).x + e.yyy * map(p + e.yyy).x);   \n}\n\n//Moody clouds from Patu\n//https://www.shadertoy.com/view/4tVXRV\nvec3 clouds(vec3 rd) {\n    vec2 uv = rd.xz / (rd.y + 0.6);\n    float nz = fbm(vec3(uv.yx * 1.4 + vec2(CT, 0.0), CT)) * 1.5;\n    return clamp(pow(vec3(nz), vec3(4.)) * rd.y, 0., 1.);\n}\n\n// Based on original by IQ.\n// http://www.iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm\nfloat AO(vec3 rp, vec3 n) {\n\n    float r = 0.;\n    float w = 1.;\n    float d = 0.;\n\n    for (float i = 1.; i < 5.; i += 1.){\n        d = i / 5.;\n        r += w * (d - map(rp + n * d).x);\n        w *= 0.5;\n    }\n\n    return 1. - clamp(r, 0., 1.);\n}\n\nvec4 march(vec3 ro, vec3 rd) {\n \n    float t = 0.;\n    float id = 0.;\n    float li1 = 0.;\n    float li2 = 0.;\n    \n    for (int i = 0; i < 98; i++) {\n        vec3 rp = ro + rd * t;\n        vec4 ns = map(rp);\n        if (ns.x < EPS || t > FAR) {\n            id = ns.y;\n            break;\n        }\n        \n        li1 += 1. / (1. + ns.z * ns.z * 1000.);\n        li2 += 1. / (1. + ns.w * ns.w * 5000.);\n        \n        t += ns.x;\n    }\n    \n    return vec4(t, id, li1, li2);\n}\n\nvec3 setupCamera(vec2 uv, vec3 ro, vec3 lookAt) {\n    \n    float FOV = PI / 3.;\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x)); \n    vec3 up = cross(forward, right);\n\n    return normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    float mint = FAR;\n    vec3 pc = vec3(0.);\n    vec3 lp = vec3(4., 9., 2.);\n    vec3 fn = vec3(0., 1., 0.);\n    vec3 fo = vec3(0., -1., 0.);\n    \n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    vec2 uv2 = fragCoord.xy / iResolution.xy;\n    vec3 lookAt = BUF(LOOK_AT);\n    lookAt += (0.2 * noise3(T * 4.) - 0.5) + sin(T * 2.) * 0.3;\n    vec3 ro = BUF(CAM);\n    vec3 rd = setupCamera(uv, ro, lookAt);\n    \n    pc = vec3(1., 0., 0.) * clouds(rd);\n    \n    vec4 t = march(ro, rd);\n    float ft = planeIntersection(ro, rd, fn, fo);\n    if (ft > 0. && ft < mint) {\n        mint = ft;    \n        vec3 rp = ro + rd * ft;\n        vec3 ld = normalize(lp - rp);\n        float lt = length(lp - rp);\n        float diff = max(dot(ld, fn), 0.05);\n        float atten = 1. / (1. + lt * lt * 0.1); \n        pc = vec3(1.) * diff * atten;\n    }\n    \n    if (t.x > 0. && t.x < mint) {\n        mint = t.x;\n        vec3 rp = ro + rd * t.x;\n    \tvec3 n = normal(rp);\n        vec3 ld = normalize(lp - rp);\n        float diff = max(dot(ld, n), 0.05);\n        float spec = pow(max(dot(reflect(-ld, n), -rd), 0.), 32.);\n        float ao = AO(rp, n);\n        vec3 rrd = reflect(rd, n);\n        vec3 rc = vec3(1., 0., 0.) * clouds(rrd);\n        \n        if (t.y == MASK) {\n            pc = vec3(0.1) * ao * diff;\n            pc += vec3(1.) * spec * 0.1;\n        } else if (t.y == JOINT) {\n            pc = vec3(0.1) * ao * diff; \n            pc += vec3(1.) * spec * 0.3;\n        } else if (t.y == MASK_LENS) {\n            pc = vec3(0.5, 0., 0.) * ao * diff;\n            pc += vec3(1.) * spec;\n            pc += rc * 2.;\n        } else if (t.y == MASK_LIGHT) {\n            pc = vec3(1., 1., 0.);   \n        } else if (t.y == SKIN) {\n            pc = vec3(0.3);\n            pc += vec3(1.) * spec * 0.2;\n            pc += rc * n.y;\n            pc *= ao;\n        }\n    }\n    \n    pc += vec3(1., 0., 0.) * t.z;\n    pc += vec3(1., 0., 0.) * t.w;\n    \n    pc *= min(T * 0.2, 1.);\n    pc *= clamp(LOOP_LENGTH - (T + 0.4), 0., 1.);\n    pc *= sin((uv2.y + T * 0.1) * 1000.0) * 0.2 + 0.5;\n\n    \n    fragColor = vec4(pc * 2.0, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.141592\n#define MOD3 vec3(443.8975,397.2973, 491.1871)\n#define MASK 1.\n#define MASK_LIGHT 2.\n#define MASK_LENS 3.\n#define SKIN 5.\n#define JOINT 6.\n#define FLOOR 10.\n#define CAM vec2(1.5, 0.5)\n#define LOOK_AT vec2(0.5, 0.5)\n#define HEAD_ROT vec2(2.5, 0.5)\n#define LEFT_HIP vec2(0.5, 1.5)\n#define LEFT_KNEE vec2(1.5, 1.5)\n#define LEFT_ANKLE vec2(2.5, 1.5)\n#define RIGHT_HIP vec2(4.5, 1.5)\n#define RIGHT_KNEE vec2(5.5, 1.5)\n#define RIGHT_ANKLE vec2(6.5, 1.5)\n#define SPINE_BOTTOM vec2(8.5, 1.5)\n#define SPINE_TOP vec2(9.5, 1.5)\n#define HEAD vec2(10.5, 1.5)\n#define LEFT_SHOULDER vec2(11.5, 1.5)\n#define LEFT_ELBOW vec2(12.5, 1.5)\n#define LEFT_WRIST vec2(13.5, 1.5)\n#define LEFT_FINGERTIP vec2(14.5, 1.5)\n#define RIGHT_SHOULDER vec2(15.5, 1.5)\n#define RIGHT_ELBOW vec2(16.5, 1.5)\n#define RIGHT_WRIST vec2(17.5, 1.5)\n#define RIGHT_FINGERTIP vec2(18.5, 1.5)\n#define LOOP_LENGTH 34.25\n\nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}\n\nvec3 rotBone(vec3 origin, vec3 pos, float a) {\n    pos -= origin;\n    pos.zy *= rot(a);\n    return pos += origin;\n}\n\n//SDF IQ and Mercury\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdConeSection(vec3 p, float h, float r1, float r2) {\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5 * (r1 - r2) / h;\n    float d2 = max(sqrt(dot(p.xz, p.xz) * (1. - si * si)) + q * si - r2, q);\n    return length(max(vec2(d1, d2), 0.)) + min(max(d1, d2), 0.);\n}\n\n//mercury sdf\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa, ba) / dot(ba, ba), 0., 1.);\n    return length(pa - ba * h) - r;\n}\n\nfloat sdEllipsoid(vec3 p, vec3 r) {\n    return (length(p / r) - 1.) * min(min(r.x, r.y), r.z);\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat planeIntersection(vec3 ro, vec3 rd, vec3 n, vec3 o) {\n    return dot(o - ro, n) / dot(rd, n);\n}\n\n//neat trick from Shane\nvec2 nearest(vec2 a, vec2 b){ \n    float s = step(a.x, b.x);\n    return s * a + (1. - s) * b;\n}\n\n//IQs noise\nfloat noise(vec3 rp) {\n    vec3 ip = floor(rp);\n    rp -= ip; \n    vec3 s = vec3(7, 157, 113);\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    rp = rp * rp * (3. - 2. * rp); \n    h = mix(fract(sin(h) * 43758.5), fract(sin(h + s.x) * 43758.5), rp.x);\n    h.xy = mix(h.xz, h.yw, rp.y);\n    return mix(h.x, h.y, rp.z); \n}\n\n//Dave Hoskins - Noise and Hashing\nvec3 hash31(float p) {\n   vec3 p3 = fract(vec3(p) * MOD3);\n   p3 += dot(p3.xyz, p3.yzx + 19.19);\n   return fract(vec3(p3.x * p3.y, p3.x*p3.z, p3.y*p3.z));\n}\n\nvec3 noise3(float n) {\n    float f = fract(n);\n    n = floor(n);\n    f = f * f * (3.0 - 2.0 * f);\n    return mix(hash31(n), hash31(n + 1.0), f);\n}\n\nfloat fbm(vec3 x) {\n    float r = 0.;\n    float w = 1.;\n    float s = 1.;\n    for (int i = 0; i < 5; i++) {\n        w *= 0.5;\n        s *= 2.;\n        r += w * noise(s * x);\n    }\n    return r;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by SHAU - 2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n/* Camera and animation */\n\n#define T mod(iTime, LOOP_LENGTH)\n#define N_PATH_POINTS 38\n#define HW 0.55\n#define SW 1.2\n\n//Dave Hoskins - Pylon \n//https://www.shadertoy.com/view/XltSRf\n//Catmull-rom spline\nvec3 spline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t) {\n    \n    vec3 c2 = -0.5 * p0\t+  0.5 * p2;\n\tvec3 c3 =        p0\t+ -2.5 * p1 +  2.0 * p2 + -0.5 * p3;\n    vec3 c4 = -0.5 * p0\t+  1.5 * p1 + -1.5 * p2 +  0.5 * p3;\n\t\n    return(((c4 * t + c3) * t + c2) * t + p1);\n}\n\nvoid positionsAtTime(inout vec3 cameraPosition) {\n    \n    //initialise camera arrays\n    vec3 cameraPath[N_PATH_POINTS];\n    cameraPath[0]  = vec3( -2.,  5., 5.);\n    cameraPath[1]  = vec3( -2.,  5., 5.);\n    cameraPath[2]  = vec3( -2.,  5., 5.);\n    cameraPath[3]  = vec3( -2.,  5., 6.);\n    cameraPath[4]  = vec3( -2.,  5., 7.);\n    cameraPath[5]  = vec3( -1.,  5., 8.);\n    cameraPath[6]  = vec3( 0.,  5., 7.);\n    cameraPath[7]  = vec3( 1.,  6., 6.);\n    cameraPath[8]  = vec3( 2.,  6., 5.);\n    cameraPath[9]  = vec3( 3.,  7., 4.);\n    cameraPath[10] = vec3( 4.,  7., 3.);\n    cameraPath[11] = vec3( 5.,  7., 1.);\n    cameraPath[12] = vec3( 6.,  8., -1.);\n    cameraPath[13] = vec3( 6.,  8., -4.);\n    cameraPath[14] = vec3( 5.,  8., -8.);\n    cameraPath[15] = vec3( 4.,  8., -9.);\n    cameraPath[16] = vec3( 3.,  7., -10.);\n    cameraPath[17] = vec3( 2.,  7., -10.);\n    cameraPath[18] = vec3( 1.,  7., -9.);\n    cameraPath[19] = vec3( 0.,  7., -8.);\n    cameraPath[20] = vec3( -1.,  7., -7.);\n    cameraPath[21] = vec3( -2.,  7., -5.);\n    cameraPath[22] = vec3( -3.,  6., -1.);\n    cameraPath[23] = vec3( -4.,  5., 2.);\n    cameraPath[24] = vec3( -5.,  4., 6.);\n    cameraPath[25] = vec3( -4.,  3., 9.);\n    cameraPath[26] = vec3( -3.,  3., 11.);\n    cameraPath[27] = vec3( -1.,  4., 12.);\n    cameraPath[28] = vec3( 1.,  5., 12.);\n    cameraPath[29] = vec3( 2.,  6., 11.);\n    cameraPath[30] = vec3( 3.,  7., 10.);\n    cameraPath[31] = vec3( 2.,  8., 9.);\n    cameraPath[32] = vec3( 1.,  9., 7.);\n    cameraPath[33] = vec3( -1.,  8., 6.);\n    cameraPath[34] = vec3( -2.,  7., 5.);\n    cameraPath[35] = vec3( -2.,  6., 5.);\n    cameraPath[36] = vec3( -2.,  5., 5.);\n    cameraPath[37] = vec3( -2.,  5., 5.);\n\n    int nt = int(T);\n    float ft = fract(T);\n    \n    vec3 p0 = cameraPath[nt];\n    vec3 p1 = cameraPath[nt + 1];\n    vec3 p2 = cameraPath[nt + 2];\n    vec3 p3 = cameraPath[nt + 3];\n    \n    cameraPosition = spline(p0, p1, p2, p3, ft);    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    fragColor = vec4(0., 0., 0., 1.);\n    \n    vec3 cameraPosition, lookAtPosition = vec3( 0.,  7., 0.);\n    positionsAtTime(cameraPosition);\n\n    //body animation and joint positions\n    //dodgy walk animation using a few sin waves \n    float headRot = sin(max(T - 8., 0.)) * -step(T, 8. + PI);\n    headRot += sin(max(T - 26., 0.)) * 0.6;\n    float walkCycle = mod(T * 2.4, PI * 2.) - PI;\n    float bounce = abs(sin(walkCycle)) * 0.15;\n    vec3 leftHip = vec3(-HW, 4. + bounce, 0.);\n    vec3 rightHip = vec3(HW, 4. + bounce, 0.);\n    float leftThighAngle = sin(walkCycle) * 0.5;\n    float rightThighAngle = sin(walkCycle) * -0.5;\n    vec3 leftKnee = rotBone(leftHip, vec3(-HW, 2. + bounce, 0.), leftThighAngle);\n    vec3 rightKnee = rotBone(rightHip, vec3(HW, 2. + bounce, 0.), rightThighAngle);\n    float leftShinAngle = max(0., -leftThighAngle) + max(0., sin(walkCycle - PI * 0.5) * 0.8);\n    float rightShinAngle = max(0., -rightThighAngle) + max(0., sin(walkCycle - PI * 1.5) * 0.8);;\n    vec3 leftAnkle = rotBone(leftHip, vec3(-HW,  bounce, 0.), leftThighAngle); \n    vec3 rightAnkle = rotBone(rightHip, vec3(HW,  bounce, 0.), rightThighAngle);\n    leftAnkle = rotBone(leftKnee, leftAnkle, leftShinAngle);\n    rightAnkle = rotBone(rightKnee, rightAnkle, rightShinAngle);\n    vec3 leftShoulder = vec3(-SW, 6.6 + bounce, 0.);\n    vec3 rightShoulder = vec3(SW, 6.6 + bounce, 0.);\n    float leftShoulderElbowAngle = sin(-walkCycle) * 0.5;\n    float rightShoulderElbowAngle = sin(walkCycle) * 0.5;\n    vec3 leftElbow = rotBone(leftShoulder, vec3(-SW, 5.4 + bounce, 0.), leftShoulderElbowAngle);\n    vec3 rightElbow = rotBone(rightShoulder, vec3(SW, 5.4 + bounce, 0.), rightShoulderElbowAngle);\n    float leftElbowWristAngle = max(0., leftShoulderElbowAngle) * -1.;\n    float rightElbowWristAngle = max(0., rightShoulderElbowAngle) * -1.;\n    vec3 leftWrist = rotBone(leftShoulder, vec3(-SW, 4.4 + bounce, 0.), leftShoulderElbowAngle);\n\tvec3 rightWrist = rotBone(rightShoulder, vec3(SW, 4.4 + bounce, 0.), rightShoulderElbowAngle);\n    leftWrist = rotBone(leftElbow, leftWrist, leftElbowWristAngle);\n    rightWrist = rotBone(rightElbow, rightWrist, rightElbowWristAngle);\n    vec3 leftFingertip = leftWrist - vec3(0.3, 1. + bounce, 0.);\n    vec3 rightFingertip = rightWrist - vec3(-0.3, 1. + bounce, 0.);\n    \n    if (fragCoord == LOOK_AT) {   \n        fragColor = vec4(lookAtPosition, 0.);\n    } else if (fragCoord == CAM) {\n        fragColor = vec4(cameraPosition, 0.);\n    } else if (fragCoord == HEAD_ROT) {\n        fragColor = vec4(vec3(headRot), 0.);\n    } else if (fragCoord == LEFT_HIP) {\n        fragColor = vec4(leftHip, 0.);\n    } else if (fragCoord == LEFT_KNEE) {\n        fragColor = vec4(leftKnee, 0.);\n    } else if (fragCoord == LEFT_ANKLE) {\n        fragColor = vec4(leftAnkle, 0.);\n    } else if (fragCoord == RIGHT_HIP) {\n        fragColor = vec4(rightHip, 0.);\n    } else if (fragCoord == RIGHT_KNEE) {\n        fragColor = vec4(rightKnee, 0.);\n    } else if (fragCoord == RIGHT_ANKLE) {\n        fragColor = vec4(rightAnkle, 0.);\n    } else if (fragCoord == SPINE_BOTTOM) {\n        fragColor = vec4(0., 4. + bounce, 0., 0.);\n    } else if (fragCoord == SPINE_TOP) {\n        fragColor = vec4(0., 6.6 + bounce, 0., 0.);\n    } else if (fragCoord == HEAD) {\n        fragColor = vec4(0., 8. + bounce, 0.5, 0.);\n    } else if (fragCoord == LEFT_SHOULDER) {\n        fragColor = vec4(leftShoulder, 0.);\n    } else if (fragCoord == LEFT_ELBOW) {\n        fragColor = vec4(leftElbow, 0.);\n    } else if (fragCoord == LEFT_WRIST) {\n        fragColor = vec4(leftWrist, 0.);\n    } else if (fragCoord == LEFT_FINGERTIP) {\n        fragColor = vec4(leftFingertip, 0.);\n    } else if (fragCoord == RIGHT_SHOULDER) {\n        fragColor = vec4(rightShoulder, 0.);\n    } else if (fragCoord == RIGHT_ELBOW) {\n        fragColor = vec4(rightElbow, 0.);\n    } else if (fragCoord == RIGHT_WRIST) {\n        fragColor = vec4(rightWrist, 0.);\n    } else if (fragCoord == RIGHT_FINGERTIP) {\n        fragColor = vec4(rightFingertip, 0.);\n    }    \n}","name":"Buffer A","description":"","type":"buffer"}]}