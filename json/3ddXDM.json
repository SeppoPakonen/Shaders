{"ver": "0.1", "info": {"id": "3ddXDM", "date": "1572216658", "viewed": 381, "name": "Voronoi Malonie", "username": "pjkarlik", "description": "Voronoi shader - function from IQ's article/shader listed in the comments.\nWanted to play with some 2D as my skills mixing colors and shapes needs much improvement!\nMouse moves and changes noise (click + x/y)", "likes": 18, "published": 3, "flags": 0, "tags": ["flat"], "requires": ["imagebuf"]}, "renderpass": [{"inputs": [], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "// Practice with 2D shaders and mixing colors\n// and patterns. \n// Voronoi - Wooley noise\n\n#define time iTime * .3\n#define PI  3.1415926\n#define PI2 6.2831853\n\n// real world - id use colors coming from a web page\n// these are the basic rgb web colors - example\n// https://codepen.io/pjkarlik/pen/ExxwLGq \nvec3 colorA = vec3(150, 102, 73);\nvec3 colorB = vec3(89, 96, 107);\nvec3 colorC = vec3(89, 95, 88);\n\n/** alt color\nvec3 colorA = vec3(0, 100, 175);\nvec3 colorB = vec3(210, 125, 0);\nvec3 colorC = vec3(200, 170, 0);\n*/\n\n// normal the color from web to shader\n// takes in 255 => 1. makes it easier to use webcolor.\nvec3 normal_color( vec3 x ) {\n    return (x-min(x,1.))/(max(x,255.)-min(x,1.));\n}\n\n// alpha of a mouse thing - just easier to deal with\n// in once place. idea is that center x/y is 0 input.\nvec2 get_mouse(void) {\n    float ax = (iMouse.x - iResolution.x/2.)*.1;\n    float ay = (iMouse.y - iResolution.y/2.)*.1;  \n    return vec2(ax,ay);\n}\n\nvec2 hash2( vec2 p ) {\n\treturn fract(\n        sin(\n            vec2(\n                dot(p,vec2(44.3,25.7)),\n                dot(p,vec2(87.2,54.1)))\n           )*4258.4373);\n}\n\n// Copyright \u00a9 2013 Inigo Quilez\n// http://www.iquilezles.org/www/articles/voronoilines/voronoilines.htm\n// updated to a vec4 to return hash of object in grid\n\nvec4 voronoi( in vec2 x )\n{\n    vec2 mouse = get_mouse();\n    x.x += mouse.x*.5;\n    x.y += mouse.y*.5;\n    \n\tfloat wave = (time*.7) + mouse.x; // mouse.x; // time;\n    \n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\tfloat ox = 0.;\n\tvec2 mg, mr;\n\n    float md = 8.;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        ox = o.x;\n        o = .5 + .5 *sin(o * wave + PI2);\n        //o = .5 + .5 * sin( time + PI2 * o );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    md = 8.;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        ox = o.x;\n        o = .5 + .5 *sin(o * wave + PI2);\n        //o = .5 + .5 * sin( time + PI2 * o );\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec4( md, mr, ox );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/max(iResolution.x,iResolution.y);\n    // for fun effect \n    //uv = abs(uv-vec2(.5,.27));\n    vec2 buv = uv;\n    uv.y -= time * .1;\n    buv.y -= time * .13;\n    uv *= 6.5; \n    \n    vec2 uid = vec2(\n        \tfloor(uv.x),\n    \t\tfloor(uv.x)\n    \t);\n    \t\n    vec4 c = voronoi( uv );\n\tvec4 inset = voronoi( uv + vec2(.09,.06));\n    vec4 backv = voronoi( buv *25.5);\n    \n\tvec3 sle = vec3(c.z - c.x);\n    vec3 sne = vec3(c.y - c.x);\n    \n    vec3 col = vec3(1.);\n \tvec3 mate = vec3(1.);\n    vec3 dmate = vec3(1.);\n    \n    // color top layer\n    if(c.w<.25){\n       mate = normal_color(colorC);\n    } else if (c.w<.5) {\n       mate = normal_color(colorB);\n    } else if (c.w<.75) {\n       mate = normal_color(colorA);\n    } else {\n       mate = vec3( .8 );\n    }\n    \n    // color bottom layer\n    if(backv.w<.25){\n       dmate = normal_color(colorC);\n    } else if (backv.w<.5) {\n       dmate = normal_color(colorA);\n    } else if (backv.w<.75) {\n       dmate = normal_color(colorB);\n    } else {\n       dmate = vec3(.9);\n    }\n  \n    // Stripes from Shane https://www.shadertoy.com/view/XlXBzl\n    // his stuff is amazing!\n    float diag = clamp(sin((uv.x - uv.y)*PI2*30.)*1. + .95, 0., 1.)*.08 + .08;\n    \n \t// background voronoi pattern\n\tvec3 bkgnd = smoothstep( 0.01, 0.05, backv.x) * dmate;\n\n    float border = 1.-smoothstep( 0.04, 0.05, c.x);\n\tbkgnd = min(bkgnd,1.-border); // cut the background away from border\n\t\n    // shade which has the inner drop shadow\n    vec3 shade = smoothstep( -.01, 0.13, inset.x) * mate - diag;\n \tshade = min(shade,1.-border); // cut the shade away from border\n    \n    // highlights and offsets\n    vec3 hglt = clamp(sne + sle, 0., 1.);\n    \n    // Layering is hard and still quite frustating.. but this is pretty!\n    col = (border*.15) + bkgnd * sne + shade + border * sin(sle*2.4) - hglt*.5 * vec3(.4);\n    \n    // Solo variations\n    //col = vec3(4.5) * shade * diag + border * sin(sle*2.4);\n    \n\tfragColor = vec4(col,1.);\n}\n", "name": "Image", "description": "", "type": "image"}]}