{"ver":"0.1","info":{"id":"WlXBD2","date":"1597707899","viewed":177,"name":"You better run!","username":"pjkarlik","description":"A mix of things I've been playing with, just a cute landscape/terrain detour","likes":13,"published":3,"flags":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \tAs they say in the movies - RUN!!!!\n// \tpjk | 08/12-17/2020\n//\tHeight map ray marching\n//  Added some heat distortion, random\n//  lava balls and fake motion! \n//\n//////////////////////////////////////////\n\n\n#define SCALE .44\n#define MHEIGHT 5.0\n#define SHEIGHT 1.\n\n#define MAX_DIST \t75.\n#define PI  \t\t3.1415926\n#define R \t\t\tiResolution\n#define M \t\t\tiMouse\n#define T \t\t\tiTime\n#define S \t\t\tsmoothstep\n#define r2(a)  mat2(cos(a), sin(a), -sin(a), cos(a))\n#define hash2(a, b) fract(sin(a*1.2764745 + b*.9560333 + 3.) * 14958.5453)\n\nvec3 hitPoint;\n\n// second hash\nfloat hash(vec2 p) {\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// iMouse pos function\nvec3 get_mouse( vec3 ro ) {\n    float x = M.xy==vec2(0) ? 0. : -(M.y / R.y * 1. - .5) * PI;\n    float y = M.xy==vec2(0) ? 0. : (M.x / R.x * 2. - 1.) * PI;\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    return ro;\n}\n// cheap hight map\nfloat height_map(vec2 p) {\n    float height = noise(p * SCALE) * MHEIGHT;\n    height = floor(height / SHEIGHT) * SHEIGHT;\n    return height;\n}\n//@iq smooth union\nfloat su( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\nfloat glow = 0.;\nvec2 map (in vec3 pos) {\n    vec3 q = pos;\n    vec3 p = pos+vec3(0.,1.,iTime*6.85);\n    vec2 res = vec2(100.,-1.);\n\tfloat sz = 12.;\n    float hlf = sz/2.;\n    \n    vec3 qid = floor((q+hlf)/sz);\n    q = vec3(\n        mod(q.x+hlf,sz)-hlf,\n        q.y,\n        mod(q.z+hlf,sz)-hlf\n        );\n\n    // ground\n\tfloat height = height_map(p.xz) * SCALE;\n    float d = (p.y-height);\n    d = 1.+p.y - height;\n    hitPoint = p;\n\n    // rnd bouncy phases based on hash\n    float hsx = hash2(qid.x,qid.z);\n    hsx*=6.37;\n    float sw = -7.+pow(hsx+hsx*sin(hsx*25.+T*.75),1.);\n    float zw = .2*sin(hsx-T*2.10);\n\t// balls\n    float bs = length(q-vec3(sw*.1,sw,zw))-2.75;\n    glow += .1/(.01+bs*bs);\n    // merge balls and land\n    bs = su(bs,d,2.25);\n    if(bs<res.x) res = vec2(bs/1.65,height+q.y);\n    \n    return res;\n}\n\nvec3 get_normal(in vec3 p, float t) {\n    float e = 0.001*t;\n\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n}\n\nvec2 ray_march( in vec3 ro, in vec3 rd, int maxstep ) {\n    float t = .0;\n    float m = 0.;\n    for( int i=0; i<maxstep; i++ ) {\n        vec2 d = map(ro + rd * t);\n        m = d.y;\n        if(d.x<.0001*t||t>MAX_DIST) break;\n        t += d.x*.5;\n    }\n    return vec2(t,m);\n}\n\nvec3 get_hue(float rnd) {\n    return mix(vec3(.25,.3,.1),vec3(.5,.4,.1),rnd*2.);\n}\n\n// ACES tone mapping from HDR to LDR\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x) {\n    float a = 2.51,\n          b = 0.03,\n          c = 2.43,\n          d = 0.59,\n          e = 0.14;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    vec2 U = (2.*F.xy-R.xy)/max(R.x,R.y);\n    float mt = mod(T*.03,2.);\n    float zoom = mt<1.? -10.75 : 9.75;\n    vec3 ro = vec3(5.65*sin(T*.25),9.-4.+4.*sin(T*.18),zoom),\n         lp = vec3(0.,.4,.0);\n    \n    // sligth heat distortion at the bottom of the screen\n    U = mix(U, U+(sin(U*45.)*.0045),1.-U.y*1.15);\n    \n\t// uncomment to look around\n    //ro = get_mouse(ro);\n    vec3 cf = normalize(lp-ro),\n     \t cp = vec3(0.,1.,0.),\n     \t cr = normalize(cross(cp, cf)),\n     \t cu = normalize(cross(cf, cr)),\n     \t c = ro + cf * .75,\n     \t i = c + U.x * cr + U.y * cu,\n     \t rd = i-ro;\n\n    vec3 C = vec3(0.);\n    vec3 fC = vec3(.25,.3,.1);\n    \n    // sky clouds using same height map\n    float clouds = .0 - max(rd.y,0.0)*0.5; //@iq trick\n    vec2 sv = 1.5*rd.xz/rd.y;\n    clouds += 0.1*(-1.0+2.0*smoothstep(-0.1,0.1,height_map(sv*2.)));\n    vec3 sky = mix( vec3(clouds), fC, exp(-10.0*max(rd.y,0.0)) ) * fC; \n\n\t// trace \n    vec2 ray = ray_march(ro,rd,256);\n    float t = ray.x;\n\tfloat m = ray.y;\n\n    if(t<MAX_DIST) {\n\t\tvec3 p = ro + t * rd,\n             n = get_normal(p, t),\n             h = get_hue(m);\n\n        C += h * (ray.x*.025);\n        C = mix( C, fC, 1.-exp(-.000025*t*t*t));\n    } else {\n       C = mix( C, fC, 1.-exp(-.000025*t*t*t));\n       C += sky;\n    }\n    //\n\tC = ACESFilm(C);\n    C += min(glow*.1*vec3(.9,.4,.0),1.);\n    O = vec4(pow(C, vec3(0.4545)),1.0);\n}\n","name":"Image","description":"","type":"image"}]}