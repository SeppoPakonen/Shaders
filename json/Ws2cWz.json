{"ver": "0.1", "info": {"id": "Ws2cWz", "date": "1586463328", "viewed": 174, "name": "spectral prisms", "username": "stduhpf", "description": "Blackbody light diffracted by some prism, with montecarlo integration for the wavelengths", "likes": 13, "published": 1, "flags": 32, "tags": ["body"], "requires": ["texture", "library", "imagebuf"]}, "renderpass": [{"inputs": [{"id": "4dXGR8", "filepath": "/media/previz/buffer00.png", "previewfilepath": "/media/previz/buffer00.png", "type": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "\nvec4 rein(vec4 c){\n    c*=.05;\n    float l = dot(c.rgb,vec3(.2126,.7152,.0722));\n    return c/(1.+l);\n}\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fragColor = pow(rein(texture(iChannel0,uv)/float(iFrame+1)),vec4(1.0/2.4));\n}", "name": "Image", "description": "", "type": "image"}, {"inputs": [{"id": "4dXGR8", "filepath": "/media/previz/buffer00.png", "previewfilepath": "/media/previz/buffer00.png", "type": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dXGR8", "channel": 0}], "code": "const float size = 5.;\nfloat map(vec2 p){\n    float d = length(p-vec2(.5,-.0))-.1;\n    p*=size;\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return min(d,-length(p)*sign(p.y)/size);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec2 grad(vec2 p){\n    vec2 e = vec2(1e-3,0);\n    return normalize(map(p)-vec2(map(p-e),map(p-e.yx)));\n}\n\n/* //low dispersion glass for comparison\nfloat sellmeier(float wl, float b1, float b2, float b3, float c1, float c2, float c3){\n    float l = wl*1e-3;\n    l = wl*wl;\n    float s =1.+ b1*l/(l-c1)+b2*l/(l-c2)+b3*l/(l-c3);\n    \n    return sqrt(max(s,0.));\n    \n}\n\nfloat iorGlass(float wl){ //https://refractiveindex.info/?shelf=glass&book=BK7&page=SCHOTT\n    return sellmeier(wl,1.03961212,0.231792344,1.01046945,.00600069867,.0200179144,103.560653);\n}*/\n\n//high dispersion cristal\nfloat iorGlass(float wl){//https://refractiveindex.info/?shelf=glass&book=OHARA-TIH&page=TIH6\n    float l = wl*wl*1e-4;\n    return sqrt(3.1200483-0.012774901*l+0.042416181/l+0.0025526467/(l*l)-0.00011907015/(l*l*l));\n}\n\nfloat seed;\nint base;\nconst int primes[25] = int[](2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97);\n\nfloat haltonSeq(int i) {\n    #define PERIOD 256\n    const float phi = .5-.5*sqrt(5.);//\"most irrational\" number\n   \tfloat off = fract(phi*float((base+1)*(i/PERIOD)));\n    i=int((i%PERIOD));\n    int b=primes[base++%25];\n\t\tfloat r = 0.;\n    float f = 1.;\n    while(i>0){\n        r += (f/=float(b))*float((i%b));\n        i = i/b;\n    }\n    return fract(r+off); \n}\n\nfloat hash()\n{\n    return fract(seed+haltonSeq(iFrame));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.x-vec2(-0.2,0.0);\n    \n    seed = 0.;//bayer16(fragCoord);\n    //dithering adds too much divergence and lowers the performance, so i discarded it\n    base = 0;\n    vec2 lo = vec2(-1,-.7);\n    vec2 ld = normalize(vec2(1,.8+.0*(hash()-.5)));\n   \n    \n    float wl = 200.+700.*hash();\n    \n    vec3 l = spectrum_to_rgb(wl)*blackbody(wl,4000.)*.0000000001;\n    vec3 col = vec3(0);\n    for(int i=0;i++<2000;){\n        vec2 lop = lo;\n        float d = map(lo);\n        if(abs(d)<1e-4){\n            l*=.999;\n            vec2 n = grad(lo)*sign(d);\n            float ind = iorGlass(wl);\n            if(d>0.)\n                ind=1./ind;\n            vec2 rd = normalize(refract(ld,n,ind));\n            \n            float cti = dot(ld,n),ctt = dot(rd,n);\n            float fresnel = (cti-ind*ctt)/(cti+ind*ctt);\n            fresnel*=fresnel;\n            float fresnel2 = (ind*ctt-cti)/(cti+ind*ctt);\n            fresnel =clamp(.5*(fresnel+fresnel2*fresnel2),0.,1.);\n            \n           \tif(hash()<fresnel){\n                rd = reflect(ld,n);\n               \tlo+=2e-4*n;\n            }else{\n                lo-=2e-4*n;\n            }\n            ld=rd;\n            \n        }else{\n        \tlo+=abs(d)*ld;\n            /*\n            if(sign(d)<0.)\n            \tl*=exp2(-4.*abs(d));\n\t\t\t*/\n        }\n        col=max(l*smoothstep(3./iResolution.x,0.,sdSegment(uv,lo,lop)),col);\n        if(dot(lo,lo)>4.||dot(l,l)<.0000001)\n            break;\n    }\n    \n    \n    fragColor = texture(iChannel0,fragCoord/iResolution.xy)\n        +vec4(col+0.1*smoothstep(3./iResolution.x,0.,abs(map(uv))-.002),1.0);\n}", "name": "Buffer A", "description": "", "type": "buffer"}, {"inputs": [], "outputs": [], "code": "float red(float wl){\n    float a = 0.;\n    float b1 = wl-440.;\n    a+=exp2(-b1*b1*.004)*.3;\n    float b2 = wl-600.;\n\ta+=exp2(-b2*b2*(1.-sign(b2)*.4)*.001)*2.5;\n    return a;\n}\n\nfloat green(float wl){\n    float a = 0.;\n    float b1 = wl-540.;\n    a+=exp2(-b1*b1*.0008)*1.5;\n    return a;\n}\n\nfloat blue(float wl){\n    float a = 0.;\n    float b1 = wl-450.;\n    a+=exp2(-b1*b1*.0015)*2.;\n    return a;\n}\n\n\nfloat blackbody(float wl, float T){\n    float h = 6.6e-34; // Planck constant\n    float k = 1.4e-23; // Boltzmann constant\n    float c = 3e8;// Speed of light\n   \twl*=1e-9;\n    return  2.*h*(c*c)/(wl*wl*wl*wl*wl*(exp(h*c/(T*wl*k))-1.));\n}\n\nvec3 getRGB(float wl){\n    return vec3(red(wl),green(wl),blue(wl));\n}\nfloat gaussian(float x,float al, float mu, float s1, float s2){\n    float y = x-mu;\n    y/=y<0.?s1:s2;\n    return al*exp(-y*y*.5);\n}\n\n\nvec3 lambdatoXYZ(float wl){\n    return vec3( gaussian(wl, 1.056, 599.8, 37.9, 31.0)+gaussian(wl, 0.362, 442.0, 16.0, 26.7)+ gaussian(wl, -0.065, 501.1, 20.4, 26.2)\n                ,gaussian(wl, 0.821, 568.8, 46.9, 40.5)+gaussian(wl,0.286, 530.9, 16.3, 31.1)\n                ,gaussian(wl, 1.217, 437.0, 11.8, 36.0)+gaussian(wl, 0.681, 459.0, 26.0, 13.8));\n}\nconst mat3 xyz = mat3(\n\t3.240479, -1.537150, -0.498535,\n    -0.969256, 1.875992, 0.041556,\n    0.055648, -0.204043, 1.057311);\n\nvec3 spectrum_to_rgb(in float w){\n    float a = 0.;\n    float wl = w;\n\n    return lambdatoXYZ(w)*xyz-vec3(0,0,a);\n}\n\nfloat bayer2(vec2 v)\n{\n    v=floor(v);\n return fract(v.y*v.y*.75+v.x*.5);   \n}\nfloat bayer4(vec2 v)\n{\n    return bayer2(.5*v)*.25+bayer2(v);\n}\nfloat bayer8(vec2 v)\n{\n    return bayer4(.5*v)*.25+bayer2(v);\n}\nfloat bayer16(vec2 v)\n{\n    return bayer8(.5*v)*.25+bayer2(v);\n}\nfloat bayer32(vec2 v)\n{\n    return bayer16(.5*v)*.25+bayer2(v);\n}\nfloat bayer64(vec2 v)\n{\n    return bayer32(.5*v)*.25+bayer2(v);\n}\nfloat bayer128(vec2 v)\n{\n    return bayer64(.5*v)*.25+bayer2(v);\n}", "name": "Common", "description": "", "type": "common"}]}