{"ver":"0.1","info":{"id":"4d2czR","date":"1490639179","viewed":2600,"name":"Voxel Cone Tracing (old)","username":"Mathis","description":"Improved version here:\nhttps://www.shadertoy.com/view/WdlyWs\n\nThis is my take at Global illumination! Includes glossy reflections and indirect light in real time!","likes":78,"published":1,"flags":32,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define Aspect vec2(iResolution.x/iResolution.y,1.)\n//VoxelFetch\n#define i16 1./16.\n#define r32 vec2(256.,128.)/iResolution.xy\n#define r16 vec2(256.,16.)/iResolution.xy\n#define r8 vec2(64.,8.)/iResolution.xy\n#define o16 i16*(256./iResolution.x)\n#define o8 0.125*(64./iResolution.x)\n\nstruct Pixel { vec3 P; vec3 N; vec3 C; lowp int e; lowp float r; };\n\nfloat noise(vec3 p) {\n     p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract(fract( p.x*p.y*p.z*(p.x+p.y+p.z))*4625.3725+iTime);\n}\n\nmat3 TBN(vec3 N) {\n    vec3 Nb=normalize(cross(N,vec3(0.,1.,0.)));\n    vec3 Nt=normalize(cross(Nb,N));\n    return mat3(Nb.x,Nt.x,N.x,Nb.y,Nt.y,N.y,Nb.z,Nt.z,N.z);\n}\n\nmat3 TBN(vec3 N, vec3 p) {\n    vec3 Nt,Nb;\n    if (abs(N.x)>abs(N.y)) Nt=vec3(N.z,0.,-N.x)/sqrt(N.x*N.x+N.z*N.z);\n    else Nt=vec3(0.,-N.z,N.y)/sqrt(N.y*N.y+N.z*N.z);\n    Nb=normalize(cross(N,Nt));\n    Nt=normalize(cross(Nb,N));\n    //*\n    mat3 nm=mat3(Nt.x,Nb.x,N.x,Nt.y,Nb.y,N.y,Nt.z,Nb.z,N.z);\n    float ang=noise(p);\n    Nt=vec3(sin(ang),cos(ang),0.)*nm;\n    Nb=normalize(cross(N,Nt));//*/\n    return mat3(Nt.x,Nb.x,N.x,Nt.y,Nb.y,N.y,Nt.z,Nb.z,N.z);\n}\n\nvec2 PosToVt(vec3 p) {\n    float yy=floor(p.z*4.);\n    return vec2(p.x*0.125+floor(p.z*RES)*0.125-yy,\n                p.y*0.25+yy*0.25)*r32;\n}\n\nvec4 MIX32(vec3 pos) {\n    float f=fract(pos.z*32.);\n    vec2 uv=PosToVt(pos);\n    return mix(texture(iChannel0,uv),\ntexture(iChannel0,PosToVt(pos+vec3(0.,0.,IRES))),f);\n}\n\nvec4 MIX16(vec2 uv, float posz) {\n    //float uvminn=(floor(uv.x*16.)+IRES)*i16;\n   \t//vec2 uvv=clamp(uv,uvminn,uvminn+i16-i16*i16);\n    float f=fract(posz*16.);\n    return mix(texture(iChannel1,uv),\ntexture(iChannel1,uv+vec2(o16,0.)),f);\n}\n\nvec4 MIX8(vec2 uv, float posz) {\n    //float uvminn=(floor(uv.x*8.)+i16)*0.125;\n   \t//vec2 uvv=vec2(clamp(uv.x,uvminn,uvminn+0.125-0.125*0.125*0.5),uv.y);\n    float f=fract(posz*8.);\n    return mix(texture(iChannel2,uv),\ntexture(iChannel2,uv+vec2(o8,0.)),f);\n}\n\nvec4 VoxelFetch(vec3 pos, float lod) {\n    if (lod<1.) {\n    \treturn mix(MIX32(pos)\n        ,MIX16(vec2(pos.x*i16+floor(pos.z*16.)*i16,pos.y)*r16,pos.z)\n        ,lod);\n    } else {\n        return mix(\n        MIX16(vec2(pos.x*i16+floor(pos.z*16.)*i16,pos.y)*r16,pos.z)\n        ,MIX8(vec2(pos.x*0.125+floor(pos.z*8.)*0.125,pos.y)*r8,pos.z)\n        ,min(1.,lod-1.));\n    }\n}\n\nvec4 Cone(vec3 pos, vec3 dir, float ConeRatio) {\n    float dist=IRES+IRES*0.7*noise(pos);\n    float sD,sL,sW; vec3 sP; vec4 sC;\n    vec4 Col=vec4(0.,0.,0.,0.);\n//Tracing\n    for (int i=0; i<32; i++) {\n        sD=max(IRES,dist*ConeRatio);\n    \tsP=pos+dir*dist;\n        sL=log2(sD*RES);\n        sC=VoxelFetch(sP,sL);\n        sW=1.-Col.w;\n        Col=Col+sC*sW;//pow(sW,2.);\n        dist=dist+sD;\n    }\n    return Col;\n}\n\nvec4 Cone60(vec3 pos, vec3 dir) {\n    float dist=IRES;\n    float sL=0.;\n    float sD,sW; vec3 sP; vec4 sC;\n    vec4 Col=vec4(0.,0.,0.,0.);\n//Tracing\n    for (int i=0; i<6; i++) {\n    \tsP=pos+dir*dist;\n        sC=VoxelFetch(sP,sL);\n        sW=1.-Col.w;\n        Col=Col+sC*sW;\n        sL=sL+1.;\n        dist=dist*2.;\n    }\n    return Col;\n}\n\nbool TraceRay(vec3 pos, vec3 dir, out Pixel R) {\n    Info t; float dist=0.; R.P=pos;\n    //while (dist<4.) {\n    for (int i=0; i<64; i++) {\n    if (dist>4.) break;\n        R.P=pos+dir*dist;\n        t=DF(R.P,iTime);\n        if (t.d<0.002) {\n            R.C=t.c;\n            R.N=Gradient(R.P,iTime);\n            R.e=t.e; R.r=t.r;\n            return true;\n        }\n        dist=dist+t.d;\n    }\n    return false;\n}\n\nfloat Shadows(vec3 Pos, vec3 Dir, float MaxDist, float ConeRatio) {\n    Info t; float Dist=0.; float Occ=1.; float sD;\n    while (Dist<MaxDist) {\n        t=DF(Pos+Dir*Dist,iTime);\n        if (t.d<0.001) return 0.;\n        sD=Dist*ConeRatio;\n        Occ=min(Occ,t.d/sD);\n        Dist=Dist+t.d;\n    }\n    return Occ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n//Light Direction\n    float LightAngle=-(iMouse.x/iResolution.x)*2.-2.;\n    vec3 LD=normalize(vec3(sin(LightAngle),-((iMouse.y/iResolution.y)*2.-1.),cos(LightAngle)));\n//Camera\n    vec2 uv=fragCoord.xy/iResolution.xy;\n    float Rot=3.14159;//(iMouse.x/iResolution.x)*3.14*0.+3.14;\n\tvec3 Pos=vec3(0.5+sin(Rot),0.8,0.5+cos(Rot));\n\tmat3 MM=TBN(-normalize(Pos-vec3(0.5,0.4,0.5)));\n    vec3 Dir=normalize(vec3((uv*2.-1.)*Aspect,1.)*MM);\n//Trace\n    vec3 col=vec3(0.);\n    Pixel Hit;;\n    if (TraceRay(Pos,Dir,Hit)) {\n        if (Hit.e==1) col=Hit.C;\n        else {\n            //Direct Light\n            col=Hit.C*(((Hit.r==0.)?1.:Hit.r*Hit.r)*max(0.,dot(Hit.N,LD))\n                      *Shadows(Hit.P+LD*0.02,LD,10.,0.25));\n            //Reflections\n            vec3 HP=Hit.P+Hit.N*IRES;\n      \t\tif (Hit.r!=0.) col+=Cone(HP,reflect(Dir,-Hit.N),Hit.r).xyz;\n            //Indirect light\n            //*\n            mat3 MM=TBN(Hit.N,Hit.P);\n    col=col+(Cone60(HP,Hit.N).xyz\n    +Cone60(HP,vec3(0.707,0.,0.707)*MM).xyz*0.7\n    +Cone60(HP,vec3(-0.707,0.,0.707)*MM).xyz*0.7\n    +Cone60(HP,vec3(0.,0.707,0.707)*MM).xyz*0.7\n    +Cone60(HP,vec3(0.,-0.707,0.707)*MM).xyz*0.7)*0.2*Hit.C; //*/\n        }\n    }\n    fragColor=vec4(pow(col,vec3(0.45)),1.0);\n\t//fragColor=vec4(pow(texture(iChannel0,uv).xyz,vec3(0.45)),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*float Shadows(vec3 Pos, vec3 Dir, float MaxDist, float ConeRatio) {\n    Info t; float Dist=0.; float Occ=1.; float sD,Dif;\n    while (Dist<MaxDist) {\n        t=DF(Pos+Dir*Dist,iTime);\n        if (t.d<0.001) return 0.;\n        sD=Dist*ConeRatio;\n        Dif=t.d-sD;\n        Occ=Occ*((Dif<0.)?(sD*2.+Dif)/(sD*2.):1.);\n        Dist=Dist+t.d;\n    }\n    return Occ;\n} //*/\n\nfloat Shadows(vec3 Pos, vec3 Dir, float MaxDist, float ConeRatio) {\n    Info t; float Dist=0.; float Occ=1.; float sD;\n    while (Dist<MaxDist) {\n        t=DF(Pos+Dir*Dist,iTime);\n        if (t.d<0.001) return 0.;\n        sD=Dist*ConeRatio;\n        Occ=min(Occ,t.d/sD);\n        Dist=Dist+t.d;\n    }\n    return Occ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 col=vec4(0.,0.,0.,0.);\n    if (fragCoord.y<128. && fragCoord.x<256.) {\n        vec3 Pos=VtToPos(floor(fragCoord));\n        Info t=DF(Pos,iTime);\n        if (t.d<IRESH) {\n            if (t.e==1) col=vec4(t.c,1.-max(0.,t.d*64.)); //Emissive\n            else {\n                float LightAngle=-(iMouse.x/iResolution.x)*2.-2.;\n    \t\t\tvec3 LD=normalize(vec3(sin(LightAngle)\n                ,-((iMouse.y/iResolution.y)*2.-1.),cos(LightAngle)));\n    \t\t\t//vec3 LD=normalize(vec3(sin(LightAngle),0.5,cos(LightAngle)));\n                vec3 N=Gradient(Pos,iTime);\n                col=vec4(t.c\n                    *max(0.,dot(N,LD))*Shadows(Pos+N*IRES,LD,10.,0.25),\n                1.-max(0.,t.d*64.));\n            }\n        }\n    }\n    fragColor=col;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define r32 vec2(256.,128.)/iResolution.xy\n#define i16 1./16.\n\nvec2 PosToVt(vec3 p) {\n    float yy=floor(p.z*4.);\n    return vec2(p.x*0.125+floor(p.z*RES)*0.125-yy,\n                p.y*0.25+yy*0.25\n           )*r32;\n}\n\nvec4 MipMap(vec3 pos) {\n    return (texture(iChannel0,PosToVt(pos))\n    +texture(iChannel0,PosToVt(pos+vec3(0.,0.,IRES)))\n    +texture(iChannel0,PosToVt(pos+vec3(0.,IRES,0.)))\n    +texture(iChannel0,PosToVt(pos+vec3(0.,IRES,IRES)))\n    +texture(iChannel0,PosToVt(pos+vec3(IRES,0.,0.)))\n    +texture(iChannel0,PosToVt(pos+vec3(IRES,0.,IRES)))\n    +texture(iChannel0,PosToVt(pos+vec3(IRES,IRES,0.)))\n    +texture(iChannel0,PosToVt(pos+vec3(IRES,IRES,IRES))))*0.125;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 col=vec4(0.,0.,0.,0.);\n    if (fragCoord.y<16. && fragCoord.x<256.) {\n        vec3 p=vec3(floor(fract(fragCoord.x*i16)*16.)*i16\n                    ,floor(fragCoord.y)*i16\n                    ,floor(fragCoord.x*i16)*i16)+IRES*0.5;\n        col=MipMap(p);\n    }\n    fragColor=col;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define r16 vec2(256.,16.)/iResolution.xy\n#define i8 1./8.\n#define oX (1./256.)*(256./iResolution.x)\n#define oY (1./16.)*(16./iResolution.y)\n#define oZ (1./16.)*(256./iResolution.x)\n\nvec4 MipMap(vec2 pvt) {\n    return (texture(iChannel0,pvt)\n    +texture(iChannel0,pvt+vec2(oX,0.))\n    +texture(iChannel0,pvt+vec2(0.,oY))\n    +texture(iChannel0,pvt+vec2(oX,oY))\n    +texture(iChannel0,pvt+vec2(oZ,0.))\n    +texture(iChannel0,pvt+vec2(oZ+oX,0.))\n    +texture(iChannel0,pvt+vec2(oZ,oY))\n    +texture(iChannel0,pvt+vec2(oZ+oX,oY)))*i8;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 col=vec4(0.,0.,0.,0.);\n    if (fragCoord.y<8. && fragCoord.x<64.) {\nvec2 pvt=(vec2(floor(fragCoord.x*0.125)*0.125\n+floor(fract(fragCoord.x*0.125)*8.)*0.125*0.125*0.5\n,floor(fragCoord.y)*0.125)+vec2(0.5/256.,1./32.)*0.)*r16;\n        col=MipMap(pvt);\n    }\n    fragColor=col;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define eps vec2(0.001,0.)\n#define RES 32.\n#define IRES 1./32.\n#define IRESH IRES*0.5\n#define IRESO IRES*0.5\n\nstruct Info { lowp vec3 c; lowp int e; lowp float r; highp float d; };\n\nfloat Box(vec3 p, vec3 b) {\n    vec3 d = abs(p)-b;\n    return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\n}\n\nInfo minn(Info a, Info b) {\n    if (a.d<b.d) return a; else return b;\n}\n\nInfo DF(vec3 p, float Time) {\n    Info df=Info(vec3(0.),0,0.,10000.);\n//*\n//Yellow Sphere\n    df=minn(df,Info(vec3(1.,1.,0.),0,0.,\n    length(p-vec3(0.7,0.25+sin(Time)*0.25+0.25,0.5))-0.2));\n//Reflective Sphere\n    df=minn(df,Info(vec3(1.),0,0.1,\n    length(p-vec3(0.3,0.2,0.75))-0.15));\n//Sides\n    df=minn(df,Info(vec3(1.,0.,0.),0,0.,\n                    Box(p-vec3(0.,0.5,0.5),vec3(0.05,0.5,0.5))));\n    df=minn(df,Info(vec3(0.,1.,0.),0,0.,\n                    Box(p-vec3(1.,0.5,0.5),vec3(0.05,0.5,0.5))));\n//Floor\n    df=minn(df,Info(vec3(1.,1.,1.),0,0.2*0.,\n                    Box(p-vec3(0.5,0.,0.5),vec3(0.55,0.05,0.5))));\n//2 Ceiling\n    df=minn(df,Info(vec3(1.,1.,1.),0,0.,\n                    Box(p-vec3(0.2,1.,0.5),vec3(0.3,0.05,0.5))));\n//Back\n    df=minn(df,Info(vec3(1.,1.,1.),0,0.,\n                    Box(p-vec3(0.5,0.5,1.),vec3(0.5,0.5,0.05))));\n//*/\n    \n/*\n//Floor\n    df=minn(df,Info(vec3(1.,1.,1.),0,0.2*0.,\n    Box(p-vec3(0.5,0.,0.5),vec3(0.5,IRESH,0.5))));\n//Floor\n    df=minn(df,Info(vec3(1.,1.,1.),0,0.2*0.,\n    Box(p-vec3(0.5,IRES*3.,0.5),vec3(IRES,IRES*3.,IRES))));\n//*/\n\t\n    return df;\n}\n\nvec3 VtToPos(vec2 uv) {\n    return vec3(mod(uv.x,RES)*IRES,\n                fract(uv.y*IRES),\n\t\t\t\tfloor(uv.x*IRES)*IRES+floor(uv.y*IRES)*0.25\n           )+IRESO;\n}\n\nvec3 Gradient(vec3 p, float Time) {\n    return normalize(vec3(\n        DF(p+eps.xyy,Time).d-DF(p-eps.xyy,Time).d,\n        DF(p+eps.yxy,Time).d-DF(p-eps.yxy,Time).d,\n        DF(p+eps.yyx,Time).d-DF(p-eps.yyx,Time).d\n    ));\n}","name":"Common","description":"","type":"common"}]}