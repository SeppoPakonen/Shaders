{"ver": "0.1", "info": {"id": "Nsd3Wl", "date": "1630873797", "viewed": 213, "name": "Mysterious Roman Dodecahedron", "username": "sylvain69780", "description": "While visiting the Lugdunum Museum at Lyon (France) I was [url=https://sylvain69780.github.io/assets/images/roman_dodecahedron.jpg]shocked by a very strange artifact ! [/url]\nYou can play with it. Try to create your own Roman dodecahedron !", "likes": 23, "published": 1, "flags": 0, "usePreview": 0, "tags": [], "requires": ["library", "imagebuf"]}, "renderpass": [{"inputs": [], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "/*\n \n    Mysterious Roman dodecahedron\n    -----------------------------\n    \n    While visiting the Lugdunum Museum at Lyon (France) I was shocked by a very strange artifact ! \n    \n    A Roman dodecahedron or Gallo-Roman dodecahedron is a small hollow object \n    made of copper alloy which has been cast into a regular dodecahedral shape: \n    twelve flat pentagonal faces, each face having a circular hole of varying \n    diameter in the middle, the holes connecting to the hollow center. \n    Roman dodecahedra date from the 2nd to 4th centuries AD.    \n\n    Some people suggested it is a simple tool to make gloves because they are found \n    only on the north of Europe, I prefer to think it's a kind of magic object. \n    We will probably never know !\n    \n    It's amazing what people were able to do even before Shadertoy was created.\n\n    Related references:\n    \n    Roman dodecahedron - Wikipedia\n    https://en.wikipedia.org/wiki/Roman_dodecahedron\n\n    icosahedronal symmetry & Icosahedron Weave - DjinnKahn\n    https://www.shadertoy.com/view/Mly3R3\n    https://www.shadertoy.com/view/Xty3Dy\n\n    Polyhedron again - knighty\n    https://www.shadertoy.com/view/XlX3zB\n\n    Polyhedrons, many many polyhedrons... - Fractalforums\n    https://www.fractalforums.com/fragmentarium/solids-many-many-solids/30/\n        \n    Wythoff Mathematical Details - Greg Egan\n    http://www.gregegan.net/APPLETS/26/WythoffNotes.html\n        \n    heavy metal squiggle orb - mattz\n    https://www.shadertoy.com/view/wsGfD3\n\n    IQ Distance functions\n    https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n    smooth minimum - IQ\n    https://iquilezles.org/www/articles/smin/smin.htm\n    \n    soft shadows in raymarched SDFs - IQ\n    http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n\n    RayMarching starting point - BigWIngs\n    https://shadertoy.com/view/WtGXDD\n    \n    Wythoff Polyhedra with Exact SDF - mla\n    https://www.shadertoy.com/view/WlccR8\n\n*/\n\n/*\n    I'am not a professional graphic programmer but will try an explanation with my words.\n    All this is based on **tiling** the sphere with **Schwarz triangles** and reflexions\n    This is based on space **folding**, a technic experimented by knighty a decade ago (see also KIFS fractals)\n    All the cartesian space will be folded to a domain limited between 3 intersecting plans (xz,yz,n) giving 3 directions (P,Q,R)\n    the Wythoff construction allows to compute many polyhedra using this spherical tiling (see references)\n    \n    this is a (P, Q, R) **spherical** triangle with **fractions of PI** for the angles Q=3 and R=2 (mattz ascii art below)\n    \n      Q=3 *--__\n          |    ^^--__\n      R=2 *----------* P = 5\n    \n    When p=5 this is the Icosahedral symetry\n    **Don't be shocked** if the sum of the angles PI/2+PI/3+PI/5 is more than PI (180\u00b0)\n    This equality is true on a plane but we are on a sphere and not on a plane !\n    On a projected flat triangle on the XY plane, RP is X axis, RQ is Y axis\n    Without any change in the projection plan, the shape generated by the distance in z direction is a Rhombic Triacontahedron\n    with 30 rhombic faces made of 4 coplanar triangles\n    If we bend the triangle projection plan in the good direction, we can build an Icosahedron or a Dodecahedron.\n    R is the middle of an edge of the Ico or Dode\n    Q is the vertex of a Dode, middle of the face of an Ico\n    P is the vertex of an Ico, middle of the face of a Dode\n\n    We focus only on the Icosahedron and the Dodecaheron, the goal is to get rounded edges \n    like in the DjinnKahn's shader.\n    By playing with distance functions, one can get many fascinating shapes !\n\n    This is a wonderfull playgroud for trigonometry's hacker.\n    \n    Regarding the lighting, it is done using IQ's Blinn-Phong specular formula (I love it !)\n*/\n\nfloat GetDistDodecahedron(vec3 p) {\n    // Dodecahedron distance to a face\n    vec3 q = p;\n    q -= ICOMIDEDGE; // walking from center to an edge\n     // rotation among the edge (Y axis for the Dode) to align the face\n    q.xz *= Rot(DODEDIHEDRAL*.5); // smoothly folds the face on the Y axis\n    // draws a face, rounded at the corners\n    float dDode = length(max(vec3(-q.x,q.y - Y_TO_DODE_VERTEX,q.z), 0.))+min(q.z, 0.);\n    dDode = abs(dDode-.025)-.05; // onioning and rounding\n    // Holes are centered on the dodecaheron's faces center\n    float dHole = length( vec2(q.x - X_TO_DODE_CENTER,q.y) ) - .3;    \n    // Smaller circles are centered somewhere between the middle of the face and the vertex of the Ico\n    float dSmallHole = length( q.xy-mix(vec2(0.0,Y_TO_DODE_VERTEX),vec2(X_TO_DODE_CENTER,0.0),.3) ) - .07;\n    dSmallHole = abs(dSmallHole)-.030;\n    dSmallHole = abs(dSmallHole)-.020;\n    // Spheres on the vertices (dodecahedron's vectrices are icosahedron face's centers)\n    float dCorners = length(p - ICOMIDFACE * 1.24)-.12;    \n    // blobby cross picked from IQ's magic box\n    float dBlobbyCross = sdBlobbyCross(vec2(q.x-X_TO_DODE_CENTER*.2,q.y)*13.0,0.80)/13.0-.03;\n    // shaking mixing the distances\n    float dist = dDode;\n    dist = smax(dist,-dSmallHole,.01);\n    dist = smax(dist,-dHole,.02);\n    dist = smax(dist,-dBlobbyCross,.01);\n    dist = smin(dist,dDode+.005,.02);\n    dist = smax(dist,-(dHole+.1),.04);\n    dist = smin(dist,dCorners,.07);\n    return dist;\n}\n\nfloat GetDistIcosahedron(vec3 p) {\n    // Icosahedron distance to a face\n    vec3 q = p;\n    q -= ICOMIDEDGE; // walking from center to an edge\n     // rotation among the edge (X axis for the Dode) to align the face\n    q.yz *= Rot(ICODIHEDRAL*.5); // smoothly folds the face on the X axis\n    // draws a face, rounded at the corners\n    float dIco = length(max(vec3(q.x - X_TO_ICO_VERTEX,-q.y,q.z), 0.))+min(q.z, 0.);\n    dIco = abs(dIco-.025)-.05; // onioning and rounding\n    // Circles are centered on the icosahedron's faces\n    float dBigHole = length(q.xy - vec2(0.0,Y_TO_ICO_CENTER))-.16;\n    dBigHole = abs(dBigHole)-.08;\n    dBigHole = abs(dBigHole)-.04;\n    dBigHole = abs(dBigHole)-.02;\n    // Smaller circles are centered somewhere between the middle of the face and the vertex of the Ico\n    float dSmallHole = length( q.xy - mix(vec2(0.0,Y_TO_ICO_CENTER),vec2(X_TO_ICO_VERTEX,0.0),.63) ) - .07;\n    dSmallHole = abs(dSmallHole)-.04;\n    dSmallHole = abs(dSmallHole)-.02;\n    // little chains of spheres on the edges\n    float dEdges = length(q-vec3(round(q.x*20.0)/20.0,0.0,0.1))-.03;\n    // Corners of the Ico\n    q = p;\n    q -= ICOVERTEX * 1.3; // distance from center to an edge\n    q.xz *= Rot(DODEDIHEDRAL*.5); // smoothly folds the face on the Y axis\n    float dCorners = length(q)-.04*(1.0+.5*sin(q.z*50.0));    \n    // shaking mixing the distances\n    float dist = dIco;\n    dist = smax(dist,-dBigHole,.01);\n    dist = smax(dist,-dSmallHole,.01);\n    dist = smin(dist,dIco+.005,.01);\n    dist = smin(dist,dCorners-.13,.1);\n    dist = min(dist,dEdges);\n    \n    return dist;\n}\n\nfloat GetDistSmallStellatedDodecahedron(vec3 p) {\n    float zoom = 0.70;\n    float dist = 1e10;\n    p /= zoom;\n    float dStella,dBase;\n    {\n        vec3 q = p;\n        q -= ICOMIDEDGE; // walking from center to an edge\n        q.zx *= Rot(DODEDIHEDRAL*.5); \n        // draws a face, rounded at the corners\n        // Derived from IQ's orented box to get a rounded oridented edge \n        vec2 border = vec2(X_TO_DODE_CENTER/cos(DODEDIHEDRAL),Y_TO_DODE_VERTEX);\n        float l = length(border);\n        vec2  d = vec2(border.x,-border.y)/l;\n        vec2 e = q.xy;\n        e.y -= border.y; // from Dode vertex\n        e = mat2(d.x,-d.y,d.y,d.x)*e;   // rotation\n        e = vec2(abs(e.x-l*.5)-l*.5,e.y); // to center\n        dStella = length(max(vec3(e.xy,q.z), 0.))+min(q.z, 0.);\n        dist = dStella-.1;\n        float dHorseShoe = sdHorseshoe(q.yx-vec2(0.0,0.4),vec2(sin(0.45),cos(0.45)),.14,vec2(.04));\n        dist = smax(dist,-dHorseShoe,.02); \n        dist = min(dist,dStella-.05); \n        float pen = clamp(q.x-l*.55,0.0,0.48);\n        dist = dist - 0.01*smoothstep(-0.3,0.9,sin(pen*3.14*20.));\n        \n    }\n    {\n        vec3 q = p;\n        q.z -= 1.15; \n        dBase = q.z;\n        q.yz *= Rot(ICODIHEDRAL*.5); \n        dBase = smax(dBase,q.z-.13,.01);\n        dist = smin(dist,dBase,.01);\n    }\n    return dist * zoom;\n}\n\nfloat GreatDodecahedron(vec3 p) {\n    float zoom = 0.99;\n    float dist = 1e10;\n    p /= zoom;\n    vec3 q = p;\n    q -= ICOMIDEDGE; // walking from center to an edge\n    q.zy *= Rot(-ICODIHEDRAL);\n    dist = sdSegment(q,vec3(X_TO_ICO_VERTEX,0.0,0.0),vec3(0.0,Y_TO_DODE_VERTEX,0.0))-.02;\n    vec2 qqq = q.xy;\n    q.x -= X_TO_ICO_VERTEX;\n    vec3 qq = q;\n    q.y = - q.y;\n    dist = min(dist,length(max(q, 0.0)) + min(q.z, 0.0));\n    dist -= .1;\n    vec2 d = normalize(vec2(-X_TO_ICO_VERTEX,Y_TO_DODE_VERTEX));\n    qq -= vec3(0.0,-.08,0.1);\n    dist = min(dist,length(qq-vec3(clamp(round(dot(qq.xy,d)*15.0),3.0,10.0)/15.*d,0.0))-.025);\n    qqq.y = 0.22-qqq.y;\n    dist = smax(dist,-sdHeart(qqq*5.)/5.,.025);\n    return dist * zoom;\n}\n\nfloat Ico(vec3 p) {\n    vec3 q = p;\n    q.z -= 1.; // distance from center to an edge\n    q.yz *= Rot(ICODIHEDRAL*.5); // smoothly folds the face on the X axis\n    float dIco = length(max(vec3(q.x - X_TO_ICO_VERTEX,-q.y,q.z), 0.))+min(q.z, 0.);\n    return dIco;\n}\n\nfloat GreatStellatedDodecahedron(vec3 p) {\n    float zoom = 0.5;\n    float dist = Ico(p/.52)*.52-.1;\n    p /= zoom;\n    vec3 q = p;\n    q -= ICOMIDEDGE; // walking from center to an edge\n    q.zy *= Rot(PI*.5-DODEDIHEDRAL*.5);\n    vec2 border = vec2(Y_TO_DODE_VERTEX/cos(PI*.5-DODEDIHEDRAL*.5+ICODIHEDRAL*.5),X_TO_ICO_VERTEX);\n    float l = length(border);\n    vec2  d = vec2(border.x,-border.y)/l;\n    vec2 e = q.yx;\n    e.y -= border.y; // from ico vertex\n    e = mat2(d.x,-d.y,d.y,d.x)*e;   // rotation to align x with the edge\n    e = vec2(abs(e.x-l*.5)-l*.5,e.y); // to edge center\n    float dStella = length(max(vec3(e.xy,q.z), 0.))+min(q.z, 0.);\n    dist = min(dist,dStella-.1);\n    return dist * zoom;\n}\n\n\nfloat GetDist(vec3 p) {\n    const float nShapes = 5.;\n    float timeLine = fract(T*0.1/nShapes)*nShapes;\n    p.zx *= Rot(T);\n    p = opIcosahedron(p);\n    float z = smoothstep(0.0,0.05,1.0-cos(timeLine*6.28));\n    float d = 1e10;\n    if ( timeLine < 1.0 ) {\n        d = GetDistDodecahedron(p/z)*z;\n    } else if ( timeLine < 2.0 ) {\n        d = GetDistIcosahedron(p/z)*z;\n    } else if ( timeLine < 3.0 ) {\n        d = GetDistSmallStellatedDodecahedron(p/z)*z;\n    } else if ( timeLine < 4.0 ) {\n        d = GreatDodecahedron(p/z)*z;\n        } else d = GreatStellatedDodecahedron(p/z)*z;\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<24; i++ )\n    {\n\t\tfloat h = GetDist( ro + rd*t );\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.33*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 orange = vec3(1.00,.25,0.01);\n    vec3 sun   = vec3(1.64,1.27,0.99);\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0, 1, -2.8);\n    if ( iMouse.x > 0.0 ) {\n        ro.yz *= Rot(-m.y*3.14);\n        ro.xz *= Rot(-m.x*6.2831);\n    }    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.0);\n    vec3 col = orange*(1.-abs(rd.y)); // fast gradient - \"the sky will be blue\" - https://youtu.be/Cfe5UQ-1L9Q?t=2795\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 nor = GetNormal(p);\n        float occ = max(.1,calcOcclusion(p,nor));\n        vec3  lig1 = normalize( vec3( 0.10, 1.50, 0.40) );\n        vec3  lig2 = normalize( vec3(-1.50,-1.00, -1.00) );\n        vec3  lig3 = normalize( vec3( 1.50,-1.00, -1.00) );\n        vec3  lig1_hal = normalize( lig1-rd );\n        vec3  lig2_hal = normalize( lig2-rd );\n        vec3  lig3_hal = normalize( lig3-rd );\n        // IQ's Blinn-Phong specular formula\n        float lig1_dif = max(0.0,dot(nor,lig1));\n        float lig1_spe = pow(clamp(dot(nor,lig1_hal),0.0,1.0),8.0)*lig1_dif*(0.04+0.96*pow(clamp(1.0+dot(lig1_hal,rd),0.0,1.0),5.0));\n        float lig2_dif = max(0.0,dot(nor,lig2));\n        float lig2_spe = pow(clamp(dot(nor,lig2_hal),0.0,1.0),8.0)*lig2_dif*(0.04+0.96*pow(clamp(1.0+dot(lig2_hal,rd),0.0,1.0),5.0));\n        float lig3_dif = max(0.0,dot(nor,lig3));\n        float lig3_spe = pow(clamp(dot(nor,lig3_hal),0.0,1.0),8.0)*lig3_dif*(0.04+0.96*pow(clamp(1.0+dot(lig3_hal,rd),0.0,1.0),5.0));\n        float sha1 = calcSoftshadow( p+0.01*nor, lig1, 0.01, 2.1 );\n        vec3 r = reflect(rd, nor);\n\n        col = vec3(.01) * lig1_dif * sha1;\n        col *= lig3_dif * lig3_dif * occ * occ;\n        col += 10.0 * lig1_spe * sun * sha1;\n        col += 5.0 * lig2_spe * orange * occ;\n        col += 5.0 * lig3_spe * orange * occ;\n        \n        \n    } \n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}\n", "name": "Image", "description": "", "type": "image"}, {"inputs": [], "outputs": [], "code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define T iTime*.3\n\nconst float PI = 3.14159265359;\nconst float PHI = (1.+sqrt(5.))/2.;\n\n// Normal of a plan having a dihedral angle of PI/3 with the YZ plan and PI/5 with the XZ plane\nconst float CP = cos(3.1415/5.), SP=sqrt(0.75-CP*CP);\nconst vec3  P35 = vec3(-0.5, -CP, SP);\n\n// Dihedral angles of the Dode. and Ico.\n// https://en.wikipedia.org/wiki/Table_of_polyhedron_dihedral_angles\n\nconst float ICODIHEDRAL  = acos(sqrt(5.)/3.);  \nconst float DODEDIHEDRAL = acos(sqrt(5.)/5.);\n\n// below are the directions from the origin limiting the coordniate's domain after folding space\nconst vec3 ICOMIDEDGE = vec3(0,0,1);\nconst vec3 ICOVERTEX  = normalize(vec3(SP,0.0,0.5)); // direction in the XZ plan, you will find the ICO vertex on this line\nconst vec3 ICOMIDFACE = normalize(vec3(0.0,SP,CP));  // direction in the YZ plan, you will find the DODE vertex on this line\n\n/*\n                Y_TO_DODE_VERTEX\n                Y_TO_ICO_CENTER (after ICODIHEDRAL rotation on X axis)\n                \n                         ** \n                      ********\n                   ***   **    ***\n                ***      **       ***\n             ***         **          ***\n          ***            **             ***\n       ***               **                ***\n    ***                  ** (0,0)             ***\n ***************************************************  X_TO_ICO_VERTEX\n    ***                  **                   ***    X_TO_DODE_CENTER (after DODEDIHEDRAL rotation on Y axis)\n       ***               **                ***\n          ***            **             ***\n             ***         **          ***\n                ***      **       ***\n                   ***   **    ***\n                      ********\n                         ** \n\n*/\n\n// below the X and Y dimensions of the triangles forming the Ico. and Dode. faces\n// 10 triangles (5 pairs) for the Dode., 6 (3 pairs) for the Ico.\n// In order to get and exact distance for the edges\n// I reproduced the DjinnKahn's idea but my approach is to walk on the axis from the origin (that is on ICOMIDEDGE) to the vertices.\n// The advantage is that the can use XY coordinates to draw some nice shapes on the faces of the figures.\n// provided you use shapes with 1/2 , 1/3 or 1/5 symetries\n\nconst float X_TO_ICO_VERTEX  = length(cross(ICOMIDEDGE,ICOVERTEX))/dot(ICOMIDEDGE,ICOVERTEX);\nconst float Y_TO_DODE_VERTEX = length(cross(ICOMIDEDGE,ICOMIDFACE))/dot(ICOMIDEDGE,ICOMIDFACE);\nconst float X_TO_DODE_CENTER = X_TO_ICO_VERTEX*cos(DODEDIHEDRAL*.5);\nconst float Y_TO_ICO_CENTER  = Y_TO_DODE_VERTEX*cos(ICODIHEDRAL*.5);\n\nvec3 opIcosahedron( vec3 p )\n{    \n    const float c = cos(PI/5.), s=sqrt(0.75-c*c);\n    const vec3  n = vec3(-0.5, -c, s);\n    p = abs(p);\n    p -= 2.*min(0., dot(p, n))*n;\n    p.xy = abs(p.xy);\n    p -= 2.*min(0., dot(p, n))*n;\n    p.xy = abs(p.xy);\n    p -= 2.*min(0., dot(p, n))*n;\n    return p;\n}    \n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdSphere( vec3 p, float r )\n{\n\treturn length(p) - r;\n}\n\n// List of other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\n\nfloat sdBlobbyCross( in vec2 pos, float he )\n{\n    pos = abs(pos);\n    pos = vec2(abs(pos.x-pos.y),1.0-pos.x-pos.y)/sqrt(2.0);\n\n\n    float p = (he-pos.y-0.25/he)/(6.0*he);\n    float q = pos.x/(he*he*16.0);\n    float h = q*q - p*p*p;\n    \n    float x;\n    if( h>0.0 ) { float r = sqrt(h); x = pow(q+r,1.0/3.0) - pow(abs(q-r),1.0/3.0)*sign(r-q); }\n    else        { float r = sqrt(p); x = 2.0*r*cos(acos(q/(p*r))/3.0); }\n    x = min(x,sqrt(2.0)/2.0);\n    \n    vec2 z = vec2(x,he*(1.0-2.0*x*x)) - pos;\n    return length(z) * sign(z.y);\n}\n\nfloat sdHorseshoe( in vec2 p, in vec2 c, in float r, in vec2 w )\n{\n    p.x = abs(p.x);\n    float l = length(p);\n    p = mat2(-c.x, c.y, \n              c.y, c.x)*p;\n    p = vec2((p.y>0.0 || p.x>0.0)?p.x:l*sign(-c.x),\n             (p.x>0.0)?p.y:l );\n    p = vec2(p.x,abs(p.y-r))-w;\n    return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\nfloat opExtrussion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nfloat sdHeart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nfloat sdSegment( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n", "name": "Common", "description": "", "type": "common"}]}