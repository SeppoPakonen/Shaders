{"ver":"0.1","info":{"id":"tlSBRV","date":"1599326080","viewed":164,"name":"A-SVGF Denoiser","username":"Mathis","description":"A humble attempt to implement A-SVGF.\n\nWASD to move, mouse to look, hold space to move fast!\nPress n or m to rotate the directional light.","likes":15,"published":1,"flags":48,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Some things to note:\n//\tOne denoising-pass is temporal since shadertoy only offers 4 buffers and the last frame\n//\tis the input to the denoiser in the current frame\n//\t\tThis means input will lag 2 frames behind\n\n\nfloat DenoiseCoeff(vec4 att, float CD, vec3 CN, vec3 deltaL, float LCoeff) {\n    if (att.w>99990.) return 0.;\n    return WeightVar(CD-att.w,dot(CN,Read(att.y).xyz*2.-1.),deltaL,LCoeff);\n}\n\nvec4 Denoise(vec2 lUV, vec2 aUV, sampler2D light, sampler2D attr,\n             float radius, float CD, vec3 CN) {\n    vec4 L0,L1,L2,L3,L4,L5,L6,L7,L8;\n    //Light fetching\n    L0=texture(light,lUV*IRES); L1=texture(light,(lUV+vec2(radius,0.))*IRES);\n    L2=texture(light,(lUV+vec2(-radius,0.))*IRES); L3=texture(light,(lUV+vec2(0.,radius))*IRES);\n    L4=texture(light,(lUV+vec2(0.,-radius))*IRES);\n    L5=texture(light,(lUV+vec2(radius))*IRES); L6=texture(light,(lUV+vec2(-radius,radius))*IRES);\n    L7=texture(light,(lUV+vec2(radius,-radius))*IRES); L8=texture(light,(lUV+vec2(-radius))*IRES);\n    //Variance\n    vec2 Moments=(Read(L0.w).yz*0.25\n        \t\t+(Read(L1.w).yz+Read(L2.w).yz+Read(L3.w).yz+Read(L4.w).yz)*0.125\n        \t\t+(Read(L5.w).yz+Read(L6.w).yz+Read(L7.w).yz+Read(L8.w).yz)*I16)*16.;\n    float Variance=abs(Moments.y-Moments.x*Moments.x);\n    Moments=clamp(Moments,vec2(0.),vec2(0.99));\n    //SVGF filter\n    //float Lc=1./(Coeff_L*sqrt(Variance)+0.0001);\n    \tfloat Lc=1./(pow(0.5,radius-1.)*Coeff_L*sqrt(Variance)+0.0001);\n    vec4 Accum=vec4(L0.xyz*0.25,0.25);\n    Accum+=(vec4(L1.xyz,1.)*DenoiseCoeff(texture(attr,(aUV+vec2(radius,0.))*IRES),CD,CN,L1.xyz-L0.xyz,Lc)+\n            vec4(L2.xyz,1.)*DenoiseCoeff(texture(attr,(aUV+vec2(-radius,0.))*IRES),CD,CN,L2.xyz-L0.xyz,Lc)+\n            vec4(L3.xyz,1.)*DenoiseCoeff(texture(attr,(aUV+vec2(0.,radius))*IRES),CD,CN,L3.xyz-L0.xyz,Lc)+\n            vec4(L4.xyz,1.)*DenoiseCoeff(texture(attr,(aUV+vec2(0.,-radius))*IRES),CD,CN,L4.xyz-L0.xyz,Lc)\n            )*0.125;\n    Accum+=(vec4(L5.xyz,1.)*DenoiseCoeff(texture(attr,(aUV+vec2(radius))*IRES),CD,CN,L5.xyz-L0.xyz,Lc)+\n            vec4(L6.xyz,1.)*DenoiseCoeff(texture(attr,(aUV+vec2(-radius,radius))*IRES),CD,CN,L6.xyz-L0.xyz,Lc)+\n            vec4(L7.xyz,1.)*DenoiseCoeff(texture(attr,(aUV+vec2(radius,-radius))*IRES),CD,CN,L7.xyz-L0.xyz,Lc)+\n            vec4(L8.xyz,1.)*DenoiseCoeff(texture(attr,(aUV+vec2(-radius))*IRES),CD,CN,L8.xyz-L0.xyz,Lc)\n            )*I16;\n    //Output\n    return vec4(Accum.xyz/Accum.w,Write(vec4(Read(L0.w).x,Moments,0.)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //Output\n    vec3 Color=vec3(0.1,0.3,0.5);\n    vec2 UV=floor(fragCoord*0.5)+0.5;\n    vec4 LastAtt=texture(iChannel0,UV*IRES+vec2(0.,0.5));\n    if (LastAtt.w<99990.) {\n    \tvec3 CN=Read(LastAtt.y).xyz*2.-1.;\n    \tColor=Denoise(UV+vec2(HRES.x,0.),UV+vec2(0.,HRES.y),iChannel3,iChannel0,8.,LastAtt.w,CN).xyz;\n    \tColor=Color*Read(texture(iChannel0,(fragCoord*0.5+vec2(0.,HRES.y))*IRES).x).xyz;\n\t}\n    \n    \n    //DEBUG\n    //Color=texture(iChannel3,fragCoord*IRES).xyz;\n    \n    fragColor=vec4(pow(Color,vec3(0.45)),1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Settings\nconst float FOV=0.9; //In radians\nconst float ALPHA=1./64.;\nconst float Coeff_L=4.;\nconst float Coeff_N=1.;\nconst float Coeff_Z=1.;\nconst float AdaptiveDenoisingRadius=3.;\nconst float SunConeRatio=tan(radians(2.)*0.5);\n#define DEF_SUN\n\n//Constants\nconst float PI=3.14159265;\nconst float I16=1./16.;\nconst float I255=1./255.;\nconst vec2 eps=vec2(0.001,0.);\nconst float CFOV=tan(FOV);\nconst vec2 InvAF=(0.5/CFOV)*vec2(180./320.,1.);\nconst float GaussExp=1./(2.*AdaptiveDenoisingRadius*AdaptiveDenoisingRadius*(1./4.));\n#define HRES (iResolution.xy*0.5)\n#define AdaptRES ((HRES)*0.25)\n#define IRES 1./iResolution.xy\n#define IHRES 2./iResolution.xy\n#define ASPECT vec2(iResolution.x/iResolution.y,1.)\n\n//Structs\nstruct DF { float D; vec3 C; float Mat; float V_y; };\nstruct HIT { float D; vec3 P; vec3 N; vec3 C; float Mat; float V_y; };\n\n  \nfloat Box(vec3 p, vec3 b) {\n    vec3 d=abs(p-b*0.5)-b*0.5;\n    return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\n}\n\nfloat BoxC(vec3 p, vec3 b) {\n    vec3 d=abs(p)-b;\n    return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\n}\n\nfloat Box2(vec2 p, vec2 b) {\n    vec2 d=abs(p-b*0.5)-b*0.5;\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\nfloat BoxC2(vec2 p, vec2 b) {\n    vec2 d=abs(p)-b;\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\nvec2 Rotate(vec2 p, float ang) {\n    float c=cos(ang), s=sin(ang);\n    return vec2(p.x*c-p.y*s,p.x*s+p.y*c);\n}\n\nvec2 Repeat(vec2 p, float n) {\n    float ang=2.*3.14159/n;\n    float sector=floor(atan(p.x,p.y)/ang+0.5);\n    p=Rotate(p,sector*ang);\n    return p;\n}\n\nfloat Plane(vec3 p, vec3 n, float offs) {\n\treturn dot(p,n)-offs;\n}\n\nfloat Line(vec3 p, vec3 a, vec3 b) {\n    vec3 ba=b-a;\n    float k=dot(p-a,ba)/dot(ba,ba);\n    return length((a+clamp(k,0.,1.)*(b-a))-p);\n}\n\nfloat SMIN(float a, float b, float k) {\n    float h=clamp(0.5+0.5*(b-a)/k,0.,1.);\n    return mix(b,a,h)-k*h*(1.-h);\n}\n\nvoid MIN(inout DF df, DF a) {\n    if (a.D<=df.D) df=a;\n}\n\nDF SDF(vec3 p, float Time) {\n    DF df=DF(1000.,vec3(0.99),1.,0.);\n    //Rum\n    \tdf.D=min(df.D,max(Box(p,vec3(64.,42.,32.)),-Box(p-vec3(2.,1.,2.),vec3(60.,40.,28.)))); //V\u00e4ggar\n    \tvec3 rp=p-vec3(8.,9.,24.); rp.xy=Rotate(rp.xy,3.14159*0.25);\n    \tdf.D=max(df.D,-Box(rp,vec3(16.,16.,16.))); //D\u00f6rr\n    \t//Roterade sf\u00e4rf\u00f6nster\n    \t\trp=p-vec3(64.,16.,16.); rp.yz=Rotate(rp.yz,0.6);\n    \t\tdf.D=max(df.D,-(length(vec3(rp.x,fract(rp.yz*0.125)*8.-4.))-4.));\n    \t//Sphere\n    \t\tMIN(df,DF(length(p-vec3(48.,4.,5.))-4.,vec3(0.6,0.9,0.7),1.,0.));\n    \t//Weird rotated stuff on the wall\n    \t\trp=p-vec3(48.,16.,23.); rp.xy=Rotate(rp.xy,Time);\n    \t\tMIN(df,DF(Box(vec3(abs(rp.xy)-vec2(2.5,2.5),rp.z),vec3(5.,5.,8.)),vec3(0.99,0.9,0.6),0.,0.));\n    //Golv\n    \tMIN(df,DF(Box(p,vec3(64.,1.,54.)),vec3(0.99),1.,0.));\n    \t//F\u00e4rgade golvbitar\n    \t\tMIN(df,DF(Box(p-vec3(24.,1.,20.),vec3(12.,1.,10.)),vec3(0.99,0.1,0.1),1.,0.));\n    \t\tMIN(df,DF(Box(p-vec3(36.,1.,20.),vec3(12.,1.,10.)),vec3(0.1,0.99,0.1),1.,0.));\n    //R\u00f6rlig kvadrat vid d\u00f6rren\n    \tvec3 bp=p-vec3(6.,10.+10.*sin(Time),30.5);\n    \tMIN(df,DF(Box(bp,vec3(26.,20.,1.)),vec3(0.99),1.,10.*cos(Time)));\n    \n    //Return\n\treturn df;\n}\n\nvec3 Gradient(vec3 p, float t) {\n    return normalize(vec3(\n        SDF(p+eps.xyy,t).D-SDF(p-eps.xyy,t).D,\n        SDF(p+eps.yxy,t).D-SDF(p-eps.yxy,t).D,\n        SDF(p+eps.yyx,t).D-SDF(p-eps.yyx,t).D));\n}\n\nmat3 TBN(vec3 N) {\n    vec3 Nb,Nt;\n    if (abs(N.y)>0.999) {\n        Nb=vec3(1.,0.,0.);\n        Nt=vec3(0.,0.,1.);\n    } else {\n    \tNb=normalize(cross(N,vec3(0.,1.,0.)));\n    \tNt=normalize(cross(Nb,N));\n    }\n    return mat3(Nb.x,Nt.x,N.x,Nb.y,Nt.y,N.y,Nb.z,Nt.z,N.z);\n}\n\nvec3 TBN(vec3 N, out vec3 O) {\n    O=normalize(cross(N,vec3(0.,1.,0.)));\n    return normalize(cross(O,N));\n}\n\nfloat boxfar(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax) {\n    vec3 tMin=(bmin-origin)*dir;\n    vec3 tMax=(bmax-origin)*dir;\n    vec3 t2=max(tMin,tMax);\n    return min(min(t2.x,t2.y),t2.z);\n}\n\nvec2 box(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax) {\n    vec3 tMin=(bmin-origin)*dir;\n    vec3 tMax=(bmax-origin)*dir;\n    vec3 t1=min(tMin,tMax);\n    vec3 t2=max(tMin,tMax);\n    return vec2(max(max(t1.x,t1.y),t1.z),min(min(t2.x,t2.y),t2.z));\n}\n\nbool TraceRay(vec3 pos, vec3 dir, out HIT R, float FAR, float Time) {\n    DF t; float dist=0.; R.P=pos;\n    for (int i=0; i<256; i++) {\n        if (dist>FAR) break;\n        R.P=pos+dir*dist;\n        t=SDF(R.P,Time);\n        if (t.D<eps.x) {\n\t\t\tR.D=dist;\n            R.N=Gradient(R.P,Time);\n            R.C=t.C;\n            R.Mat=t.Mat;\n            R.V_y=t.V_y;\n            return true;\n        }\n        dist=dist+t.D;\n    }\n\treturn false;\n}\n\nvec3 RandSample(vec2 v) {\n    float theta=sqrt(v.x);\n    float phi=2.*3.14159*v.y;\n    float x=theta*cos(phi);\n    float z=theta*sin(phi);\n    return vec3(x,z,sqrt(max(0.,1.-v.x)));\n}\n\nvec2 ProjectUV(vec3 p, vec3 LP, vec3 LD, vec3 LT, vec3 LB) {\n\tvec3 CVPos=p-LP;\n    vec3 LVPos=vec3(dot(CVPos,LT),dot(CVPos,LB),dot(CVPos,LD));\n    return (LVPos.xy/LVPos.z)*InvAF+0.5;\n}\n\nvec3 ComputeLight(vec3 P, vec3 N, vec3 LD, vec2 rand, float iTime) {\n    HIT LHIT; mat3 NM; vec3 Sample; vec3 Color=vec3(0.);\n    #ifdef DEF_SUN\n    //Direct Light\n    float LDot=dot(LD,N);\n    if (LDot>0.) {\n        NM=TBN(LD);\n        Sample=normalize(RandSample(rand)*NM*SunConeRatio+LD);\n        if (!TraceRay(P,Sample,LHIT,64.,iTime))\n            Color.xyz+=vec3(0.9,0.7,0.3)*2.*LDot;\n    }\n    #endif\n    //Diffuse\n    NM=TBN(N);\n    Sample=RandSample(rand)*NM;\n    if (TraceRay(P,Sample,LHIT,64.,iTime)) {\n        if (LHIT.Mat==2.) Color+=LHIT.C; else {\n            //Direct Light\n            #ifdef DEF_SUN\n            LDot=dot(LD,LHIT.N);\n    \t\tif (LDot>0.) {\n                NM=TBN(LD);\n                Sample=normalize(RandSample(rand)*NM*SunConeRatio+LD);\n                if (!TraceRay(LHIT.P+LHIT.N*0.05,Sample,LHIT,64.,iTime))\n                    Color.xyz+=vec3(0.9,0.7,0.3)*2.*LDot*LHIT.C;\n            }\n            #endif\n        }\n    } else\n        Color.xyz+=(Sample.y*0.5+0.5)*vec3(0.1,0.3,0.5);\n    //Return\n    return Color;\n}\n\nfloat Weight(float deltaZ, float dotN) {\n    return max(0.001,pow(dotN,Coeff_N))*min(exp(-(deltaZ*deltaZ)*Coeff_Z),1.);\n}\n\nfloat WeightVar(float deltaZ, float dotN, vec3 deltaL, float L_div_inv) {\n    return max(0.001,pow(dotN,Coeff_N))*min(exp(-(deltaZ*deltaZ)*Coeff_Z),1.)\n        \t*min(exp(-dot(deltaL,deltaL)*L_div_inv),1.);\n}\n\n//Decode/encode from user \"cornusammonis\": https://www.shadertoy.com/view/Xlfcz8\nuint Write0(vec4 x) {\n\tx = clamp(x,-1.0, 1.0) * 127.0;\n    uvec4 sig = uvec4(mix(vec4(0), vec4(1), greaterThanEqual(sign(x),vec4(0))));\n    uvec4 mag = uvec4(abs(x));\n    uvec4 r = sig << 7 | mag;\n    return r.x << 24 | r.y << 16 | r.z << 8 | r.w;\n}\nvec4 Read0(uint x) {\n\tuvec4 r = (uvec4(x) >> uvec4(24, 16, 8, 0)) & uvec4(0xFF);\n    uvec4 sig = r >> 7;\n    uvec4 mag = r & uvec4(0x7F);\n    vec4 fsig = mix(vec4(-1), vec4(1), greaterThanEqual(sig,uvec4(1)));\n    vec4 fmag = vec4(mag) / 127.0;\n    return fsig * fmag;\n}\n#define Read(x) (Read0(floatBitsToUint(x))*0.5+0.5)\n#define Write(x) uintBitsToFloat(Write0(x*2.-1.))","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Color=texture(iChannel0,fragCoord.xy/iResolution.xy);\n    vec2 fragFloor=floor(fragCoord);\n    if (iFrame==0) { //Initialization\n        if (fragCoord.x<10. && fragCoord.y<1.) { //Store vars\n            if (fragCoord.x<1.) Color=vec4(0.,0.,0.,1.); //Mouse\n            else if (fragCoord.x<2.) Color=vec4(0.,0.,-0.2,0.7); //Player Eye (Angles)\n            else if (fragCoord.x<3.) Color=vec4(0.,0.,0.,1.); //Player Eye (Vector)\n            else if (fragCoord.x<4.) Color=vec4(37.5,15.3,4.5,1.); //Player Pos\n            else if (fragCoord.x<5.) Color=vec4(0.7,-0.5,0.,0.); //Sun angles\n            else if (fragCoord.x<6.) Color=vec4(0.,0.,0.,0.); //Sun direction\n        }\n    } else { //Update\n\t\tif (fragCoord.x<10. && fragCoord.y<1.) { //Update vars\n            if (fragCoord.x<1.) { //Mouse\n                if (iMouse.z>0.) { //B\u00f6rjat klicka\n                    Color.w=1.;\n                    Color.xy=iMouse.xy-iMouse.zw;\n                } else Color.w=0.;\n            } else if (fragCoord.x<2.) { //Player Eye (Angles)\n                vec4 LMouse=texture(iChannel0,vec2(0.5,0.5)*IRES);\n                if (LMouse.w==0.)  Color.zw=Color.xy;\n                if (LMouse.w==1.) {\n                \t//Y led\n                \tColor.x=Color.z+LMouse.y*0.01;\n                \tColor.x=clamp(Color.x,-2.8*0.5,2.8*0.5);\n                \t//X led\n                \tColor.y=Color.w-LMouse.x*0.02;\n               \t\tColor.y=mod(Color.y,3.1415926*2.);\n                }\n            } else if (fragCoord.x<3.) { //Player Eye (Vector)\n                vec3 Angles=texture(iChannel0,vec2(1.5,0.5)*IRES).xyz;\n                Color.xyz=normalize(vec3(cos(Angles.x)*sin(Angles.y),\n                  \t\t\t   \t\t\tsin(Angles.x),\n                  \t\t\t   \t\t\tcos(Angles.x)*cos(Angles.y)));\n            } else if (fragCoord.x<4.) { //Player Pos\n                float Speed=iTimeDelta*8.;\n                \tif (texelFetch(iChannel1,ivec2(32,0),0).x>0.) Speed=20.*iTimeDelta;\n                vec3 Eye=texture(iChannel0,vec2(2.5,0.5)*IRES).xyz;\n                if (texelFetch(iChannel1,ivec2(87,0),0).x>0.) Color.xyz+=Eye*Speed; //W\n                if (texelFetch(iChannel1,ivec2(83,0),0).x>0.) Color.xyz-=Eye*Speed; //S\n                vec3 Tan=normalize(cross(vec3(Eye.x,0.,Eye.z),vec3(0.,1.,0.)));\n                if (texelFetch(iChannel1,ivec2(65,0),0).x>0.) Color.xyz-=Tan*Speed; //A\n                if (texelFetch(iChannel1,ivec2(68,0),0).x>0.) Color.xyz+=Tan*Speed; //D\n            } else if (fragCoord.x<5.) { //Sun angle\n                if (texelFetch(iChannel1,ivec2(77,0),0).x>0.) Color.y+=0.02;\n                if (texelFetch(iChannel1,ivec2(78,0),0).x>0.) Color.y-=0.02;\n                Color.z=Color.y; //Sunangle last frame\n            } else if (fragCoord.x<6.) { //Sun direction\n                vec2 Angles=texture(iChannel0,vec2(4.5,0.5)*IRES).xy;\n                Color=vec4(normalize(vec3(cos(Angles.y)*cos(Angles.x)\n                \t,sin(Angles.x),sin(Angles.y)*cos(Angles.x))),1.);\n            } else if (fragCoord.x<7.) { //Old eye\n                Color=texture(iChannel0,vec2(2.5,0.5)*IRES);\n            } else if (fragCoord.x<8.) { //Old pos\n                Color=texture(iChannel0,vec2(3.5,0.5)*IRES);\n            } else if (fragCoord.x<9.) { //Old old eye\n                Color=texture(iChannel0,vec2(6.5,0.5)*IRES);\n            } else if (fragCoord.x<10.) { //Old old pos\n                Color=texture(iChannel0,vec2(7.5,0.5)*IRES);\n            }\n        } else if (fragCoord.y>HRES.y) {\n            if (fragCoord.x>HRES.x)\n                //Copy last frames attributes\n            \tColor=texture(iChannel2,fragCoord*IRES);\n            else\n                Color=texture(iChannel3,fragCoord*IRES+vec2(0.5,0.));\n        } else if (Box2(fragCoord-vec2(HRES.x,0.),AdaptRES)<0.) {\n            //Denoise the gradient from Buffer C\n            //\tUses a simple Guassian blur with depth and normal weights\n            vec2 UV=(floor(fragCoord-vec2(HRES.x,0.))*4.+0.5);\n            vec4 SA,SL; vec4 Accum=vec4(0.); float weight;\n            vec4 CAtt=texture(iChannel0,UV*IRES+0.5);\n            vec3 CN=Read(CAtt.y).xyz*2.-1.;\n            for (float x=-AdaptiveDenoisingRadius; x<=AdaptiveDenoisingRadius; x++) {\n                for (float y=-AdaptiveDenoisingRadius; y<=AdaptiveDenoisingRadius; y++) {\n                \tSA=texture(iChannel0,(UV+vec2(x,y)*4.)*IRES+0.5);\n                    if (SA.w>99990.) continue;\n                    SL=texture(iChannel3,(fragCoord+vec2(x,y))*IRES);\n                    weight=exp(-GaussExp*(x*x+y*y))*Weight(SA.w-CAtt.w,dot(CN,Read(SA.y).xyz*2.-1.));\n                    Accum+=vec4(SL.xyz,1.)*weight;\n            \t}\n            }\n            Color=Accum/Accum.w;\n        }\n    }\n    fragColor=Color;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":3,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float GradientSample(vec2 uv, out float w, vec3 CN, float CD) {\n    vec4 GA=texture(iChannel0,uv*IRES+vec2(0.5));\n    if (GA.w>99990.) { w=0.; return 0.; }\n    w=Weight(CD-GA.w,dot(CN,Read(GA.y).xyz*2.-1.));\n    return texture(iChannel0,uv*0.25*IRES+vec2(0.5,0.)).x*w;\n}\n\nfloat UpsampledGradient(vec2 uv, vec3 CN, float CD) {\n    float w0,w1,w2,w3;\n    vec2 fluv=(floor(uv)*4.+0.5);\n    float G0=GradientSample(fluv,w0,CN,CD);\n    float G1=GradientSample(fluv+vec2(4.,0.),w1,CN,CD);\n    float G2=GradientSample(fluv+vec2(0.,4.),w2,CN,CD);\n    float G3=GradientSample(fluv+vec2(4.),w3,CN,CD);\n    vec2 fuv=fract(uv+0.5-0.5);\n    return clamp(mix(mix(G0,G1,fuv.x),mix(G2,G3,fuv.x),fuv.y)\n    \t\t\t/(0.001+mix(mix(w0,w1,fuv.x),mix(w2,w3,fuv.x),fuv.y))*3.,0.,1.);\n}\n\nvec3 LinearSample0(vec2 uv, out float coeff, out vec2 Moments, vec3 CN) {\n    vec4 Attr=texture(iChannel2,uv+0.5);\n    if (Attr.w>99990. || BoxC2(uv-0.25,vec2(0.25))>0.) {coeff=0.; Moments=vec2(0.); return vec3(0.); }\n    coeff=max(0.0001,pow(dot(CN,Read(Attr.y).xyz*2.-1.),Coeff_N));\n    vec4 ALS=texture(iChannel1,uv);\n    Moments=Read(ALS.w).yz*coeff;\n    return ALS.xyz*coeff;\n}\n\nvec3 LinearSample(vec2 uv, vec3 CN, out vec2 Moments) {\n    float c0,c1,c2,c3; vec2 m0,m1,m2,m3;\n    vec2 fuv=floor(uv*HRES-0.499)+0.5;\n    vec3 C0=LinearSample0(fuv*IRES,c0,m0,CN);\n    vec3 C1=LinearSample0((fuv+vec2(1.,0.))*IRES,c1,m1,CN);\n    vec3 C2=LinearSample0((fuv+vec2(0.,1.))*IRES,c2,m2,CN);\n    vec3 C3=LinearSample0((fuv+vec2(1.))*IRES,c3,m3,CN);\n    vec2 fruv=fract(uv*HRES-0.499);\n    float mc=max(0.0001,mix(mix(c0,c1,fruv.x),mix(c2,c3,fruv.x),fruv.y));\n    Moments=mix(mix(m0,m1,fruv.x),mix(m2,m3,fruv.x),fruv.y)/mc;\n    return mix(mix(C0,C1,fruv.x),mix(C2,C3,fruv.x),fruv.y)/mc;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Color=texture(iChannel1,fragCoord*IRES);\n    if (fragCoord.y>HRES.y) {\n        Color=vec4(0.,0.,0.,0.);\n        if (fragCoord.x<HRES.x) {\n            //New 1 spp light\n            vec3 LD=texture(iChannel0,vec2(5.5,0.5)*IRES).xyz;\n            //Primary rays\n            vec2 uv=(fragCoord-vec2(0.,HRES.y))*IHRES;\n            vec3 Pos=texture(iChannel0,vec2(3.5,0.5)*IRES).xyz;\n    \t\tmat3 MM=TBN(texture(iChannel0,vec2(2.5,0.5)*IRES).xyz);\n    \t\tvec3 Dir=normalize(vec3((uv*2.-1.)*(ASPECT*CFOV),1.)*MM);\n            HIT Pixel;\n            if (TraceRay(Pos,Dir,Pixel,80.,iTime)) {\n                if (Pixel.Mat==2.)\n                    Color.xyz=Pixel.C;\n                else {\n                    float modsum=mod(floor(fragCoord.x),4.)+mod(floor(fragCoord.y),4.);\n                    float modframe=mod(float(iFrame),256.);\n                    vec2 rand=texture(iChannel3,(fragCoord+modframe*vec2(325.253,537.171))*IRES).xy;\n                    Color.xyz=ComputeLight(Pixel.P+Pixel.N*0.05,Pixel.N,LD,rand,iTime);\n                }\n            }\n        } else {\n            //New attributes\n            Color=vec4(Write(vec4(0.)),Write(vec4(0.)),0.,100000.);;\n            //Attributes\n            vec2 uv=(fragCoord-HRES)*IHRES;\n            vec3 Pos=texture(iChannel0,vec2(3.5,0.5)*IRES).xyz;\n    \t\tmat3 MM=TBN(texture(iChannel0,vec2(2.5,0.5)*IRES).xyz);\n    \t\tvec3 Dir=normalize(vec3((uv*2.-1.)*(ASPECT*CFOV),1.)*MM);\n            HIT Pixel;\n            if (TraceRay(Pos,Dir,Pixel,80.,iTime)) {\n                vec3 fp=floor(Pixel.P*0.62371);\n                vec3 Checker=Pixel.C*(0.5+0.5*mod(fp.x+fp.y+fp.z,2.));\n                Color=vec4(Write(vec4(Pixel.C*Checker,0.)),         //Color\n                           Write(vec4(Pixel.N*0.5+0.5,0.5)*0.99),\t//Normal\n                           Pixel.V_y,\t\t\t\t\t\t\t\t//Velocity y-component\n                           Pixel.D);\t\t\t\t\t\t\t\t//Depth\n            }\n        }\n    } else if (fragCoord.x<HRES.x) {\n        //Temporal accumulation\n        vec3 LPos=texture(iChannel0,vec2(7.5,0.5)*IRES).xyz;\n        mat3 LMM=TBN(texture(iChannel0,vec2(6.5,0.5)*IRES).xyz);\n        vec3 LDir=normalize(vec3(((fragCoord*IHRES)*2.-1.)*(ASPECT*CFOV),1.)*LMM);\n        vec4 LPixel=texture(iChannel0,(fragCoord+HRES)*IRES);\n        vec3 LPixelPos=LPos+LDir*LPixel.w;\n        if (LPixel.w>99990.) {\n            Color=vec4(0.,0.,0.,Write(vec4(0.)));\n        } else {\n        \t//Non-sky pixel\n            vec4 NewLight;\n            vec3 LLPos=texture(iChannel0,vec2(9.5,0.5)*IRES).xyz;\n            vec3 LLEye=texture(iChannel0,vec2(8.5,0.5)*IRES).xyz;\n            vec3 LLTan=normalize(cross(LLEye,vec3(0.,1.,0.)));\n            vec3 LLBit=normalize(cross(LLTan,LLEye));\n            //Reprojection\n            vec2 Luv=ProjectUV(LPixelPos,LLPos,LLEye,LLTan,LLBit);\n            vec4 LLA=texture(iChannel2,Luv*0.5+0.5);\n            vec3 LLPP=LLPos+normalize(vec3((Luv*2.-1.)*(ASPECT*CFOV),1.)*TBN(LLEye))*LLA.w;\n            if (BoxC2(Luv-0.5,vec2(0.5))>0. || length(LLPP-LPixelPos)>2.\n            || dot(Read(LPixel.y).xyz*2.-1.,Read(LLA.y).xyz*2.-1.)<0.5) {\n                //Invalid pixel\n                //Variance (new pixel, approximation with spatial blur -> rip compilation time)\n                vec2 Var=vec2(0.5,0.);\n                //Output\n                Color=vec4(texture(iChannel1,(fragCoord+vec2(0.,HRES.y))*IRES).xyz,Write(vec4(I255,Var,0.)));\n            } else {\n                //Valid pixel\n                //Upsampled gradient\n                float NSamples=min(32.,Read(Color.w).x*255.+1.);\n                float Grad=UpsampledGradient(fragCoord*0.25,Read(LPixel.y).xyz*2.-1.,LPixel.w);\n                float alpha=max(1./NSamples,(1.-Grad)*ALPHA+Grad);\n                //Accumulation\n                vec2 AccumMoments;\n                vec3 AccumLight=LinearSample(Luv,Read(LPixel.y).xyz*2.-1.,AccumMoments);\n                vec3 OldLight=texture(iChannel1,(fragCoord+vec2(0.,HRES.y))*IRES).xyz;\n                vec3 MixedLight=AccumLight*(1.-alpha)+OldLight*alpha;\n                //Variance\n\t\t\t\tvec2 MixedMoments=vec2(1.,0.);\n                if (NSamples>3.) {\n                    //Stable temporal variance\n                    float OldLum=dot(OldLight,vec3(0.299,0.587,0.114));\n                    MixedMoments=AccumMoments*(1.-alpha)+vec2(OldLum,OldLum*OldLum)*alpha;\n                }  \n                MixedMoments=clamp(MixedMoments,vec2(0.),vec2(0.99));\n                //Output\n                Color=vec4(MixedLight,Write(vec4(NSamples*I255,MixedMoments,0.)));\n            }\n        }\n    }\n    fragColor=Color;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":3,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"float DenoiseCoeff(vec4 att, float CD, vec3 CN, vec3 deltaL, float LCoeff) {\n    if (att.w>99990.) return 0.;\n    return WeightVar(CD-att.w,dot(CN,Read(att.y).xyz*2.-1.),deltaL,LCoeff);\n}\n\nvec4 Denoise(vec2 lUV, vec2 aUV, sampler2D light, sampler2D attr,\n             float radius, float CD, vec3 CN) {\n    vec4 L0,L1,L2,L3,L4,L5,L6,L7,L8;\n    //Light fetching\n    L0=texture(light,lUV*IRES); L1=texture(light,(lUV+vec2(radius,0.))*IRES);\n    L2=texture(light,(lUV+vec2(-radius,0.))*IRES); L3=texture(light,(lUV+vec2(0.,radius))*IRES);\n    L4=texture(light,(lUV+vec2(0.,-radius))*IRES);\n    L5=texture(light,(lUV+vec2(radius))*IRES); L6=texture(light,(lUV+vec2(-radius,radius))*IRES);\n    L7=texture(light,(lUV+vec2(radius,-radius))*IRES); L8=texture(light,(lUV+vec2(-radius))*IRES);\n    //Variance\n    vec2 Moments=(Read(L0.w).yz*0.25\n        \t\t+(Read(L1.w).yz+Read(L2.w).yz+Read(L3.w).yz+Read(L4.w).yz)*0.125\n        \t\t+(Read(L5.w).yz+Read(L6.w).yz+Read(L7.w).yz+Read(L8.w).yz)*I16)*16.;\n    float Variance=abs(Moments.y-Moments.x*Moments.x);\n    Moments=clamp(Moments,vec2(0.),vec2(0.99));\n    //SVGF filter\n    //float Lc=1./(Coeff_L*sqrt(Variance)+0.0001);\n    \tfloat Lc=1./(pow(0.5,radius-1.)*Coeff_L*sqrt(Variance)+0.0001);\n    vec4 Accum=vec4(L0.xyz*0.25,0.25);\n    Accum+=(vec4(L1.xyz,1.)*DenoiseCoeff(texture(attr,(aUV+vec2(radius,0.))*IRES),CD,CN,L1.xyz-L0.xyz,Lc)+\n            vec4(L2.xyz,1.)*DenoiseCoeff(texture(attr,(aUV+vec2(-radius,0.))*IRES),CD,CN,L2.xyz-L0.xyz,Lc)+\n            vec4(L3.xyz,1.)*DenoiseCoeff(texture(attr,(aUV+vec2(0.,radius))*IRES),CD,CN,L3.xyz-L0.xyz,Lc)+\n            vec4(L4.xyz,1.)*DenoiseCoeff(texture(attr,(aUV+vec2(0.,-radius))*IRES),CD,CN,L4.xyz-L0.xyz,Lc)\n            )*0.125;\n    Accum+=(vec4(L5.xyz,1.)*DenoiseCoeff(texture(attr,(aUV+vec2(radius))*IRES),CD,CN,L5.xyz-L0.xyz,Lc)+\n            vec4(L6.xyz,1.)*DenoiseCoeff(texture(attr,(aUV+vec2(-radius,radius))*IRES),CD,CN,L6.xyz-L0.xyz,Lc)+\n            vec4(L7.xyz,1.)*DenoiseCoeff(texture(attr,(aUV+vec2(radius,-radius))*IRES),CD,CN,L7.xyz-L0.xyz,Lc)+\n            vec4(L8.xyz,1.)*DenoiseCoeff(texture(attr,(aUV+vec2(-radius))*IRES),CD,CN,L8.xyz-L0.xyz,Lc)\n            )*I16;\n    //Output\n    return vec4(Accum.xyz/Accum.w,Write(vec4(Read(L0.w).x,Moments,0.)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Color=vec4(0.);\n    if (fragCoord.y>HRES.y) {\n        if (fragCoord.x<HRES.x) {\n            //First denoising pass (of accumulated light)\n            vec2 UV=fragCoord-vec2(0.,HRES.y);\n            vec4 LastAtt=texture(iChannel0,UV*IRES+0.5);\n            vec3 CN=Read(LastAtt.y).xyz*2.-1.;\n            Color=Denoise(UV,UV+HRES,iChannel1,iChannel0,1.,LastAtt.w,CN);\n        } else {\n            //Oldold attributes (used in accumulation)\n            Color=texture(iChannel0,fragCoord*IRES);\n        }\n    } else if (Box2(fragCoord-vec2(HRES.x,0.),AdaptRES)<0.) {\n        //Gradient (using \"backwards projection\" because I can)\n        vec2 UV=(floor(fragCoord-vec2(HRES.x,0.))*4.+0.5)*IRES;\n        //Primary rays\n        vec2 uv=(fragCoord-vec2(0.,HRES.y))*IHRES;\n        vec3 Pos=texture(iChannel0,vec2(3.5,0.5)*IRES).xyz;\n        mat3 MM=TBN(texture(iChannel0,vec2(2.5,0.5)*IRES).xyz);\n        vec3 Dir=normalize(vec3((UV*4.-1.)*(ASPECT*CFOV),1.)*MM);\n        vec4 Att=texture(iChannel1,UV+0.5);\n        vec3 CLight=texture(iChannel1,UV+vec2(0.,0.5)).xyz;\n        vec3 CPixelPos=Pos+Dir*Att.w;\n        //Recomputing the ray in the last frame\n        vec3 CPixelNor=Gradient(CPixelPos,iTime);\n        float modframe=mod(float(iFrame),256.);\n        vec2 rand=texture(iChannel3,modframe*vec2(325.253,537.171)*IRES+UV+vec2(0.,0.5)).xy;\n        vec2 Angles=texture(iChannel0,vec2(4.5,0.5)*IRES).xz;\n        vec3 LastLD=normalize(vec3(cos(Angles.y)*cos(Angles.x),sin(Angles.x),sin(Angles.y)*cos(Angles.x)));\n        vec3 LLight=ComputeLight(CPixelPos+CPixelNor*0.05,CPixelNor,LastLD,rand,iTime-iTimeDelta);\n        //Compute the relative difference\n        float CLum=dot(CLight,vec3(0.299,0.587,0.114));\n        float LLum=dot(LLight,vec3(0.299,0.587,0.114));\n        Color.xyz=vec3(min(1.,abs(CLum-LLum))/(max(CLum,LLum)+0.01));\n    }\n    fragColor=Color;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"float DenoiseCoeff(vec4 att, float CD, vec3 CN, vec3 deltaL, float LCoeff) {\n    if (att.w>99990.) return 0.;\n    return WeightVar(CD-att.w,dot(CN,Read(att.y).xyz*2.-1.),deltaL,LCoeff);\n}\n\nvec4 Denoise(vec2 lUV, vec2 aUV, sampler2D light, sampler2D attr,\n             float radius, float CD, vec3 CN) {\n    vec4 L0,L1,L2,L3,L4,L5,L6,L7,L8;\n    //Light fetching\n    L0=texture(light,lUV*IRES); L1=texture(light,(lUV+vec2(radius,0.))*IRES);\n    L2=texture(light,(lUV+vec2(-radius,0.))*IRES); L3=texture(light,(lUV+vec2(0.,radius))*IRES);\n    L4=texture(light,(lUV+vec2(0.,-radius))*IRES);\n    L5=texture(light,(lUV+vec2(radius))*IRES); L6=texture(light,(lUV+vec2(-radius,radius))*IRES);\n    L7=texture(light,(lUV+vec2(radius,-radius))*IRES); L8=texture(light,(lUV+vec2(-radius))*IRES);\n    //Variance\n    vec2 Moments=(Read(L0.w).yz*0.25\n        \t\t+(Read(L1.w).yz+Read(L2.w).yz+Read(L3.w).yz+Read(L4.w).yz)*0.125\n        \t\t+(Read(L5.w).yz+Read(L6.w).yz+Read(L7.w).yz+Read(L8.w).yz)*I16)*16.;\n    float Variance=abs(Moments.y-Moments.x*Moments.x);\n    Moments=clamp(Moments,vec2(0.),vec2(0.99));\n    //SVGF filter\n    //float Lc=1./(Coeff_L*sqrt(Variance)+0.0001);\n    \tfloat Lc=1./(pow(0.5,radius-1.)*Coeff_L*sqrt(Variance)+0.0001);\n    vec4 Accum=vec4(L0.xyz*0.25,0.25);\n    Accum+=(vec4(L1.xyz,1.)*DenoiseCoeff(texture(attr,(aUV+vec2(radius,0.))*IRES),CD,CN,L1.xyz-L0.xyz,Lc)+\n            vec4(L2.xyz,1.)*DenoiseCoeff(texture(attr,(aUV+vec2(-radius,0.))*IRES),CD,CN,L2.xyz-L0.xyz,Lc)+\n            vec4(L3.xyz,1.)*DenoiseCoeff(texture(attr,(aUV+vec2(0.,radius))*IRES),CD,CN,L3.xyz-L0.xyz,Lc)+\n            vec4(L4.xyz,1.)*DenoiseCoeff(texture(attr,(aUV+vec2(0.,-radius))*IRES),CD,CN,L4.xyz-L0.xyz,Lc)\n            )*0.125;\n    Accum+=(vec4(L5.xyz,1.)*DenoiseCoeff(texture(attr,(aUV+vec2(radius))*IRES),CD,CN,L5.xyz-L0.xyz,Lc)+\n            vec4(L6.xyz,1.)*DenoiseCoeff(texture(attr,(aUV+vec2(-radius,radius))*IRES),CD,CN,L6.xyz-L0.xyz,Lc)+\n            vec4(L7.xyz,1.)*DenoiseCoeff(texture(attr,(aUV+vec2(radius,-radius))*IRES),CD,CN,L7.xyz-L0.xyz,Lc)+\n            vec4(L8.xyz,1.)*DenoiseCoeff(texture(attr,(aUV+vec2(-radius))*IRES),CD,CN,L8.xyz-L0.xyz,Lc)\n            )*I16;\n    //Output\n    return vec4(Accum.xyz/Accum.w,Write(vec4(Read(L0.w).x,Moments,0.)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec4 Color=vec4(0.);\n    if (fragCoord.y>HRES.y) {\n        if (fragCoord.x<HRES.x) {\n            //Second denoising pass\n            vec2 UV=fragCoord-vec2(0.,HRES.y);\n            vec4 LastAtt=texture(iChannel0,UV*IRES+0.5);\n            vec3 CN=Read(LastAtt.y).xyz*2.-1.;\n            Color=Denoise(UV+vec2(0.,HRES.y),UV+HRES,iChannel1,iChannel0,2.,LastAtt.w,CN);\n        }\n    } else if (fragCoord.x>HRES.x) {\n        //Third denoising step (temporal, one frame after)\n        vec2 UV=fragCoord-vec2(HRES.x,0.);\n        vec4 LastAtt=texture(iChannel0,UV*IRES+vec2(0.,0.5));\n        vec3 CN=Read(LastAtt.y).xyz*2.-1.;\n        Color=Denoise(UV+vec2(0.,HRES.y),UV+vec2(0.,HRES.y),iChannel2,iChannel0,4.,LastAtt.w,CN);\n    }\n    fragColor=Color;\n}","name":"Buffer D","description":"","type":"buffer"}]}