{"ver": "0.1", "info": {"id": "fsdXWj", "date": "1634466386", "viewed": 211, "name": "Lady Bugs in the Meadow", "username": "byt3_m3chanic", "description": " (mouseable) I did a 2D concept of this previously - but after watching some of Nusans livestream - I had some ideas on how to make it 3D [url]https://www.shadertoy.com/view/fsfXD2[/url] og shader.", "likes": 14, "published": 3, "flags": 0, "usePreview": 0, "tags": [], "requires": ["imagebuf"]}, "renderpass": [{"inputs": [], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "/**\n\n    Lady Bugs in the Meadow. (mouseable)\n    (I know it's a very fancy name for me)\n    10/17/21 @byt3_m3chanic\n    \n    This is a 3D concept based on a 2D version\n    I did last year https://www.shadertoy.com/view/fsfXD2\n\n    Yusef28 did a recent grass shader and was intregued\n    https://www.shadertoy.com/view/7stSzf\n    So while watching Nusans livestream video I had the idea\n    to make this. However the path/math isn't 100% and  glitchy. \n\n    Hoping to get some pointers cause I'm in deeper\n    than my math skills allow.. lol\n    \n    I did try another attempt at the grass - but sadly it\n    still has issues - check here using multi-tap setup.\n    https://www.shadertoy.com/view/fsySzm\n    \n    Nusans's video\n    https://www.youtube.com/watch?v=vpwukN_FUa8&t=4924s\n*/\n\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MAX_DIST    120.\n#define MIN_DIST    .0005\n\nfloat hash21(vec2 p) { return fract(sin(dot(p,vec2(23.86,48.32)))*4374.432); }\nvec2  hash2( vec2 p) { return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453); }\nvec3  hash3( vec2 p) {\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)), dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nvec3 noised( in vec2 x ){\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 p = vec2(floor(x));\n    float a = hash21( p+vec2(0,0) );\n\tfloat b = hash21( p+vec2(1,0) );\n\tfloat c = hash21( p+vec2(0,1) );\n\tfloat d = hash21( p+vec2(1,1) );\n\treturn vec3(a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y,\n\t\t   6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx));\n}\n\nfloat fbm( vec2 p, float freq ) {\t\n\tfloat h = -1.,w = 2.6,m = .35;\n\tfor (float i = 0.; i < freq; i++) {\n\t\th += w * noised((p * m)).x;\n\t\tw *= .5;\n\t\tm *= 2.;\n\t}\n\treturn h;\n}\n\nvec2 truchet(vec2 uv, float scale) {\n    uv *= scale;   \n    vec2 grid = fract(uv)-.5;\n    vec2 id = floor(uv);\n    float hs = hash21(id);\n    if(hs>.5) grid.x*=-1.;\n    vec2 d2 = vec2(length(grid-.5), length(grid+.5));\n    vec2 gx = d2.x<d2.y? vec2(grid-.5) : vec2(grid+.5);\n    float circle = length(gx)-.5;\n    circle=abs(circle)-.095;\n    return vec2(clamp(circle,0.,1.),hs);\n}\n\n//@iq Voronoi Distances\n//https://www.shadertoy.com/view/ldl3W8\nvec4 voronoi( in vec2 x){\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n    float ox = 0.;\n\tfloat wave = 223.3;\n\tvec2 mg, mr;\n\n    float md = 8.;\n    for( float j=-1.; j<=1.; j++ )\n    for( float i=-1.; i<=1.; i++ )\n    {\n        vec2 g = vec2(i,j);\n\t\tvec2 o = hash2( n + g );\n\n\t\to = .35 + .35 *sin(o * wave + PI2);\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n        if( d<md ){\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    md = 8.;\n    for( float j=-2.; j<=2.; j++ )\n    for( float i=-2.; i<=2.; i++ )\n    {\n        vec2 g = mg + vec2(i,j);\n\t\tvec2 o = hash2( n + g );\n        ox = o.x;\n\t\to = .35 + .35 *sin(o * wave + PI2);\n        vec2 r = g + o - f;\n        if( dot(mr-r,mr-r)>.00001 )\n        md = min( md, dot( .5*(mr+r), normalize(r-mr) ) );\n    }\n    return vec4( md, mr, ox );\n}\n\n//globals\nvec3 hitPoint,hit;\nmat2 rotA,rotB,rotC;\n\nfloat box(vec3 p,vec3 s) {\n    p=abs(p)-s; return max(p.x,max(p.y,p.z));\n}\n\nfloat box(vec2 p, vec2 b) {\n    vec2 d = abs(p)-b; return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// Field created watching @nusans shader livestream\n// with some improvisations on some things\n\nfloat blade(vec3 p, float sc) {\n    p/=sc; p.y-=1.5;\n    p.zx+= abs(p.xz)*.1;\n    float wd = sin((p.y+1.5)*1.5)*.1;\n    float d = box(p,vec3(wd,1.5,wd));\n    return d*sc*.8;\n}\n\nvec2 field(vec3 p, float rp) {\n    vec2 res=vec2(1e5,0);\n    vec2 id=floor(p.xz/rp-.5);\n    float hs = hash21(id);\n    p.xz=(fract(p.xz/rp-.5)-.5)*rp;\n\n    p.xz*=rot(hs*PI2);\n    float fs = hash21(id+3.4);\n    float sc = .5+hs*.8;\n    float b = blade(p,sc);\n    if(b<res.x) res =vec2(b,1.);\n    \n    if(fs>.9) {\n        float fb=length(p-vec3(0,sc*2.,0))-(sc*.075);\n        if(fb<res.x) res =vec2(fb,6.);\n    }\n    return res;\n}\n\nvec2 grass(vec3 p) {\n    vec2 res = vec2(1e5,0),d;\n    \n    p.xz +=sin(p.zx*.15+p.y*.1+T*3.)*.3*max(0.,p.y)*.5;\n    d = field(p,1.75);\n    if(d.x<res.x) res = d;\n    \n    p.xz*=rotA;\n    p.x+=45.35;\n    d = field(p,1.15);\n    if(d.x<res.x) res = d;\n  \n    p.xz*=rotB;\n    p.x+=141.5;\n    d = field(p,.75);\n    if(d.x<res.x) res = d;\n \n    return res;\n}\n\nfloat specks(vec3 p,float rp) {\n    p.z+=T*5.+abs(sin(T*.5-p.z*.01))*10.;\n    p.xyz+=sin(p.zxy*vec3(.02,0,.07)+vec3(.1,.07,.05)*T)*5.5;\n    p = (fract(p/rp-.5)-.5)*rp;   \n    return length(p)-.05;\n}\n\nfloat mst=0.;\nfloat mist(vec3 p) {  \n    vec3 q = p;\n    float d = specks(p,11.);\n    p.xz*=rotC;\n    p.yz*=rotB;\n    d = min(specks(p,7.),d);\n    \n    d += max(.0,-(6.-q.y)*.025);\n    return d; \n}\n\n// The truchet path is something I made up, however I haven't\n// found a good way of implimenting yet - tried some other \n// multi-tap systems so prevent the cutoff but not smart enough\n// mathwise to know what I'm trying to do.\n// well its not perfect but looks ok if you squint.\n\nfloat gid,sid;\nvec2 map(vec3 p, float sd) {\n\tvec2 res = vec2(1e5,0.);\n    vec3 pbk = p;\n    float gnd = fbm(p.xz*.15,.1)*1.95;\n    p.y+=gnd;\n    \n    vec2 uv = p.xz*.05;\n    float py = p.y+.5;\n    vec2 tc = truchet(p.xz,.05);\n    float cc = tc.x;\n    vec2 dx = grass(p);\n    if(dx.x<res.x) {\n        if(cc<.03){\n           dx.x += max(.1,.15-cc*.25);\n        }\n       res = vec2(dx.x,dx.y);\n       hit=p;\n    }\n   \n    float mt3 = mist(p);\n\n    if(mt3<res.x && sd>0.) {\n       res = vec2(mt3,3.);\n       mst +=clamp(.0025/(.00025+mt3*mt3) ,.0, max(.0, (gnd)*.015) );\n       //mst += .0025/(.00025+mt3*mt3);\n    }\n    \n    vec2 id = floor(p.xz*.05);\n    vec2 guv= fract(p.xz*.05)-.5;\n    \n    float hs = hash21(id);\n    if(hs>.5) guv.x*=-1.;\n    \n    float dir = mod(id.x+id.y,2.)<.5? -1. : 1.;\n    \n    vec2 x2 = vec2(length(guv-.5), length(guv+.5)); \n    vec2 pp = x2.x<x2.y? vec2(guv-.5) : vec2(guv+.5);\n    \n    pp *= rot(T*.125*dir);\n    \n    float amt = 3.,dbl = 6.;\n    \n    float a = atan(pp.y, pp.x);\n    float ai = floor(dir*a-.5/PI*dbl);\n    a = (floor(a/PI2*dbl) + .5)/dbl;\n    float ws = mod(ai,3.);\n    gid=ws;\n    vec2 qr = rot(-a*PI2)*pp; \n    qr.x -= .5;\n    vec3 np = vec3(qr.x/.05, py, qr.y/.05);\n    \n    //ladybugs\n    float d6=box(np,vec3(2.5,.6,2.5));\n    float d5=length(np-vec3(0,.5,0))-.75;\n    d5=max(d5,-d6);\n    if(d5<res.x) {\n       res = vec2(d5,5.);\n       hit=vec3(np.x,np.y,dir*np.z);\n    }\n    float d7=length(np-vec3(0,.75,dir*.6))-.35;\n    d7=max(d7,-d6);\n    if(d7<res.x) {\n       res = vec2(d7,4.);\n       hit=vec3(np.x,np.y,np.z-(dir*.6));\n    }\n\n    float d2=p.y;\n    if(d2<res.x) {\n       res = vec2(d2,2.);\n       hit=pbk;\n    }\n\n    return res;\n}\n\n// Normal\nvec3 normal(vec3 p, float t) {\n    float e = MIN_DIST*t;\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( \n        h.xyy*map( p + h.xyy*e,0. ).x + \n        h.yyx*map( p + h.yyx*e,0. ).x + \n        h.yxy*map( p + h.yxy*e,0. ).x + \n        h.xxx*map( p + h.xxx*e,0. ).x );\n}\n\nvec3 render(vec3 ro, vec3 rd, vec2 uv) {\n\n    vec3 C = vec3(0);\n    vec3 p = ro;\n    \n    // Sky\n    vec3 sky = mix(\n    max(vec3(.03),vec3(0.5,0.6,1.)-rd.y*2.),\n    vec3(0.9,0.7,0.5)*10.,\n    pow(max(.03, dot(rd,normalize(vec3(4.,15,4.)) )),10.));\n    vec2 vuv = (rd.xz/(rd.y+.075))-vec2(0,T*.75)*.75;\n    sky = mix(sky,vec3(.9), .25+.25*smoothstep(.01,.75,fbm(vuv,2.)) );\n\n    // Marcher\n    float d =0.,m = 0.;\n    for (int i = 0; i<192;i++) {\n     \tp = ro + rd * d;\n        vec2 ray = map(p,1.);\n        if(abs(ray.x)<d*MIN_DIST || d>MAX_DIST)break;\n        d += i<32? ray.x*.25 : ray.x*.85;  \n        m = ray.y;\n    }\n    \n    hitPoint=hit;\n    sid=gid;\n    float alpha = 0.;\n    \n    if(d<MAX_DIST){\n      \tvec3 n = normal(p, d);\n        vec3 lpos = vec3(15.,35,10.);\n        vec3 l = normalize(lpos-p); \n\n        // Diffused and Shadow\n        float diff = clamp(dot(n,l),0.,1.);\n\n        float shdw = 1., t = .01;\n        for(int i=0; i<25; i++){\n            float h = map(p + l*t,0.).x;\n            if( h<MIN_DIST ) {shdw = 0.; break;}\n            shdw = min(shdw, 25.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>32. ) break;\n        }\n        diff = mix(diff,diff*shdw,.35);\n\n        // Materials\n        vec3 h = vec3(.0);\n        if(m==1.) h = vec3(0.192,0.490,0.07);\n        if(m==2.) {\n            \n            vec2 uv = hitPoint.xz;\n            float px = fwidth(uv.x);\n            float circle = truchet(uv, .05).x;\n            circle=smoothstep(px,-px,circle);\n            \n            float dmp = hash21(floor(uv*25.))*.175;\n            h = vec3(0.059,0.196+dmp,0.004);\n            h = mix(h, h*vec3(0.020,0.055,0.004),circle);\n            \n            uv*=.05;\n            \n            vec2 guv = fract(uv)-.5;\n            vec2 id = floor(uv);\n\n            float hs = hash21(id);\n            if(hs>.5) guv.x*=-1.;\n            float dir = mod(id.y + id.x,2.) * 2. - 1.;\n\n            vec2 d2 = vec2(length(guv-.5), length(guv+.5));\n            vec2 gx = d2.x<d2.y? vec2(guv-.5) : vec2(guv+.5);\n\n            float width = .125;\n    \n            vec2 arc = guv-sign(guv.x+guv.y)*.5;\n            float angle = atan(arc.x, arc.y);\n\n            float d = length(arc);\n\n            vec2 tuv = vec2(fract(dir*angle/1.570796),(d-(.5-width))/(2.*width)*2.);\n            tuv.y-=.5;\n            vec2 tid = vec2(floor(dir*angle/1.570796),floor(d-(.5-width))/(2.*width));\n\n\n            if(hs<.5 ^^ dir>0.) tuv.y=1.-tuv.y;\n            if(mod(tid.x,2.)==0.) tuv.x = 1.-tuv.x;\n\n            tuv.xy*=vec2(2.5,.75);\n            tuv.x=mod(tuv.x+.5,1.)-.5;\n\n            vec4 c = voronoi(dir*tuv*6.);\n            float dx = c.x;\n            dx=smoothstep(.15+px,-px,dx);\n            \n            float clip = box(tuv-vec2(0,.35),vec2(.345,.375))-.1;\n            clip=smoothstep(-px,px,clip);\n            dx=max(clip,dx);\n            dmp = hash21(floor(uv*575.))*.175;\n            h = mix(vec3(0.525,0.408,0.294)-dmp,h,clip);\n            h = mix(h,vec3(0.200,0.137,0.082),dx-clip);\n            h = mix(h,vec3(0.031,0.020,0.008),clamp((c.y+c.z)-clip,0.,1.));\n            C += h * diff;\n        }\n        if(m==3.) h = vec3(0.831,0.961,0.780);\n        if(m==4.) {\n            vec2 uv = hitPoint.xz;\n            float px = fwidth(uv.x)*.5;\n            float d= length(abs(uv)-vec2(.15,.25))-.035;\n            d=smoothstep(px,-px,d);\n            \n            h = vec3(.001);\n            h = mix(h,vec3(.9),d); \n        }\n        if(m==5.) {\n            vec2 uv = hitPoint.xz;\n            float px = fwidth(uv.x)*.5;\n            h = sid==2.? vec3(0.957,0.043,0.043) : sid==1.?vec3(0.604,0.035,0.035) :vec3(0.757,0.525,0.525) ;\n            if(uv.x>-.025&&uv.x<.025) h=vec3(.003);\n            float d= length(vec2(abs(uv.x)-.2,uv.y+.5))-.08;\n            d= min(length(vec2(abs(uv.x)-.475,uv.y+.15))-.175,d);\n            d= min(length(vec2(abs(uv.x)-.275,uv.y-.275))-.125,d);\n            d=smoothstep(px,-px,d);\n            h = mix(h,vec3(.003),d);\n        }\n        if(m==6.) h = vec3(0.941,0.820,0.039);\n        if(m==7.) h = vec3(0.733,0.925,0.922);\n\n        C += (m==3.) ? h : h * diff;\n        \n        C += mst*vec3(0.843,0.902,0.976);\n        C = mix(sky,C,  exp(-.0000020*d*d*d));\n\n        ro = p+n*.1;\n        rd = reflect(rd,n);\n       \n    } else {\n        C = sky;\n    }\n    return C;\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    // precal\n    rotA = rot(.8511);\n    rotB = rot(.3851);\n    rotC = rot(.2851);\n    // uv + ro + rd\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,2.,35.);\n    vec3 rd = normalize(vec3(uv,-1));\n    \n    // mouse\n    float x = M.xy == vec2(0) ? .0 : (M.y/R.y *  1. - .5) * PI;\n    float y = M.xy == vec2(0) ? .0 : -(M.x/R.x * 1. - .5) * PI;\n    if(x<-.05)x=-.05;\n    mat2 rx = rot(x+(.15+.11*sin(T*.2))+.1); mat2 ry = rot(y+T*2.*PI/180.);\n    ro.yz *= rx; ro.xz *= ry;\n    rd.yz *= rx; rd.xz *= ry;\n\n    vec3 C = vec3(0);\n    C = render(ro, rd, uv);\n\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n// end\n\n", "name": "Image", "description": "", "type": "image"}]}