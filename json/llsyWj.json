{"ver":"0.1","info":{"id":"llsyWj","date":"1506479317","viewed":117,"name":"Marble Texture *","username":"stemkoski","description":"A procedurally generate marble texture created using fractal Perlin noise.","likes":0,"published":1,"flags":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// helper functions\n\n// works best for values of f in the range (0,1)\nfloat randomFloat(float f)\n{\n \treturn fract(98765.432109 * sin(123.456789*f));\n}\n\n// random vector with components in range (-1, 1)\nvec2 random2(vec2 v)\n{\n    v = vec2(0.123456 * v.x + 0.337345 * v.y,\n\t\t\t 0.753198 * v.x + 0.453627 * v.y);\n\treturn -1.0 + 2.0 * fract(12345.678901 * sin(v));\n}\n\n// gradient-based noise\n// random vectors at integer UV coordinates\n//   interpolate values within each square\nfloat gradientNoise(vec2 v) \n{\n    vec2 i = floor(v);\n    vec2 f = fract(v);\n\t\n\tvec2 u = smoothstep(0.0, 1.0, f);\n\t\n\t// random vectors at square corners\n\tvec2 randomA = random2(i + vec2(0.0,0.0));\n\tvec2 randomB = random2(i + vec2(1.0,0.0));\n\tvec2 randomC = random2(i + vec2(0.0,1.0));\n\tvec2 randomD = random2(i + vec2(1.0,1.0));\n\t\n\t// direction vectors from square corners to v\n    //  directionN = v - (i + vec2(x,y)) = f - vec2(x,y)\n\tvec2 directionA = f - vec2(0.0,0.0);\n\tvec2 directionB = f - vec2(1.0,0.0);\n\tvec2 directionC = f - vec2(0.0,1.0);\n\tvec2 directionD = f - vec2(1.0,1.0);\n\t\n\t// \"influence values\"\n\tfloat a = dot(randomA, directionA);\n\tfloat b = dot(randomB, directionB);\n\tfloat c = dot(randomC, directionC);\n\tfloat d = dot(randomD, directionD);\n\t\n    // final result: interpolate from corner values\n\treturn mix( mix(a, b, u.x), mix(c, d, u.x), u.y );\n}\n\n// add copies of itself at different scales\n// weighted (amplitudes) so that sum approx equals 1.0\nfloat fractalNoise(vec2 v) \n{\n    // initialize\n    float value = 0.0;\n    float amplitude = 0.5;\n    // loop\n    for (int i = 0; i < 4; i++) \n    {\n        value += amplitude * gradientNoise(v);\n        // double the frequency\n        v *= 2.0;\n        // half the amplitude\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float xPeriod = 6.0;\n\tfloat yPeriod = 6.0;\n    \n\tfloat r = sin(uv.x * xPeriod * 6.283 + uv.y * yPeriod * 6.283 \n                  + 15.0 * fractalNoise(10.0 * uv));\n    r = r + 1.0;\n    \n    vec4 gray = vec4(r,r,r, 1.0);\n    vec4 lightGreen = vec4(0.75, 1.0, 0.75, 1.0);\n    vec4 darkGreen  = vec4(0.0, 0.25, 0.0, 1.0);\n\tfragColor = gray * lightGreen + (1.0 - gray) * darkGreen;\n}","name":"Image","description":"","type":"image"}]}