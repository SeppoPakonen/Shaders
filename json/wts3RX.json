{"ver":"0.1","info":{"id":"wts3RX","date":"1557167218","viewed":397,"name":"Cube root function","username":"scholarius","description":"Cube root function without using pow()\nDoes not choke on negative numbers either.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define NEWTON_ITER 2\n#define HALLEY_ITER 0\n\nfloat cbrt( float x )\n{\n\tfloat y = sign(x) * uintBitsToFloat( floatBitsToUint( abs(x) ) / 3u + 0x2a514067u );\n\n\tfor( int i = 0; i < NEWTON_ITER; ++i )\n    \ty = ( 2. * y + x / ( y * y ) ) * .333333333;\n\n    for( int i = 0; i < HALLEY_ITER; ++i )\n    {\n    \tfloat y3 = y * y * y;\n        y *= ( y3 + 2. * x ) / ( 2. * y3 + x );\n    }\n    \n    return y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2. * ( fragCoord - iResolution.xy / 2. ) / iResolution.y;\n\tfloat x = uv.x;    \n    float y = cbrt(x);\n    float invddx = 3. * cbrt(x) * cbrt(x);\n\n    // compute relative error wrt. to pow\n    float rel_error = round( 16777216. * abs( abs(y) / pow( abs(x), .333333333 ) - 1. ) ) / 40.;\n    \n    float d = -.5 + .5 * iResolution.y * abs( y - uv.y ) * min( 1., invddx );\n    \n    d = min( d, .0 + .5 * iResolution.y * abs( rel_error - uv.y ) / max( 1., fwidth( rel_error ) ) );\n    \n    d = min( d, .875 + .0625 * iResolution.y * abs( uv.y - round( uv.y * 10. ) / 10. ) );\n    d = min( d, .875 + .0625 * iResolution.y * abs( uv.x - round( uv.x * 10. ) / 10. ) );\n    d = min( d, .5 + .25 * iResolution.y * abs( uv.y - round( uv.y ) ) );\n    d = min( d, .5 + .25 * iResolution.y * abs( uv.x - round( uv.x ) ) );\n    \n    fragColor.xyz = vec3( pow( clamp( d, 0., 1. ), 0.4545 ) );\n}","name":"Image","description":"","type":"image"}]}