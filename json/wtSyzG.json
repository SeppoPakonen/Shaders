{"ver": "0.1", "info": {"id": "wtSyzG", "date": "1594656357", "viewed": 47, "name": "Trackmania 2020's loading ring ", "username": "laralex", "description": "I'm too noob to make something more complex, thanks god developers implemented a loading ring the dumbest way possible", "likes": 3, "published": 1, "flags": 0, "tags": ["loading"], "requires": ["imagebuf"]}, "renderpass": [{"inputs": [], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "float circle(in vec2 uv, in vec2 center, in float radius, in float widthAA) {\n    return 1.0 - smoothstep(-1.0, +1.0, widthAA*(length(uv - center) - radius));\n}\n\nfloat ring(in vec2 uv, in vec2 center, in float radiusSmall, in float radiusBig, in float widthAA) {\n    return circle(uv, center, radiusBig, widthAA) - circle(uv, center, radiusSmall, widthAA);\n}\n\n#define PI 3.1415926\n//float mod(in float a, in float b) { return (a)-(floor((a)/(b))*(b)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float rot = radians(-iTime * 120.0);\n    mat2 m = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n    \n    // center and scale uvs\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tuv -= 0.5;\n    uv *= iResolution.xy/iResolution.y;\n    \n    uv = m * uv; \n    \n    float phi = atan(uv.x,uv.y);\n    float rho = length(uv)* 2.0;\n    \n    float transparency = mod(phi, PI) / PI;\n    \n    vec3 col = vec3(0);\n    float pixelWidth = iResolution.y * 0.6; \n    col += vec3(transparency*ring(uv, vec2(0.0,0.0), 0.18, 0.4, pixelWidth));\n    fragColor = vec4(col,1.0);\n    \n}", "name": "Image", "description": "", "type": "image"}]}