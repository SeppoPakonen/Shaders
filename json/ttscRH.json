{"ver":"0.1","info":{"id":"ttscRH","date":"1591477582","viewed":264,"name":" L'h\u00f4pital avec horreur","username":"pjkarlik","description":"Welcome to: L'h\u00f4pital avec horreur\nThe sum of my shader skills after 9 or so months of trying to learn the dark GL arts.. 4.7 sec compile - trying to get that lower...\n\narrow keys/wasd = move | mouse pan and tilt","likes":26,"published":3,"flags":48,"tags":[]},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// flycam by @spalmer - https://www.shadertoy.com/view/tdsfR4\n\n/**\n\tL'h\u00f4pital avec horreur\n\n\tI'm not that smart - had very minimal knowledge of the math\n\tinvolved in shaders, heck most of what people say here I need \n\tto look up the meaning before I can try to impliment..\n\n\tBut everyone here has given great feedback and way better\n\tcommented code - so thank you, you've greatly expanded my brain.\n\tI've learned a lot from eveyrone here but especially.. \n\t\n\t@iq @spalmer @Shane @mla @eiffie @jeyko and - @FabriceNeyret2 \n\tfor scaring me with AA formulas after my first post!\n\t(which I still need to figure out)\n\n\tThank you!\n\n\ttodo - texture/bmp maps/better lighting.\n*/\n\n#define LOOKUP(COORD) texture(iChannel0,(COORD))\n// silly rgb sepration based post effect\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\n\tvec2 uv = fragCoord.xy/iResolution.xy;    \n\n    vec3 color = LOOKUP(uv).rgb;\n    // effect sammple\n    vec3 fgclr = vec3(0.);\n    float f = length(uv  - 1.75);\n    fgclr.x = LOOKUP(uv - vec2(f*0.002,0.)).x;\n    fgclr.y = LOOKUP(uv + vec2(f*0.002,.001)).y;\n    fgclr.z = LOOKUP(uv + vec2(f*0.002,.001)).z;\n    // mask for effect and mixdown \n    float dt = distance(uv.xy,vec2(.5))*2.15;\n    dt = smoothstep(0.,.8,1.-dt);\n    vec3 fColor = mix(fgclr,color,dt);\n    // output\n    fragColor = vec4(fColor,1.);\n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define BufA iChannel0\n#define ResA iChannelResolution[0].xy\n#define IZERO min(iFrame, 0)\n\nconst float \n  tau = 2. * acos(-1.)\n, voxtile = 8.\n;\n\nconst vec3 voxorg = vec3(0,2,0);\n\nconst int\n  mSky  = 0\n, mGray = 1\n, mRed  = 2\n;\n\nvec2 spin(float r)\n{\n    return sin((r + vec2(.25, 0)) * tau);\n}\n\nmat2 mrot(vec2 cs)\n{\n\treturn mat2(cs.x,-cs.y\n              , cs.y, cs.x);\n}\n\nvoid rot(inout float a, inout float b, mat2 m)\n{\n    vec2 r = m * vec2(a, b); a = r.x; b = r.y;\n}\n\nvoid rot(inout vec2 a, inout vec2 b, mat2 m)\n{\n    rot(a.x, b.x, m);\n\trot(a.y, b.y, m);\n}\n\nvoid rot(inout vec3 a, inout vec3 b, mat2 m)\n{\n    rot(a.x, b.x, m);\n\trot(a.y, b.y, m);\n    rot(a.z, b.z, m);\n}\n\nmat3 Camera(vec2 uv)\n{\n    mat3 m = mat3(1);\n    rot(m[0], m[2], mrot(spin(-1.*uv.x)));\n    rot(m[1], m[2], mrot(spin(.25 - .5*uv.y)));\n    return m; \n}\n\nvec4 fetch(sampler2D ch, ivec2 p)\n{\n\treturn texelFetch(ch, p, 0);\n}\n\nstruct State\n{\n    ivec2 resolution;\n    vec3 eyepos;\n    vec3 eyevel;\n    vec2 eyeaim;\n};\n\nconst int\n  slotResolution = 0\n, slotEyePosAz   = 1\n, slotEyeVelEl   = 2\n, slotCount      = 3\n;\n\nvoid LoadState(out State state, sampler2D A, ivec2 R)\n{\n\tvec4[slotCount] data;\n\tfor (int i = slotCount; i-- > 0; )\n        data[i] = fetch(A, R-1-ivec2(i,0));\n    state.resolution = ivec2(data[slotResolution].xy);\n    state.eyepos = data[slotEyePosAz].xyz;\n    state.eyevel = data[slotEyeVelEl].xyz;\n    state.eyeaim = vec2(data[slotEyePosAz].w\n                       ,data[slotEyeVelEl].w);\n}\n\nvoid SaveState(inout vec4 c, State state, ivec2 p)\n{\n    ivec2 R = state.resolution;\n    if (p.y == R.y - 1) switch (R.x - 1 - p.x) {\n      case slotResolution:\n        c.xy = vec2(R);\n        break;\n      case slotEyePosAz:\n        c = vec4(state.eyepos, state.eyeaim.x);\n        break;\n      case slotEyeVelEl:\n        c = vec4(state.eyevel, state.eyeaim.y);\n        break;\n      default:\n        break;\n    }\n}\n\nvec3 voxpos(ivec3 i)\n{\n    return vec3(i) * voxtile + voxorg;\n}\n     \nivec3 voxid(vec3 p)\n{\n    p -= voxorg;\n    p /= voxtile;\n    ivec3 i = ivec3(round(p));\n \n    return i;\n}\n\nbool isVoxel(ivec3 i)\n{\n    return i.y >= 0 && i.y <= 1;\n}\n\nivec3 voxstorage(ivec3 i)\n{\n    i.x >>= 1;\n    return i;\n}\n\nvec2 Scene(vec3 p)\n{\n    float tile = voxtile\n    , scale = .5 //1.6*.5*tile //sqrt(2.)*.5*tile //.5 // object radius\n    ;\n    ivec3 i = voxid(p);\n    vec3 q = p - voxpos(i);\n    float l = length(q)\n    , s = .7*.5*tile // cell \"radius\"\n    , db = l - scale // ball at lattice points\n    , dp = p.y; // ground plane +Y\n    db = max(db, p.y-tile*4.+.5); // intersect tiled balls with a slab - hacky way\n    return db < dp\n    \t? vec2(db, mRed)\n        : vec2(dp, mGray);\n}\n\n\nvec3 SceneNormal(vec3 p, float h, out float d)\n{\n    vec3 n = vec3(\n          Scene(p + vec3(h,0,0)).x\n        , Scene(p + vec3(0,h,0)).x\n        , Scene(p + vec3(0,0,h)).x\n      ) - (d = Scene(p).x);\n    if (dot(n,n) < 1e-7) n = vec3(0,1,0);\n    else n = normalize(n);\n    return n;\n}\n\n//@spalmer flycam https://www.shadertoy.com/view/tdsfR4\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define BufA iChannel0\n#define ResA iChannelResolution[0].xy\n#define Kbd  iChannel3\n\nconst float \n  eyeradius = .25\n, eyespeed = 1.5\n, eyespin = 1.    // spin rate per mouse uv\n, eyesmooth = .05 // just a little is plenty\n, eyeh = 3. //0. //.75 - eyeradius //\n;\n\nstruct Inputs\n{\n    vec3 move;\n    vec2 mouse;\n    bool button;\n    float dt; // delta time seconds\n    // debug features TODO\n};\n    \nconst int // http://keycode.info\n  KEY_SPACE = 32\n, KEY_SHIFT = 16\n, KEY_C     = 67\n// https://wikipedia.org/wiki/Arrow_keys#WASD_keys\n, KEY_W     = 87\n, KEY_A     = 65\n, KEY_S     = 83\n, KEY_D     = 68\n// in DVORAK it's ,AOE, in AZERTY it's ZQSD\n, KEY_Z     = 90\n, KEY_Q     = 81\n, KEY_O     = 79\n, KEY_E     = 69\n, KEY_G     = 71\n, KEY_COMMA = 188\n, KEY_LEFT  = 37 // arrow keys\n, KEY_RIGHT = 39\n, KEY_UP    = 38\n, KEY_DOWN  = 40\n// key bindings to local directions\n#if 0\n    // arrows\n, KEY_LF    = KEY_LEFT\n, KEY_RT    = KEY_RIGHT\n, KEY_FW    = KEY_UP\n, KEY_BW    = KEY_DOWN\n#elif 0\n    // AZERTY ZQSD\n, KEY_FW    = KEY_Z\n, KEY_LF    = KEY_Q\n, KEY_BW    = KEY_S\n, KEY_RT    = KEY_D\n#elif 0\n    // DVORAK ,AOE\n, KEY_FW    = KEY_COMMA\n, KEY_LF    = KEY_A\n, KEY_BW    = KEY_O\n, KEY_RT    = KEY_E\n#else\n    // QWERTY\n, KEY_FW    = KEY_W\n, KEY_LF    = KEY_A\n, KEY_BW    = KEY_S\n, KEY_RT    = KEY_D\n#endif\n, KEY_UW    = KEY_SPACE // up - maybe PgUp/Dn?\n, KEY_DW    = KEY_C     // down - anything but control!\n//, KEY_F     = 70\n//, KEY_R     = 82\n//, KEY_V     = 86\n//, KEY_X     = 88\n//, KEY_PGUP  = 33\n//, KEY_PGDN  = 34\n//, KEY_TAB   = 9\n//, KEY_CAPS  = 20 // shouldn't encourage usage\n//, KEY_ALT   = 18 // alt is likely unwise also\n//, KEY_CTRL  = 17 // DO NOT use control because unwanted browser commands\n;\n\nfloat key(int vk)\n{\n    return step(.5, texelFetch(Kbd, ivec2(vk, 0), 0).x);\n}\n\nbool option(int vk)\n{\n    return .5 <= texelFetch(Kbd, ivec2(vk,2), 0).x;\n}\n\nvoid LoadInputs(out Inputs inp)\n{\n    inp.button = iMouse.z >= 0.;\n    inp.mouse = iMouse.xy;\n    if (iMouse.xyz == vec3(0)) // icon? //dot(iMouse,iMouse) < 1e-3) //\n        inp.mouse.y = iResolution.y*.5; // don't look at ground\n    inp.move = vec3(key(KEY_RT) - key(KEY_LF)\n                  , key(KEY_UW) - key(KEY_DW)\n                  , key(KEY_FW) - key(KEY_BW));\n    inp.dt = iTimeDelta;\n}\n\nvec3 CollideSphere(vec3 pos, float radius)\n{\n    float d;\n    vec3 n = SceneNormal(pos, radius, d);\n    pos -= n * min(0., d - radius * .7); // collision\n    n = SceneNormal(pos, radius, d);\n    pos -= n * min(0., d - radius * .9); // again!\n    n = SceneNormal(pos, radius, d);\n    pos -= n * min(0., d - radius); // again! helps with getting stuck in crevices\n    pos.y = max(pos.y, radius); // HACK prevent going beneath ground plane just in case\n    return pos;\n}\n\n// TODO support capsule as collision shape\n// a vertically-oriented one seems fine\n// also probably not hard to just specify the half-seg-offset\nvec3 CollideCapsule(vec3 pos, vec3 ofs, float radius)\n{ // could abuse CollideSphere multiple times,\n    vec3 p = pos;\n\t// but probably should do something custom\n\t// so can keep more info than CollideSphere exposes\n    for (int i = 2; --i >= 0; ) {\n    \tfloat d, dp, dm;\n    \tvec3 no = SceneNormal(p      , radius, d )\n    \t, np = SceneNormal(p + ofs, radius, dp)\n    \t, nm = SceneNormal(p - ofs, radius, dm)\n    \t// TODO estimate closest point on seg from 3 distances\n    \t;\n        // keep only the most negative of the results\n        if (d < dp && d < dm) {} //dp = dm = radius;\n        else if (dp < dm) { no = np; d = dp; } //dm = d = radius;\n        else { no = nm; d = dm; } // dp = d = radius;\n    \tp -= no * min(0., d  - radius);\n    \t//p -= np * min(0., dp - radius);\n    \t//p -= nm * min(0., dm - radius);\n    }\n    pos = p;\n    pos.y = max(pos.y, radius + abs(ofs.y)); // HACK prevent going beneath ground plane just in case\n    return pos;\n}\n\nvoid MoveCamera(inout State state, Inputs inp) \n{\n    vec2 oa = state.eyeaim;\n    mat3 view = Camera(oa);\n    float d, spd = eyespeed;\n    if (key(KEY_SHIFT) > .5) spd *= 4.; // just test key directly, it doesn't need to be state\n//    if (state.boost) spd *= 4.;\n    vec3 op = state.eyepos\n    , move = inp.move * inp.dt * spd \n    , p = op\n    // TODO we must find the closest point on the capsule core line segment\n    // to the world sdf isosurface, then repel *that* but poofed as a sphere\n    // then offset back from the repelled location to find where the capsule center should wind up\n    // or the lame way would be to sample many spheres along the capsule\n    // but then would need to collide them all; seems the wrong approach.\n    // however there may still be some local minima to deal with,\n    // so tracking simply one point seems prone to getting stuck in minima\n        // I propose tracking 2 or 3 points along the capsule core segment\n        // and interpolating among those to estimate the true closest point\n    //, n = SceneNormal(p, eyeradius, d) \n    ;\n    if (option(KEY_G)) { // 'G' = 71\n        const float acc = 4., ldamp = 4., vdamp = .1;\n        const vec3 grav = vec3(0,-9.8,0);\n    \tstate.eyevel += iTimeDelta * grav; // gravity force\n        state.eyevel += view * move * acc; // control force\n        state.eyevel *= exp2(-iTimeDelta*vec3(ldamp,vdamp,ldamp)); // damping\n    \tp += iTimeDelta * state.eyevel; // momentum\n        // TODO separate jump vs. levitate controls\n    } else {\n     \tp += view * move;\n    }\n    // gravity requires velocity state\n    //p = CollideSphere(p, eyeradius);\n    //p = CollideCapsule(p, vec3(0,eyeh,0), eyeradius);\n    p.y -= eyeh; p = CollideCapsule(p, vec3(0,eyeh,0), eyeradius); p.y += eyeh; // offset for eye height\n    state.eyepos = p;\n    state.eyevel = (p - op) / max(1e-7, iTimeDelta);\n    float evl2 = dot(state.eyevel, state.eyevel);\n    state.eyevel *= isnan(evl2) ? 0. : evl2 > 1e4 ? .5 : 1.;\n}\n\n// TODO actual turning, not just mimicking mouse state w/ mouse smoothing\n// idk, this is actually ok.  Sure, turning, then lifting mouse button,\n// then moving mouse, and clicking somewhere else will turn the camera,\n// but the way I'm doing it with smoothing and wrapping turns out all right,\n// and it's far simpler than maintaining the extra mouse or angle states\n// necessary to implement arcball or some other more stateful thing.\n// I'll live with this for now until I can think of something better.\n// if you want the other behavior you can always try Debug Camera's way.\n// this is actually more like Orbit Camera's way.\nvoid TurnCamera(inout State state, Inputs inp) \n{\n    vec2 R = vec2(state.resolution) //iResolution.xy\n    , oa = state.eyeaim\n    , a = inp.mouse / R; //iMouse.xy / R;\n    a.x = fract(a.x * eyespin);\n    a.y = clamp(a.y, 0., 1.);\n    if (abs(a.x - oa.x) > .5)\n        oa.x += sign(a.x - oa.x); // put on side of nearest wrapped angle\n    a = mix(a, oa, exp2(-inp.dt / eyesmooth)); // smooth interpolate\n    state.eyeaim = a;\n}\n\nvoid Update(inout State state, ivec2 R, bool init)\n{\n    Inputs inp;\n    LoadInputs(inp);\n    if (state.resolution != R) { // resized?\n        init = true; state.resolution = R; \n    }\n    if (init) { // if zeroes aren't good enough\n        state.eyepos = vec3(0,eyeh,-5);\n        state.eyeaim = vec2(0.,.5);\n    } else { // update state\n\t    MoveCamera(state, inp);\n\t    TurnCamera(state, inp);\n    }\n}\n\n// designed to support various dynamic state\n// once initialized, certain pixels can discard\n// if that works out advantageously;\n// for instance a texture atlas could skip all \n// the other state loading etc. once computed.\n// But since every single pixel does the same\n// state loading, which is trivial, \n// it doesn't add up to squat anyway.\n// Unless at full screen resolution, using all 4 Buffer tabs,\n// my gpu seems to be able to keep up with updating all\n// the buffer pixels all the time in most cases.\n// And that makes things a bit simpler since then we needn't\n// worry about the double-buffering or late-loaded textures.\n// Usually the prior data is loaded and passed through unchanged.\nvoid mainImage(out vec4 o, vec2 p)\n{\n    bool init = iFrame == 0;\n    ivec2 R = ivec2(iResolution)\n    , i = ivec2(p);\n    vec4 c = init\n        ? vec4(0,0,0,1)\n     \t: fetch(BufA, i);\n    State state;\n    LoadState(state, BufA, R);\n    Update(state, R, init);\n    SaveState(c, state, i);\n    o = c;\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//  L'h\u00f4pital avec horreur\n// Inifinity hallway in a scary hospital \n\n#define MAX_DIST \t30.\n#define MIN_DIST \t.001\n#define MAX_STEPS \t150\n\n#define PI  \t\t3.1415926\n#define PI2 \t\t6.2831853\n\n#define r2(a)  mat2(cos(a), sin(a), -sin(a), cos(a))\n#define isMouse() iMouse.xy==vec2(0)\n#define mx() isMouse() ? .0 : (iMouse.y / iResolution.y * .8 - .45) * PI\n#define my() isMouse() ? .0 : -(iMouse.x / iResolution.x * 1. - .5) * PI\n#define hash(a, b) fract(sin(a*1.2664745 + b*.9560333 + 3.) * 14958.5453)\n\n#define debug 0\n\n// mod setting to control the door to wall ratio\nfloat room_mod = 2.; \n\n// iMouse pos function\nvec3 get_mouse(vec3 ro) {\n    ro.zy *= r2(mx());\n    ro.zx *= r2(my());\n    return ro;\n}\n\n// sdf's @iq\nfloat box( vec3 p, vec3 b ) {\n  \tvec3 d = abs(p) - b;\n  \treturn length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat cap( vec3 p, float h, float r ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// global room vars for position\nconst float size = 4.;\nconst float hlf = 2.;\nconst float wall_pos = hlf;\nvec3 hitPoint;\nvec3 id;\n\n// base room cutout\nvec2 roombase( in vec3 pos, bool show_door ) {\n    vec2 res = vec2(MAX_DIST,0.);\n    // mirror vectors\n    vec3 absx = vec3(abs(pos.x), pos.yz);\n\tvec3 absxz = vec3(abs(pos.x),pos.y,abs(pos.z));\n    // floor\n    float room_floor = box(pos, vec3(wall_pos,.1,hlf));\n    hitPoint = pos;\n    if(room_floor<res.x) res = vec2(room_floor,3.);\n    // walls\n    float walls = box(absx - vec3(wall_pos,1.5,0.), vec3(.05,1.5,hlf));\n    // doors cutout\n    float door = box(absx - vec3(wall_pos,1.25,0.), vec3(.2,1.15,.5));\n    if(show_door) walls = max(-door, walls);   \n    if(walls<res.x) res = vec2(walls,1.);\n    // wooden support beams\n    float beams = box(absx-vec3(wall_pos-.06,0.2,0.), vec3(.02,.15,hlf));\n\t// baseboard\n    beams = min(box(absx-vec3(wall_pos-.06,1.14,0.), vec3(.02,.1,hlf)),beams);\n    // cut door from beams \n    if(show_door) {\n        beams=max(beams,-door);\n        float dframe1 = box(absxz-vec3(wall_pos-.02,1.19,0.5), vec3(.1,1.19,.06)); \n        dframe1 = min(box(absx-vec3(wall_pos-.02,2.35,0.), vec3(.1,.075,.56)),dframe1);\n        if (dframe1<res.x) res = vec2(dframe1,10.);\n        \n        float ds1 = box(pos- vec3(wall_pos-.0155,1.75,.95), vec3(.05,.25,.2 ));\n        if(ds1<res.x) res = vec2(ds1,7.); \n        \n        float ds2 = box(pos- vec3(-wall_pos+.0155,1.75,-.95), vec3(.05,.25,.2 ));\n        if(ds2<res.x) res = vec2(ds2,7.); \n         \n        float ds3 = box(pos- vec3(wall_pos-.0155,2.35,-.9), vec3(.65,.1,.005 ));\n        if(ds3<res.x) res = vec2(ds3,12.);\n        \n    }\n    if(!show_door) {\n        float ds1 = box(pos- vec3(-wall_pos+.0155,2.35,-.95), vec3(.65,.1,.005 ));\n        if(ds1<res.x) res = vec2(ds1,9.); \n \n    }\n    // add baseboard\n   \tif (beams<res.x) res = vec2(beams,2.);     \n    \n    return res;\n}\n\nvec2 roofbase(vec3 pos, bool show_door ) {\n    vec2 res = vec2(MAX_DIST,0.);\n\tfloat rooftop = box(pos- vec3(0.,3.,0.), vec3(wall_pos-.05,.05,hlf));\n    if(rooftop<res.x) res = vec2(rooftop,8.); \n    hitPoint = pos;\n    if(!show_door){\n    \tfloat toplight = box(pos- vec3(0.,2.92,0.), vec3(1.,.05,.35));\n    \tif(toplight<res.x) res = vec2(toplight,6.); \n        float lightframe = box(pos- vec3(0.,2.95,0.), vec3(1.05,.05,.37));\n    \tif(lightframe<res.x) res = vec2(lightframe,10.);\n    }\n    return res;\n}\n\nvec2 tablebase(vec3 pos, in float c) {\n    vec2 res = vec2(MAX_DIST,0.);\n    float tbh = .8;\n    vec3 tablepos = pos - vec3(0.,tbh,0.);\n    vec3 absxz = vec3(abs(tablepos.x),tablepos.y,abs(tablepos.z));\n\tfloat tabletop = box(tablepos, vec3(.25,.01,.5));\n    tabletop = min(\n        box(tablepos-vec3(0.,-.15,.0), vec3(.25,.01,.5)),\n        tabletop);\n\tfloat tablelegs = cap(absxz-vec3(.23,-tbh,.48),.02,tbh );\n    float table = min(tabletop,tablelegs);\n    if(table<res.x) res = vec2(table,10.); \n    return res;\n}\n\nvec2 chairbase(vec3 pos, in float c, float side) {\n    vec2 res = vec2(MAX_DIST,0.);   \n    vec3 seatpos = pos - vec3(0.,.5,0.);\n    vec3 absxz = vec3(abs(seatpos.x),seatpos.y,abs(seatpos.z));\n    float seat = min(\n        box(seatpos - vec3(side>0.?-.225:.225,.25,0.), vec3(.025,.25,.25)),\n        box(seatpos, vec3(.25,.05,.25)));\n    if(seat<res.x) res = vec2(seat,11.); \n    float legs = cap(absxz-vec3(.24,-.5,.24),.01,.5 );\n    if(legs<res.x) res = vec2(legs,1.);\n    return res;\n}\n\nvec2 framebase(vec3 pos, float c) {\n    vec2 res = vec2(MAX_DIST,0.);   \n    vec3 framepos = pos - vec3(wall_pos,1.9,.25); \n    float frame = max(\n        box(framepos, vec3(.1,.5,1.25)),\n        -box(framepos, vec3(.2,.48,1.23))\n        );\n\t\n    if(frame<res.x) res = vec2(frame,10.);\n    framepos.x -=.03;\n    float pic = box(framepos, vec3(.09,.48,1.23));\n    if(pic<res.x) res = vec2(pic,7.);\n    return res;\n}\n\nvec2 map(in vec3 p) {\n    vec2 res = vec2(MAX_DIST,0.);\n  \tp += vec3(0., -5.65, 0);\n    \n    id = floor((p + hlf)/size);\n    vec3 pos = vec3(\n        mod(p.x+hlf,size)-hlf,\n\t\tp.y,\n        mod(p.z+hlf,size)-hlf\n    );\n    \n\t#if debug>0\n   \tpos = p;\n    #else\n    #endif\n\n    \n    bool show_door = (mod(id.z,room_mod)==.0);\n    \n    vec2 base = roombase(pos,show_door);\n    if(base.x<res.x) res = base;\n    \n    vec2 roof = roofbase(pos,show_door);\n    if(roof.x<res.x) res = roof;  \n    // comment above and uncomment below to \n    // have roof removed when flying above.\n    /*\n    State state;\n    vec2 R = iResolution.xy;\n    LoadState(state, BufA, ivec2(R));\n    if(state.eyepos.y<8.){\n    \tvec2 roof = roofbase(pos,show_door);\n    \tif(roof.x<res.x) res = roof;\n    }*/\n    if(!show_door){\n    \tvec2 table = tablebase(pos+vec3(wall_pos-.45,0.,0.75),id.z);\n        table=min(tablebase(pos-vec3(wall_pos-.45,0.,0.75),id.z),table);\n    \tif(table.x<res.x) res = table;\n\n        vec2 chair = chairbase(pos+vec3(wall_pos-.5,0.,-.25),id.z,1.);\n        if(chair.x<res.x) res = chair;\n        hitPoint = pos;\n        vec2 chair2 = chairbase(pos+vec3(wall_pos-.5,0.,-.85),id.z,1.);\n        if(chair2.x<res.x) res = chair2;\n        hitPoint = pos;\n        vec3 npos = pos-vec3(wall_pos-.5,0.,-.85);\n        npos.xz*=r2(.25);\n        vec2 chair5 = chairbase(npos,id.z,0.);\n        if(chair5.x<res.x) res = chair5;\n        //hitPoint = npos;\n        vec2 picframe = framebase(pos,id.z);\n        if(picframe.x<res.x) res = picframe;\n        \n    } else {         \n        vec2 chair3 = chairbase(pos+vec3(wall_pos-.5,0.,1.05),id.z,1.);\n        if(chair3.x<res.x) res = chair3;\n       // hitPoint = pos;\n        vec3 npos = pos-vec3(wall_pos-.5,0.,-.85);\n        npos.xz*=r2(-.2);\n        vec2 chair4 = chairbase(npos,id.z,0.);\n        if(chair4.x<res.x) res = chair4;\n   \t\t//hitPoint = npos;\n    }\n\n    \n    return res;\n}\n\nvec3 get_normal(in vec3 p) {\n\tfloat d = map(p).x;\n    vec2 e = vec2(.01,.0);\n    vec3 n = d - vec3(\n        map(p-e.xyy).x,\n        map(p-e.yxy).x,\n        map(p-e.yyx).x\n    );\n    return normalize(n);\n}\n\nvec2 get_march( in vec3 ro, in vec3 rd) {\n    float mat = 0.;\n    float depth = 0.;\n    for (int i = 0; i<MAX_STEPS;i++)\n    {\n     \tvec3 pos = ro + depth * rd;\n        vec2 dist = map(pos);\n        mat = dist.y;\n        if(dist.x<MIN_DIST*depth) break;\n        depth += dist.x; \n        if(depth>MAX_DIST) break;\n    }\n    return vec2(depth,mat);\n}\n\nfloat get_ao(vec3 p, vec3 n){\n\t//@iq & @Shane\n    float r = 0., w = 1., d;\n    for (float i=1.; i<5.+1.; i++){\n        d = i/4.;\n        r += w*(d - map(p + n*d).x);\n        w *= .5;\n    }\n    return 1.-clamp(r,.0,1.);\n}\n\nfloat get_light(vec3 p, vec3 lpos) {\n    vec3 l = normalize(lpos-p);\n    vec3 n = get_normal(p);\n    float dif = clamp(dot(n,l),0. , 1.);\n    \n    float shadow = get_march(p + n * MIN_DIST * 2., l).x;\n    if(shadow < length(p -  lpos)) dif *= .2;\n \n    return dif;\n}\n\nvec3 get_stripes(vec2 uv){\n    uv.y -= tan(radians(-45.)) * uv.x;\n    float sd = mod(floor(uv.y * 2.5), 2.);\n    vec3 mate = (sd<1.) ? vec3(1.) : vec3(0.);\n    return mate;\n}\n\nvec3 get_color(float m, vec3 pos) {\n\tvec3 mate = vec3(.3);\n    vec3 mtp = hitPoint*.5;\n    if ( m==12.) mate = vec3(.4,.1,.1);\n    if ( m==11.) mate = vec3(.3,.6,.6);\n    //metalframe\n    if ( m==10.) mate = vec3(.1);\n    //hazard\n    if ( m==9.) mate = vec3(.8,.4,.0)*get_stripes(mtp.xy*15.);\n    if ( m==8.) { // roof\n        vec2 u = fract(mtp.xz * 2.);\n        float l = 3. * 2.0 / iResolution.x;\n        float ns = hash(u.x,u.y)*.6;\n        mate += 1.-vec3(max(step(u.x,l+.04), step(u.y,l+.04))*.75)+ns;\n    }\n    //wall sign\n    if ( m==7.)  mate = vec3(1.);\n    //light\n    if ( m==6.)  mate = vec3(2.5, 2.5, .5);\n    if ( m==5.)  { \n        vec2 f=fract(mtp.xz * 1.)-0.5;\n        mate = vec3(.02) * vec3(f.x*f.y>0.?.2:.7); \n    } \n    if ( m==4.) mate = vec3(.01);\n    //floor\n    if ( m==3.) { \n        mate = vec3(.02);\n        vec2 f=fract(mtp.xz * 2.)-0.5;\n        mate *= vec3(f.x*f.y>0.?.2:.7); \n    } \n    // beams\n    if ( m==2.) mate = vec3(.01,.03,.03);\n    if ( m==1.) mate = vec3(.6,.8,.6);\n\n    return mate;  \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv) {\n    vec3 color = vec3(.0);\n    vec3 lc1 = vec3(1.0,1.1,.98);\n    vec3 lc2 = vec3(2.);\n    \n    State state;\n    vec2 R = iResolution.xy;\n    LoadState(state, BufA, ivec2(R));\n    \n    vec3 fadeColor = vec3(.7);\n\n    vec3 lpos1 = state.eyepos;\n\n    vec2 ray = get_march(ro, rd);\n    float t = ray.x;\n \n    if(t<MAX_DIST) {\n        vec3 p = ro + t * rd;\n        vec3 nor = get_normal(p);\n\t\tvec3 tint=get_color(ray.y, p);\n        vec3 diff  = (lc1 * get_light(p, lpos1));\n        float ao = get_ao(p,nor);\n        \n        color += tint * diff * ao;\n        \n\t\tif ( ray.y==3. || ray.y==10.) {\n            vec3 rr=reflect(rd,nor);\n            vec2 ref=get_march(p,rr);\n            if(ray.x<MAX_DIST){\n                p+=ref.x*rr;\n                vec3 rtint = get_color(ref.y,p);\n                diff  = (lc1 * get_light(p, lpos1));\n                color += ((tint*2.)+rtint * diff)*.035;\n                color = mix( color, fadeColor, 1.-exp(-0.00045*ref.x*ref.x*ref.x));\n            }   \n        }\n        \n    } else {\n        color = fadeColor;\n    }\n    color = mix( color, fadeColor, 1.-exp(-0.00025*ray.x*ray.x*ray.x));\n    return pow(color, vec3(0.4545));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/\n        max(iResolution.x,iResolution.y);\n\n\tvec2 p = fragCoord;\n    \n    State state;\n    vec2 R = iResolution.xy;\n    ivec2 i = ivec2(p);\n    \n    LoadState(state, BufA, ivec2(R));\n    vec2 q = (p + p - R) / R.y;\n    mat3 view = Camera(state.eyeaim);\n\n    vec3 rv = vec3(q, 1.); // ray dir in view space\n    vec3 rd = normalize(view * rv);\n    vec3 ro = state.eyepos;\n\n    vec3 color = render(ro, rd, uv);\n    // correct yo gamma\n\tcolor = pow(color, vec3(0.4545));\n    fragColor = vec4(color,1.0);\n}\n","name":"Buffer B","description":"","type":"buffer"}]}