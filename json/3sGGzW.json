{"ver": "0.1", "info": {"id": "3sGGzW", "date": "1569769730", "viewed": 241, "name": "Seamless Pattern Distribution", "username": "yuchengzhong", "description": "Fast noise based seamless ramdom pattern distribution.\nbased on https://www.shadertoy.com/view/4sGfzG by FabriceNeyret2", "likes": 9, "published": 3, "flags": 0, "tags": ["distribution"], "requires": ["texture", "imagebuf", "library", "texturebuf"]}, "renderpass": [{"inputs": [{"id": "4dXGRn", "filepath": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "type": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "//based on https://www.shadertoy.com/view/4sGfzG by FabriceNeyret2\n\nfloat ofs = 0.;        // jitter centers in -ofs ... 1.+ofs\n\nvec2  CYCLE = vec2(0); // pattern repeat scale ( in #cells )\n\n\n// for shapes:  [multishape] = UNUSED here for now \nfloat ROUND = 0.25;               // radius of round corners\nfloat polyN  = 5.0;                 // nb sides for polygon and star shape\nfloat starR  = 0.5;                 // star interior radius ( % exterior )\nvec2  BEVEL = vec2(.5)/4.;\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\nvec3 hsv2rgb(vec3 c) \n{\n  vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n#define Inside(uv) float(uv.x>0.0&&uv.x<1.0&&uv.y>0.0&&uv.y<1.0)\n// === dot shape\n// --- custom shapes: local centered coordinates, box size, shape id (=hash)\nvec4 shapeCube(vec2 U) \n{\n    vec4 O = vec4(0);\n    vec2 A = 0.5 - U;                   // coords from borders \n    vec2 B  = A * 2.0 / BEVEL;                   // coords in bevel\n    float m = min(B.x,B.y);                 // in bevel if [0,1]\n    vec4 tex = vec4(Inside(A))*texture(iChannel0,A);\n    return tex;\n}\n\n// rectangular brick\nvec4 shapeTile(vec2 U) \n{\n    vec4 O = vec4(0);\n    vec2 A = 0.5 - abs(U);                   // coords from borders \n    vec2 B  = A * 2. / BEVEL;                   // coords in bevel\n    float m = min(B.x,B.y);                 // in bevel if [0,1]\n    if (A.x<ROUND && A.y<ROUND)                 // round edges\n    {\n        m = (ROUND-length(ROUND-A)) *2./dot(BEVEL,normalize(ROUND-A));    \n    }\n    return vec4(clamp(m,0.,1.));\n}\n\n// disc brick\nvec4 shapeDisc(vec2 U) \n{\n    vec4 O = vec4(0);\n    float A = 0.5 - length(U);             // distance from borders \n    float B = A * 2. / BEVEL.y;                 // distance in bevel\n    float m = B;                                // in bevel if [0,1]\n    return vec4(clamp(m,0.,1.));\n}\n\n// poly brick\nvec4 shapePoly(vec2 U) \n{\n     vec4 O = vec4(0);\n     float a = atan(U.x,U.y);\n     float l = length(U);\n     float b = 3.14159/polyN;\n     float A = 0.5 - l * cos(mod(a,2.*b)-b) / cos(b);\n     float B = A * 2. / BEVEL.y;                // distance in bevel\n     float m = B;                               // in bevel if [0,1]\n     return vec4(clamp(m,0.,1.));\n}\n\n// star brick\nvec4 shapeStar(vec2 U) \n{\n    vec4 O = vec4(0);\n    float a = atan(U.x,-U.y);\n    float l = length(U);\n    float b = 3.14159/polyN;\n    float tb = tan(b);\n    float s = .5*(starR * tb)/(sqrt(1.+tb*tb)-starR);\n    a = mod(a,2.*b)-b;\n    U = l * vec2(cos(a),sin(a)) / cos(b);\n    U.y = abs(U.y);\n    U.x -= 0.5;\n    float A = -(s*U.x+U.y)/sqrt(1.+s*s);\n    float     B = A * 2. / BEVEL.y;                 // distance in bevel\n    float      m = B;                                // in bevel if [0,1]\n    return vec4(clamp(m,0.,1.));\n}\nvec4 shaper(vec2 U) \n{           \n    return shapeStar(U);                \n}\n\nfloat SIZE = 1.5;       // dot size ( in CELL% ) . Equivalent to filtering dots\nfloat SIZE_Min = 0.5;       // size distribution \n\nfloat BRIGHTNESS = 1.0;       // dot intensity distribution around .5 (attention: same seed)\nfloat BRIGHTNESS_Min = 0.2;       \n\nfloat ROT0 = 0.0;       \nfloat ROT1 = 360.0;     \n\nfloat OFFSET = 0.5;\n\n#define REPEAT 6.0\n#define SEARCH_GRID 1\n\n#define d_hash3f(x)  vec3(((((((((uvec3( x * float(0xffffffffU))>>8U)^uvec3( x * float(0xffffffffU)).yzx)*1103515245U)>>8U)^(((uvec3( x * float(0xffffffffU))>>8U)^uvec3( x * float(0xffffffffU)).yzx)*1103515245U).yzx)*1103515245U)>>8U)^((((((uvec3( x * float(0xffffffffU))>>8U)^uvec3( x * float(0xffffffffU)).yzx)*1103515245U)>>8U)^(((uvec3( x * float(0xffffffffU))>>8U)^uvec3( x * float(0xffffffffU)).yzx)*1103515245U).yzx)*1103515245U).yzx)*1103515245U)/ float(0xffffffffU) + 1e-30\n#define d_hash3i(x) vec3(((((((((uvec3(ivec3(floor(x)))>>8U)^uvec3(ivec3(floor(x))).yzx)*1103515245U)>>8U)^(((uvec3(ivec3(floor(x)))>>8U)^uvec3(ivec3(floor(x))).yzx)*1103515245U).yzx)*1103515245U)>>8U)^((((((uvec3(ivec3(floor(x)))>>8U)^uvec3(ivec3(floor(x))).yzx)*1103515245U)>>8U)^(((uvec3(ivec3(floor(x)))>>8U)^uvec3(ivec3(floor(x))).yzx)*1103515245U).yzx)*1103515245U).yzx)*1103515245U)/ float(0xffffffffU) + 1e-30\n//simple one\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{  \n    fragCoord /= iResolution.y;\n    float dir = 0.0;\n    vec4 color= vec4(0.); \n    vec2 uv = fragCoord*10.0+iTime;\n    \n    \n//uv 0-10    \nvec2 iu = floor(uv);\nfor( int kx=-SEARCH_GRID; kx <= SEARCH_GRID; kx++ ) \n{\n  for( int ky=-SEARCH_GRID; ky <= SEARCH_GRID; ky++ ) \n  {\n    vec2 currentPosition = iu + vec2(kx,ky);            \n    vec3 repeatPosition = mod(vec3(currentPosition,1.0),REPEAT);\n    //Random          \n    vec3 Random0 = d_hash3i(repeatPosition);\n    vec3 Random1 = d_hash3f(Random0);                          \n    //Brightness\n    float brightness = mix(0.25,1.0,Random1.z);            \n    //color\n    vec4 ColorRGB = vec4(hsv2rgb(vec3(0.085,0.2+0.3*Random1.x,1.0)),1.0);\n     //Shapes\n    vec2 local = ((currentPosition - uv + mix(-vec2(OFFSET),vec2(OFFSET),Random0.xy))/mix(SIZE,SIZE_Min,Random0.z))*mat2(sin(radians(mix(0.0,360.0,Random1.y)) + vec4(1,0,2,1)*1.5707));\n    vec4 h = ColorRGB * brightness * shaper(local);              \n    color = max(color, h);\n  }\n}\nfragColor += color;        \n}", "name": "Image", "description": "", "type": "image"}, {"inputs": [], "outputs": [], "code": "vec3 hash3( uvec3 x ) \n{\n#define scramble  x = ( (x>>8U) ^ x.yzx ) * 1103515245U // GLIB-C const\n    scramble; scramble; scramble; \n    return vec3(x) / float(0xffffffffU) + 1e-30; // <- eps to fix a windows/angle bug\n}\nvec3 hash3f(vec3 x) \n{              // float[0,1] param\n    return hash3(uvec3( x * float(0xffffffffU)));\n}\nvec3 hash3i(vec3 x)\n{\n    return hash3(uvec3(ivec3(floor(x))));\n}\n#define d_hash3(sss)  vec3(((((((((sss>>8U)^sss.yzx)*1103515245U)>>8U)^(((sss>>8U)^sss.yzx)*1103515245U).yzx)*1103515245U)>>8U)^((((((sss>>8U)^sss.yzx)*1103515245U)>>8U)^(((sss>>8U)^sss.yzx)*1103515245U).yzx)*1103515245U).yzx)*1103515245U)/ float(0xffffffffU) + 1e-30\n\n\n#define rot(a) mat2(sin(radians(a) + vec4(1,0,2,1)*1.5707))\n//detail one\n/*\nvoid mainImage2( out vec4 fragColor, vec2 fragCoord )\n{  \n    fragCoord /= iResolution.y;\n\n    float dir = 0.0;\n    vec4 color= vec4(0.); \n\n    vec2 uv = fragCoord*10.0+iTime;\n    vec2 iu = floor(uv);//snap to grid\n    \n\n        for( int kx=-SEARCH_GRID; kx <= SEARCH_GRID; kx++ ) \n        {\n          for( int ky=-SEARCH_GRID; ky <= SEARCH_GRID; ky++ ) \n          {\n            vec2 p = iu + vec2(kx,ky);//search in SEARCH_GRID*SEARCH_GRID prevent leaking\n            \n            vec3 repeatPosition = mod(vec3(p,1.0),REPEAT);\n              \n            vec3 Random0 = hash3i(repeatPosition);\n            vec3 Random1 = hash3f(Random0);\n              \n            vec2 offset = mix(-vec2(OFFSET),vec2(OFFSET),Random0.xy);\n            vec2 local = p - uv + offset;\n            local /= mix(SIZE,SIZE_Min,Random0.z);\n                            \n            //rotation\n            float dir0 = mix(ROT0,ROT1,Random1.y);\n            local *= rot(dir0);\n            \n            //Brightness\n            float brightness = mix(BRIGHTNESS_Min,BRIGHTNESS,Random1.z);\n            \n            //color\n            vec3 RandomColorHSV = rgb2hsv(vec3(1.0,0.8,0.6));\n            RandomColorHSV.y = 0.2+0.3*Random1.x;\n            vec3 ColorRGB =  hsv2rgb(RandomColorHSV);\n            //Shapes\n            vec4 h = vec4(ColorRGB,1.0)*brightness* shaper(local);\n              \n            color = max(color, h);\n          }\n        }\n        fragColor += color;\n}\n*/", "name": "Common", "description": "", "type": "common"}]}