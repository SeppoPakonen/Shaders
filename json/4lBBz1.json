{"ver": "0.1", "info": {"id": "4lBBz1", "date": "1514495817", "viewed": 376, "name": "Path Tracing Materials", "username": "janispritzkau", "description": "My first attempt to create a path tracer in shaders", "likes": 13, "published": 1, "flags": 32, "tags": ["nation", "path_tracer"], "requires": ["texture", "imagebuf"]}, "renderpass": [{"inputs": [{"id": "4dXGR8", "filepath": "/media/previz/buffer00.png", "previewfilepath": "/media/previz/buffer00.png", "type": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "void mainImage(out vec4 fragColor, vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}", "name": "Image", "description": "", "type": "image"}, {"inputs": [{"id": "4dXGR8", "filepath": "/media/previz/buffer00.png", "previewfilepath": "/media/previz/buffer00.png", "type": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dXGR8", "channel": 0}], "code": "\nconst int SAMPLES = 48;\n\nconst float PI = 3.14159265359;\nconst float EPSILON = 0.00001;\nconst float INFINITY = 100000.0;\n\nfloat rand( inout vec2 seed ) {\n    seed *= 1.0102099;\n    return fract(sin(dot(seed, vec2(0.0923921, 0.000354164)))*341201.0239);\n}\n\nstruct Ray { vec3 origin; vec3 direction; };\n\nstruct Material { \n    vec3 baseColor;\n    float metallic;\n};\n    \nstruct Intersection {\n    float distance;\n\tvec3 position;\n    vec3 normal;\n    Material material;\n};\n\nbool intersectSphere( float radius, vec3 center, Material m, Ray ray, out Intersection hit ) {\n\tvec3 oc = center - ray.origin;\n    float l = dot(ray.direction, oc);\n    float det = pow(l, 2.0) - dot(oc, oc) + pow(radius, 2.0);\n    if (det < 0.0) return false;\n\n    // Find the Closer of Two Solutions\n             float len = l - sqrt(det);\n    if (len < 0.0) len = l + sqrt(det);\n    if (len < 0.0) return false;\n    vec3 pos = ray.origin + len * ray.direction;\n    hit = Intersection(len, pos, (pos - center) / radius, m);\n    return true;\n}\n\nbool intersectPlane( vec3 normal, Material m, Ray ray, out Intersection hit ) {\n\tfloat len = -dot(ray.origin, normal) / dot(ray.direction, normal);\n    if (len < 0.0) return false;\n    hit = Intersection(len, ray.origin + len * ray.direction, normal, m);\n    return true;\n}\n\nMaterial groundMaterial = Material(vec3(0.95), 0.0);\nMaterial sphereMaterial = Material(vec3(1.1, 0.84, 0.55), 1.0);\n\nbool intersect( Ray ray, out Intersection hit ) {\n    float t = INFINITY;\n    Intersection nearest;\n    \n    for (int i = 0; i < 3; i++) {\n      //if (intersectSphere(0.5, vec3(0.0), ray, hit) && hit.distance < t) { t = hit.distance; nearest = hit; }\n      if (intersectSphere(0.4, vec3(i - 1, 0.0, 0.4), sphereMaterial, ray, hit) && hit.distance < t) { t = hit.distance; nearest = hit; }\n    }\n    \n    if (intersectPlane(vec3(0.0, 0.0, 1.0), groundMaterial, ray, hit) && hit.distance < t) { t = hit.distance; nearest = hit; }\n\n    \n    hit = nearest;\n\treturn t < INFINITY;\n}\n\nvec3 radiance( Ray ray, inout vec2 seed ) {\n    int diffuseBounces = 0;\n    vec3 color = vec3(0.0);\n    vec3 colorB = vec3(1.0);\n    for (int i = 0; i < 8; i++) {\n        Intersection hit;\n        if (!intersect(ray, hit)) {\n            // some weird sky generating code\n            color += mix(vec3(1.1, 0.5, 0.4), vec3(0.2, 0.3, 0.5), 0.5 + dot(ray.direction, vec3(0.0, 0.0, 1.0)) / 2.0);\n            color += vec3(2.1, 1.2, 0.75) * pow(max(0.0, dot(ray.direction, normalize(vec3(1.0, 0.0, 1.0)))), 24.0) * 3.0;\n            color += vec3(2.0, 1.0, 0.6) * pow(max(0.0, dot(ray.direction, normalize(vec3(1.0, 0.0, 1.0)))), 3.0) * 0.5;\n        \tbreak;\n        }\n\n        if (hit.material.metallic == 1.0 || (hit.material.metallic != 0.0 && hit.material.metallic >= rand(seed))) {\n            ray = Ray(hit.position + hit.normal * EPSILON, ray.direction - hit.normal * 2.0 * dot(hit.normal, ray.direction));\n        } else {\n            diffuseBounces += 1;\n            float phi = PI * 2.0 * rand(seed);\n            float theta = asin(rand(seed));\n\n            vec3 normalZ = hit.normal;\n            vec3 normalX = normalize(cross(normalize(vec3(1.2, 1.3, 0.2)), normalZ));\n            vec3 normalY = cross(normalX, normalZ);\n\n            vec3 direction = normalize(normalX * cos(theta) * cos(phi) + normalY * cos(theta) * sin(phi) + normalZ * sin(theta));\n            ray = Ray(hit.position + hit.normal * EPSILON, direction);\n        }\n        \n\n        colorB *= hit.material.baseColor;\n        \n        if (diffuseBounces == 3) break;\n    }\n    return color * colorB;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 0.4;\n    vec2 seed = fragCoord * iTime; // * time\n    \n    vec3 camPos = 2.2 * vec3(0.0 + sin(time), 0.0 + cos(time), 0.35);\n   \tvec3 forward = normalize(vec3(0.0, 0.0, 0.65) - camPos);\n \tvec3 right = normalize(cross(forward, vec3(0.0, 0.0, 1.0)));\n    vec3 up = cross(right, forward);\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    //fragColor = vec4(vec3(1.0) * rand(seed), 1.0);\n    vec3 color = vec3(0.0);\n    \n    for (int s = 0; s < SAMPLES; s += 1) {\n        vec2 uv = (1.0 - (fragCoord.xy + vec2(rand(seed), rand(seed))) / iResolution.xy * 2.0) * 0.6;\n        Ray ray = Ray(camPos, normalize(right * uv.x * aspectRatio + forward + up * -uv.y));\n    \tcolor += radiance(ray, seed) / float(SAMPLES);\n    }\n    \n    vec3 c = pow(min(color, vec3(1.0)), vec3(1.0 / 2.3));\n    vec4 fcolor = vec4(max(vec3(0.0), 0.32 + 1.5 * (c - 0.5)), 1.0);\n\tfragColor = mix(texture(iChannel0, fragCoord / iResolution.xy), fcolor, iFrame == 1 ? 1.0 : 0.17);\n}", "name": "Buf A", "description": "", "type": "buffer"}]}