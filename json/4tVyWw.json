{"ver":"0.1","info":{"id":"4tVyWw","date":"1536573849","viewed":858,"name":"4D Cube","username":"iq","description":"Another 4D cube. For the 4D->3D projection, you can switch between orthographic and perspective projections, in line 9.","likes":21,"published":3,"flags":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by inigo quilez - iq/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n// Another 4D cube. For the 4D->3D proection, you can switch between \n// orthographic and perspective projections, in line 9.\n   \n// 0 = orthographics\n// 1 = perspective\n#define PROJECTION 1\n\n    \n#define AA 3   // make this 1 is your machine is too slow\n\n//------------------------------------------------------------------\n\nfloat iCapsule( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n\n        float y = baoa + t*bard;\n        \n        // body\n        if( y>0.0 && y<baba ) return t;\n\n        // caps\n        vec3 oc = (y<=0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - r*r;\n        h = b*b - c;\n        if( h>0.0 )\n        {\n            return -b - sqrt(h);\n        }\n    }\n    return -1.0;\n}\n\nvec3 nCapsule( in vec3 p, in vec3 a, in vec3 b, in float r )\n{\n    vec3 ba = b-a, pa = p-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return (pa - h*ba)/r;\n}\n\nvec3 dCapsule( in vec3 ro, in vec3 rd, vec3 pa, vec3 pb, float rad )\n{\n\tvec3 ba = pb - pa;\n\tvec3 oa = ro - pa;\n\t\n\tfloat oad  = dot( oa, rd );\n\tfloat dba  = dot( rd, ba );\n\tfloat baba = dot( ba, ba );\n\tfloat oaba = dot( oa, ba );\n\t\n\tvec2 th = vec2( -oad*baba + dba*oaba, oaba - oad*dba ) / (baba - dba*dba);\n\t\n\tth.x = max(   th.x, 0.0 );\n\tth.y = clamp( th.y, 0.0, 1.0 );\n\t\n\tvec3 p = pa + ba*th.y;\n\tvec3 q = ro + rd*th.x;\n\t\n\treturn vec3( length( p-q )-rad, th );\n}\n\n\n\nint objA, objB;\n\nconst float rad = 0.07;\n\nfloat intersect( in vec3 ro, in vec3 rd, in vec3 v[16] )\n{\n    float tmp;\n    \n    float res = 1e10;\n\n    for( int i=0; i<16; i++ ) // for each vertex\n    for( int j=0; j< 4; j++ ) // connect it to its 4 neighbors\n    {\n        int a = i;\n        int b = a ^ (1<<j); // change one bit/dimension\n        if( a<b )          // skip edge if already visited\n        {\n            tmp = iCapsule( ro, rd, v[a], v[b], rad );\n            if( tmp>0.0 && tmp<res )\n            {\n                res = tmp; \n                objA = a; \n                objB = b;\n            }\n        }\n    }\n\n    return (res<1e9)?res:-1.0;\n}\n\nvec3 calcNormal( in vec3 pos, in vec3 v[16] )\n{\n    return nCapsule( pos, v[objA], v[objB], rad );\n}\n\nfloat softShadowCapsule( in vec3 ro, in vec3 rd, in vec3 a, in vec3 b, in float r )\n{\n    const float k = 16.0;\n    vec3 t = dCapsule( ro, rd, a, b, r );\n    return clamp( k*t.x/max(t.z,0.0001), 0.0, 1.0 );\n}\n\n\n// soft shadows\nfloat calcShadow( in vec3 ro, in vec3 rd, in vec3 v[16] )\n{\n    float t = 1.0;\n    \n    for( int i=0; i<16; i++ ) // for each vertex\n    for( int j=0; j< 4; j++ ) // connect it to its 4 neighbors\n    {\n        int a = i;\n        int b = a ^ (1<<j); // change one bit/dimension\n        if( a<b )           // skip edge if already visited\n        {\n            t = min( t, softShadowCapsule( ro, rd, v[a], v[b], rad ) );\n        }\n    }    \n\n    return t;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor, in float seed, in vec3 v[16] )\n{\n    return 1.0;\n}\n\n\nvec3 render( in vec3 ro, in vec3 rd, in float seed, in vec3 v[16] )\n{ \n    vec3 col = vec3(0.04) + 0.03*rd.y;\n\n    float t = intersect(ro,rd,v);\n    if( t>0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, v );\n            \n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = vec3(0.4);\n\n        // lighting        \n        float occ = calcAO( pos, nor, seed, v )*(0.7+0.3*nor.y);\n\t\tvec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        float sha = (dif>0.001) ? calcShadow( pos+0.02*nor, lig, v ) : 0.0;\n\n\t\tfloat spe = pow( clamp( dot(nor,hal), 0.0, 1.0 ),16.0)*dif*sha*\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.30*dif*vec3(1.20,0.80,0.65)*vec3(sha,0.5*sha+0.5*sha*sha,sha*sha);\n        lin += 0.70*amb*vec3(0.70,0.80,1.00)*occ;\n        lin += 1.00*fre*vec3(1.20,1.10,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 15.00*spe*vec3(1.00,0.90,0.70);\n    }\n\n\treturn col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nmat2 rot(float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\nvec3 transform( in vec4 p )\n{\n    p.xw *= rot(iTime*0.41);\n    p.yw *= rot(iTime*0.23);\n    p.xy *= rot(iTime*0.73);\n    p.wz *= rot(iTime*0.37);\n    \n    // orthogonal projection\n    #if PROJECTION==0\n    return p.xyz;\n    #else\n    // perspective projection\n\treturn 2.5*p.xyz/(3.0+p.w);\n    #endif\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 v[16];\n\n    // rotate 4D cube\n    v[ 0] = transform( vec4(-1,-1,-1,-1));\n    v[ 1] = transform( vec4(-1,-1,-1, 1));\n    v[ 2] = transform( vec4(-1,-1, 1,-1));\n    v[ 3] = transform( vec4(-1,-1, 1, 1));\n    v[ 4] = transform( vec4(-1, 1,-1,-1));\n    v[ 5] = transform( vec4(-1, 1,-1, 1));\n    v[ 6] = transform( vec4(-1, 1, 1,-1));\n    v[ 7] = transform( vec4(-1, 1, 1, 1));\n    v[ 8] = transform( vec4( 1,-1,-1,-1));\n    v[ 9] = transform( vec4( 1,-1,-1, 1));\n    v[10] = transform( vec4( 1,-1, 1,-1));\n    v[11] = transform( vec4( 1,-1, 1, 1));\n    v[12] = transform( vec4( 1, 1,-1,-1));\n    v[13] = transform( vec4( 1, 1,-1, 1));\n    v[14] = transform( vec4( 1, 1, 1,-1));\n    v[15] = transform( vec4( 1, 1, 1, 1));\n    \n    \n    // camera (static)\n    vec3 ro = vec3( 4.5, 1.5, 0.0 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n\t#define ZERO min(iFrame,0)\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float seed =  gl_FragCoord.x + gl_FragCoord.y*131.1 + iTime + 17.1*float(m) + 37.4*float(n);\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        float seed =  gl_FragCoord.x + gl_FragCoord.y*131.1 + iTime;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n        // render\t\n        vec3 col = render( ro, rd, seed, v );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // cheap dither to remove banding from background\n    tot += 0.5*sin(fragCoord.x)*sin(fragCoord.y)/256.0;\n    \n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}