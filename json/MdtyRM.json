{"ver":"0.1","info":{"id":"MdtyRM","date":"1518360541","viewed":502,"name":"A Stupidly Expensive Pathtracer","username":"slerpy","description":"A pathtracer combined with two older shaders of mine. I had this idea in my head for quite some time now, but I didn't know how to make it a reality.\n\nSpace to reset","likes":19,"published":1,"flags":48,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 col = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    fragColor = pow(col / col.w, vec4(1.4));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define TAU 6.28318530718\n\n#define AA 2.\n#define DOF 4.\n\n#define FAR 50.\n#define ITER 80\n#define STEP .8\n#define NORK 1e-3\n\n#define RITER 6\n#define RRFB .001\n\nstruct obj {\n    vec3 emit;\n    float opaque;\n    bool screen;\n    vec3 tuv;\n} objHit;\n\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hashHs( vec3 n, uint seed )\n{\n    float a=(float((seed*0x73493U)&0xfffffU)/float(0x100000))*2.-1.;\n    float b=6.283*(float((seed*0xAF71fU)&0xfffffU)/float(0x100000));\n    float c=sqrt(1.-a*a);\n    vec3 r=vec3(c*cos(b),a,c*sin(b));\n    return dot(r,n)>0.?r:-r;\n}\n\nmat3 rx(float a){ float s=sin(a), c=cos(a); return mat3(1,0,0,0,c,s,0,-s,c); }\nmat3 ry(float a){ float s=sin(a), c=cos(a); return mat3(c,0,s,0,1,0,-s,0,c); }\nmat3 rz(float a){ float s=sin(a), c=cos(a); return mat3(c,s,0,-s,c,0,0,0,1); }\n\nfloat box(vec3 p){ p=abs(p); return max(max(p.x, p.y), p.z); }\nfloat box(vec2 p){ p=abs(p); return max(p.x, p.y); }\n\nfloat sbox(vec3 p){ return max(max(p.x, p.y), p.z); }\nfloat sbox(vec2 p){ return max(p.x, p.y); }\n\nbool dmin(inout float d, in float x){ bool b=x<d; if(b)d=x; return b; }\n\n\n/////////////////////////////////\n\n\nvec3 screen( vec2 uv, float time )\n{   \n\tvec3  R = iResolution,\n         rd = normalize(vec3(uv-.5, R.y/R.x)),\n\t     ro = vec2(0, time).xxy;\n    \n    rd *= ry(.6);\n    \n    float t=.0, m;\n    for( int i=0; ++i < 30; )\n    {\n        vec3 p = ro + rd * t;\n        \n        float s = sin( time + .6*p.z )/4.;\n        p *= rz( s );\n        p.xy += .5 + vec2( -s, s );\n\n        vec3 q = abs( p-round(p) );\n        float d = min(min(length(q.xy), length(q.xz)), length(q.yz)) - .01;\n        d = min(d, box(q) - .05);\n        q = vec3(.0, p.xy - vec2(2.5, 0.5) ) * rz( p.z + time );\n        d = min(d, box(q) - .25);\n    \t\n        t += d/2.;\n    }\n    \n    return vec3( cos(t*rd.z + time - .5),\n                 exp(-t/6.),\n                 1.-exp(-t/4.) );\n}\n\n\n/////////////////////////////////\n\n\nfloat wall(vec3 p)\n{\n    float d = -p.z;\n    if(d > .5)return d;\n    \n    p.xy = -abs(p.xy-round(p.xy));\n    \n    for(int tx=0; tx<2; tx++)\n    {\n        for(int ty=0; ty<2; ty++)\n        {\n    \t\tvec3 q = vec3(tx, ty, 0) + p;\n            float l = length(q.xy);\n            d = min(d, max(l-1., -p.z-(l*l)/8.));\n        }\n    }\n    \n    return d;\n}\n\nfloat map(vec3 p)\n{\n    objHit.emit = vec3(0);\n    objHit.opaque = 1.;\n    objHit.screen = false;\n    \n    float d = 1e+31;\n    \n    dmin(d, wall(p-vec3(2.5)));\n    dmin(d, max(1.5+p.y, -3.-p.z));\n    \n    \n    const float w = 2.25;\n    float t = 3. * round(.5 * p.x/w);\n    \n    vec3 q = p;\n    q.x = mod(p.x + w, 2.*w) - w;\n    //q.z -= .1 * sin(t);\n    \n    float ratio = iResolution.x/iResolution.y;\n    \n    float screen = sbox(abs(q)-vec3(ratio, 1, 0)-.1);\n    dmin(screen, sbox(abs(q-vec3(0, -4, .2))-vec3(-.3*p.y, 4, .2)));\n    dmin(screen, sbox(abs(q*rx(-.04)-vec3(0, -1.45, -1.5))-vec3(1, .1, .6)));\n    \n    if(dmin(d, screen))objHit.opaque = .5;\n    objHit.screen = (abs(q.z+.1) < .1) && (box(q.xy/vec2(ratio,1)) < 1.);\n    //if(objHit.screen)objHit.opaque = .0;\n    \n    vec2 tuv = q.xy / vec2(ratio, 1);\n    objHit.tuv = vec3(0.5 * tuv + 0.5, t);\n    \n    \n    //if(dmin(d, 2.4-p.z+.02*pow(p.y-1., 2.) ))objHit.emit = vec3(2);\n    if(dmin(d, 2.46-p.z))objHit.emit = vec3(2);\n    \n    if(dmin(d, length(p-vec3(-10, 4, -8))-5.))objHit.emit = vec3(2,1,0) * .3;\n    if(dmin(d, length(p-vec3(+10, 4, -8))-5.))objHit.emit = vec3(0,1,2) * .5;\n    \n    if(dmin(d, length(p.yz-vec2(8, -8))-5.))objHit.emit = vec3(.5);\n    \n\treturn d;\n}\n\n\n/////////////////////////////////\n\n\nvec3 normal(vec3 p, float k)\n{\n    float m = map(p);\n\tvec2 e = vec2(0,k);\n\treturn normalize(m-vec3(\n\t\tmap(p - e.yxx),\n\t\tmap(p - e.xyx),\n\t\tmap(p - e.xxy)\n\t));\n}\n\nfloat tracer(vec3 ro, vec3 rd)\n{\n    float t=RRFB, m;\n    for(int i=0; i < ITER; i++)\n    {\n        t += STEP * map(ro + rd*t);\n        if(t > FAR)break;\n    }\n    return t;\n}\n\n\n/////////////////////////////////\n\n\nvoid camera(out vec3 ro, out vec3 rd, in vec2 p)\n{\n    p.xy += AA * (hash23(vec3(p.xy, iFrame)) - .5);\n\tvec2 uv = (2.*p.xy-iResolution.xy)/iResolution.x;\n    \n    vec2 blur = DOF * (hash23(vec3(iFrame, p.xy))-.5) / iResolution.x;\n    mat3 rm = rx(blur.x) * ry(blur.y + TAU/8.);\n    \n\tro = rm * vec3(-.75, -0.25, -8);\n    rd = rm * normalize(vec3(uv, 2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    \n    if(iFrame > 0 && texelFetch(iChannel1, ivec2(0x20, 0), 0).r < .5)\n\t\tfragColor = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    \n    uint seed = uint(fragCoord+12345.) * uint(fragCoord.y+67890.);\n    \n    vec3 emit = vec3(0), ro, rd, sp, sn;\n    camera(ro, rd, fragCoord);\n    \n    for(int i=0; i<RITER; i++)\n    {\n        float t = tracer(ro, rd);\n        if(t > FAR)break; \n        \n        obj objSave = objHit;\n        \n\t\tsp = ro + rd*t;\n\t\tsn = normal(sp,NORK);\n        \n        emit += objSave.emit;\n        \n        if(objSave.screen)\n        {\n            float time = objSave.tuv.z;\n            emit = .8 * screen(objSave.tuv.xy, time);\n        }\n        \n        seed ^= uint(iFrame) / uint(i+1);\n        rd = mix(reflect(rd, sn), hashHs(sn, seed), objSave.opaque);\n        ro = sp;\n    }\n    \n    //emit = 10. * emit / (box(emit)+1.);\n    //emit = pow(emit, vec3(.4545));\n    \n    fragColor += vec4(emit, 1);\n}","name":"Buf A","description":"","type":"buffer"}]}