{"ver":"0.1","info":{"id":"3l2Gz1","date":"1558585096","viewed":454,"name":"OpticalFlowAttempt","username":"granito","description":"*Mouse-down for debug view\n\nBufA: Apply Vertical Blur (stored in Alpha)\nBufB: Apply Horizontal Blur (stored in Alpha)\n\nBufC: Store 4fr history\nBufD: Calc Optical Flow\n\nImage: Apply Motion Blur\n\ni'm open to any suggestions! ","likes":2,"published":3,"flags":32,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvoffsets = (texture(iChannel0, uv).xy);\n    \n    //apply motion blur\n    vec3 sum = vec3(0.);\n    vec3 accumulation = vec3(0.);\n    vec3 weightsum = vec3(0.);\n    for (float i = -mblursamples; i <= mblursamples; i++){    \n        vec3 currsample = texture(iChannel1, uv + vec2(i * uvoffsets) ).xyz;\n        accumulation += currsample * weight;\n        weightsum += weight;\n    }\n    sum = accumulation / weightsum;\n\n    vec3 debug = vec3( uvoffsets.xy * 1000. + 0.5, 0.);\n    \n    //output\n    fragColor.xyz = mix( sum , debug , saturate(iMouse.z) );\n    //fragColor.xyz = sum;\n    //fragColor.xyz = debug;\n}\n\n// use motion vectors to blur video and also show motion vectors debug view","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float scale = 1.0;       // scale flow\nfloat threshold = 0.0001;     // flow intensity threshold\n\nconst float kernel = 64.0;\nconst float weight = 1.0;\n\nconst float mblursamples = 32.0;\nconst float mblurstrength = 1.0;\n\n\n\n// taken from https://tinyurl.com/y6yl5z3j \nvec2 flow(float prev, float curr){\n  float currddx = dFdx(curr);\n  float currddy = dFdy(curr);\n  float prevddx = dFdx(prev);\n  float prevddy = dFdy(prev);\n  // dt, dx, dy\n  float dt = curr - prev; // dt\n  float dx = currddx + prevddx; // dx_curr + dx_prev\n  float dy = currddy + prevddy; // dy_curr + dy_prev    \n  // gradient length\n  float dd = sqrt(dx*dx + dy*dy + 1.0);\n  // optical flow\n  vec2 flow = scale * dt * vec2(dx, dy) / dd; \n  return flow;\n}\n\nconst vec3 grayscaleweights = normalize(vec3(0.3,0.6,0.1));\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat saturate (float x){\n\treturn min(max(x,0.),1.);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 ch0 = texture(iChannel0, uv);\n\n    fragColor = ch0;\n    \n\tfloat sum = 0.;\n    float pixelSize = 1.0 / iResolution.y; \n    \n    // Vertical Blur\n    float accumulation = 0.;\n    float weightsum =0.;\n    for (float i = -kernel; i <= kernel; i++){\n        float currsample = dot( texture(iChannel0, uv + vec2(0.0, i * pixelSize)).xyz, grayscaleweights);\n        accumulation += currsample * weight;\n        weightsum += weight;\n    }\n    sum = accumulation / weightsum;\n    \n    fragColor.w = sum; //store blurred buffer in alpha\n}\n\n// I'm blurring the image in order to get better low frequency motion detection. it's not ideal but i can't think of a better alternative. ","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 ch0 = texture(iChannel0, uv);\n\n    fragColor = ch0;\n    \n\tfloat sum = 0.;\n    float pixelSize = 1.0 / iResolution.x; \n    \n    // Horizontal Blur\n    float accumulation = 0.;\n    float weightsum =0.;\n    for (float i = -kernel; i <= kernel; i++){\n        float currsample = texture(iChannel0, uv + vec2(i * pixelSize, 0.0)).w;\n        accumulation += currsample * weight;\n        weightsum += weight;\n    }\n    sum = accumulation / weightsum;\n    \n    fragColor.w = sum; //store blurred buffer in alpha\n}\t    \n\n// done blurring now","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // curr frame to 4 quadrants\n    vec4 ch0 = texture(iChannel0, fract(uv*2.));\n    \n    // backbuffer\n    vec4 ch1 = texture(iChannel1, uv);   \n    \n    //quadrant cycler mask\n    float mask = 0.;   \n    float framestep = floor(fract(float(iFrame)*0.25) * 4.) * 0.25 ;\n    float quadrants = floor(uv.x*2.) * 0.25 + floor(uv.y*2.)  * 0.5;\n\tif(framestep == quadrants) \n    { \n        mask = 1.;\n    }\n    \n    //draw curr frame in matching quadrant\n    fragColor = mix(ch1, ch0, mask);\n}\n\n// im buferring 4 frames of the video in order to generate motion vectors ","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"vec2 froffsets[4] = vec2[]( vec2(0.,0.), vec2(0.5,0.), vec2(0.,0.5), vec2(0.5,0.5) );\n\nint frstep (int offset) {\n    return int( floor( fract(float(iFrame)*0.25 + float(offset)*0.25 ) * 4.)  );\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //4 frame buffer to generate optical flow with\n    float frA = texture(iChannel0, uv * 0.5 + froffsets[frstep(0)] ).w;\n    float frB = texture(iChannel0, uv * 0.5 + froffsets[frstep(1)] ).w;\n    float frC = texture(iChannel0, uv * 0.5 + froffsets[frstep(2)] ).w;\n    float frD = texture(iChannel0, uv * 0.5 + froffsets[frstep(3)] ).w;\n    \n    vec2 offsets = flow(frA,frB) + flow(frB,frC) * 0.5 + flow(frC,frD) * 0.25;\n    \n    fragColor.xy = offsets;\n    \n    //*fragColor.zw unused\n}\n\n// generated motion vectors","name":"Buffer D","description":"","type":"buffer"}]}