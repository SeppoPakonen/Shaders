{"ver": "0.1", "info": {"id": "MdGfDG", "date": "1530203931", "viewed": 2862, "name": "Space Glider 2020 VR", "username": "scholarius", "description": "You fly the 'Super-XR 7000' spaceplane around a small planet.\nSelect a start location by pressing the corresponding key.\nAfter watching the transfer sequence you are free to go.\n\nAccompanying article: [url]http://www.thetenthplanet.de/archives/4519[/url]\n", "likes": 56, "published": 1, "flags": 49, "tags": ["flight", "game", "pbr", "primitive", "light", "simulation", "space", "sphere", "star", "atmosphere", "terrain", "tone", "tonemap", "ai", "orb", "orbit", "map", "rain"], "requires": ["library", "texturebuf", "keyboardbuf", "imagebuf", "texture", "volumebuf"]}, "renderpass": [{"inputs": [{"id": "4dXGzr", "filepath": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "type": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "4dXGR8", "filepath": "/media/previz/buffer00.png", "previewfilepath": "/media/previz/buffer00.png", "type": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "XdfGR8", "filepath": "/media/previz/buffer03.png", "previewfilepath": "/media/previz/buffer03.png", "type": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "XsBSR3", "filepath": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "type": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "/*\n *\t\t\t\tSPACE GLIDER 2020 SHADERTOY EDITION\n *\t\t\t\t\t   by Christian Sch\u00fcler\n *                       (c) 2001 - 2020\n *\n * Part 6 of 6: Image shader (postprocess, HMD and text overlay)\n * This software comes with no warranty. Use it at your own risk.\n *\n * ----------------------------------------------------------------------------\n *\n * You fly the 'Super-XR 7000' spaceplane around a small planet.\n * Select a start location by pressing the corresponding key.\n * After watching the transfer sequence you are free to go.\n *\n *\n * Controls\n * --------\n *\n *\t\tTAB\t\t\t \t\tMenu\n *\t\tM\t\t\t\t\tMap view\n *\n *\t\tup/down\t\t\t\tPitch control\n *\t\tup/down + alt/ctrl\tPitch trim (for aero controls only)\n *\t\tleft/right\t\t\tRoll control\n *\t\tA/D or Q/D\t\t\tYaw control or wheel steering\n *\t\tW/S or Z/S\t\t\tThrottle control (with stops at 15%, 35% and 70%)\n *\n *\t\t(pressing shift gives finer controls for all of the above)\n *\n *\t\tF\t\t\t\t\tMove flaps down one notch\n *\t\tF + shift\t\t\tMove flaps up one notch\n *\t\tV\t\t\t\t\tToggle spoilers (airbrakes)\n *\t\tG\t\t\t\t\tToggle landing gear\n *\t\tB\t\t\t\t\tHold wheel brakes\n *\t\tB + shift\t\t\tHold wheel brakes (less effort)\n *\t\tspace\t\t\t\tHalt (Cut throttle and apply brakes)\n *\n *\t\t< or `\t\t\t\tRotate thrust vector up one position\n *\t\t< or ` + shift\t\tRotate thrust vector down one position\n *\n *\t\tmouse \t\t\t\tMouse look\n *\t\tbackspace\t\t\tForward look\n *\n *\t\tR\t\t\t\t\tCycle image magnification\n *\t\tH\t\t\t\t\tCycle overlay brightness\n *\t\tN\t\t\t\t\tToggle photo multiplier overlay ('night vision')\n *\t\tT\t\t\t\t\tToggle terrain radar overlay\n *\t\tI\t\t\t\t\tToggle J-band infrared image\n *\n *\t\tP\t\t\t\t\t'dynamic' pause mode\n *\t\tF1\t\t\t\t\tTime acceleration up to \u00d710\n *\t\tF2\t\t\t\t\tTime acceleration up to \u00d7100\n *\t\tF3\t\t\t\t\tTime acceleration up to \u00d71000\n *\t\tF4\t\t\t\t\tTime acceleration up to \u00d710000 (only in space)\n *\t \tF12\t\t\t\t\tCHEESE mode (hide all text and HMD overlays)\n *\n * \tWhen in map view\n *\n *\t\tTAB\t\t\t \t\tMenu\n *\t\tM\t\t\t\t\tExit map view\n *\n * \t\tW/S or Z/S\t\t\tzoom\n *\t\tmouse drag\t\t\tmove/pan\n *\t\tmouse click\t\t\tset marker position\n *\t\t\t\t\t\t\t\t- double click to remove\n *\t\t\t\t\t\t\t\t- convert marker to waypoint via menu item 6\n *      backspace\t\t\treset position\n *\n *\n * Menu: Info pages\n * ----------------\n *  Info pages can be selected via menu item 1.\n *\n *\tLocation info:\n *\t\tShows current position.\n *  \tLatitude (lat), longitude (long), altitude (alt), heading (hdg).\n *\n *\tWaypoint info:\n *\t\tShows relation to the selected waypoint.\n *\t\tBearing (brg), slant range (dst), height difference (delta-h),\n *\t\testimated time to arrival (eta).\n *\n *\tOrbit info:\n *\t\tShows continuously updated orbital elements.\n *\t\tApoapsis (Ap), periapsis (Pe), eccentricity (e),\n *\t  \ttrue anomaly (theta).\n *\n *\tGlide info:\n *\t\tShows continuously updated aerodynamic coefficients.\n *\t\tLift coeffienct (CL), drag coefficient (CD), glide ratio (L/D),\n *      angle of attack (alpha).\n *\n *\tControl info:\n *\t\tShows current control inputs.\n *\t\tElevator (elev), aileron (ail), rudder (rudd), trim tab (trim).\n *\n *\tAir info:\n *\t\tShows current outside air data.\n *\t\tTemperature (T), static pressure (P), dynamic pressure (Q),\n *\t\tdensity (rho).\n *\n *  Time info:\n *\t\tShows current in-game date (year-day), time (hours:minutes),\n *\t\tlocal time with timezone. The ingame time scale is defined by the\n *\t\tconstant SECONDS_PER_MINUTE in the common tab.\n *\n *\n * Menu: HMD modes\n * ---------------\n *  Modes for the helmet mounted display (HMD) can be selected via menu item 2.\n *\n *\tHMD off:\n *\t\tHMD overlay is disabled.\n *\n *\tSurface overlay:\n *\t\tShows speed and flight path relative to the local surface\n *\t\tand a pitch ladder oriented to the local horizon.\n *\n *\tOrbit overlay:\n *\t\tSame as surface mode but speed and flight path are shown relative\n *\t\tto the orbit center of mass (local planet) with additional\n *\t\tmarkers that indicate the outcome of applying thrust in the\n *\t\tgiven direction:\n *\n *\t\t+a or -a\t\tchange Pe and Ap so that eccentricity does not change\n *\t\t+e or -e\t\tchange Pe and Ap by equal and opposing amounts\n *\t\t+Pe or -Pe\t\tchange only Pe, leave Ap constant\n *\t\t+Ap or -Ap\t\tchange only Ap, leave Pe constant\n *\t\t+h or -h\t\tchange obital inclination\n *\n *\t\t---   ---\t\ta pair of dashed lines (when they appear) indicate the\n *\t\t\t\t\t\tpitch angle at which the current engine thrust will\n *\t\t\t\t\t\texactly counter gravity\n *\n *\tGeneral overlay symbology:\n *\n *\t\tleft group\t\tspeed in m/s, mach number (M), dyn. pressure in bars (Q)\n *\t\tright group\t\taltitude in meters and vertical speed in m/s\n *\t\tbottom group\theading in degrees and vertical acc. in g units (G)\n *\n *\t\tpitch ladder\tmajor ticks every 10\u00b0, minor ticks every 5\u00b0\n *\t\t\t\t\t\tsurface only: one tick at -3\u00b0 for landing\n *\t\t_\t _\n * \t\t \\/\\/\t\t\tWater line\n *\t\t\t\t\t\t(direction of the body-fixed x axis)\n *        .\n *      --O--\t\t\tFlight path marker\n *\t\t\t\t\t\t(direction of the velocity vector)\n *\n *\t\t\\  /\n *       \\/\t\t\t\tWaypoint (if set)\n *\n *\n * Menu: Aero modes\n * ----------------\n *  Operating modes for the aerodynamic control surfaces (elevator, aileron and\n *  rudder) can be selected from menu item 3.\n *\n *\tAero off:\n *\t\tAero control is disabled, but manual trim setting is preserved.\n *\n *\tDirect manual control:\n *\t\tPitch, roll and yaw inputs are directly connected to elevator, aileron\n *\t\tand rudder.\n *\n *\tFly by wire control (experimental):\n *\t\tAutomatic controller where pitch input commands a desired g-load (-3..9)\n *\t\tand roll input commands roll rate. Yaw input is still manual.\n *\n *\n * Menu: RCS modes\n * ----------------\n *\tOperating modes for the reaction control system (RCS) can be selected from\n *  menu item 4.\n *\n *\tRCS off:\n *\t\tRCS control is disabled.\n *\n *\tDirect manual control:\n *\t\tPitch, roll and yaw inputs are directly connected to the corresponding\n *\t\tthrusters.\n *\n *\tRotation rate control:\n *\t\tPitch, roll and yaw inputs command rotation rates in the inertial\n *\t\treference frame.\n *\n *\tRotation rate control + LVLH:\n *\t\tPitch, roll and yaw inputs command rotation rates relative to\n *\t\tthe LVLH reference frame (local vertical, local horizon).\n *\n *\n * Menu: Engine modes\n * ------------------\n *  Engine modes can be selected from menu item 5.\n *\n *\tEngine off:\n *\t\tAll engines are disabled.\n *\n *\tDrive engine:\n *\t\tAn electical motor connected to the wheels.\n *\t\tProvides passive wheel braking.\n *\n *\tImpulse engine:\n *\t\tA hypothetical propellant-less propulsion engine.\n *\n *\tNova engine:\n *\t\tNot yet implemented.\n *\n *\n * How to fly\n * ----------\n *\n *\tThe simulated plane is a blend between an F16 and a Space Shuttle.\n *  Full throttle gives a thrust-to-weight ratio of 130%.\n *\n *  Some reference speeds (valid at sea level):\n *\n *\t\tstall speed\t\t\t45 m/s\n *\t\ttouchdown speed\t\t65 m/s\n *\t\tapproach speed\t\t70 m/s\n *\t\tbest glide speed\t83 m/s\n *\n *  Speed is shown in m/s relative to the selected frame (surface or orbit).\n *  Inside an atmosphere, the dynamic pressure (Q, in bars) relates to \n *  equivalent airspeed (EAS, in knots):\n *\n *\t\tQ \tairspeed\tQ\tairspeed\n *\t\t------------\t------------\n * \t\t0.01\t  80\t0.20\t 350\n *\t\t0.02\t 110\t0.26\t 400\n *\t\t0.03\t 140\t0.33\t 450\n *\t\t0.04\t 160\t0.41\t 500\n *\t\t0.05\t 175\t0.49\t 550\n *\t\t0.06\t 190\t0.58\t 600\n *\t\t0.08\t 220\t0.68\t 650\n *\t\t0.10\t 250\t0.79\t 700\n *\t\t0.12\t 270\t0.91\t 750\n *\t\t0.15\t 300\t1.04\t 800\n *\n * \tTake off:\n *\n *\t\tGentle (like an airliner)\t\t\t\t\tScramble (like a fighter)\n *\n *\t\t- Trim 2.5%, flaps 2 notches down\t\t\t- Trim neutral, no flaps\n *\t\t- Throttle to 35%\t\t\t\t\t\t\t- Throttle to 70%\n *\n *\t\tFor all cases\n *\n *\t\t- Accelerate to 75 m/s\n *\t\t- Bring the nose up *gently* (repeated tap on keyboard is enough)\n *\t\t- Retract gears immediately\n *      - Retract flaps when climb is stable\n *\t\t- Manually adjust trim as you go, or select the fly-by-wire controller\n *\n * \tCruise:\n *\n *      During cruise it is recommended to select the fly-by-wire controller,\n *\t\tas this will automatically keep the plane on a straight path.\n *  \tSome typical settings to fly like a ...\n *\n *\t\t  \t\t\t\tspeed\talt\t\tthrottle    flaps\n *\n *\t\tCessna\t \t\t60 \t\t500\t\t10\t\t    3\n *\t\tAirliner\t\t250\t\t11 k\t15\n *\t\tConcorde \t\t600\t\t18 k\t45\n * \t\tSR-71\t\t\t1000\t24 k\t50\n *\n *\tLanding:\n *\n *  \tThe goal is to come in on a 5% glide slope (or about -3 degrees).\n *  \tThis means that at 20 km distance the runway is 1 km below, etc.\n *\t\tThe safe limit to deploy gears is about Q < 0.1, but this is not \n *\t\tchecked yet.\n *\n *\t\tThe final configuration for approaching the runway should be:\n *\n *\t\t\tspeed \t\t\t\t70 m/s\n *\t\t\tvertical speed\t\t-3.5 m/s\n *\t\t\tfull flaps\n *\t\t\tgears down\n *\n *\t\tThe vertical speed at touchdown then determines the rating you are\n *\t\tgiven for the landing:\n *\n * \t\t\t0 .. 2 m/s\t\texcellent\n *\t\t\t2 .. 4 m/s\t\tnormal\n *\t\t\t4 .. 6 m/s\t\thard landing\n *\t\t\t6 and above\t\tcrash landing\n *\n * \tGoing into orbit:\n *\n *\t\tThe lowest practical altitude for an orbit in this simulation is 120 km,\n *\t\teverything below that would suffer atmospheric drag. The required speed\n *\t\tis around 2900 m/s. It takes about 8 minutes real time to get there.\n *\t\tThe following procedure works to reach near (up to 200 km) orbits in\n *\t\tprograde (eastwards) direction:\n *\n *\t\t(1) Accelerate upwards\n *\n *      At the surface:\n *\t\t- Full throttle\n *\t\t- Maintain a steady 60\u00b0 climb angle\n *\n *\t\tAt 30 km altitude:\n *\t\t- Enable RCS (with rate control)\n *\n *\t\t(2) Transition to accelerate forward and increase Ap\n *\n *      When vertical speed has reached 600 m/s:\n *\t\t- Switch HMD to orbit overlay (shows the orbital velocity vector)\n *\t\t- Follow the flight path marker as it moves down ('gravity turn')\n *      - Switch to orbit info page and keep an eye on the 'Ap' value\n *\n *\t\t(4) Increase Pe\n *\n *\t\tWhen 'Ap' has reached the intended target altitude:\n *\t\t- Pitch down below the horizon and follow the '+Pe' symbol on the HMD\n *      - Keep an eye on the 'theta' value on the orbit info page\n *\t\t\n *\t\tEventually one of the following will happen:\n *\n *      - 'theta' is no longer increasing:\n *\t\t    - Throttle down until theta is increasing again\n *\n *      - 'theta' has reached 180\u00b0, but 'Pe' is still lower than 'Ap':\n *\t\t\t- Throttle up and pitch up to the dashed 'hover line' in the HMD\n *      \t- keep vertical speed at zero while Pe increases\n *\n *      (5) Orbital insertion:\n *\n *      - You are finished when 'theta' has reached 180\u00b0 and 'Pe' equals 'Ap'\n *      - Switch RCS to LVLH mode to keep aligned with the orbital rotation\n *      - Congratulations, and enjoy the view!\n *\n *\n * \tReturn from orbit:\n *\n *\t\tThis procedure requires roughly 1/2 orbit to complete so you will\n *\t\tend up on the opposite side of the planet from where the procedure\n *\t\tis started.\n *\n * \t\tAt first your altitude will decrease, but at some point it\n *\t\twould start to rise again when you get lift from the atmosphere.\n *\t\tThe idea in the second part is not let that happen and deflect the\n *\t\tundesirable lift sideways by rolling to the side (hard).\n *\n *\t\tStage 1 (deorbit)\n *\n *\t\t- Align with flight path\n *\t\t- Reverse thrust until Pe is just above the surface (5 km or so)\n *\t\t- Select aero direct manual control\n *\t\t- Trim up to 100%\n *\t\t- Pitch up to 20 degrees\n *\t\t- Deploy spoilers\n *\n *\t\tStage 2 (reentry)\n *\n *\t\t- Wait until air contact at about 80 km altitude\n * \t\t- Switch to surface HMD\n *\t\t- Keep an eye on vertical speed\n *\t\t- Bank sideways to maintain negative vertical speed at -100 m/s\n *\t\t- Perform roll reversals from time to time to maintain course\n *\n *\t\tThe following roll reversal schedule is an example\n *\t\tthat works most of the time:\n *\n *\t\t- When vertical speed gets to -100 m/s, roll to the side on which\n *\t\t\tyour target is, trim down to 70%\n *\t\t- At mach 7.5, roll to the other side, trim 50%\n *\t\t- At mach 5.5, roll to the other side, trim 20%\n *\t\t- At mach 3.5, or whenever back on course, roll upright,\n *\t\t  disable RCS and trim for glide, or enable fly-by-wire.\n *\n *\t\tYou should then be in atmospheric flight, flying Mach 3 in 30 km\n *\t\taltitude right over your target.\n */\n\n// ----------------------------------------------------------------------------\n\n/*\nTODO:\n\n-\tadd automatic flaps mode\n-\tadd autothrottle modes\n-\tadd tracking targets to RCS modes\n-\tproper sun position\n-\tsupport multiple celestial bodies\n\t-\tcurrent localplanet index and orbitplanet index in gamestate\n\t-\tmove hardcoded cloud params to planetdata\n\t-\tmove hardcoded terrain colors to planetdata\n-\tseasonal variation of cloud patterns\n\n*/\n\n// ----------------------------------------------------------------------------\n// IMAGE OPTIONS\n// ----------------------------------------------------------------------------\n\n#define WITH_IMG_BALANCE\t\t\t1\t\t\t\t\t// enable white balance\n#define WITH_IMG_DCI_P3\t\t\t\t0\t\t\t\t\t// for MacBook with P3 display when browser does not color manage\n#define WITH_IMG_EXPOSURE\t\t\t1\t\t\t\t\t// enable auto exposure\n#define WITH_IMG_FILMIC \t\t\t1\t\t\t\t\t// film like contrast enhancement for high exposures\n#define WITH_IMG_GLARE\t\t\t\t1\t\t\t\t\t// mip-map based glare effect, simulating aperture diffraction\n#define WITH_IMG_LENS\t\t\t\t1\t\t\t\t\t// mip-map based lens flare effect, simulating internal reflections\n#define WITH_IMG_PRIMARIES \t\t\t1\t\t\t\t\t// enable conversion from monochromatic color primaries to sRGB (or P3)\n#define WITH_IMG_RODVISION\t\t\t1\t\t\t\t\t// enable a simulation of scotopic vision at low light levels\n#define WITH_IMG_SOFT_SATURATE\t\t1\t\t\t\t\t// choose a soft saturation function: 0 = none, 1 = exp, 2 = tanh, 3 = sin\n#define WITH_IMG_SRGB_EOTF\t\t\t1\t\t\t\t\t// use the exact piecewise sRGB curve, otherwise a simple gamma curve\n#define WITH_IMG_SUNGLARE\t\t\t1\t\t\t\t\t// enable the special-case glare effect centered on the sun\n\n#define WITH_IMG_EXPERIMENTAL_ROD_ACUITY 0\t\t\t\t// enable a blurry image for scotopic vision\n\nconst float IMG_BALANCE = .5;\nconst float IMG_BLACKLEVEL = 0. / 255.;\nconst float IMG_BLACKLEVEL_VR = 0. / 255.;\nconst float IMG_FILMIC = bool(WITH_IMG_SRGB_EOTF) ? .05 : .08;\nconst float IMG_FILMIC_VR = .02;\nconst float IMG_FILMIC_EXPOSURE_REF = 4.5;\nconst float IMG_GAMMA = 2.2;\nconst float IMG_GAMMA_VR = 2.4; \t\t\t\t\t\t// measured for the HTC vive\nconst float IMG_QUANTIZE = 1. / 255.;\n\n// Conversion matrices from monochromatic color\n// primaries (615, 535, 445) to display color space\n// including a white point change from illuminant E to D65\n#if WITH_IMG_DCI_P3\nconst mat3\tIMG_PRIMARIES = mat3(  1.3272,  0.0177, -0.0008,\n                      \t  \t\t  -0.1814,  1.0097, -0.0328,\n                       \t\t\t   0.0136, -0.0706,  0.9504  );\n#else\nconst mat3\tIMG_PRIMARIES = mat3(  1.6218, -0.0374, -0.0283,\n                      \t\t      -0.4493,  1.0598, -0.1119,\n                       \t\t\t   0.0325, -0.0742,  1.0491  );\n#endif\nconst vec3\tIMG_BALANCE_ADAPT = pow( inverse( IMG_PRIMARIES ) * ONE, vec3( IMG_BALANCE ) );\n\nconst float VIS_EXPONENT = -.65;\nconst float VIS_EXPONENT_VR = -.35;\nconst vec3  VIS_LIMITS = vec3( .0013, .94e-6, .0001 );\nconst vec3  VIS_SCOTOPIC_Y = vec3( .02, .63, .35 ) * 1600. / 683.;\nconst float VIS_PRE_EXPOSURE = 1.;\nconst float VIS_POST_EXPOSURE = 1.;\n\n// ----------------------------------------------------------------------------\n\nGameState g_game;\nVehicleState g_vehicle;\nPlanetState g_planet;\nLocalEnvironment g_env;\nPlanetData g_data;\nfloat g_pixelscale = 0.;\nvec4 g_exposure = vec4(0);\nvec3 g_hudcolor = ZERO;\nvec3 g_raydir = ZERO;\nmat2x3 g_Kr = mat2x3(0);\n\nfloat g_textlodbias = 0.;\nvec2 g_textscale = vec2(1);\nvec4 g_overlayframe = vec4(0);\n\nbool g_vrmode = false;\nmat3 g_vrframe = mat3(0);\nvec4 g_vrfocus = vec4(0);\nvec2 g_vrcoord = vec2(0);\nvec3 g_vrdir = ZERO;\nuniform vec4 unViewport;\nuniform vec3 unCorners[5];\n\nvec2 project3d( vec3 r, float z )\n{\n\treturn g_vrmode ?\n        unViewport.zw * ( g_vrfocus.xy + .5 * z * g_vrfocus.zw * r.yz / r.x * vec2( 1, -1 ) ) :\n\t\tiResolution.xy * ( .5 + .5 * z * barrel_distort_inv( CAM_FOCUS * r.yz / r.x, CAM_DISTORT ) * vec2( 1, -iResolution.x / iResolution.y ) );\n}\n\n// ----------------------------------------------------------------------------\n// HMD PRIMITIVES\n// ----------------------------------------------------------------------------\n\nfloat hmd_chrout_inner( vec2 coord, float size, float chr )\n{\n    float result = 0.;\n    if( coord.x >= 0. && coord.x < size && coord.y >= 0. && coord.y < size )\n    {\n        vec2 cell = vec2( mod( chr, 16. ), 15. - floor( chr / 16. ) );\n        float lod = 5. - log2( size ) + g_textlodbias;\n        result += textureLod( iChannel2, cell / 16. + coord * 64. / ( size * iChannelResolution[2].xy ), lod ).x;\n    }\n    return result;\n}\n\nfloat hmd_chrout( vec2 coord, float size, float chr )\n{\n    coord.x += TXT_FONT_BACKSLANT * coord.y;\n    return hmd_chrout_inner( coord, size, chr );\n}\n\nfloat hmd_txtout( vec2 coord, vec3 cc, int index )\n{\n    float result = 0.;\n    ivec2 addr = ivec2( ( index / 2 ) << 4, int( iResolution.y - 2. ) + ( index & 1 ) );\n    vec4 params = IMG_MIPMAP_HIDE * texelFetch( iChannel1, addr, 0 );\n    bool underline = params.z < 0.;\n    bool vector = params.w < 0.;\n    params.zw = abs( params.zw );\n    float n = IMG_MIPMAP_HIDE * texelFetch( iChannel1, ivec2( addr.x + 1, addr.y ), 0 ).x;\n    bool hudclip = n < 0.;\n    n = abs(n);\n    if( vector )\n    {\n        vec3 v = vec3( floor( params.x ), fract( params.x ) * 4096., params.y ) / 2047.5 - 1.;\n        if( g_vrmode )\n        \tv *= g_vrframe;\n        if( v.x > 0. )\n            params.xy = ( project3d( v, g_game.camzoom ) - g_overlayframe.xy ) * g_textscale\n            \t\t    - params.w * vec2( n * TXT_FONT_SPACING, 1 ) / 2.;\n        else\n            n = 0.;\n    }\n    coord -= params.xy;\n    coord.x += TXT_FONT_BACKSLANT * coord.y;\n  \tfloat i = floor( coord.x / ( params.w * TXT_FONT_SPACING ) );\n    float w = params.w * n * TXT_FONT_SPACING;\n    if( n != 0. &&\n        coord.x >= 0. && coord.x < w && coord.y >= -1. && coord.y < params.w &&\n        ( !hudclip || ( abs( cc.y ) < HMD_BORDER.x * cc.x && abs( cc.z ) < HMD_BORDER.y * cc.x ) ) )\n    {\n       \tfloat chr = IMG_MIPMAP_HIDE * texelFetch( iChannel1, ivec2( addr.x + ( int( i + 5. ) >> 2 ), addr.y ), 0 )[ uint( i + 5. ) & 3u ];\n   \t\tresult += params.z * hmd_chrout_inner( coord - vec2( params.w * ( i * TXT_FONT_SPACING - TXT_FONT_HOFFSET ), 0. ), params.w, chr );\n   \t\tif( underline )\n       \t{\n        \tfloat q = min( max( 0., 1. - abs( coord.y + 0. ) ), min( 1. + coord.x, w + 1. - coord.x ) );\n        \tresult += params.z * q;\n        }\n    }\n    return result;\n}\n\nfloat hmd_center_dot( vec2 coord )\n{\n    float result = 0.;\n    vec2 p = g_vrmode ? unViewport.zw * g_vrfocus.xy : iResolution.xy / 2.;\n\tif( coord.x >= p.x - 1. && coord.x < p.x &&\n\t\tcoord.y >= p.y - 1. && coord.y < p.y )\n\t{\n\t\tresult += .7;\n\t}\n    return result;\n}\n\nfloat hmd_symbol_border( inout vec3 v, vec2 limits )\n{\n    float result = 1.;\n \tif( v.x < 0. )\n    \tv = UNIT_X + normalize(v);\n    v.yz /= v.x;\n    v.x = 1.;\n    if( abs( v.y ) >= limits.x )\n    {\n        v.z *= limits.x / abs( v.y );\n        v.y = limits.x * sign( v.y );\n        result = .5;\n    }\n\tif( abs( v.z ) >= limits.y )\n\t{\n        v.y *= .35 / abs( v.z );\n        v.z = .35 * sign( v.z );\n        result = .5;\n\t}\n    return result;\n}\n\nfloat hmd_waterline( vec2 coord )\n{\n    float result = 0.;\n    vec3 v = g_vehicle.localB[0] * g_game.camframe;\n\tif( g_vrmode )\n    \tv *= g_vrframe;\n    if( dot( v, v ) > .25e-6 )\n    {\n        float sz = hmd_symbol_border( v, HMD_BORDER_SYM );\n\t\tmat2 I = mat2( g_textscale.x, 0, 0, g_textscale.y );\n    \tvec2 p = ( coord - project3d( v, g_game.camzoom ) ) * g_textscale;\n       \tif( Linfinity( p ) < 10. )\n        {\n            vec2 a = sz * vec2( -3, -6 );\n            vec2 b = sz * vec2( +3, -6 );\n            vec2 c = sz * vec2( +6,  0 );\n            vec2 d = sz * vec2( +9,  0 );\n            float shape = 0.;\n            shape = max( shape, aaa_line( I, p, a, vec2(0), 1. ) );\n            shape = max( shape, aaa_line( I, p, b, vec2(0), 1. ) );\n            shape = max( shape, aaa_line( I, p, a, -c, 1. ) );\n            shape = max( shape, aaa_line( I, p, b, +c, 1. ) );\n            shape = max( shape, aaa_hline( I, p, -d, sz * 3., 1. ) );\n            shape = max( shape, aaa_hline( I, p, +c, sz * 3., 1. ) );\n        \tresult += shape * sz;\n        }\n    }\n    return result;\n}\n\nfloat hmd_flight_path_marker( vec2 coord )\n{\n    float result = 0.;\n    vec3 localv = g_vehicle.modes.x == VS_HMD_ORB ?\n        g_vehicle.orbitv * g_planet.B * g_game.camframe :\n    \tg_vehicle.localv * g_game.camframe;\n    if( g_vrmode )\n        localv *= g_vrframe;\n    if( dot( localv, localv ) >= .25e-6 )\n    {\n        vec3 v = localv;\n        float sz = hmd_symbol_border( v, HMD_BORDER_SYM );\n        mat2 I = mat2( g_textscale.x, 0, 0, g_textscale.y );\n    \tvec2 p = ( coord - project3d( v, g_game.camzoom ) ) * g_textscale;\n        vec2 a = vec2( +4, 0 );\n        vec2 b = vec2( +9, 0 );\n        vec2 c = vec2( 0, +4 );\n        float shape = 0.;\n        if( Linfinity( p ) < 10. )\n        {\n        \tshape = max( shape, aaa_ring( I, p, sz * 8., 1. ) );\n            shape = max( shape, aaa_hline( I, p, -sz * b, sz * 5., 1. ) );\n            shape = max( shape, aaa_hline( I, p, +sz * a, sz * 5., 1. ) );\n            shape = max( shape, aaa_vline( I, p, +sz * c, sz * 4., 1. ) );\n        }\n\t\tif( localv.x < 0. &&\n            abs( localv.y ) < -HMD_BORDER_SYM.x * localv.x &&\n            abs( localv.z ) < -HMD_BORDER_SYM.y * localv.x )\n\t\t{\n        \tp = ( coord - project3d( localv, g_game.camzoom ) ) * g_textscale;\n            if( Linfinity( p ) < 10. )\n            {\n            \tshape = max( shape, aaa_ring( I, p, 8., 1. ) );\n            \tshape = max( shape, aaa_hline( I, p, -a, 8., 1. ) );\n            \tshape = max( shape, aaa_vline( I, p, -c, 8., 1. ) );\n            }\n        }\n        result += shape * sz;\n    }\n    return result;\n}\n\nfloat hmd_waypoint( vec2 coord )\n{\n    float result = 0.;\n    vec3 v = ( g_game.waypoint - g_game.campos ) * g_game.camframe;\n    if( g_vrmode )\n        v *= g_vrframe;\n\tfloat sz = hmd_symbol_border( v, HMD_BORDER_SYM );\n\tmat2 I = mat2( g_textscale.x, 0, 0, g_textscale.y );\n    vec2 p = ( coord - project3d( v, g_game.camzoom ) ) * g_textscale;\n    if( Linfinity( p ) < 13. )\n    {\n        float shape = 0.;\n    \tshape = max( shape, aaa_line( I, p, vec2(0), +sz * vec2( -6, 12 ), 1. ) );\n    \tshape = max( shape, aaa_line( I, p, vec2(0), +sz * vec2( +6, 12 ), 1. ) );\n    \tresult += shape * sz;\n    }\n    return result;\n}\n\nfloat hmd_pitch_ladder( vec2 coord, vec3 cc )\n{\n    float result = 0.;\n    vec3 localv = g_vehicle.modes.x == VS_HMD_ORB ?\n        g_vehicle.orbitv * g_planet.B :\n    \tg_vehicle.localv;\n\tif( dot( localv, localv ) >= .25e-6 )\n    {\n        vec3 down = normalize( -g_vehicle.localr );\n        vec3 horz = normalize( reject( localv, down ) );\n       \tvec3 left = cross( down, horz );\n        mat3 M = mat3( horz, left, down );\n        vec3 dir = g_raydir * M;\n       \tfloat Kp = degrees( Linfinity( ( down * dir.x - horz * dir.z ) * g_Kr ) ) / dot( dir.xz, dir.xz );\n       \tfloat Ks = degrees( Linfinity( left * g_Kr ) ) * inversesqrt( 1. - dir.y * dir.y );\n\n\t\tif( abs( cc.y ) < HMD_BORDER_LAD.x * cc.x && abs( cc.z ) < HMD_BORDER_LAD.y * cc.x )\n        {\n            // pitch ladder lines\n        \tfloat pitch = degrees( atan( -dir.z, dir.x ) );\n        \tfloat side = degrees( atan( dir.y, length( dir.zx ) ) );\n        \tfloat twist = max( 0., .5 * dir.z );        \t\n            float p = pitch + twist * ( abs( side ) - 5. );\n            bool tick = mod( abs(p) + 2.5, 10. ) < 5.;            \n            float shape = 0.;\n            if( g_vehicle.modes.x == VS_HMD_SFCE )\n                shape = aaa_interval( Kp, pitch + 2.8624, Kp / g_textscale.y );\n            shape = ( tick ? 1. : .5 ) * max( shape, \n\t\t\t\taaa_stipple( Kp, p + 2.5, 5., Kp / ( 5. * g_textscale.y ) ) ) * \n                aaa_interval( Ks, abs( side ) - ( tick ? 7.5 : 5.5 ), tick ? 5. : 1. );\n            shape = max( shape, \n                aaa_interval( Kp, pitch, Kp ) * aaa_interval( Ks, abs( side ) - 45., 80. ) );\n        \tshape = max( shape,\n        \t    aaa_stipple( Kp, pitch + 5. + sign( pitch ) * 0.625, 10., .125 ) *\n        \t    aaa_interval( Ks, abs( side ) - 7.5 - 2.5 * sign( pitch ), Ks / g_textscale.y ) );\n\t\t\tfloat bright = .5;\n\t\t\tresult += shape * bright;\n\n            // pitch ladder numbers\n            const float s15 = sin( radians( 12. ) );\n            const float c15 = cos( radians( 12. ) );\n            for( float i = -3.; i < 4.; ++i )\n            if( i != 0. )\n            {\n                float a = 30. * i;\n                float b = a + 6. * max( 0., .5 * sin( radians(a) ) );\n                for( float side = -1.; side < 3.; side += 2. )\n                {\n                    vec2 sc = sincospi( b / 180. );\n                \tvec3 v = M * vec3( sc.y * c15, side * s15, sc.x * c15 ) * g_game.camframe;\n                \tif( g_vrmode )\n                    \tv *= g_vrframe;\n                \tif( v.x > 0. )\n                \t{\n                    \tvec2 p = ( coord - project3d( v, g_game.camzoom ) ) * g_textscale;\n                    \tresult += .5 * hmd_chrout( p + 12. * vec2( TXT_FONT_SPACING, .5 ), 12., 48. + round( abs(a) / 10. ) );\n                \t}\n                }\n            }\n\n            // neutral-g indicator for orbit HMD\n\t\t\tif( g_vehicle.modes.z == VS_ENG_IMP &&\n                g_vehicle.modes.x == VS_HMD_ORB )\n            {\n                vec3 r = g_vehicle.orbitr;\n\t\t\t    float r2 = dot( r, r );\n    \t\t\tvec3 gr = r2 < square( g_data.radius ) ?\n        \t\t\t- g_data.GM / cube( g_data.radius ) * r :\n        \t\t\t- g_data.GM / ( r2 * sqrt( r2 ) ) * r;\n\t\t\t\tvec3 movement_omega = cross( g_vehicle.orbitr, g_vehicle.orbitv ) / dot( g_vehicle.orbitr, g_vehicle.orbitr );\n        \t\tgr -= cross( movement_omega, cross( movement_omega, g_vehicle.orbitr ) );\n\n                float a_max = FDM_MASS_SCALE * 136000. / 10630.;\n                float a = 0.001 * g_vehicle.throttle * a_max;\n                vec3 rn = normalize( g_vehicle.orbitr );\n                float f = sin( radians( g_vehicle.tvec ) ) * dot( rn, g_vehicle.B[1] );\n                float sinpitch = -dot( gr, rn ) / ( a * sqrt( max( 0., 1. - f * f ) ) );\n                if( sinpitch < 1. )\n                {\n                    float line1 = degrees( asin( sinpitch ) ) - g_vehicle.tvec;\n                    float line2 = 180. - degrees( asin( sinpitch ) ) - g_vehicle.tvec;\n\t                float shape =\n                        max( aaa_stipple( Kp, pitch + 180. - line1, 360., Kp / ( 360. * g_textscale.y ) ),\n                             aaa_stipple( Kp, pitch + 180. - line2, 360., Kp / ( 360. * g_textscale.y ) ) ) *\n    \t    \t    \taaa_interval( Ks, abs( side ) - 5., 5. ) *\n                        aaa_stipple( Ks, side, 2., .5 );\n                    result += .25 * shape;\n                }\n            }\n        }\n    }\n    return result;\n}\n\nvoid hmd_night_vision( inout vec3 col, vec2 coord, vec3 cc )\n{\n    vec2 uv = coord / iResolution.xy;\n    if( abs( cc.y ) < HMD_BORDER.x * cc.x && abs( cc.z ) < HMD_BORDER.y * cc.x )\n    {\n        float relbright = g_game.hudbright * g_exposure.z;\n        if( g_vrmode )\n            relbright /= g_game.camzoom;\n        float sat = COL_NVISNSAT / relbright;\n        float gain = min( COL_NVISNGAIN, 1. / ( g_exposure.x * g_exposure.z ) );\n        float y = dot( col, irselect( COL_NVISNSENS, ( g_game.switches & GS_IRCAM ) != 0u ) );\n        col += COL_P43PHOSPHOR * relbright * sat * y / ( y + sat / gain );\n    }\n}\n\nvoid hmd_terrain_radar( inout vec3 col, vec2 coord, vec3 cc )\n{\n    vec2 uv = ( g_vrmode ? coord + unViewport.xy : coord ) / iResolution.xy;\n\tif( abs( cc.y ) < HMD_BORDER.x * cc.x && abs( cc.z ) < HMD_BORDER.y * cc.x )\n    {\n\t\tfloat center = textureLod( iChannel1, uv, 0. ).w;\n    \tvec4 sides = vec4(\n        \ttextureLodOffset( iChannel1, uv, 0., ivec2( -1,  0 ) ).w,\n\t\t\ttextureLodOffset( iChannel1, uv, 0., ivec2( +1,  0 ) ).w,\n\t\t\ttextureLodOffset( iChannel1, uv, 0., ivec2(  0, -1 ) ).w,\n\t\t\ttextureLodOffset( iChannel1, uv, 0., ivec2(  0, +1 ) ).w );\n    \tfloat mu = dot( sides, vec4(.25) );\n    \tfloat laplace = ( center - mu ) * g_game.camzoom;\n        float sigma = dot( ( sides - mu ) * ( sides - mu ), vec4(.25) );\n        float range = 2. * sqrt( sigma );\n\t\tfloat shape = .1 / ( .4 + mu * exp2pp( 32. * ( laplace / ( 0.0003 + range ) ) ) );\n\t\tcol += g_hudcolor * shape;\n    }\n}\n\nvoid map_position( inout vec3 col, vec2 coord )\n{\n    float shape = 0.;\n    mat2 I = mat2(1);\n    vec2 s0 = mc2sc( gs_map_project( g_game, g_vehicle.localr ) );\n    float sr = dot( g_vehicle.localB[0], normalize( g_vehicle.localr ) );\n\n    if( abs( sr ) < .9995 )\n    {\n        // arrow if heading is defined\n        vec2 s1 = mc2sc( gs_map_project( g_game, g_vehicle.localr + g_vehicle.localB[0] ) );\n        vec2 ds = normalize( s1 - s0 );\n        mat2 M = mat2( ds, perp( ds ) );\n        vec2 a = s0 + M * vec2( +6, 0 );\n        vec2 b = s0 + M * vec2( -6, -4 );\n        vec2 c = s0 + M * vec2( -6, +4 );\n        shape = max( shape, aaa_line( I, coord, a, b, 1. ) );\n        shape = max( shape, aaa_line( I, coord, b, c, 1. ) );\n        shape = max( shape, aaa_line( I, coord, c, a, 1. ) );\n    }\n    else\n    if( sr < 0. )\n        // cross if downwards\n        shape = max( aaa_line( I, coord, s0 - 5., s0 + 5., 1. ),\n                     aaa_line( I, coord, s0 + vec2( +5, -5 ), s0 + vec2( -5, +5 ), 1. ) );\n    else\n        // ring if upwards\n        shape = aaa_ring( I, coord - s0, 10., 1. );\n\n\tfloat phase = .25 + .75 * step( .5, fract( iTime ) );\n    col += vec3( 1, .5, .0 ) * shape * phase;\n}\n\nvoid map_marker( inout vec3 col, vec2 coord )\n{\n\tmat2 I = mat2(1);\n    float shape = 0.;\n    vec2 s = mc2sc( gs_map_project( g_game, g_game.mapmarker ) );\n    shape = max( shape, aaa_hline( I, coord, s - vec2( 6, 0 ), 12., 1. ) );\n    shape = max( shape, aaa_vline( I, coord, s - vec2( 0, 6 ), 12., 1. ) );\n    col += vec3( 1, .5, .0 ) * shape;\n}\n\nvoid map_waypoint( inout vec3 col, vec2 coord )\n{\n\tmat2 I = mat2(1);\n    float shape = 0.;\n    vec2 s = mc2sc( gs_map_project( g_game, g_game.waypoint ) );\n    shape = max( shape, aaa_line( I, coord, s, s + vec2( -6, 12 ), 1. ) );\n    shape = max( shape, aaa_line( I, coord, s, s + vec2( +6, 12 ), 1. ) );\n    col += vec3( 1, .5, .0 ) * shape;\n}\n\nvoid map_orbit_track( inout vec3 col, vec2 sc )\n{\n    vec3 dpdx = ZERO, dpdy = ZERO;    \n    vec4 p = gs_map_unproject_d( g_game, sc, iResolution.xy, dpdx, dpdy );    \n    vec4 px = vec4( dpdx.x, dpdy.x, 0, p.x );\n    vec4 py = vec4( dpdx.y, dpdy.y, 0, p.y );\n    vec4 pz = vec4( dpdx.z, dpdy.z, 0, p.z );    \n    vec4 plng = atan2_d( py, px );\n\n    vec3 r = g_vehicle.localr;\n    vec3 v = g_vehicle.orbitv * g_planet.B; // not: localv!     \n    Kepler K = Kepler( 0., 0., 0., 0., 0. );\n    float nu = kepler_init( K, r, v, g_data.GM );  \n    float M = cvt_E2M( cvt_nu2E( nu, K.e ), K.e );    \n    vec3 h = cross( r, v );\n    float invsin_i = length(h) / length( h.xy );\n    float invtan_i = h.z / length( h.xy );\n    if( K.e < .00005 )\n    {\n\t\tK.w = asin( clamp( normalize(r).z * invsin_i, -1., 1. ) );\n        if( v.z < 0. )\n            K.w = PI - K.w;\n    }\n    \n    vec4 dlng = asin_d( clamp_d( div_d( pz, hypot_d( px, py ) ) * invtan_i, -ONE_D, ONE_D ) );\n    vec4 dnu = asin_d( clamp_d( pz * invsin_i, -ONE_D, ONE_D ) );        \n    float dMdt = sqrt( g_data.GM * cube( abs( 1. - K.e * K.e ) / K.p ) );\n    float dphidM = g_planet.omega / dMdt;    \n    mat2x4 ll = mat2x4( const_d( K.O ) + dlng, const_d( K.O ) - dlng - const_d(PI) );\n    mat2x4 nn = mat2x4( const_d( -K.w ) + dnu, const_d( -K.w ) - dnu - const_d(PI) );\n    mat2x4 MM = mat2x4( cvt_E2M_d( cvt_nu2E_d( nn[0], K.e ), K.e ), cvt_E2M_d( cvt_nu2E_d( nn[1], K.e ), K.e ) );\n    mat2x4 aa = MM - mat2x4( const_d(M), const_d(M) );   \n    vec2 KK = vec2( length( ll[0].xy - plng.xy - aa[0].xy * dphidM ), length( ll[1].xy - plng.xy - aa[1].xy * dphidM ) );\n    vec2 JJ = vec2( length( aa[0].xy ), length( aa[1].xy ) );\n    \n    vec3[3] colors = vec3[3]( \n        vec3( .9, .7, .1 ),\n        vec3( .4, .4, .4 ),\n        vec3( .1, .1, .1 ) );\n    \n    float stipple = 15. * dMdt;\n    float mask = aaa_interval( dFdy(p.w), p.w, 2. );   \n    float revlimit = 3. * TAU;\n    \n#define w2vec2( _a ) vec2( _a[0].w, _a[1].w )\n    \n    if( mask >= FRACT_1_64 )\n    for( int i = 0; i < ( K.e < .99995 ? 3 : 1 ); ++i )\n    {    \n\t\tfloat shape = 0.;\n        float k = float(i) * TAU;\n        vec2 d = ( K.e < .99995 ? ( mod( w2vec2( aa ), TAU ) + k ) : w2vec2( aa ) ) * dphidM;\n    \tvec2 u = mod( w2vec2( ll ) - plng.w - d + PI, TAU ) - PI;        \n        vec2 s = aaa_interval2( KK, u, KK ) * aaa_stipple2( JJ, w2vec2( aa ), vec2( stipple ), vec2(.5) ) * \n            aaa_step2( JJ, revlimit - d ) * ( K.e < 1. ? vec2(1.) : aaa_step2( KK, w2vec2( aa ) ) );\n        col += mask * hmax(s) * colors[ min( i, 3 ) ];\n    }\n    \n#undef w2vec2\n}\n\n// ----------------------------------------------------------------------------\n// POST PROCESSING\n// ----------------------------------------------------------------------------\n\nvec3 lens_lookup( vec2 uv, float k, float lod, float subsample )\n{\n    uv = .5 * subsample + k * ( .5 * subsample - uv );\n    return textureLod( iChannel1, uv, lod ).xyz *\n        16. * saturate( uv.x ) * saturate( uv.y ) * saturate( 1. - uv.x ) * saturate( 1. - uv.y );\n}\n\nvec3 post_get_image( vec2 uv, float subsample )\n{\n    float k = min( 2.3, 60. * sqrt( sqrt( g_pixelscale ) ) );\n    float sharpen = .25;\n\n    uv *= subsample;\n    if( g_vrmode && uv.x >= .5 * subsample )\n    \tuv.x += .5 - .5 * subsample;\n\n\tvec3 col = ZERO;\n#if WITH_IMG_GLARE\n    if( ( g_game.switches & GS_TRMAP ) == 0u )\n    {\n    #if WITH_IMG_EXPERIMENTAL_ROD_ACUITY\n        float y = max( 0., dot( textureLod( iChannel1, uv, 3. ).xyz - textureLod( iChannel1, uv, 4. ).xyz, VIS_SCOTOPIC_Y ) );\n    #endif\n\t    vec3 wsum = ZERO;\n    \tfor( float i = 0.; i < 10.; ++i )\n    \t{\n            float w = 1. / ( 1. + exp2( k * i ) );\n            if( i == 1. )\n                w -= sharpen;\n   \t\t#if WITH_IMG_EXPERIMENTAL_ROD_ACUITY\n\t\t\tif( i < 3. )\n            {\n    \t\t\tfloat suppress = VIS_LIMITS.z / ( 16384. * y + VIS_LIMITS.z );\n                w *= g_exposure.y / ( g_exposure.y + suppress * VIS_LIMITS.x );\n            }\n        #endif\n            col += w * textureLod( iChannel1, uv, i ).xyz;\n            wsum += w;\n    \t}\n        col = clamp( col / wsum, 0., 16. );\n    }\n    else\n#endif\n    \tcol = textureLod( iChannel1, uv, 0. ).xyz;\n\n#if WITH_IMG_LENS\n    if( ( g_game.switches & GS_TRMAP ) == 0u )\n    {\n\t    float bias = .5 * log2( g_pixelscale );\n\t    col += .25 * FRACT_1_64 * lens_lookup( uv,-.5, -5. - bias, subsample );\n\t   \tcol += .25 * FRACT_1_64 * lens_lookup( uv, .5, -4. - bias, subsample );\n\t   \tcol += .25 * FRACT_1_64 * lens_lookup( uv, 1., -5.5 - bias, subsample );\n\t    col += .25 * FRACT_1_64 * lens_lookup( uv, 2., -7. - bias, subsample );\n    }\n#endif\n\n    // add absolute threshold of vision\n    col = col * 1. + vec3( COL_THRESHOLD );\n    return col;\n}\n\nvoid post_sun_glare( inout vec3 col, vec3 raydir )\n{\n#if WITH_IMG_SUNGLARE\n    vec3 sunshadow = IMG_MIPMAP_HIDE * texelFetch( iChannel1, ivec2( 0, 0 ), 0 ).xyz;\n    mat3 frame = g_game.camframe;\n    if( g_vrmode )\n        frame *= g_vrframe;\n    float d = dot( normalize( reject( cross( g_env.L, raydir ), frame[0] ) ),\n                   normalize( reject( cross( g_env.L, frame[2] ), frame[0] ) ) );\n    float s = 1. / ( 1. + 0.985 * chebychev6(d) );\n    float a = square( g_planet_data[0].radius ) / dot( g_vehicle.r, g_vehicle.r );\n    float b = 1. - square( .81 / g_game.camzoom );\n    float c = 1. - square( .71 / g_game.camzoom );\n    float offimage = parabolstep( b, c, dot( frame[0], g_env.L ) );\n    vec3 tmp = offimage * g_env.sunlight *\n        exp2( -24. * sqrt( max( 0., 1. - square( dot( raydir, g_env.L ) ) ) ) ) *\n        a * s * sunshadow / max( vec3( a * s / IMG_EXPOSURE_MAX ), 1. - a * sunshadow - dot( raydir, g_env.L ) );\n    col += tmp;\n#endif\n}\n\nvoid console_throttle_graphics( inout vec3 col, vec2 coord )\n{\n    mat2 I = mat2(1);\n    float t = g_vehicle.throttle;\n    vec2 size = vec2( 15, 60. * abs(t) );\n    if( Linfinity( coord ) < 61. )\n    {\n\t    float shape = aaa_rect( I, coord - size / 2., size, vec2(1) );\n\t    if( t >= 0. )\n\t        shape = max( shape, aaa_box( I, coord - size / 2., size, vec2(1) ) * .25 );\n\t    col += g_hudcolor * shape;\n    }\n}\n\nvoid post_console_overlay( inout vec3 col, vec2 coord )\n{\n    vec2 uv = mix( vec2( iResolution.x, 0 ), coord, g_textscale ) / iResolution.xy;\n    coord = ( coord - g_overlayframe.xy ) * g_textscale;\n    if( !g_vrmode )\n    {\n        float consolemask = uv.y * iResolution.y - 24.;\n        if( ( g_game.switches & GS_IPAGE_MASK ) != 0u )\n        {\n            vec2 b = ( uv.xy * iResolution.xy - vec2( iResolution.x - 136., 80 ) ) * vec2( -1, 1 );\n            float c = max( b.x + b.y, hmax( b ) );\n            consolemask = clamp( consolemask, 0., 16. ) + clamp( c, 0., 16. ) - 16.;\n        }\n        col *= mix( .5, 1., saturate( consolemask / 16. ) );\n    }\n \tconsole_throttle_graphics( col, coord - vec2( 16, 12 ) );\n}\n\nvoid post_hmd_overlay( inout vec3 col, vec2 coord, vec3 cc )\n{\n    col += g_hudcolor * hmd_center_dot( coord );\n    col += g_hudcolor * hmd_waterline( coord );\n    col += g_hudcolor * hmd_flight_path_marker( coord );\n   \tcol += g_hudcolor * hmd_pitch_ladder( coord, cc );\n    if( dot( g_game.waypoint, g_game.waypoint ) > 0. )\n        col += g_hudcolor * hmd_waypoint( coord );\n}\n\nvoid post_map_overlay( inout vec3 col, vec2 coord )\n{\n    coord = ( coord - g_overlayframe.xy ) * iResolution.xy / g_overlayframe.zw;\n\tmap_position( col, coord );\n    if( dot( g_game.mapmarker, g_game.mapmarker ) > 0. )\n    \tmap_marker( col, coord );\n    if( dot( g_game.waypoint, g_game.waypoint ) > 0. )\n    \tmap_waypoint( col, coord );\n    if( g_env.H == 0. ) \n    \tmap_orbit_track( col, coord );\n}\n\nvoid post_text_overlay( inout vec3 col, vec2 coord, vec3 cc )\n{\n    coord = ( coord - g_overlayframe.xy ) * g_textscale;\n\tfor( int i = 0; i < TXT_FMT_MAX_COUNT; ++i )\n\t\tcol += g_hudcolor * hmd_txtout( coord, cc, i );\n}\n\nvoid post_overlay( inout vec3 col, vec2 coord, vec3 cc )\n{\n    bool mapmode = ( g_game.switches & GS_TRMAP ) == GS_TRMAP;\n\tif( g_game.stage == GS_RUNNING )\n    {\n    \tif( !mapmode )\n        {\n\t    \tif( ( g_game.switches & GS_NVISN ) == GS_NVISN )\n    \t    \thmd_night_vision( col, coord, cc );\n    \t\tif( ( g_game.switches & GS_TRDAR ) == GS_TRDAR )\n        \t\thmd_terrain_radar( col, coord, cc );\n            if( g_vehicle.modes.x > 0 )\n\t\t\t\tpost_hmd_overlay( col, coord, cc );\n        \tpost_console_overlay( col, coord );\n    \t}\n        else\n\t\t\tpost_map_overlay( col, coord );\n    }\n    post_text_overlay( col, coord, cc );\n}\n\nvoid post_exposure( inout vec3 col )\n{\n#if WITH_IMG_EXPOSURE\n  #if WITH_IMG_RODVISION\n    float y = dot( col, VIS_SCOTOPIC_Y );\n    float suppress = VIS_LIMITS.z / ( y + VIS_LIMITS.z );\n    col = g_exposure.z * col + g_exposure.w * suppress * y * .25 * COL_RODVISION;\n  #else\n\tcol = g_exposure.z * col;\n  #endif\n#endif\n}\n\nvoid post_balance( inout vec3 col )\n{\n#if WITH_IMG_BALANCE\n    col *= IMG_BALANCE_ADAPT / hmax( IMG_PRIMARIES * IMG_BALANCE_ADAPT );\n#endif\n}\n\nvoid post_saturate( inout vec3 col )\n{\n#if WITH_IMG_SOFT_SATURATE == 1\n    col = 1. - exp( -col * 1.1025 );\n#elif WITH_IMG_SOFT_SATURATE == 2\n    col = 2. / ( 1. + exp( -col * 2.0220 ) ) - 1.;\n#elif WITH_IMG_SOFT_SATURATE == 3\n    col = sin( min( col * 1.0055, PI / 2. ) );\n#else\n    col = saturate( col );\n#endif\n}\n\nvoid post_primaries( inout vec3 col )\n{\n#if WITH_IMG_PRIMARIES\n    col = max( ZERO, IMG_PRIMARIES * col );\n#endif\n}\n\nvoid post_filmic( inout vec3 col )\n{\n#if WITH_IMG_FILMIC\n    float b = ( g_vrmode ? IMG_FILMIC_VR : IMG_FILMIC ) * min( 1.0, IMG_FILMIC_EXPOSURE_REF * g_exposure.y );\n    float c = 0.166666667 * ( sqrt( 200. * ( b * b + b ) + 9. ) + 3. ) / ( b + 1. );\n    vec3 d = col * c;\n    col = ( 1. + b ) * d * d / ( b + d );\n#endif\n}\n\n// ----------------------------------------------------------------------------\n// MAIN\n// ----------------------------------------------------------------------------\n\nvec3 eotf( vec3 arg )\n{\n    return g_vrmode ?\n        pow( arg, vec3( IMG_GAMMA_VR ) ) :\n#if WITH_IMG_SRGB_EOTF\n        mix( arg / 12.92, pow( ( arg + .055 ) / 1.055, vec3( 2.4 ) ), lessThan( vec3( .04045 ), arg ) );\n#else\n    \tpow( arg, vec3( IMG_GAMMA ) );\n#endif\n}\n\nvec3 oetf( vec3 arg )\n{\n    return g_vrmode ?\n    \tpow( arg, vec3( 1. / IMG_GAMMA_VR ) ) :\n#if WITH_IMG_SRGB_EOTF\n        mix( 12.92 * arg, 1.055 * pow( arg, vec3( .416667 ) ) - .055, lessThan( vec3( .0031308 ), arg ) );\n#else\n    \tpow( arg, vec3( 1. / IMG_GAMMA ) );\n#endif\n}\n\nvec3 dither( vec3 arg, vec3 noise, float quant )\n{\n    vec3 c0 = floor( oetf( arg ) / quant ) * quant;\n    vec3 c1 = c0 + IMG_QUANTIZE;\n    vec3 discr = mix( eotf( c0 ), eotf( c1 ), noise );\n    return mix( c0, c1, lessThan( discr, arg ) );\n}\n\nvoid main_image_worker( out vec4 fcolor, in vec2 fcoord )\n{\n    fcolor = vec4( ZERO, 1 );\n\n#if BUFFER_RUNLEVEL >= 5\n\n    g_game = gs_load( iChannel0, ADDR_GAMESTATE );\n    g_data = g_planet_data[1];\n\tbool mapmode = ( g_game.switches & GS_TRMAP ) == GS_TRMAP;\n    float subsample = mapmode ? 1. : SCN_SUBSAMPLE_INV;\n\n    if( fcoord.y >= 2. * subsample && fcoord.y < iResolution.y - 2. * subsample )\n    {\n        g_vehicle = vs_load( iChannel0, ADDR_VEHICLE );\n        g_planet = ps_load( iChannel0, ADDR_PLANETS + ivec2( 1, 0 ) );\n        g_env = env_load( iChannel0, ADDR_LOCALENV );\n        g_exposure.xy = g_game.exposure;\n        g_exposure.zw = pow( g_game.exposure + VIS_LIMITS.xy, vec2( g_vrmode ? VIS_EXPONENT_VR : VIS_EXPONENT ) );\n        g_hudcolor = ( mapmode ? 1. : g_game.hudbright ) * COL_P43PHOSPHOR;\n        if( !mapmode && g_vrmode )\n        \tg_hudcolor /= g_game.camzoom;\n\n        vec2 uv = fcoord / iResolution.xy;\n\t\tvec2 sc = 2. * uv - 1.;\n   \t \tvec2 ec = sc * vec2( 1, iResolution.y / iResolution.x );\n        vec3 cc = ZERO;\n        if( g_vrmode )\n        {\n            cc = g_vrdir * g_vrframe;\n         \tif( !mapmode && dot( cc.yz, cc.yz ) >= 1.5 / g_game.camzoom * cc.x * cc.x )\n            \treturn;\n\t\t\tcc.yz /= g_game.camzoom;\n            cc = normalize( cc );\n\t\t    g_raydir = g_game.camframe * g_vrframe * cc;\n        }\n        else\n        {\n            cc = normalize( vec3( CAM_FOCUS, barrel_distort( vec2( ec.x, -ec.y ) / g_game.camzoom, CAM_DISTORT ) ) );\n        \tg_raydir = g_game.camframe * cc;\n        }\n       \tg_pixelscale = .25 * abs( cc.x * dFdx( cc.y / cc.x ) * dFdy( cc.z / cc.x ) );\n\t    g_Kr = mat2x3( dFdx( g_raydir ), dFdy( g_raydir ) );\n\n        vec3 col = post_get_image( uv, subsample );\n\n        //*\n        if( ( g_game.switches & GS_CHEES ) == 0u )\n        {\n            g_overlayframe = vec4( 0, 0, iResolution.xy );\n            if( g_vrmode )\n            {\n                float z = mapmode ? 1. : g_game.camzoom;\n            \tg_overlayframe.xy = project3d( vec3( 1.35, -1, +iResolution.y / iResolution.x ), z );\n                g_overlayframe.zw = project3d( vec3( 1.35, +1, -iResolution.y / iResolution.x ), z ) - g_overlayframe.xy;\n            }\n            g_textscale = texelFetch( iChannel1, ivec2( 2, 0 ), 0 ).xy * IMG_MIPMAP_HIDE / g_overlayframe.zw;\n    \t\tg_textlodbias = log2( max( g_textscale.x, g_textscale.y ) );\n        \tpost_overlay( col, g_vrmode ? fcoord - unViewport.xy : fcoord, cc );\n        }\n\n        if( !mapmode )\n        {\n        \tpost_sun_glare( col, g_raydir );\n            col *= VIS_PRE_EXPOSURE;\n        \tpost_exposure( col );\n            col *= VIS_POST_EXPOSURE;\n\t\t\tpost_filmic( col );\n        }\n\n        post_saturate( col );\n        post_balance( col );\n        post_primaries( col );\n\t\t//*/\n\n        // black level, noise shaping and display gamma\n\t\tvec3 noise = .5/65536. +\n            \t\t texelFetch( iChannel3, ivec2( fcoord / 8. ) & ( int( iChannelResolution[3] ) - 1 ), 0 ).xyz * 255./65536. +\n            \t\t texelFetch( iChannel3, ivec2( fcoord )      & ( int( iChannelResolution[3] ) - 1 ), 0 ).xyz * 255./256.;\n\n        col = mix( col, ONE, eotf( vec3( g_vrmode ? IMG_BLACKLEVEL_VR : IMG_BLACKLEVEL ) ) );\n        fcolor.xyz = dither( col, noise, IMG_QUANTIZE );\n    }\n#endif // RUNLEVEL\n}\n\nvoid mainImage( out vec4 fcolor, in vec2 fcoord )\n\t{ main_image_worker( fcolor, fcoord ); }\n\nvoid mainVR( out vec4 fcolor, in vec2 fcoord, in vec3 _ro_dummy_, in vec3 _rd_dummy_ )\n{\n    g_vrmode = true;\n    vec3 horz = ( unCorners[1] + unCorners[2] - unCorners[0] - unCorners[3] ).zxy * vec3( -1, 1, -1 );\n    vec3 down = ( unCorners[0] + unCorners[1] - unCorners[2] - unCorners[3] ).zxy * vec3( -1, 1, -1 );\n    vec3 forw = ( unCorners[0] + unCorners[1] + unCorners[2] + unCorners[3] - 4. * unCorners[4] ).zxy * vec3( -1, 1, -1 );\n    g_vrframe[1] = normalize( horz );\n    g_vrframe[2] = normalize( down );\n    g_vrframe[0] = cross( g_vrframe[1], g_vrframe[2] );\n    vec3 cent = g_vrframe[0] * dot( forw, g_vrframe[0] ) - 2. * ( unCorners[0] - unCorners[4] ).zxy * vec3( -1, 1, -1 );\n    g_vrfocus.xy = vec2( dot( cent, g_vrframe[1] ) / dot( horz, g_vrframe[1] ), dot( cent, g_vrframe[2] ) / dot( -down, g_vrframe[2] ) );\n    g_vrfocus.zw = dot( forw, g_vrframe[0] ) / vec2( dot( horz, g_vrframe[1] ), dot( down, g_vrframe[2] ) );\n    g_vrcoord = ( gl_FragCoord.xy - unViewport.xy ) / unViewport.zw;\n    g_vrdir = normalize( mix( mix( unCorners[0], unCorners[1], g_vrcoord.x ),\n                              mix( unCorners[3], unCorners[2], g_vrcoord.x ), g_vrcoord.y ) - unCorners[4] ).zxy * vec3( -1, 1, -1 );\n    main_image_worker( fcolor, gl_FragCoord.xy );\n}\n\n#define unViewport _unViewport_dummy_\n#define unCorners _unCorners_dummy_\n", "name": "Image", "description": "", "type": "image"}, {"inputs": [], "outputs": [], "code": "/*\n *\t\t\t\tSPACE GLIDER 2020 SHADERTOY EDITION\n *\t\t\t\t\t   by Christian Sch\u00fcler\n *                       (c) 2001 - 2020\n *\n * Part 1 of 6: Common definitions\n * This software comes with no warranty. Use it at your own risk.\n */\n\n// ----------------------------------------------------------------------------\n// OPTIONS\n// ----------------------------------------------------------------------------\n\n// Set the overall quality level\n\n#define QUALITY_LEVEL\t\t\t\t3\n\n\t/*\n\tQUALITY_LEVEL\t\t\t\t\t0\t\t1\t\t2\t\t3\t\t4\n\n\tWITH_ATM_BILATERAL_UPSAMPLE\t\t-\t\t-\t\t-\t\tx\t\tx\n\tWITH_ATM_QUADRATURE\t\t\t\t-\t\t-\t\t-\t\tx\t\tx\n\tWITH_ATM_TWEAKS\t\t\t\t\t-\t\t-\t\t-\t\t-\t\tx\n\tWITH_TRN_REFINE\t\t\t\t\t-\t\tx\t\tx\t\tx\t\tx\n\tWITH_TRN_CENTRAL_DIFF\t\t\t-\t\t-\t\tx\t\tx\t\tx\n\tWITH_TRN_HIGHP_RAYCAST\t\t\t-\t\t-\t\tx\t\tx\t\tx\n\n\tATM_CLOUD_MAX_ITER\t\t\t\t20\t\t25\t\t30\t\t35\t\t40\n\tATM_CLOUD_TAU50_CUTOFF\t\t\t8\t\t9\t\t10\t\t11\t\t12\n\tATM_SCATTER_MAX_ITER\t\t\t30\t\t45\t\t60\t\t75\t\t90\n\tATM_SUBSAMPLE\t\t\t\t\t4\t\t3\t\t2\t\t2\t\t2\n\tSCN_RAYCAST_MAX_ITER\t\t\t250\t\t300\t\t350\t\t400\t\t450\n\tSCN_SUBSAMPLE\t\t\t\t\t2   \t3/2\t\t1\t\t1\t\t1\n\tTRN_MAX_REFINE_LEVELS\t\t\t-\t\t1\t\t2\t\t3   \t4\n\t*/\n\n// Enables kiosk mode\n// disables interactive controls and activates a simple autopilot\n// see the KSK_ parameters further down\n\n#define KIOSK_MODE\t\t\t\t\t0\n\n// Enables workarounds against driver bugs\n\n#define WORKAROUND_01_EXP2\t\t\t1\t\t// Ubuntu Studio 18 (bionic) GTX 760\n#define WORKAROUND_02_FOR_IF\t\t1\t\t// Ubuntu Studio 18 (bionic) GTX 760\n#define WORKAROUND_03_SWITCH\t\t1\t\t// Windows ANGLE/D3D backend\n#define WORKAROUND_04_VEC4\t\t\t1\t\t// Windows ANGLE/D3D backend\n#define WORKAROUND_05_UVEC4\t\t\t1\t\t// Windows ANGLE/D3D backend\n#define WORKAROUND_07_KEYPRESS\t\t1\t\t// iMac 2010 27 inch Radeon 5670 M\n#define WORKAROUND_08_UINT2FLOAT\t1\t\t// Windows ANGLE/D3D wants uint -> int -> float in some cases?\n\n// Restrict compilation up to a certain buffer from 1..5\n// (in the order A,B,C,D,Image)\n\n#define BUFFER_RUNLEVEL\t\t\t\t5\n\n// Other compile time options\n\n#define WITH_ATMOSPHERE\t\t\t\t1\n#define WITH_ATM_AMTL_CORRECTION \t1\n#define WITH_ATM_BILATERAL_UPSAMPLE ( QUALITY_LEVEL >= 3 )\n#define WITH_ATM_LAYER_A\t\t\t1\t\t// absorbtion layer (used for ozone)\n#define WITH_ATM_LAYER_E\t\t\t1\t\t// emission layer (used for airglow)\n#define WITH_ATM_LAYER_G\t\t\t1\t\t// ground layer (used for aerosols and water vapor)\n#define WITH_ATM_QUADRATURE\t\t\t( QUALITY_LEVEL >= 3 )\n#define WITH_ATM_TWEAKS\t\t\t\t( QUALITY_LEVEL >= 4 )\n\n#define WITH_CLOUDS\t\t\t    \t1\n\n#define WITH_TERRAIN\t\t\t\t1\n#define WITH_TRN_CENTRAL_DIFF\t\t( QUALITY_LEVEL >= 2 )\n#define WITH_TRN_SHADOW\t\t\t\t1\n#define WITH_TRN_REFINE\t\t\t\t( QUALITY_LEVEL >= 1 )\n#define WITH_TRN_HIGHP_RAYCAST\t\t( QUALITY_LEVEL >= 2 )\n\n#define WITH_STARS\t\t\t\t\t1\n\n#define WITH_ILLUM_TEST\t\t\t\t0\t\t// illumination only, exposure measurements\n\nconst float SECONDS_PER_MINUTE\t\t= 10.;\nconst float ATM_SCALE\t\t\t\t= .333333333 * SECONDS_PER_MINUTE;\nconst float SCN_SCALE\t\t\t\t= .333333333 * SECONDS_PER_MINUTE;\nconst float TRN_SCALE \t\t\t\t= .333333333 * SECONDS_PER_MINUTE;\n\n// ----------------------------------------------------------------------------\n// CONSTANTS\n// ----------------------------------------------------------------------------\n\nconst float EULER = 2.71828183;\nconst float FRACT_1_16 = .0625;\nconst float FRACT_1_64 = .015625;\nconst float FRACT_15_16 = .9375;\nconst float FRACT_63_64 = .984375;\nconst float FRACT_127_128 = 0.9921875;\nconst float FRACT_1_4096 = .000244140625;\nconst vec3 \tHALF = vec3(.5);\nconst mat3 \tIDENTITY = mat3(1);\nconst float LN2 = 0.693147181;\nconst float LN10 = 2.30258509;\nconst float LOG2E = 1.44269504;\nconst vec3 \tONE = vec3(1);\nconst float ONEOVERSQRTPI = 0.564189584;\nconst float ONEOVERSQRTTWOPI = 0.398942280;\nconst float PI = 3.14159265;\nconst float PIHALF = 1.57079632;\nconst uint\tRNG32 = 3934873077u;\nconst float TAU = 6.28318531;\nconst float SQRTHALF = 0.707106781;\nconst float SQRTTWO = 1.41421356;\nconst float SQRTPILN2HALF = 1.04345246;\nconst float\tSHR32 = 1. / 4294967296.;\nconst vec3  UNIT_X = vec3(1,0,0);\nconst vec3  UNIT_Y = vec3(0,1,0);\nconst vec3  UNIT_Z = vec3(0,0,1);\nconst vec3 \tZERO = vec3(0);\n\nconst int \tATM_CLOUD_MAX_ITER = 20 + 5 * QUALITY_LEVEL;\nconst float ATM_CLOUD_SHADOW_MIN_TAU = 350.;\nconst float ATM_CLOUD_SHADOW_MAX_TAU = 750.;\nconst float ATM_CLOUD_TAU50_CUTOFF = 15. + float( QUALITY_LEVEL );\nconst float ATM_CLOUD_T_CUTOFF = exp2( -ATM_CLOUD_TAU50_CUTOFF );\nconst int \tATM_SCATTER_MAX_ITER = 30 + 15 * QUALITY_LEVEL;\nconst int \tATM_SCATTER_MIN_ITER = 25;\nconst float ATM_SUBSAMPLE = max( 2., 4. - float( QUALITY_LEVEL ) );\nconst float ATM_SUBSAMPLE_INV = 1. / ATM_SUBSAMPLE;\n\nconst float CAM_FOV = 100.;\nconst float CAM_FOV_INNER = 95.;\nconst float CAM_FOCUS = 1. / tan( radians( CAM_FOV ) / 2. );\nconst float CAM_FOCUS_INNER = 1. / tan( radians( CAM_FOV_INNER ) / 2. );\nconst float CAM_DISTORT = max( 0.01, CAM_FOCUS_INNER / CAM_FOCUS - 1. );\n\nconst vec4 \tCOL_AIRGLOW = 1.0154e-6 * vec4( .8670, 1.0899, .4332, 15. );\t// mixture of mostly 558 + some 589 and 630 nm emission lines\nconst vec4  COL_NVISNSENS = vec4( .6, .3, .1, 1.3 );\t\t\t\t\t\t// night vision sensitivities\nconst float COL_NVISNSAT = 0.023;\t\t\t\t\t\t\t\t\t\t\t// night vision saturation luminance\nconst float COL_NVISNGAIN = 215.;\t\t\t\t\t\t\t\t\t\t\t// night vision amplification factor\nconst vec3  COL_RODVISION = vec3( 0.4856, 0.4856, 0.9713 );\t\t\t\t\t// color of 2 parts S-cone over 1 part L + M cones\nconst vec3  COL_P20PHOSPHOR = vec3( 0.8975, 1.0930, 0.0934 );\t\t\t\t// color of P20 phosphor emission spectrum\nconst vec3  COL_P43PHOSPHOR = vec3( 0.5335, 1.2621, 0.1874 );\t\t\t\t// color of P43 phosphor emission spectrum\nconst vec3  COL_PRIMARYRED = vec3( 0.4470, 0.0000, 0.0000 );\t\t\t\t// brightest physically realizable in-gamut red material color\nconst vec4  COL_STARLIGHT = 0.9178e-6 * vec4( 0.9714, 1.0123, 1.0341, .3 );\t// luminance and color of total starlight\nconst float COL_STARLIGHT_ISL = 0.7875;\t\t\t\t\t\t\t\t\t\t// fraction of integrated starlight\nconst vec4  COL_SUNLIGHT = vec4( 0.9420, 1.0269, 1.0242, .3 );\t\t\t\t// color of sunlight emission spectrum\nconst float COL_THRESHOLD = 3.462e-8;\t\t\t\t\t\t\t\t\t\t// threshold of vision\nconst vec4  COL_XENONARC = vec4( 0.8203, 1.0856, 1.0254, 0.25 );\t\t\t// color of xenon arc emission light spectrum\nconst vec3  COL_YWEIGHTS = vec3( 0.3161, 0.6543, 0.0296 );\t\t\t\t\t// luminance weights of the 615,535,445 primaries\n\nconst float\tFDM_MASS_SCALE = 3.34359350 / SCN_SCALE;\nconst int\tFDM_MIN_ITER = 4;\nconst int\tFDM_MAX_ITER = 30;\nconst float FDM_STD_G = 32.7894512 / SCN_SCALE;\n\nconst vec2\tHMD_BORDER = vec2( .80, .40 );\nconst vec2\tHMD_BORDER_LAD = vec2( .40, .30 );\nconst vec2\tHMD_BORDER_SYM = vec2( .65, .35 );\n\nconst float IMG_EXPOSURE_MAX = 8.;\nconst int\tIMG_EXPOSURE_SAMPLES = 1024;\nconst float IMG_MIPMAP_HIDE = 16777216.;\n\n#if KIOSK_MODE\nconst int   KSK_START_LOCATION = 19;\nconst float KSK_TRANSITION_DELAY = 3.5;\nconst float KSK_THROTTLE_TAKEOFF = 0.70;\nconst float KSK_THROTTLE_CLIMB = 0.35;\nconst float KSK_THROTTLE_CRUISE = 0.20;\nconst float\tKSK_TRIM_TAKEOFF = 0.050;\nconst float\tKSK_TRIM_CLIMB = 0.015;\nconst float KSK_TRIM_CRUISE = 0.012;\nconst float KSK_CRUISE_ALT = 3000. * SCN_SCALE;\nconst ivec3 KSK_MODES = ivec3( 2, 1, 0 );\n#endif\n\nconst int \tSCN_MAX_PRIMITIVES = 40;\nconst int \tSCN_RAYCAST_MAX_ITER = 250 + 50 * QUALITY_LEVEL;\nconst float SCN_RAYCAST_MIN_ADVANCE = .002;\nconst float SCN_RAYCAST_MIN_ADVANCE_SCALE = 8. / float( SCN_RAYCAST_MAX_ITER );\nconst int \tSCN_RAYCAST_SHADOW_MAX_ITER = SCN_RAYCAST_MAX_ITER * 2 / 3;\nconst float SCN_RAYCAST_SHADOW_MIN_ADVANCE = .006;\nconst float SCN_RAYCAST_SHADOW_MIN_ADVANCE_SCALE = 8. / float( SCN_RAYCAST_SHADOW_MAX_ITER );\nconst float SCN_RAYCAST_SHADOW_HBIAS = .002;\nconst float SCN_RAYCAST_SHADOW_HSCALE = .005;\nconst float SCN_RAYCAST_SHADOW_TBIAS = .001;\nconst float SCN_RAYCAST_SHADOW_UMBRA = 42.9002412 * SCN_SCALE / ATM_SCALE;\nconst float SCN_RAYCAST_SHADOW_UMBRA_INV = 1. /  SCN_RAYCAST_SHADOW_UMBRA;\nconst float SCN_SUBSAMPLE = ATM_SUBSAMPLE / 2.;\nconst float SCN_SUBSAMPLE_INV = 1. / SCN_SUBSAMPLE;\nconst float SCN_ZNEAR = 0.001;\nconst float SCN_ZFAR = 99999.;\n\nconst float TRN_AO_LOD_OFFSET = 2.;\nconst float TRN_LOD_BIAS = 1.; // + log2( TRN_SCALE );\nconst float TRN_MAX_LEVELS = 16.;\nconst float TRN_MAX_REFINE_LEVELS = float( QUALITY_LEVEL );\nconst float TRN_UPDATE_THRESHOLD = 9.;\nconst float TRN_UV_RANGE = SQRTTWO;\nconst float TRN_UV_RANGE_INV = 1. / TRN_UV_RANGE;\n\nconst float TXT_FONT_SPACING = .50;\nconst float TXT_FONT_HOFFSET = .27;\nconst float TXT_FONT_BACKSLANT = .15;\nconst int\tTXT_FMT_MAX_LEN = 59;\nconst int\tTXT_FMT_MAX_COUNT = 52;\nconst uint  TXT_FMT_FLAG_CENTER = 0x10u;\nconst uint  TXT_FMT_FLAG_RIGHT = 0x20u;\nconst uint  TXT_FMT_FLAG_HUDCLIP = 0x80u;\nconst uint  TXT_FMT_LENGTH_MASK = 0x0fu;\nconst int   TXT_MSG_MAX_PHRASES = 7;\n\n// ----------------------------------------------------------------------------\n// MEMORY MAP\n// ----------------------------------------------------------------------------\n\nbool in_addr_range( ivec2 sc, ivec2 addr, int size, int count )\n\t{ return sc.y >= addr.x && sc.y < addr.x + count &&\n             sc.x >= addr.y && sc.x < addr.y + size; }\n\nvec4 memload( sampler2D ch, ivec2 addr, int offs )\n\t{ return texelFetch( ch, addr.yx + ivec2( offs, 0 ), 0 ); }\n\nmat2x3 memload_mat2x3( sampler2D ch, ivec2 addr, int offs )\n\t{ return mat2x3( memload( ch, addr, offs ).xyz, memload( ch, addr, offs + 1 ).xyz ); }\n\nmat3 memload_mat3( sampler2D ch, ivec2 addr, int offs )\n\t{ return mat3( memload( ch, addr, offs ).xyz, memload( ch, addr, offs + 1 ).xyz, memload( ch, addr, offs + 2 ).xyz ); }\n\nvec3 memload_mat3extra( sampler2D ch, ivec2 addr, int offs )\n\t{ return vec3( memload( ch, addr, offs ).w, memload( ch, addr, offs + 1 ).w, memload( ch, addr, offs + 2 ).w ); }\n\nvoid memstore( vec4 value, ivec2 addr, int offs, ivec2 sc, inout vec4 fc )\n\t{ if( sc.y == addr.x && sc.x == addr.y + offs ) fc = value; }\n\nvoid memstore( vec3 value1, float value2, ivec2 addr, int offs, ivec2 sc, inout vec4 fc )\n\t{ if( sc.y == addr.x && sc.x == addr.y + offs ) fc = vec4( value1, value2 ); }\n\nvoid memstore( vec2 value1, vec2 value2, ivec2 addr, int offs, ivec2 sc, inout vec4 fc )\n\t{ if( sc.y == addr.x && sc.x == addr.y + offs ) fc = vec4( value1, value2 ); }\n\nvoid memstore( mat3 value1, vec3 value2, ivec2 addr, int offs, ivec2 sc, inout vec4 fc )\n{\n    if( sc.y == addr.x && sc.x == addr.y + offs )\n        fc = vec4( value1[0], value2.x );\n    if( sc.y == addr.x && sc.x == addr.y + offs + 1 )\n        fc = vec4( value1[1], value2.y );\n    if( sc.y == addr.x && sc.x == addr.y + offs + 2 )\n        fc = vec4( value1[2], value2.z );\n}\n\nvoid memstore( mat3 value, ivec2 addr, int offs, ivec2 sc, inout vec4 fc )\n\t{ memstore( value, ZERO, addr, offs, sc, fc ); }\n\n// A buffer addresses\n\n/*\n\t.\t\t\t\t  .\t\t\t\t\t.\t\t\t\t  .\n\t.\t\t\t\t  .\t\t\t\t\t.\t\t\t\t  .\n\t.\t\t\t\t  .\t \t\t\t\t.\t\t\t\t  .\n\n\tppppppp. ........ aaaaaaaa aaaa.... ssssss.. ........ ........ ........\n\tppppppp. ........ aaaaaaaa aaaa.... ssssss.. ........ ........ ........\n\tppppppp. ........ aaaaaaaa aaaa.... ssssss.. ........ ........ ........\n\tppppppp. ........ aaaaaaaa aaaa.... ssssss.. ........ ........ ........\n\tppppppp. ........ aaaaaaaa aaaa.... ssssss.. ........ ........ ........\n\tppppppp. ........ aaaaaaaa aaaa.... ssssss.. ........ ........ ........\n\tppppppp. ........ aaaaaaaa aaaa.... ssssss.. ........ ........ ........\n\tppppppp. ........ aaaaaaaa aaaa.... ssssss.. ........ ........ ........\n\n\tEEEEEEEE ........ ........ ........ ........ ........ ........ ........\n\tEEEEEEEE ........ ........ ........ ........ ........ ........ ........\n\tEEEEEEEE ........ ........ ........ ........ ........ ........ ........\n\tEEEEEEEE ........ AA...... ........ ........ ........ ........ ........\n\tEEEEEEEE ........ ........ ........ ........ ........ ........ ........\n\tEEEEEEEE ........ LLLL.... ........ ........ ........ ........ ........\n\tEEEEEEEE ........ ........ ........ ........ ........ ........ ........\n\tEEEEEEEE ........ MMMMMMMM MMMMMMM. ........ ........ ........ ........\n\n\t........ ........ ........ ........ ........ ........ ........ ........\n    ........ ........ TTT..... ........ ........ ........ ........ ........\n    ........ ........ ........ ........ ........ ........ ........ ........\n    sizes... ........ TTT..... ........ ........ ........ ........ ........\n    ........ ........ ........ ........ ........ ........ ........ ........ .\n\tD....... ........ VVVVVVVV VVVVVVVV VVV..... ........ ........ ........ .\n    ........ ........ ........ ........ ........ ........ ........ ........ .\n\tR....... ........ GGGGGGGG GGG..... ........ ........ ........ ........ const data ...\n*/\n\nconst ivec2\tADDR_RESOLUTION = ivec2( 0, 0 );\nconst ivec2\tADDR_DTIME = ivec2( 2, 0 );\nconst ivec2\tADDR_DATASIZES = ivec2( 4, 0 );\nconst ivec2\tADDR_EXPOSURE = ivec2( 8, 0 );\n\nconst ivec2\tADDR_GAMESTATE = ivec2( 0, 16 );\nconst ivec2\tADDR_VEHICLE = ivec2( 2, 16 );\nconst ivec2\tADDR_TSAMPLER = ivec2( 4, 16 );\nconst ivec2\tADDR_TSAMPLER_LAST = ivec2( 6, 16 );\nconst ivec2\tADDR_MESSAGES = ivec2( 8, 16 );\nconst ivec2\tADDR_LOCALENV = ivec2( 10, 16 );\nconst ivec2 ADDR_ACHIEVEMENTS = ivec2( 12, 16 );\n\nconst ivec2\tADDR_PLANETS = ivec2( 16, 0 );\nconst ivec2\tADDR_ATMCONTEXTS = ivec2( 16, 16 );\nconst ivec2\tADDR_SCENE_OBJECTS = ivec2( 16, 32 );\n\nconst ivec2 ADDR_SCENE_DATA_OBJECTS = ivec2( 0, 64 );\nconst ivec2 ADDR_MENU_DATA = ivec2( 0, 72 );\nconst ivec2 ADDR_START_DATA = ivec2( 0, 80 );\n\n// ----------------------------------------------------------------------------\n// UTILITIES\n// ----------------------------------------------------------------------------\n\n#define FORCE_EVAL( x ) clamp( x, -1e12, 1e12 )\n\n// screen coordinate utils\n\n#define sc2uv( _sc ) ( (_sc) / iResolution.xy )\n#define uv2sc( _uv ) ( (_uv) * iResolution.xy )\n#define sc2ec( _sc ) ( ( 2. * (_sc) - iResolution.xy ) / iResolution.x )\n#define ec2sc( _ec ) ( .5 * ( (_ec) * iResolution.x + iResolution.xy ) )\n#define sc2mc( _sc ) ( ( 2. * (_sc) - iResolution.xy ) / iResolution.y )\n#define mc2sc( _ec ) ( .5 * ( (_ec) * iResolution.y + iResolution.xy ) )\n\n// type-generic utils\n\n#define cosatan(x) ( 1. / sqrt( (x) * (x) + 1. ) )\n#define cube(x) ( (x) * (x) * (x) )\n#define expm1(x) ( exp(x) - 1. )\n#define log1p(x) log( (x) + 1. )      // - ( FORCE_EVAL( FORCE_EVAL( (x) + 1. ) - 1. ) - (x) ) / ( (x) + 1. ) )\n#define project(a,b) ( (b) * dot( a, b ) )\n#define lensq(x) dot( x, x )\n#define reject(a,b) ( (a) - project(a,b) )\n#define reject_max(a,b) ( (a) - (b) * max( 0., dot( a, b ) ) )\n#define reject_min(a,b) ( (a) - (b) * min( 0., dot( a, b ) ) )\n#define sinatan(x) ( (x) / sqrt( (x) * (x) + 1. ) )\n#define softadd(a,b) ( (a) + (b) - (a) * (b) )\n#define softdiv( a, b, scale ) ( (a) * (b) / ( (scale) * (scale) + (b) * (b) ) )\n#define softnormalize( a, scale ) ( softdiv( a, length(a), scale ) )\n#define safediv( a, b ) softdiv( a, b, 1e-6 )\n#define safenormalize( a ) softnormalize( a, 1e-6 )\n#define saturate(a) clamp( a, 0., 1. )\n#define sqdiff(a,b) ( ( (a) - (b) ) * ( (a) + (b) ) )\n#define square(x) ( (x) * (x) )\n\n// type-specific utils\n\nvec2 barrel_distort( vec2 ec, float a ) { return ec / max( 0., 1. + a * ( 1. - dot( ec, ec ) ) ); }\nvec2 barrel_distort_inv( vec2 ec, float a ) { float ec2 = dot( ec, ec ); float u = a * ( a + 1. ) * ec2; return u < 1. / 4096. ? ec * ( a + 1. ) : ec / ( 2. * a * ec2 ) * ( sqrt( 4. * u + 1. ) - 1. ); }\nfloat barrel_distort_rate( float ec2, float a ) { return ( a + 1. + a * ec2 ) / square( a + 1. - a * ec2 ); }\nfloat chebychev6( float x ) { float x2 = x * x; return ( ( 32. * x2 - 48. ) * x2 + 18. ) * x2 - 1.; }\nfloat fresnel_schlick( float r0, float mu ) { mu = 1. - mu; return mix( r0, 1., mu * mu * mu * mu * mu ); }\nfloat hmax( vec2 arg ) { return max( arg.x, arg.y ); }\nfloat hmax( vec3 arg ) { return max( arg.x, max( arg.y, arg.z ) ); }\nfloat hmax( vec4 arg ) { return max( arg.x, max( arg.y, max( arg.z, arg.w ) ) ); }\nfloat hmin( vec2 arg ) { return min( arg.x, arg.y ); }\nfloat hmin( vec3 arg ) { return min( arg.x, min( arg.y, arg.z ) ); }\nfloat hmin( vec4 arg ) { return min( arg.x, min( arg.y, min( arg.z, arg.w ) ) ); }\nvec3 length_normalize( vec2 x ) { float p = dot(x,x); float q = inversesqrt(max(1e-24,p)); return vec3( x, p ) * q; }\nvec4 length_normalize( vec3 x ) { float p = dot(x,x); float q = inversesqrt(max(1e-24,p)); return vec4( x, p ) * q; }\nvec4 length_normalize_r( vec3 x, vec3 r ) { vec3 s = x + r; float p = dot(x,x); float q = inversesqrt(max(1e-24,p)); return vec4( x, p ) * q; }\nfloat pack_normal( vec3 a ) { uvec3 b = uvec3( round( 511. * a ) + 512. ) & 1023u; return uintBitsToFloat( ( b.x << 20u ) | ( b.y << 10u ) | b.z ); }\nvec4 pack_uvec4( uvec4 a ) { return vec4( uintBitsToFloat( a.x ), uintBitsToFloat( a.y ), uintBitsToFloat( a.z ), uintBitsToFloat( a.w ) ); }\nfloat parabolstep( float a, float b, float x ) { float t = clamp( ( x - a ) / ( b - a ), 0., 1. ) - .5; return .5 - 2. * ( abs( t ) * t - t ); }\nvec2 perp( vec2 arg ) { return vec2( -arg.y, arg.x ); }\nvoid rot90( inout vec3 a, inout vec3 b ) { vec3 tmp = a; a = b; b = -tmp; }\nvec3 simple_refract( vec3 I, vec3 N ) { return  I - .8 * ( 1.5 - dot( N, I ) ) * N; }\nvec3 simple_refract_inv( vec3 I, vec3 R, vec3 Z ) { vec3 result = normalize( I - R * length( simple_refract( I, Z ) ) ); return I - R * length( simple_refract( I, result ) ); }\nmat3 skew( vec3 n ) { return mat3( 0, n.z, -n.y, -n.z, 0, n.x, n.y, -n.x, 0 ); }\nvec3 unpack_normal( float a ) { uint b = floatBitsToUint( a ); return ( vec3( uvec3( b >> 20u, b >> 10u, b ) & 1023u ) - 512. ) / 511.; }\nuvec4 unpack_uvec4( vec4 a ) { return uvec4( floatBitsToUint( a.x ), floatBitsToUint( a.y ), floatBitsToUint( a.z ), floatBitsToUint( a.w ) ); }\n\n#if WORKAROUND_01_EXP2\nfloat exp2pp( float x ) { return exp2( max( x, -126. ) ); }\nvec2 exp2pp( vec2 x ) { return exp2( max( x, -126. ) ); }\nvec3 exp2pp( vec3 x ) { return exp2( max( x, -126. ) ); }\nvec4 exp2pp( vec4 x ) { return exp2( max( x, -126. ) ); }\n#else\nfloat exp2pp( float x ) { return exp2(x); }\nvec2 exp2pp( vec2 x ) { return exp2(x); }\nvec3 exp2pp( vec3 x ) { return exp2(x); }\nvec4 exp2pp( vec4 x ) { return exp2(x); }\n#endif\n\n// ray utils\n\nstruct Ray { vec3 o; vec3 d; };\n\nvec2 sphere_impact( vec3 o, vec3 d )\n{\n    float q = dot( o, d );\n    /*\n    return vec2( dot( o, o ) - q * q, q );\n\t/*/\n    vec3 h = o - d * q / dot( d, d );\n    return vec2( dot( h, h ), q );\n    //*/\n}\n\nvec2 sphere_limits( float R, vec2 impact )\n{\n\tfloat D = R * R - impact.x;\n    return sqrt(D) * vec2( -1, 1 ) - impact.y;\n}\n\n// utils for automatic partial derivatives\n\nconst vec4 HALF_D = vec4( ZERO, .5 );\nconst vec4 ONE_D = vec4( ZERO, 1 );\nconst vec4 TWO_D = vec4( ZERO, 2 );\nconst vec4 ZERO_D = vec4(0);\n\nvec4 abs_d( vec4 a ) { return a * sign( a.w ); }\nvec4 asin_d( vec4 a ) { return vec4( a.xyz * inversesqrt( 1. - a.w * a.w ), asin( a.w ) ); }\nvec4 atan_d( vec4 a ) { return vec4( a.xyz / ( 1. + a.w * a.w ), atan( a.w ) ); }\nvec4 atan2_d( vec4 a, vec4 b ) { return vec4( ( a.xyz * b.w - b.xyz * a.w ) / ( square( b.w ) * ( 1. + square( a.w / b.w ) ) ), atan( a.w, b.w ) ); }\nvec4 atanh_d( vec4 a ) { return vec4( a.xyz / ( 1. - a.w * a.w ), atanh( a.w ) ); }\nvec4 clamp_d( vec4 x, vec4 a, vec4 b ) { return x.w < a.w ? a : x.w < b.w ? x : b; }\nvec4 const_d( float x ) { return vec2( 0, x ).xxxy; }\nvec4 cos_d( vec4 a ) { return vec4( -a.xyz * sin( a.w ), cos( a.w ) ); }\nvec4 cosh_d( vec4 a ) { return vec4( a.xyz * sinh( a.w ), cosh( a.w ) ); }\nvec4 div_d( vec4 a, vec4 b ) { return vec4( ( a.xyz * b.w - a.w * b.xyz ) / square( b.w ), a.w / b.w ); }\nvec4 exp_d( vec4 a ) { return exp( a.w ) * vec4( a.xyz, 1 ); }\nvec4 hypot_d( vec4 a, vec4 b ) { float h = sqrt( a.w * a.w + b.w * b.w ); return vec4( ( a.xyz * a.w + b.xyz * b.w ) / h, h ); }\nvec4 log_d( vec4 a ) { return vec4( a.xyz / a.w, log( a.w ) ); }\nvec4 max_d( vec4 a, vec4 b ) { return b.w < a.w ? a : b; }\nvec4 min_d( vec4 a, vec4 b ) { return a.w < b.w ? a : b; }\nvec4 mix_d( vec4 a, vec4 b, vec4 t ) { return mix( a, b, t.w ) + vec4( t.xyz, 0 ) * ( b.w - a.w ); }\nvec4 mul_d( vec4 a, vec4 b ) { return a * b.w + vec4( a.w * b.xyz, 0 ); }\nvec4 pow_d( vec4 a, float b ) { return a * pow( a.w, b - 1. ) * vec2( b, 1 ).xxxy; }\nvec4 saturate_d( vec4 a ) { return a.w < 0. ? ZERO_D : a.w < 1. ? a : ONE_D; }\nvec4 sin_d( vec4 a ) { return vec4( a.xyz * cos( a.w ), sin( a.w ) ); }\nvec4 sinh_d( vec4 a ) { return vec4( a.xyz * cosh( a.w ), sinh( a.w ) ); }\nvec4 smin1_d( vec4 a, float b ) { return ONE_D - log_d( ONE_D + exp_d( ( ONE_D - a ) / ( b / EULER ) ) ) * ( b / EULER ); }\nvec4 sqrt_d( vec4 a ) { return a * inversesqrt( a.w ) * vec2( .5, 1 ).xxxy; }\nvec4 square_d( vec4 a ) { return a * a.w * vec2( 2, 1 ).xxxy; }\nvec4 tan_d( vec4 a ) { float t = tan( a.w ); return vec4( a.xyz * ( 1. + t * t ), t ); }\nvec4 tanh_d( vec4 a ) { float t = tanh( a.w ); return vec4( a.xyz * ( 1. - t * t ), t ); }\n\n// ----------------------------------------------------------------------------\n// GEODESY\n// ----------------------------------------------------------------------------\n\nvec2 sincospi( float a )\n{\n    vec2 x = 2. * abs( fract( .5 * vec2( a, a + .5 ) - .25 ) - .5 ) - .5;\n    vec2 x2 = x * x;\n    return ( ( ( ( 0.08775688658 * x2 - 0.6040085292 ) * x2 + 2.551159039 ) * x2 - 5.167786189 ) * x2 + 3.141594103 ) * x;\n}\n\nvec3 nav2r( vec3 nav )\n{\n    vec2 sclat = sincospi( nav.x / 180. );\n    vec2 sclong = sincospi( nav.y / 180. );\n    return nav.z * vec3( sclat.y * sclong.y, sclat.y * sclong.x, sclat.x );\n}\n\nvec3 r2nav( vec3 r )\n{\n    return vec3(\n        degrees( atan( r.z, length( r.xy ) ) ),\n        degrees( atan( r.y, r.x ) ),\n        length(r) );\n}\n\nmat3 bearing2B( vec3 r, float bearing )\n{\n    if( dot( r.xy, r.xy ) > 0. )\n    {\n    \tvec3 east = normalize( cross( UNIT_Z, r ) );\n    \tvec3 north = normalize( cross( r, east ) );\n        vec2 scb = sincospi( bearing / 180. );\n    \tvec3 dir = scb.y * north + scb.x * east;\n    \treturn mat3( dir, -normalize( cross( r, dir ) ), -normalize(r) );\n    }\n    else\n    {\n        vec3 dir = vec3( cos( radians( bearing ) ), sin( radians( bearing ) ), 0 );\n        return mat3( dir, -normalize( cross( r, dir ) ), -normalize(r) );\n    }\n}\n\nfloat B2bearing( vec3 r, vec3 B )\n{\n    vec3 east = normalize( cross( UNIT_Z, r ) );\n    vec3 north = normalize( cross( r, east ) );\n    return mod( degrees( atan( dot( B, east ), dot( B, north ) ) ), 360. );\n}\n\nvec4 navb( vec3 r, vec3 B )\n\t{ return vec4( r2nav(r), B2bearing( r, B ) ); }\n\nvec2 arcdistance( vec3 a, vec3 b )\n{\n    vec4 an = length_normalize(a);\n    vec4 bn = length_normalize(b);\n    vec3 dn = an.xyz - bn.xyz;\n    float arclen = atan( length( reject( dn, an.xyz ) ), dot( bn.xyz, an.xyz ) );\n    return vec2( .5 * ( an.w + bn.w ) * arclen, an.w - bn.w );\n}\n\nvec2 rot2d( vec2 r, float angle )\n{\n    angle = radians( angle );\n    float s = sin( angle );\n    float c = cos( angle );\n    return r * mat2( c, s, -s, c );\n}\n\nmat3 spin( mat3 B, vec3 omega )\n{\n\tB[0] = normalize( B[0] + cross( omega, B[0] ) );\n\tB[1] = normalize( B[1] + cross( omega, B[1] ) );\n\tB[2] = normalize( cross( B[0], B[1] ) );\n\tB[1] = cross( B[2], B[0] );\n    return B;\n}\n\n// ----------------------------------------------------------------------------\n// START POSITIONS\n// ----------------------------------------------------------------------------\n\nstruct StartData\n{\n    uvec4 name;\n    ivec4 iparams;\n    vec4 params;\n};\n\nconst int ADDR_START_DATA_SIZE = 3;\nconst int ADDR_START_DATA_COUNT = 22;\n\nStartData st_load( sampler2D ch, ivec2 addr )\n{\n\treturn StartData(\n\t\tunpack_uvec4( memload( ch, addr, 0 ) ),\n\t    ivec4( memload( ch, addr, 1 ) ),\n    \tmemload( ch, addr, 2 ) );\n}\n\nvoid st_store( StartData self, ivec2 addr, ivec2 sc, inout vec4 fc )\n{\n    memstore( pack_uvec4( self.name ), addr, 0, sc, fc );\n    memstore( vec4( self.iparams ), addr, 1, sc, fc );\n    memstore( self.params, addr, 2, sc, fc );\n}\n\n// ----------------------------------------------------------------------------\n// LOCATION DATA\n// ----------------------------------------------------------------------------\n\nstruct LocData\n{\n    vec4 zone;\t\t\t// xy = lat/long, z = size, w = bearing of local grid\n    uvec4 name;\t\t\t// phrase of location name\n};\n\nconst int ADDR_LOC_DATA_SIZE = 2;\nconst int ADDR_LOC_DATA_COUNT = 16;\n\nLocData ld_load( sampler2D ch, ivec2 addr )\n{\n    return LocData(\n        memload( ch, addr, 0 ),\n        unpack_uvec4( memload( ch, addr, 1 ) ) );\n}\n\nvoid ld_store( LocData self, ivec2 addr, ivec2 sc, inout vec4 fc )\n{\n    memstore( self.zone, addr, 0, sc, fc );\n    memstore( pack_uvec4( self.name ), addr, 1, sc, fc );\n}\n\n// ----------------------------------------------------------------------------\n// SCENE DATA\n// ----------------------------------------------------------------------------\n\nstruct SceneData\n{\n    vec4 tybr;\t\t\t// x = type, y = bounding radius\n    vec4 navb;\t\t\t// x = lat, y = long, z = alt, w = heading\n    vec4 paramsA;\n    vec4 paramsB;\n};\n\nconst int ADDR_SCENE_DATA_SIZE = 4;\nconst int ADDR_SCENE_DATA_COUNT = 76;\n\nSceneData sd_load( sampler2D ch, ivec2 addr )\n{\n    return SceneData(\n        memload( ch, addr, 0 ),\n        memload( ch, addr, 1 ),\n        memload( ch, addr, 2 ),\n        memload( ch, addr, 3 ) );\n}\n\nvoid sd_store( SceneData self, ivec2 addr, ivec2 sc, inout vec4 fc )\n{\n    memstore( self.tybr, addr, 0, sc, fc );\n    memstore( self.navb, addr, 1, sc, fc );\n    memstore( self.paramsA, addr, 2, sc, fc );\n    memstore( self.paramsB, addr, 3, sc, fc );\n}\n\nconst int SCNOBJ_TYPE_INVALID = 0;\nconst int SCNOBJ_TYPE_2D = 1000;\nconst int SCNOBJ_TYPE_RUNWAY = 1001;\nconst int SCNOBJ_TYPE_3D = 2000;\nconst int SCNOBJ_TYPE_PRIMITIVE = 2001;\nconst int SCNOBJ_TYPE_COMPOUND = 3000;\nconst int SCNOBJ_TYPE_TOWER = 3001;\nconst int SCNOBJ_TYPE_LIGHTHOUSE = 3002;\n\nconst int SCNOBJ_PRIMITIVE_SPHERE = 1;\nconst int SCNOBJ_PRIMITIVE_CUBE = 2;\nconst int SCNOBJ_PRIMITIVE_CYLINDER = 3;\n\n// B buffer lower letterbox addresses\n\nconst int ADDR_B_CAMPOS_SAMPLE = 0;\nconst int ADDR_B_WAYPOINT_SAMPLE = 8;\nconst int ADDR_B_LOCDATA = 16;\nconst int ADDR_B_ZONEDATA = ADDR_B_LOCDATA + ( ADDR_LOC_DATA_COUNT * ADDR_LOC_DATA_SIZE + 7 & ~7 );\nconst int ADDR_B_SCENEDATA = ADDR_B_ZONEDATA + ( ADDR_LOC_DATA_COUNT + 7 & ~7 );\n\n// ----------------------------------------------------------------------------\n// SCENE OBJECT\n// ----------------------------------------------------------------------------\n\nstruct SceneObj\n{\n    mat3 B;\n    vec3 r;\n    vec4 tybr;\n    vec4 paramsA;\n    vec4 paramsB;\n};\n\nconst int ADDR_SCENE_OBJECT_SIZE = 6;\n\nSceneObj so_load( sampler2D ch, ivec2 addr )\n{\n    return SceneObj(\n    \tmemload_mat3( ch, addr, 0 ),\n    \tmemload_mat3extra( ch, addr, 0 ),\n    \tmemload( ch, addr, 3 ),\n    \tmemload( ch, addr, 4 ),\n    \tmemload( ch, addr, 5 ) );\n}\n\nvoid so_store( SceneObj self, ivec2 addr, ivec2 sc, inout vec4 fc )\n{\n    memstore( self.B, self.r, addr, 0, sc, fc );\n    memstore( self.tybr, addr, 3, sc, fc );\n    memstore( self.paramsA, addr, 4, sc, fc );\n    memstore( self.paramsB, addr, 5, sc, fc );\n}\n\n// ----------------------------------------------------------------------------\n// KEPLER ORBITAL ELEMENTS\n// ----------------------------------------------------------------------------\n\nstruct Kepler\n{\n    float p;\t\t// semi-latus rectum\n    float e;\t\t// eccentricity\n    float i;\t\t// inclination\n    float O;\t\t// longitude of ascending node (Omega)\n    float w;\t\t// argument of periapsis (omega)\n};\n\n#define KEPLERA( a, e, i, O, w ) Kepler( a * ( 1. - (e) ) * ( 1. + (e) ), e, i, O, w )\n\nfloat kepler_semimajor( Kepler self )\n\t{ return self.p / ( 1. - self.e * self.e ); }      \n        \nfloat kepler_init( inout Kepler self, vec3 r, vec3 v, float GM )\n{\n    float nu = 0.;\n    float r2 = dot( r, r );\n    vec3 h = cross( r, v );\n\tfloat h2 = dot( h, h );\n    float H = sqrt( h2 );\n    float R = sqrt( r2 );\n    vec3 e = cross( v, h ) / GM - r / R;\n    float e2 = dot( e, e );\n    self.e = sqrt( e2 );\n    self.p = h2 / GM;\n    float cosi = clamp( h.z / H, -1., 1. );\n    self.i = atan( length( h.xy ), h.z );\n    self.O = ( cosi == 1. ? 0. : cosi == -.1 ? PI : atan( h.x, -h.y ) );\n    if( self.e >= .00005 )\n    {\n        float arglong =\n            cosi == 1. ? atan( r.y, r.x ) :\n        \tcosi == -1. ? atan( r.y, -r.x ) :\n        \tatan( r.z * H, r.y * h.x - r.x * h.y );\n        float u = self.p - R;\n        float vH = dot( r, cross( h, e ) );\n        nu = atan( vH, u * H );\n\t\tself.w = arglong - nu;\n    }\n    else\n        self.w = 0.;\n    return nu;\n}\n\nvoid kepler_get_vectors( Kepler self, float nu, float dnudt90,\n                         inout vec3 out_r, inout vec3 out_v )\n{\n    float opecn = 1. + self.e * cos(nu);\n\tfloat R = self.p / opecn;\n    float u = R * cos( self.w + nu );\n    float v = R * sin( self.w + nu );\n    float sini = sin( self.i );\n    float cosi = cos( self.i );\n    float sinO = sin( self.O );\n    float cosO = cos( self.O );\n\n    out_r = vec3( u * cosO - v * sinO * cosi,\n    \t\t\t  u * sinO + v * cosO * cosi,\n    \t\t\t  v * sini );\n\n    float dRdnu = self.p /* R */ * self.e * sin(nu) /* / opecn */;\n    float dudnu = dRdnu * cos( self.w + nu ) - self.p * opecn /* R */ * sin( self.w + nu );\n    float dvdnu = dRdnu * sin( self.w + nu ) + self.p * opecn /* R */ * cos( self.w + nu );\n    float dnudt = dnudt90 /* * opecn * opecn */;\n\n    out_v = dnudt * vec3( dudnu * cosO - dvdnu * sinO * cosi,\n    \t\t\t\t\t  dudnu * sinO + dvdnu * cosO * cosi,\n    \t\t\t\t\t  dvdnu * sini );\n}\n\nfloat cvt_M2E( float M, float e )\n{\n\tif( e < 1. )\n\t{\n\t\tM = mod( M, TAU );\n\t\tfloat E_min = 0.;\n\t\tfloat E_max = TAU;\n\t\tfor( int i = 0, n = 24; i < n; ++i )\n\t\t{\n\t\t\tfloat E = ( E_min + E_max ) / 2.;\n\t\t\tfloat M_test = E - e * sin(E);\n\t\t\tif( M_test < M )\n\t\t\t\tE_min = E;\n\t\t\telse\n\t\t\t\tE_max = E;\n\t\t}\n\t\treturn ( E_min + E_max ) / 2.;\n\t}\n\telse\n\t{\n\t\tfloat E_min = -44.;\n\t\tfloat E_max = 44.;\n\t\tfor( int i = 0, n = 30; i < n; ++i )\n\t\t{\n\t\t\tfloat E = ( E_min + E_max ) / 2.;\n\t\t\tfloat M_test = e * sinh( E ) - E;\n\t\t\tif( M_test < M )\n\t\t\t\tE_min = E;\n\t\t\telse\n\t\t\t\tE_max = E;\n\t\t}\n\t\treturn ( E_min + E_max ) / 2.;\n\t}\n}\n\nfloat cvt_E2nu( float E, float e )\n{\n\treturn e < 1. ?\n        2. * atan( sqrt( 1. + e ) * sin( E / 2. ), sqrt( 1. - e ) * cos( E / 2. ) ) :\n        2. * atan( sqrt( e + 1. ) * sinh( E / 2. ), sqrt( e - 1. ) * cosh( E / 2. ) );\n}\n\nvec4 cvt_nu2E_d( vec4 nu, float e )\n{\n\treturn e < 1. ?\n        2. * atan2_d( sqrt( 1. - e ) * sin_d( nu / 2. ), sqrt( 1. + e ) * cos_d( nu / 2. ) ) :\n        2. * atanh_d( sqrt( ( e - 1. ) / ( e + 1. ) ) * tan_d( nu / 2. ) );\n}\n\nvec4 cvt_E2M_d( vec4 E, float e )\n\t{ return e < 1. ? E - e * sin_d(E) : e * sinh_d(E) - E; }\n\nfloat cvt_nu2E( float nu, float e )\n\t{ return cvt_nu2E_d( const_d( nu ), e ).w; }\n\nfloat cvt_E2M( float E, float e )\n\t{ return cvt_E2M_d( const_d(E), e ).w; }\n\n// ----------------------------------------------------------------------------\n// ATMOSPHERE PROFILE\n// ----------------------------------------------------------------------------\n\nstruct AtmProfile\n{\n    vec4 ref;\t\t\t\t// properties at reference altitude (temperature, pressure, density, scale height)\n    vec3 exo;\t\t\t\t// exospheric temperature profile (exobase, T_infinity, scale height)\n    float ssref;\t\t\t// speed of sound at reference altitude\n    mat4x2 pointsA;\t\t\t// temperature profile points 1..4\n    mat4x2 pointsB;\t\t\t// temperature profile points 5..8\n    vec3 lvar;\t\t\t\t// params for latitudinal variation\n    mat2x3 svar;\t\t\t// params for seasonal variation\n\tvec2 dvar;\t\t\t\t// params for diurnal variation\n};\n\nvec4 ap_eval_profile( AtmProfile self, float r, float r0, vec2 lphase, vec2 sphase, vec2 dphase )\n{\n    // get latitudinal, seasonal and diurnal variations\n    vec3 lvar = self.lvar + self.svar * sphase;\n    float dT_l = dot( lvar.xy, lphase ) + lvar.z;\n    float dT_d = dot( normalize( lvar.xy ), lphase ) * dot( self.dvar.xy, dphase );\n\n    // initial values\n    float T0 = self.ref.x;\n    float h = 0.;\n    float z = 0.;\n    float T = T0 + dT_l + dT_d;\n\tfloat profilescale = T / T0;\n\n    // get the geopotential height H from radius r and reference radius r0\n    float H = r >= r0 ?\n        ( r - r0 ) * r0 / r :\n    \t( r - r0 ) * ( r + r0 ) / ( 2. * r0 );\n\n    // climb the piecewise linear temperature profile until H\n    // (allow for negative H in the first iteration)\n    for( int i = 0; i < 8 && H != h; ++i )\n    {\n        vec2 point = i < 4 ? self.pointsA[i] : self.pointsB[i-4];\n        float h1 = point.x * profilescale;\n        float T1 = point.y * profilescale;\n        if( T1 == 0. || h1 == h )\n            break;\n        float hnext = min( H, h1 );\n        if( T1 != T )\n        {\n\t        float lapse = ( T1 - T ) / ( h1 - h );\n            float deltaT = lapse * ( hnext - h );\n            z += log1p( deltaT / T ) * T0 / lapse;\n            T = h1 != hnext ? T + deltaT : T1;\n        }\n        else\n            z += ( hnext - h ) * T0 / T;\n        h = hnext;\n    }\n\n\t// assume constant temperature above profile\n    float exobase = self.exo.x;\n\tz += max( 0., min( exobase > 0. ? exobase : H, H ) - h ) * T0 / T;\n\n    // apply Bates-Walker formula for exospheric altitudes\n    float exotemp = self.exo.y;\n    float exoscale = self.exo.z;\n    if( exotemp > 0. && exoscale > 0. )\n    {\n        float a = max( 0., H - exobase ) / exoscale;\n        float b = exoscale * T0 / exotemp;\n        if( a < 17. )\n            z += log1p( expm1( a ) * exotemp / T ) * b;\n        else\n            z += ( a + log( exotemp / T ) ) * b;\n        T = mix( T, exotemp, -expm1( -a ) );\n    }\n\n    // final result\n    float P = self.ref.y * exp( -z / self.ref.w );\n    float rho = self.ref.z * self.ref.x * P / ( self.ref.y * T );\n    return vec4( T, P, rho, H );\n}\n\n// ----------------------------------------------------------------------------\n// PLANET DATA\n// ----------------------------------------------------------------------------\n\nstruct PlanetData\n{\n    float parent;\t\t\t// parent index\n    float radius;\t\t\t// planet radius (datum)\n    float GM;\t\t\t\t// standard gravitational parameter\n    float orb_period;\t\t// orbital period (hours)\n    Kepler orbit;\t\t\t// orbital elements\n\tfloat rot_period;\t\t// rotation period (hours)\n    vec2 rot_northpole;\t\t// lat/long of north pole in ecliptic coordinates\n\n    vec3 trn_seeds;\t\t\t// seed offsets x, y, z\n    vec3 trn_levels;\t\t// min level, max level, ocean level\n    vec3 trn_offcenter;\t\t// optional center displacement\n    vec3 trn_noise;\t\t\t// noise amplitude, log-normal-distribution: mu, sigma\n    vec3 trn_flatten;\t\t// flatten modifier: base level, range, reduction amount\n    vec3 trn_slope;\t\t\t// slope modifiers: slope scale, divergence, slip\n\n    float ocn_T;\t\t\t// ocean temperature\n    float ocn_dens;\t\t\t// ocean density\n    vec4 ocn_beta50;\t\t// ocean absorbtion coefficients (exp2 based)\n    vec4 ocn_omega;\t\t\t// ocean optical albedo\n    float ocn_s2;\t\t\t// ocean optical roughness (slope variance)\n\n    AtmProfile atm_profile;\t// physical atmosphere profile\n\n    float atm_scale;\t\t// effective optical scale height\n    float atm_g;\t\t\t// effective overall asymmetry parameter\n    vec4 atm_tau;\t\t\t// total optical depth\n    vec4 atm_tau_s;\t\t\t// scattering-only optical depth\n    vec4 atm_glayer_tau;\t// ground layer: optical depth,\n    vec4 atm_glayer_tau_s;\t// ground layer: scattering-only optical depth,\n    vec4 atm_alayer_tau;\t// absorbtion layer: optical depth\n    vec2 atm_alayer_shape;\t// absorbtion layer: mu, sigma of altitude profile\n    vec4 atm_elayer_emiss;\t// emission layer: column emission\n    vec2 atm_elayer_shape;\t// emission layer: mu, sigma of altitude profile\n    float atm_glayer_scale;\t// ground layer: scale height multiplier\n};\n\n/*\n        \t\t\t\t\t\t\t615\t\t535\t\t445\t\t1250\n\n    Rayleigh optical depth [1]\t\t0.0573\t0.1001\t0.1971\t0.0034\n    Aerosol optical depth [2]\t\t0.0422  0.0520  0.0681\t0.0146\n    Ozone absorbtion [3]\t\t\t0.0346  0.0215  0.0019  0.0000029\n    Water vapor absorption [4]\t\t0.0157  0.0051  0.0003\t0.0372\n\n    [1] Fr\u00f6hlich & Shaw 1985 (with Young's correction)\n    [2] AOD 0.05, centered at 550 nm, with \u00c5ngstr\u00f6m exponent 1.5 (global average more like 1.0)\n    [3] Optical depth of 300 Dobson units ozone (about 0.35 ppm)\n    [4] Optical depth of 2.5 cm precipitable water vapor (= global average, land 2.0, oceans 2.7)\n\n*/\n\nconst float ATM_AMTL_CORRECTION = 2.8;\n\nconst vec4 ATM_TAU_RAYLEIGH = \t\t\t    \tvec4( 0.0573, 0.1001, 0.1971, 0.0034 );\nconst vec4 ATM_TAU_AEROSOL = \t  0.08 / 0.05 * vec4( 0.0422, 0.0520, 0.0681, 0.0097 );\nconst vec4 ATM_TAU_OZONE = \t      300. / 300. * vec4( 0.0346, 0.0215, 0.0019, 2.9e-6 );\nconst vec4 ATM_TAU_VAPOR = \t\t   2.0 /  2.5 *\tvec4( 0.0183, 0.0079, 0.0003, 0.0372 );\n\nconst vec4 ATM_OMEGA_AEROSOL = vec4( .93, .94, .95, .8 );\n\nconst PlanetData[] g_planet_data = PlanetData[](\n\n    // Solna\n    PlanetData(\n        0.,\n        7652.87474 * ATM_SCALE,\n        19906544.5 * SCN_SCALE,\n        0.,\n        KEPLERA( 0., 0., 0., 0., 0. ),\n        0.,\n        vec2(0),\n        ZERO, ZERO, ZERO, ZERO, ZERO, ZERO,\n        0., 0., vec4(0), vec4(0), 0.,\n        AtmProfile( vec4(0), ZERO, 0., mat4x2(0), mat4x2(0), ZERO, mat2x3( ZERO, ZERO ), vec2(0) ),\n        0., 0., vec4(0), vec4(0), vec4(0), vec4(0), vec4(0), vec2(0), vec4(0), vec2(0), 0.\n\t),\n\n    // Miderra\n    PlanetData(\n        0.,\n\t\t286.245634 * SCN_SCALE,\n        2712.27786 * SCN_SCALE,\n        73.5878199 * SCN_SCALE,\n        KEPLERA( 328310.172 * SCN_SCALE, 0.011793800, 0., radians( 114.2 ), radians( 348.7 ) ),\n        1.18074553 * SCN_SCALE,\n\t    vec2( radians( 66.5608 ), radians( 90.0000 ) ),\n\n        // terrain data\n\n   \t\tvec3( 0.00, -1.05, -8.05 ),\t\t\t// seed\n   \t\tvec3( -0.010, 0.0115, 0.00090 ),\t// levels\n   \t\tvec3( 0.00020, 0.00010, 0.00011 ), \t// offcenter\n   \t\tvec3( 2.40, 8.90, 5.6 ),           \t// noise\n   \t\tvec3( 0.00070, 0.0072, 0.96 ),     \t// flatten\n        vec3( TRN_SCALE / SCN_SCALE, -1.25, 2.50 ),\t\t\t\t\t\t\t\t\t\t\t// slope effects\n\n        // ocean data\n        277.16,\n        1025.,\n        vec4( .1760, .0567, .0355, 25 ),\n        vec4( .0125, .0336, .0659, 0 ), \t// old: vec3( 0.0155, 0.0510, 0.1136 ),\n\t\t0.1628,\t\t\t\t\t\t\t\t// ocean roughness at avg wind speed 7.5 m/s\n\n        // atmosphere data\n     \tAtmProfile(\n            vec4( 288.15, 1.01325, 1.225, 2.5226 * ATM_SCALE ),\n            vec3( 30.882 * ATM_SCALE, 1000., 17.043 * ATM_SCALE ),\n            .340293991,\n\t\t\tmat4x2( vec2( 3.2899 * ATM_SCALE, 216.65 ), vec2( 5.9816 * ATM_SCALE, 216.65 ),\n                    vec2( 9.5705 * ATM_SCALE, 228.65 ), vec2( 14.057 * ATM_SCALE, 270.65 ) ),\n            mat4x2( vec2( 15.253 * ATM_SCALE, 270.65 ), vec2( 21.235 * ATM_SCALE, 214.65 ),\n                    vec2( 25.378 * ATM_SCALE, 186.87 ), vec2(0) ),\n        \tvec3( 43.118, 0.0761, -32.6285 ),\n            mat2x3( vec3( 3.8533, -4.7020, -3.9716 ), vec3( -4.9857, 4.9801, 5.1333 ) ),\n            vec2( 6, 12 )\n        ),\n\t\t2.2589 * ATM_SCALE,\n        0.5,\n        ATM_TAU_RAYLEIGH + ATM_TAU_AEROSOL + ATM_TAU_OZONE + ATM_TAU_VAPOR,\t\t// total optical depth\n        ATM_TAU_RAYLEIGH + ATM_TAU_AEROSOL * ATM_OMEGA_AEROSOL,\t\t\t\t\t// scattering optical depth\n        ATM_TAU_AEROSOL + ATM_TAU_VAPOR,\t\t\t\t\t\t\t\t\t\t// ground layer optical depth\n        ATM_TAU_AEROSOL * ATM_OMEGA_AEROSOL,\t\t\t\t\t\t\t\t\t// ground layer scattering optical depth\n       \tATM_TAU_OZONE * 0.95,\t\t\t\t\t\t\t\t\t\t\t\t\t// ozone layer\n\t\tvec2( 6.7293, 1.9231 ) * ATM_SCALE,\t\t\t\t\t\t\t\t\t\t// (altitude profile)\n        COL_AIRGLOW,\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// emission layer\n        vec2( 25.542, 1.3459 ) * ATM_SCALE,\t\t\t\t\t\t\t\t\t\t// (altitude profile)\n        4.\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// ground layer scale height multiplier\n\t),\n\n    // Muni\n    PlanetData(\n        1.,\n        115.272442 * SCN_SCALE,\n        124.852417 * SCN_SCALE,\n        12.0017805 * SCN_SCALE,\n        KEPLERA( 5043.01510 * SCN_SCALE, 0.039031473, radians( 5.1 ), radians( 125.1 ), radians( 318.2 ) ),\n        12.0017805 * SCN_SCALE,\n        vec2( radians( -95.3701 ), radians( 89.9783 ) ),\n\n        // terrain data\n        vec3( -0.00, -1.05, -8.05 ),\t\t// seed\n        vec3( -0.023, 0.020, 0.0006 ),\t\t// levels\n        ZERO,\n        vec3( 1.70, 6, 4.5 ),\t\t\t\t// noise\n        vec3( 0.0003, 0.010, 0.95 ),\t\t// flatten\n        vec3( 1.0, -1.0, 2.0 ),\t\t\t\t// slope\n\n        // ocean data\n        0., 0., vec4(0), vec4(0), 0.,\n\n        // atmosphere data\n        AtmProfile( vec4(0), ZERO, 0., mat4x2(0), mat4x2(0), ZERO, mat2x3( ZERO, ZERO ), vec2(0) ),\n        0., 0., vec4(0), vec4(0), vec4(0), vec4(0), vec4(0), vec2(0), vec4(0), vec2(0), 0.\n\t)\n);\n\nconst int NUM_PLANETS = g_planet_data.length();\n\n// ----------------------------------------------------------------------------\n// PLANET STATE\n// ----------------------------------------------------------------------------\n\nstruct PlanetState\n{\n    // global coordinates\n    vec3 r;\t\t\t\t// position\n    vec3 v;\t\t\t\t// velocity\n    float omega;\t\t// angular velocity\n\tmat3 B;\t\t\t\t// body frame\n\n    // local coordinates\n    vec3 orbitr;\n    vec3 orbitv;\n\n    // orbital parameters\n    float M;\t\t\t// mean anomaly\n    float E;\t\t\t// eccentric anomaly\n\tfloat nu;\t\t\t// true anomaly\n    float dnudt90;\t\t// motion of true anomaly at latus rectum\n};\n\nconst int ADDR_PLANET_SIZE = 7;\n\nPlanetState ps_load( sampler2D ch, ivec2 addr )\n{\n    return PlanetState(\n \t\tmemload( ch, addr, 0 ).xyz,\n        memload( ch, addr, 1 ).xyz,\n \t\tmemload( ch, addr, 2 ).x,\n        memload_mat3( ch, addr, 3 ),\n \t\tmemload_mat3extra( ch, addr, 0 ),\n        memload_mat3extra( ch, addr, 3 ),\n \t\tmemload( ch, addr, 6 ).x,\n        memload( ch, addr, 6 ).y,\n \t\tmemload( ch, addr, 6 ).z,\n        memload( ch, addr, 6 ).w );\n\n}\n\nvoid ps_store( PlanetState self, ivec2 addr, ivec2 sc, inout vec4 fc )\n{\n    memstore( self.r, self.orbitr.x, addr, 0, sc, fc );\n    memstore( self.v, self.orbitr.y, addr, 1, sc, fc );\n    memstore( vec3( self.omega, 0, 0 ), self.orbitr.z, addr, 2, sc, fc );\n    memstore( self.B, self.orbitv, addr, 3, sc, fc );\n    memstore( vec4( self.M, self.E, self.nu, self.dnudt90 ), addr, 6, sc, fc );\n}\n\n// ----------------------------------------------------------------------------\n// VEHICLE DATA\n// ----------------------------------------------------------------------------\n\nstruct VehicleData\n{\n    vec4 Sbcm;\t                // area (S), span (b), chord (c) and mass (m)\n    vec4 I;                     // moments of inertia (Ixx, Iyy, Izz, Ixz)\n\n    // stability coefficients\n    vec4 CD;                    // drag: CD0, CDa2, CDb2, CDi\n    vec4 CL;                    // lift: CL0, CLa, CLq, CLde\n    vec4 Cm;                    // pitch: Cm0, Cma, Cmq, Cmde\n    vec4 CY;                    // side: CYb, CYp, CYr, CYdr\n    vec4 Cn;                    // yaw: Cnb, Cnp, Cnr, Cndr\n    vec4 Cl;                    // roll: Clb, Clp, Clr, Clda\n    vec2 Cadot;\t\t\t\t\t// CLadot, Cmadot\n\n    // extra stuff\n    float kD;                   // fraction of Clb attributed to dihedral (0..1)\n    float Clab;                 // roll generated with the product of alpha and beta, simulates effect of wing sweep\n    float Cmi;\t\t\t\t\t// pitching moment from induced drag\n    vec2 Cm90;\t\t\t\t\t// pitching moment at 90 deg alpha: Cm90, Cmq90\n    vec2 Cnside;\t\t\t\t// yawing moment at 90 deg beta: Cnside, Cnrside\n\tvec3 mach;\t\t\t\t\t// mach effects: MDD, d-CD mach 1, d-CD mach infinity\n\n    // configuration changes\n    mat3 dC_matrix;    \t        // [0] = flaps, [1] = spoilers, [2] = gears; x = d-CD, y = d-CL, z = d-Cm\n    float dClb_g;\t\t\t\t// extra Clb when gears down\n\n    // parameters for stall curve\n    vec4 etaCL;\t\t\t\t\t// xy = input range (sin_a) zw = output range (eta)\n\n    // other\n    vec3 dx_max;                // max control excursion, in radians (de, da, dr)\n    float T_max;                // maximum thrust\n};\n\n// ----------------------------------------------------------------------------\n// VEHICLE STATE\n// ----------------------------------------------------------------------------\n\nstruct VehicleState\n{\n    // global coordinates\n    vec3 r;             // position\n    vec3 v;             // velocity\n    vec3 omega;         // angular velocity vector\n\tmat3 B;             // body frame\n\n    // local orbit coordinates, non-rotating frame\n    vec3 orbitr;\n    vec3 orbitv;\n\n    // local surface coordinates, rotating frame\n    vec3 localr;\n    vec3 localv;\n    vec3 localomega;\n    mat3 localB;\n\n    // high precision accumulator for localr\n    vec3 localr_base;\n    vec3 localr_diff;\n\n    // time-lagged vertical acceleration for flight dynamics\n    vec3 acc;\n    float wdelay;\n\n    // vehicle configuration state\n    vec3 FSG;  \t\t   \t// flaps/spoilers/gears\n    float throttle;\n    vec3 EAR;\t\t    // elevator/aileron/rudder\n    float trim;\n    vec3 EAR_hold;    \t// hold timers for EAR\n    float thr_hold;\t\t// throttle hold timer\n    ivec3 modes;\t\t// hud/.../engine\n\tuint switches;\t\t// bitfield\n    ivec3 modes2;\t\t// aero/rcs/throttle\n    float tvec;\t\t\t// thrust vector\n\n    // read only\n    vec4 info;\t\t\t// CL, CD, alpha, contact\n\n    // autopilot\n    vec3 accz;\t\t\t// filtered versions of vertical acceleration\n    vec4 aerostuff;\t\t// state variables for aero control modes\n    vec3 rcsstuff;\t\t// state variables for rcs control modes\n};\n\nconst int ADDR_VEHICLE_SIZE = 19;\n\nconst int VS_MAX_ITER = 100;\nconst float VS_MAX_PACE_LOCAL = 0.25;\nconst float VS_MAX_PACE = 1.66666667;\n\nconst uint VS_FLAPS_MASK = 3u;\nconst uint VS_FLAPS_SHIFT = 0u;\nconst uint VS_SPOIL = 4u;\nconst uint VS_GEARS = 8u;\nconst uint VS_LIGHT = 16u;\nconst uint VS_THROTTLE_EDGE = 32u;\nconst uint VS_TVEC_MASK = 448u;\nconst uint VS_TVEC_SHIFT = 6u;\n\nconst int VS_ENG_OFF = 0;\nconst int VS_ENG_DRV = 1;\nconst int VS_ENG_IMP = 2;\nconst int VS_ENG_NOVA = 3;\n\nconst int VS_HMD_OFF = 0;\nconst int VS_HMD_SFCE = 1;\nconst int VS_HMD_ORB = 2;\n\nconst int VS_AERO_OFF = 0;\nconst int VS_AERO_MAN = 1;\nconst int VS_AERO_ATR = 2;\n\nconst int VS_RCS_OFF = 0;\nconst int VS_RCS_MAN = 1;\nconst int VS_RCS_RATE = 2;\nconst int VS_RCS_LVLH = 3;\n\nconst int VS_THR_OFF = 0;\nconst int VS_THR_MAN = 1;\n\nVehicleState vs_init()\n{\n    return VehicleState( ZERO, ZERO, ZERO, IDENTITY, ZERO, ZERO,\n\t\t\t\t\t\t ZERO, ZERO, ZERO, IDENTITY, ZERO, ZERO,\n             \t\t\t ZERO, 0., ZERO, 0., ZERO, 0.,\n             \t\t\t ZERO, 0., ivec3(0), 0u, ivec3(0), 0.,\n                         vec4(0),\n                       \t ZERO, vec4(0), ZERO );\n}\n\nVehicleState vs_load( sampler2D ch, ivec2 addr )\n{\n    return VehicleState(\n    \tmemload( ch, addr, 0 ).xyz,\n        memload( ch, addr, 1 ).xyz,\n    \tmemload( ch, addr, 2 ).xyz,\n        memload_mat3( ch, addr, 3 ),\n    \tmemload_mat3extra( ch, addr, 0 ),\n        memload_mat3extra( ch, addr, 3 ),\n\t\tmemload( ch, addr, 6 ).xyz,\n        memload( ch, addr, 7 ).xyz,\n    \tmemload( ch, addr, 8 ).xyz,\n        memload_mat3( ch, addr, 9 ),\n    \tmemload_mat3extra( ch, addr, 6 ),\n        memload_mat3extra( ch, addr, 9 ),\n    \tmemload( ch, addr, 12 ).xyz,\n        memload( ch, addr, 12 ).w,\n\t\tmemload( ch, addr, 13 ).xyz,\n        memload( ch, addr, 13 ).w,\n   \t\tmemload( ch, addr, 14 ).xyz,\n        memload( ch, addr, 14 ).w,\n    \tmemload( ch, addr, 15 ).xyz,\n        memload( ch, addr, 15 ).w,\n        ivec3( memload( ch, addr, 16 ).xyz ),\n        uint( memload( ch, addr, 16 ).w ),\n    \tivec3( memload( ch, addr, 17 ).xyz ),\n    \tmemload( ch, addr, 17 ).w,\n        memload( ch, addr, 18 ),\n    \tmemload( ch, addr, 19 ).xyz,\n    \tmemload( ch, addr, 20 ),\n    \tmemload( ch, addr, 21 ).xyz );\n}\n\nvoid vs_store( VehicleState self, ivec2 addr, ivec2 sc, inout vec4 fc )\n{\n    memstore( self.r, self.orbitr.x, addr, 0, sc, fc );\n    memstore( self.v, self.orbitr.y, addr, 1, sc, fc );\n    memstore( self.omega, self.orbitr.z, addr, 2, sc, fc );\n    memstore( self.B, self.orbitv, addr, 3, sc, fc );\n    memstore( self.localr, self.localr_base.x, addr, 6, sc, fc );\n    memstore( self.localv, self.localr_base.y, addr, 7, sc, fc );\n    memstore( self.localomega, self.localr_base.z, addr, 8, sc, fc );\n    memstore( self.localB, self.localr_diff, addr, 9, sc, fc );\n    memstore( self.acc, self.wdelay, addr, 12, sc, fc );\n    memstore( self.FSG, self.throttle, addr, 13, sc, fc );\n    memstore( self.EAR, self.trim, addr, 14, sc, fc );\n\tmemstore( self.EAR_hold, self.thr_hold, addr, 15, sc, fc );\n    memstore( vec3( self.modes ), float( self.switches ), addr, 16, sc, fc );\n    memstore( vec3( self.modes2 ), self.tvec, addr, 17, sc, fc );\n    memstore( self.info, addr, 18, sc, fc );\n    memstore( self.accz, 0., addr, 19, sc, fc );\n    memstore( self.aerostuff, addr, 20, sc, fc );\n    memstore( self.rcsstuff, 0., addr, 21, sc, fc );\n}\n\n// ----------------------------------------------------------------------------\n// MENU DATA\n// ----------------------------------------------------------------------------\n\n#define g_menu_data_length g_menu_data.length()\n\nuvec4 md_load( sampler2D ch, int index )\n\t{ return unpack_uvec4( memload( ch, ADDR_MENU_DATA + ivec2( index, 0 ), 0 ) ); }\n\nconst int MENU_COMMAND = 1;\nconst int MENU_MAP = 2;\nconst int MENU_QUIT = 7;\nconst int MENU_INFO_BEGIN = 0x10;\nconst int MENU_INFO_SIZE = 8;\n\n// ----------------------------------------------------------------------------\n// MESSAGE QUEUE\n// ----------------------------------------------------------------------------\n\nstruct MsgQueue\n{\n    vec4 state;\n    uvec4 phrase;\n    vec4 argv;\n};\n\nconst int ADDR_MESSAGES_SIZE = 13;\n\nbool msg_empty( MsgQueue msg )\n\t{ return msg.state.x == -1.; }\n\nMsgQueue msg_load_and_pace( sampler2D ch, ivec2 addr, int index, float dt )\n{\n    MsgQueue msg;\n    msg.state = memload( ch, addr, 0 );\n\n    if( !msg_empty( msg ) )\n    {\n        if( msg.state.y > 0. )\n        {\n            dt -= msg.state.y;\n            msg.state.y = max( 0., -dt );\n        }\n\n        if( msg.state.y == 0. )\n        {\n            float p = ceil( msg.state.x ) - 1.;\n            float q = msg.state.x - dt;\n\n            if( q < p )\n            {\n                msg.state.x = p;\n                uint nextphraselen = unpack_uvec4( memload( ch, addr, 2 ) ).w & TXT_FMT_LENGTH_MASK;\n                if( p >= 0. && nextphraselen > 0u )\n                    msg.state.y = 1.5 + float( nextphraselen ) / 8. + q - p;\n                index++;\n            }\n            else\n                msg.state.x = max( -1., floor(q) ) + fract(q);\n        }\n    }\n\n    if( index < 0 || index >= TXT_MSG_MAX_PHRASES )\n    {\n        msg.phrase = uvec4(0);\n        msg.argv = vec4(0);\n    }\n    else\n    {\n    \tmsg.phrase = unpack_uvec4( memload( ch, addr, index + 1 ) );\n    \tmsg.argv = memload( ch, addr, index + 1 + TXT_MSG_MAX_PHRASES );\n    }\n\n    return msg;\n}\n\n// ----------------------------------------------------------------------------\n// GAME STATE\n// ----------------------------------------------------------------------------\n\nstruct GameState\n{\n\tvec3 campos;\n    float camzoom;\n    mat3 camframe;\n    vec3 mouselook;\n    vec3 datetime;\n\tuint switches;\t\t// bitfield\n    ivec3 menustate;\t// current page, selection trigger, last selection persist\n    int stage;\n    vec3 mapmarker;\n    float timer;\n    vec2 dragstate;\n    vec3 waypoint;\n    float hudbright;\n\tvec2 exposure;\n    vec3 campos_diff;\n    vec3 vjoy;          // virtual joystick from keyboard input\n    vec3 vjoy_hold;     // latch timers\n};\n\nconst int ADDR_GAMESTATE_SIZE = 11;\n\nconst uint GS_IRCAM = 1u;\nconst uint GS_TRDAR = 2u;\nconst uint GS_NVISN = 4u;\nconst uint GS_TRMAP = 8u;\nconst uint GS_PAUSE = 16u;\nconst uint GS_FREEZ = 32u;\nconst uint GS_CHEES = 64u;\nconst uint GS_IPAGE_MASK = 0xf00u;\nconst uint GS_IPAGE_SHIFT = 8u;\nconst uint GS_MMODE_MASK = 0x3000u;\nconst uint GS_MMODE_SHIFT = 12u;\nconst uint GS_MPROJ_MASK = 0xc000u;\nconst uint GS_MPROJ_SHIFT = 14u;\nconst uint GS_HMD_BRIGHT_MASK = 0x30000u;\nconst uint GS_HMD_BRIGHT_SHIFT = 16u;\n\nconst int GS_INFO_LOCATION = 1;\nconst int GS_INFO_WAYPOINT = 2;\nconst int GS_INFO_ORBIT = 3;\nconst int GS_INFO_GLIDE = 4;\nconst int GS_INFO_CONTROLS = 5;\nconst int GS_INFO_AIR = 6;\nconst int GS_INFO_TIME = 7;\n\nconst int GS_MAP_PHYSICAL = 0;\nconst int GS_MAP_ELEVATION = 1;\nconst int GS_MAP_SLOPE = 2;\nconst int GS_MAP_EQ_AREA = 0;\nconst int GS_MAP_EQ_ANGLE = 1;\n\nconst int GS_INIT = 0;\nconst int GS_SPLASH = 1;\nconst int GS_SELECT_LOCATION = 2;\nconst int GS_TRANSITION = 3;\nconst int GS_RUNNING = 4;\n\nGameState gs_init()\n{\n    return GameState( ZERO, 1., IDENTITY, UNIT_X, ZERO, 0x30000u, ivec3(0),\n                      GS_INIT, UNIT_X, 0., vec2(0), vec3(0), 1., vec2(1), ZERO,\n                      ZERO, ZERO );\n}\n\nGameState gs_load( sampler2D ch, ivec2 addr )\n{\n    return GameState(\n\t\tmemload( ch, addr, 0 ).xyz,\n        memload( ch, addr, 0 ).w,\n    \tmemload_mat3( ch, addr, 1 ),\n        memload_mat3extra( ch, addr, 1 ),\n    \tmemload( ch, addr, 4 ).xyz,\n        uint( memload( ch, addr, 4 ).w ),\n    \tivec3( memload( ch, addr, 5 ).xyz ),\n        int( memload( ch, addr, 5 ).w ),\n   \t\tmemload( ch, addr, 6 ).xyz,\n        memload( ch, addr, 6 ).w,\n        memload( ch, addr, 7 ).zw,\n    \tmemload( ch, addr, 8 ).xyz,\n        memload( ch, addr, 8 ).w,\n    \tmemload( ch, addr, 9 ).xy,\n\t\tvec3( memload( ch, addr, 7 ).xy, memload( ch, addr, 9 ).z ),\n        memload( ch, addr, 10 ).xyz,\n        memload( ch, addr, 11 ).xyz );\n}\n\nvoid gs_store( GameState self, ivec2 addr, ivec2 sc, inout vec4 fc )\n{\n\tmemstore( self.campos, self.camzoom, addr, 0, sc, fc );\n\tmemstore( self.camframe, self.mouselook, addr, 1, sc, fc );\n\tmemstore( self.datetime, float( self.switches ), addr, 4, sc, fc );\n\tmemstore( vec3( self.menustate ), float( self.stage ), addr, 5, sc, fc );\n\tmemstore( self.mapmarker, self.timer, addr, 6, sc, fc );\n\tmemstore( vec4( self.campos_diff.xy, self.dragstate ), addr, 7, sc, fc );\n    memstore( self.waypoint, self.hudbright, addr, 8, sc, fc );\n    memstore( vec4( self.exposure.xy, self.campos_diff.zz ), addr, 9, sc, fc );\n    memstore( self.vjoy, 0., addr, 10, sc, fc );\n    memstore( self.vjoy_hold, 0., addr, 11, sc, fc );\n}\n\nvec2 gs_map_project( GameState gs, vec3 r )\n{\n    r = normalize(r) * gs.camframe;\n\tif( int( gs.switches & GS_MPROJ_MASK ) >> GS_MPROJ_SHIFT == GS_MAP_EQ_ANGLE )\n\t\tr.z = log( tan( atan( r.z, length( r.xy ) ) / 2. + PI / 4. ) );\n    vec2 coord = vec2( atan( -r.y, -r.x ) , r.z );\n    return gs.camzoom * coord;\n}\n\nvec4 gs_map_unproject_d( GameState gs, vec2 sc, vec2 res, inout vec3 ddx, inout vec3 ddy )\n{    \n    vec4 coord_x = vec4( 2, 0, 0, 2. * sc.x - res.x ) / ( gs.camzoom * res.y );\n    vec4 coord_y = vec4( 0, 2, 0, 2. * sc.y - res.y ) / ( gs.camzoom * res.y );\t\n    vec4 c = coord_y;\t\n    if( int( gs.switches & GS_MPROJ_MASK ) >> GS_MPROJ_SHIFT == GS_MAP_EQ_ANGLE )\n\t\tc = sin_d( 2. * atan_d( exp_d( coord_y ) ) - const_d( PIHALF ) );\n\t\n    vec4 s = sqrt_d( max_d( const_d( 0. ), const_d( 1. ) - square_d( c ) ) );  \n    vec4 x = -mul_d( cos_d( coord_x ), s );\n    vec4 y = -mul_d( sin_d( coord_x ), s );\n    vec4 z = clamp_d( c, -ONE_D, ONE_D );\n\n    ddx = gs.camframe * vec3( x.x, y.x, z.x );\n    ddy = gs.camframe * vec3( x.y, y.y, z.y );\n    return vec4( gs.camframe * vec3( x.w, y.w, z.w ), c.w );\n}\n\nvec4 gs_map_unproject( GameState gs, vec2 sc, vec2 res )\n\t{ vec3 _; return gs_map_unproject_d( gs, sc, res, _, _ ); }\n\n// ----------------------------------------------------------------------------\n// ACHIEVEMENT DETECTOR\n// ----------------------------------------------------------------------------\n\nstruct AchievementDetector\n{\n   // landing tracker\n   vec3 unused;\n   int LT_state;\n   vec3 LT_localv;\n   float LT_timer;\n};\n\nconst int ADDR_ACHIEVEMENTS_SIZE = 2;\n\nconst int AD_LT_INIT = 0;\nconst int AD_LT_LANDED = 1;\nconst int AD_LT_AIRBORNE = 2;\nconst int AD_LT_TOUCHDOWN = 3;\nconst int AD_LT_BELLYDOWN = 4;\nconst int AD_LT_CRASH = 5;\n\nAchievementDetector ad_init()\n\t{ return AchievementDetector( ZERO, AD_LT_INIT, ZERO, 0. ); }\n\nAchievementDetector ad_load( sampler2D ch, ivec2 addr )\n{\n    return AchievementDetector(\n\t\tZERO,\n        int( memload( ch, addr, 0 ).w ),\n    \tmemload( ch, addr, 1 ).xyz,\n        memload( ch, addr, 1 ).w );\n}\n\nvoid ad_store( AchievementDetector self, ivec2 addr, ivec2 sc, inout vec4 fc )\n{\n    memstore( ZERO, float( self.LT_state ), addr, 0, sc, fc );\n    memstore( self.LT_localv, self.LT_timer, addr, 1, sc, fc );\n}\n\n// ----------------------------------------------------------------------------\n// LOCAL ENVIRONMENT\n// ----------------------------------------------------------------------------\n\nstruct LocalEnvironment\n{\n    vec4 atm;\t\t\t// local atmosphere state (T, P, rho, a)\n    vec3 L;\t\t\t\t// local sunlight direction\n    float H;\t\t\t// local geopotential altitude\n    vec3 sunlight;\t\t// local sunlight (F over PI)\n    float radius;\t\t// radius of local planet (if applicable)\n    vec2 phases;\t\t// local seasonal and diurnal phases\n    vec2 atm2;\t\t\t// local atmospheric viscosity and molecular mean free path\n    vec3 starlight;\n};\n\nconst int ADDR_LOCALENV_SIZE = 5;\n\nLocalEnvironment env_init()\n{\n    return LocalEnvironment( vec4(0), ZERO, 0., ZERO, 0., vec2(0), vec2(0), ZERO );\n}\n\nLocalEnvironment env_load( sampler2D ch, ivec2 addr )\n{\n    return LocalEnvironment(\n\t\tmemload( ch, addr, 0 ),\n\t    memload( ch, addr, 1 ).xyz, memload( ch, addr, 1 ).w,\n        memload( ch, addr, 2 ).xyz, memload( ch, addr, 2 ).w,\n        memload( ch, addr, 3 ).xy, memload( ch, addr, 3 ).zw,\n    \tmemload( ch, addr, 4 ).xyz );\n}\n\nvoid env_store( LocalEnvironment self, ivec2 addr, ivec2 sc, inout vec4 fc )\n{\n    memstore( self.atm, addr, 0, sc, fc );\n    memstore( self.L, self.H, addr, 1, sc, fc );\n    memstore( self.sunlight, self.radius, addr, 2, sc, fc );\n    memstore( self.phases, self.atm2, addr, 3, sc, fc );\n    memstore( self.starlight, 0., addr, 4, sc, fc );\n}\n\nfloat mu_stretch( float mu, float stretch )\n{\n    // overstretched version of max( 0., ... ) for lighting cosines\n    float x = mu / stretch;\n    return x >= 24. ? mu : log2( 1. + exp2(x) ) * stretch;\n}\n\n// ----------------------------------------------------------------------------\n// TERRAIN SAMPLER\n// ----------------------------------------------------------------------------\n\nstruct TrnSampler\n{\n    vec3 r_hat;\t\t\t// normalized pivot position\n\tfloat r0;\t\t\t// hypocenter\n    mat2x3 TB;\t\t\t// tangent frame\n    float e_over_b;\t\t// distance to horizon over distance to hypocenter and cosine cone angle\n    float invm;\t\t\t// inverse mapping scale\n};\n\nconst int ADDR_TSAMPLER_SIZE = 3;\n\nTrnSampler ts_init()\n\t{ return TrnSampler( ZERO, 0., mat2x3(0), 0., 0. ); }\n\nTrnSampler ts_load( sampler2D ch, ivec2 addr )\n{\n    return TrnSampler(\n\t    memload( ch, addr, 0 ).xyz,\n        memload( ch, addr, 0 ).w,\n\t    memload_mat2x3( ch, addr, 1 ),\n\t    memload( ch, addr, 1 ).w,\n        memload( ch, addr, 2 ).w );\n}\n\nvoid ts_store( TrnSampler self, ivec2 addr, ivec2 sc, inout vec4 fc )\n{\n    memstore( self.r_hat, self.r0, addr, 0, sc, fc );\n    memstore( self.TB[0], self.e_over_b, addr, 1, sc, fc );\n    memstore( self.TB[1], self.invm, addr, 2, sc, fc );\n}\n\n// 16 levels: 1.0005\n// 12 levels: 1.002\nvec4 ts_sbem( float r0, float r )\n{\n\tfloat s = max( r0 * 1.0005, r );\n\tfloat b = sqrt( 1. - r0 * r0 / ( s * s ) );\n    float e = sqrt( s * s - r0 * r0 ) / ( s - r0 );\n    float m = asinh(e);\n\treturn vec4( s, b, e, m );\n}\n\nTrnSampler ts_init( vec3 r, float r0, vec3 T )\n{\n    vec4 rn = length_normalize(r);\n    vec4 sbem = ts_sbem( r0, rn.w );\n    T = normalize( reject( T, rn.xyz ) );\n    vec3 B = cross( rn.xyz, T );\n    TrnSampler result;\n    result.r_hat = rn.xyz;\n    result.TB = mat2x3( T, B );\n    result.e_over_b = sbem.z / sbem.y;\n    result.invm = 1. / sbem.w;\n\tresult.r0 = r0;\n    return result;\n}\n\nbool ts_is_valid( TrnSampler ts )\n\t{ return ts.r0 > 0.; }\n\nvec2 ts_uv_centered( TrnSampler ts, vec3 r )\n{\n    vec3 drn = length_normalize( ( normalize(r) - ts.r_hat ) * ts.TB );\n    return drn.xy * asinh( ts.e_over_b * drn.z ) * ts.invm * TRN_UV_RANGE_INV;\n}\n\nvec2 ts_uv( TrnSampler ts, vec3 r )\n\t{ return .5 + .5 * ts_uv_centered( ts, r ); }\n\nfloat ts_lod( TrnSampler ts, float d )\n\t{ return TRN_SCALE / SCN_SCALE * ts.e_over_b * ts.invm / ( sqrt( ts.e_over_b * ts.e_over_b * d * d + 1. ) ); }\n\nfloat ts_lod( TrnSampler ts, vec3 r )\n\t{ return ts_lod( ts, length( ( normalize(r) - ts.r_hat ) * ts.TB ) ); }\n\nbool ts_is_uv_safe( vec2 uv )\n\t{ return dot( uv, uv ) < FRACT_63_64 * FRACT_63_64; }\n\nbool ts_is_uv_safe( TrnSampler ts, vec3 r )\n\t{ return ts_is_uv_safe( ts_uv_centered( ts, r ) ); }\n\nvec4 ts_uv_inverse_lod( TrnSampler ts, vec2 uv )\n{\n    vec3 uvn = length_normalize( ( 2. * uv - 1. ) * TRN_UV_RANGE );\n    float d = sinh( uvn.z / ts.invm ) / ts.e_over_b;\n    if( d < 1. && uvn.z < TRN_UV_RANGE )\n    {\n    \tvec3 x = ts.r0 * ( ts.TB * uvn.xy * d + ts.r_hat * sqrt( 1. - d * d ) );\n    \treturn vec4( x, ts_lod( ts, d ) );\n    }\n    else\n        return vec4(0);\n}\n\nfloat ts_scale( vec3 r, float r0 )\n{\n\tvec4 rn = length_normalize(r);\n    vec4 sbem = ts_sbem( r0, rn.w );\n    return sbem.z / ( sbem.y * sbem.w );\n}\n\nvoid ts_update_stable( inout TrnSampler ts, vec3 r, float r0, float res )\n{\n    bool mustupdate = true;\n\tif( ts_is_valid( ts ) )\n\t{\n\t\tif( ts_is_uv_safe( ts, r ) )\n        {\n            vec2 uvnew = ts_uv( ts, r );\n            mustupdate = length( uvnew - .5 ) * res * TRN_SCALE >= TRN_UPDATE_THRESHOLD * SCN_SCALE;\n\n            float scalenew = ts_scale( r, r0 );\n            float scaleold = ts.e_over_b * ts.invm;\n\n            mustupdate = mustupdate ||\n                abs( scalenew - scaleold ) * res >= 4. * TRN_UPDATE_THRESHOLD * scaleold;\n\n            /*\n            if( mustupdate )\n            {\n            \tvec3 r_from_uvnew = ts_uv_inverse_lod( ts, round( uvnew * res ) / res ).xyz;\n                // if( r_from_uvnew != ZERO )\n\t\t\t\t\tr = length(r) / ts.r0 * r_from_uvnew;\n                // else\n                //\tmustupdate = false;\n            }\n\t\t\t//*/\n        }\n    }\n\tif( mustupdate )\n\t\tts = ts_init( r, r0, UNIT_Z );\n}\n\n#define ts_aspect vec2( iChannelResolution[1].y / iChannelResolution[1].x, 1. )\n#define ts_aspect_shadow min( 0.666666667, iChannelResolution[1].x / iChannelResolution[1].y - 1. )\n\nvec4 ts_unpack_normal( TrnSampler ts, vec4 tsmpl )\n{\n    vec3 N = ts.TB * tsmpl.xy + ts.r_hat * sqrt( max( 0., 1. - dot( tsmpl.xy, tsmpl.xy ) ) );\n    return vec4( N, tsmpl.w );\n}\n\nvec4 ts_lookup( TrnSampler ts, sampler2D ch, vec3 x )\n{\n    vec2 res = vec2( textureSize( ch, 0 ) );\n    vec2 aspect = vec2( res.y / res.x, 1 );\n    vec2 uv = clamp( ts_uv( ts, x ) * aspect, 2.5 / res, ( res.y - 2.5 ) / res );\n    return textureLod( ch, uv, 0. );\n}\n\nvec4 ts_sample( TrnSampler ts, sampler2D ch, vec3 x )\n\t{ return ts_unpack_normal( ts, ts_lookup( ts, ch, x ) ); }\n\nvec4 ts_shadow_lookup( TrnSampler ts, sampler2D ch, vec3 x )\n{\n    vec2 uv = ts_uv_centered( ts, x );\n    if( ts_is_uv_safe( uv ) )\n    {\n\t\tvec2 res = vec2( textureSize( ch, 0 ) );\n    \tvec2 aspect = vec2( res.y / res.x, 1 );\n    \tfloat aspect_shadow = min( 0.666666667, res.x / res.y - 1. );\n        uv = ( .5 * uv + .5 ) * aspect_shadow * aspect + vec2( aspect.x, 0 );\n \t\treturn textureLod( ch, uv, 0. );\n    }\n    else\n        return vec4(0);\n}\n\nfloat ts_shadow_eval( vec2 lookup, float test )\n    { return lookup.x != lookup.y ? parabolstep( lookup.x, lookup.y, test ) : 1.; }\n\nfloat ts_shadow_sample( TrnSampler ts, sampler2D ch, vec3 x )\n{\n#if WITH_TRN_SHADOW\n    return ts_shadow_eval( ts_shadow_lookup( ts, ch, x ).xy, length(x) );\n#else\n    return 1.;\n#endif\n}\n\nvec2 ts_shadow_sample_ao( TrnSampler ts, sampler2D ch, vec3 x )\n{\n#if WITH_TRN_SHADOW\n    vec4 lookup = ts_shadow_lookup( ts, ch, x );\n    return vec2( ts_shadow_eval( lookup.xy, length(x) ), lookup.z );\n#else\n    return vec2(1);\n#endif\n}\n\n// ----------------------------------------------------------------------------\n// TERRAIN GENERATOR\n// ----------------------------------------------------------------------------\n\nfloat rand( ivec3 p )\n{\n    ivec3 q = sign(p) * abs(p) & 65535;\n    int x = ( 3 + 4 * ( q.x + q.y * ( 1 + p.x ) + q.z * ( 1 + p.x + p.y ) ) );\n    x = ( ( x  & 262143 ) * 47485 ) & 262143;\n    float y = 2. * float(x) / 262144. - 1.;\n    return y;\n}\n\nvec4 trn_noise_d( vec3 x, out vec4 p, out vec4 q )\n{\n\tvec3 xf = fract(x);\n\tvec3 xi = floor(x);\n    ivec3 ix = ivec3( xi );\n    p = vec4( rand( ix + ivec3( 0, 0, 0 ) ), rand( ix + ivec3( 1, 0, 0 ) ),\n\t\t\t  rand( ix + ivec3( 0, 1, 0 ) ), rand( ix + ivec3( 1, 1, 0 ) ) );\n    q = vec4( rand( ix + ivec3( 0, 0, 1 ) ), rand( ix + ivec3( 1, 0, 1 ) ),\n\t\t\t  rand( ix + ivec3( 0, 1, 1 ) ), rand( ix + ivec3( 1, 1, 1 ) ) );\n    vec3 t = xf - .5;\n    vec3 u = .5 - 2. * ( abs(t) * t - t );\n    vec3 v = 2. - 4. * abs(t);\n    vec4 dpq = q - p;\n    vec4 pqz = mix( p, q, u.z );\n    return vec4(\n\t\tmix( pqz.yz - pqz.xx, pqz.ww - pqz.zy, u.yx ) * v.xy,\n        mix( mix( dpq.x, dpq.y, u.x ), mix( dpq.z, dpq.w, u.x ), u.y ) * v.z,\n    \tmix( mix( pqz.x, pqz.y, u.x ), mix( pqz.z, pqz.w, u.x ), u.y ) );\n}\n\nfloat trn_elevation( vec3 r, float detail, PlanetData data, vec4 zone )\n{\n    vec3 rn = normalize(r);\n    float zonelevel = -log2( zone.w );\n    float zoneweight = exp2pp( -lensq( zone.xyz - rn ) / ( zone.w * zone.w ) );\n    vec4 h = vec4(0);\n    mat3 H = mat3(0);\n\tfloat N = min( TRN_MAX_LEVELS, detail );\n\n    // TRN_ELEVATION_ITER_INIT\n    float invfy = 1. / data.trn_flatten.y;\n    float is = SQRTHALF / data.trn_noise.z;\n    float na = ONEOVERSQRTPI * data.trn_noise.x * is;\n\tconst float S = .05;\n\n    for( int i = 0; i < int( ceil( N ) ); i++ )\n    {\n        // TRN_ELEVATION_ITER\n        float j = float(i);\n        float k = float( 1 << i );\n        float u = ( j - data.trn_noise.y ) * is;\n        float v = na * exp2( - u * u - j );\n        float slip = 1. + data.trn_slope.z * dot( h.xyz, h.xyz );\n        vec3 x = k * ( rn + data.trn_seeds );\n        vec3 dx = data.trn_slope.y * h.xyz;\n        vec4 p, q, n = trn_noise_d( x + dx, p, q );\n        vec4 g = smin1_d( square_d( ( h - const_d( data.trn_flatten.x ) ) * invfy ), S );\n        vec4 f = mix_d( const_d( 1. - data.trn_flatten.z ), ONE_D, g );\n        vec4 l = min_d( h - const_d( data.trn_levels.x ), const_d( data.trn_levels.y ) - h );\n        vec4 d = mul_d( l, smin1_d( div_d( f * v, l ), S ) ) / slip;\n\n        float fade = saturate( N - j ) * mix( 1., ( 1. - zoneweight ), saturate( j - zonelevel ) );\n      \th += fade * mul_d( d, vec4( k * n.xyz, n.w ) );\n    }\n    return data.radius * data.trn_slope.x * ( h.w - data.trn_levels.z - dot( rn, data.trn_offcenter ) );\n}\n\nvec4 trn_elevation_refine( vec3 r, float detail, PlanetData data,\n\t\t\t\t\t\t   float origdetail, vec4 tsmpl, vec4 zone )\n{\n    vec3 rn = normalize(r);\n    float zonelevel = -log2( zone.w );\n    float zoneweight = exp2pp( -lensq( zone.xyz - rn ) / ( zone.w * zone.w ) );\n    vec4 h = vec4( - reject( tsmpl.xyz, rn ) / ( dot( tsmpl.xyz, rn ) * data.trn_slope.x ),\n                   tsmpl.w / ( data.radius * data.trn_slope.x ) + data.trn_levels.z + dot( rn, data.trn_offcenter ) );\n    float N = detail;\n    float Norig = min( TRN_MAX_LEVELS, origdetail );\n\n    // TRN_ELEVATION_ITER_INIT\n    float invfy = 1. / data.trn_flatten.y;\n    float is = SQRTHALF / data.trn_noise.z;\n    float na = ONEOVERSQRTPI * data.trn_noise.x * is;\n\tconst float S = .05;\n\n    for( int i = int( floor( Norig ) ); i < int( ceil( N ) ); i++ )\n    {\n        // TRN_ELEVATION_ITER\n        float j = float(i);\n        float k = float( 1 << i );\n        float u = ( j - data.trn_noise.y ) * is;\n        float v = na * exp2( - u * u - j );\n        float slip = 1. + data.trn_slope.z * dot( h.xyz, h.xyz );\n        vec3 x = k * ( rn + data.trn_seeds );\n        vec3 dx = data.trn_slope.y * h.xyz;\n        vec4 p, q, n = trn_noise_d( x + dx, p, q );\n        vec4 g = smin1_d( square_d( ( h - const_d( data.trn_flatten.x ) ) * invfy ), S );\n        vec4 f = mix_d( const_d( 1. - data.trn_flatten.z ), ONE_D, g );\n        vec4 l = min_d( h - const_d( data.trn_levels.x ), const_d( data.trn_levels.y ) - h );\n        vec4 d = mul_d( l, smin1_d( div_d( f * v, l ), S ) ) / slip;\n\n\t\tfloat fade = min( saturate( N - j ), saturate( j + 1. - Norig ) ) * mix( 1., ( 1. - zoneweight ), saturate( j - zonelevel ) );\n        h += fade * mul_d( d, vec4( k * n.xyz, n.w ) );\n\t}\n    return vec4( normalize( rn - reject( data.trn_slope.x * h.xyz, rn ) ), tsmpl.w );\n}\n\nvec4 ts_sample_fine( TrnSampler ts, sampler2D ch, PlanetData data, vec3 x, float Kx )\n{\n#if WITH_TRN_REFINE\n    float res = float( textureSize( ch, 0 ).y );\n    float lod = ts_lod( ts, x );\n    float detail = log2( res * lod ) - TRN_LOD_BIAS;\n    vec4 lookup = ts_lookup( ts, ch, x );\n    int zoneindex = int( lookup.z );\n    vec4 tsmpl = ts_unpack_normal( ts, lookup );\n    vec4 zone = texelFetch( ch, ivec2( ADDR_B_ZONEDATA + zoneindex, 0 ), 0 );\n \treturn trn_elevation_refine(\n\t\tx,\n \t\tmin( detail + TRN_MAX_REFINE_LEVELS, log2( data.radius / Kx ) ),\n        data,\n\t\tdetail,\n        tsmpl,\n        zone );\n#else\n\treturn ts_sample( ts, ch, x );\n#endif\n}\n\n// ----------------------------------------------------------------------------\n// ATMOSPHERE CONTEXT\n// ----------------------------------------------------------------------------\n\nstruct AtmContext\n{\n    float r0;\n    float g;\n    float H;\n    float invH50;\n    vec3 omega0;\n    float X50;\n    vec3 mu_stretch;\n    float htop;\n    vec3 tau50;\n    vec3 tau50s;\n    vec3 k50;\n    vec3 k50_s;\n    float k50max;\n  #if WITH_ATM_LAYER_G\n    vec3 glayer_k50;\n    vec3 glayer_k50_s;\n    float glayer_scale;\n  #endif\n  #if WITH_ATM_LAYER_A\n    vec3 alayer_k50;\n    vec3 alayer_shape;\n  #endif\n  #if WITH_ATM_LAYER_E\n    vec3 elayer_emiss;\n    vec3 elayer_shape;\n  #endif\n  #if WITH_CLOUDS\n    vec3 ht0s50;\n  #endif\n};\n\nconst int ADDR_ATMCONTEXT_SIZE = 14;\n\nAtmContext atm_load( sampler2D ch, ivec2 addr )\n{\n    return AtmContext(\n        memload( ch, addr, 0 ).x,\n        memload( ch, addr, 0 ).y,\n        memload( ch, addr, 0 ).z,\n        memload( ch, addr, 0 ).w,\n        memload( ch, addr, 1 ).xyz,\n        memload( ch, addr, 1 ).w,\n        memload( ch, addr, 2 ).xyz,\n        memload( ch, addr, 2 ).w,\n        memload( ch, addr, 3 ).xyz,\n        memload( ch, addr, 4 ).xyz,\n        memload( ch, addr, 5 ).xyz,\n        memload( ch, addr, 6 ).xyz,\n        memload( ch, addr, 6 ).w\n      #if WITH_ATM_LAYER_G\n        ,memload( ch, addr, 7 ).xyz\n        ,memload( ch, addr, 8 ).xyz\n        ,memload( ch, addr, 8 ).w\n      #endif\n      #if WITH_ATM_LAYER_A\n        ,memload( ch, addr, 9 ).xyz\n        ,memload( ch, addr, 10 ).xyz\n      #endif\n      #if WITH_ATM_LAYER_E\n        ,memload( ch, addr, 11 ).xyz\n        ,memload( ch, addr, 12 ).xyz\n      #endif\n\t  #if WITH_CLOUDS\n        ,memload( ch, addr, 13 ).xyz\n      #endif\n\t);\n}\n\nvoid atm_store( AtmContext self, ivec2 addr, ivec2 sc, inout vec4 fc )\n{\n    memstore( vec4( self.r0, self.g, self.H, self.invH50 ), addr, 0, sc, fc );\n    memstore( self.omega0, self.X50, addr, 1, sc, fc );\n    memstore( self.mu_stretch, self.htop, addr, 2, sc, fc );\n    memstore( self.tau50, 0., addr, 3, sc, fc );\n    memstore( self.tau50s, 0., addr, 4, sc, fc );\n    memstore( self.k50, 0., addr, 5, sc, fc );\n    memstore( self.k50_s, self.k50max, addr, 6, sc, fc );\n  #if WITH_ATM_LAYER_G\n    memstore( self.glayer_k50, 0., addr, 7, sc, fc );\n\tmemstore( self.glayer_k50_s, self.glayer_scale, addr, 8, sc, fc );\n  #endif\n  #if WITH_ATM_LAYER_A\n    memstore( self.alayer_k50, 0., addr, 9, sc, fc );\n    memstore( self.alayer_shape, 0., addr, 10, sc, fc );\n  #endif\n  #if WITH_ATM_LAYER_E\n    memstore( self.elayer_emiss, 0., addr, 11, sc, fc );\n    memstore( self.elayer_shape, 0., addr, 12, sc, fc );\n  #endif\n  #if WITH_CLOUDS\n \tmemstore( self.ht0s50, 0., addr, 13, sc, fc );\n  #endif\n}\n\nfloat atm_overarch( PlanetData planet )\n{\n    // normalized distance to horizon observable from one scale-height altitude;\n    // used as a measure of terminator 'over-arch'\n    return safediv( sqrt( planet.atm_scale * ( 2. * planet.radius + planet.atm_scale ) ),\n           ( planet.radius + planet.atm_scale ) );\n}\n\nvec3 atm_eddington_diffusion_stretch_factor( vec3 omega0, float g, float k )\n{\n    // stretch factor related to the backscatter coefficient or\n    // the average diffusion length\n    return sqrt( 3. * ( 1. - omega0 * k ) * ( 1. - omega0 * g ) );\n}\n\nvec3 atm_cvt_layer_shape( vec2 shape, float invscale )\n{\n    vec3 result;\n    result.x = shape.x * invscale;\n    result.y = safediv( ONEOVERSQRTTWOPI * LOG2E, shape.y * invscale );\n    result.z = safediv( .5 * LOG2E, square( shape.y * invscale ) );\n\treturn result;\n}\n\nvec3 irselect( vec4 a, bool b )\n\t{ return b ? a.www : a.xyz; }\n\nAtmContext atm_init( PlanetData data, bool ir )\n{\n    AtmContext result;\n    result.r0 = data.radius;\n    result.g = data.atm_g;\n    result.H = data.atm_scale;\n    result.invH50 = safediv( LOG2E, data.atm_scale );\n    result.omega0 = irselect( safediv( data.atm_tau_s, data.atm_tau ), ir );\n    result.X50 = data.radius * result.invH50;\n    vec3 stretchhalf = atm_eddington_diffusion_stretch_factor( result.omega0, result.g, .5 );\n    vec3 stretchfull = atm_eddington_diffusion_stretch_factor( result.omega0, result.g, 1. );\n    result.mu_stretch = result.X50 * stretchhalf * atm_overarch( data );\n    result.htop = ( hmax( result.tau50 ) + 15. ) * data.atm_scale;\n    result.tau50 = irselect( data.atm_tau, ir ) * LOG2E;\n    result.tau50s = result.tau50 * stretchfull;\n    result.k50 = irselect( data.atm_tau, ir ) * result.invH50;\n    result.k50_s = irselect( data.atm_tau_s, ir ) * result.invH50;\n    result.k50max = hmax( result.k50 );\n  #if WITH_ATM_LAYER_G\n    result.glayer_k50 = irselect( data.atm_glayer_tau, ir ) * result.invH50;\n    result.glayer_k50_s = irselect( data.atm_glayer_tau_s, ir ) * result.invH50;\n    result.glayer_scale = data.atm_glayer_scale;\n  #endif\n  #if WITH_ATM_LAYER_A\n    result.alayer_k50 = irselect( data.atm_alayer_tau, ir ) * result.invH50;\n    result.alayer_shape = atm_cvt_layer_shape( data.atm_alayer_shape, result.invH50 );\n  #endif\n  #if WITH_ATM_LAYER_E\n    result.elayer_emiss = irselect( data.atm_elayer_emiss, ir );\n\tresult.elayer_shape = atm_cvt_layer_shape( data.atm_elayer_shape, result.invH50 );\n  #endif\n  #if WITH_CLOUDS\n    result.ht0s50 = SQRTPILN2HALF * sqrt( result.X50 ) * irselect( data.atm_tau, ir );\n  #endif\n    return result;\n}\n\nfloat atm_chapman50_h( float X, float h, float coschi )\n{\n    // Approximation to the Chapman function (airmass integral)\n    // cf. Sch\u00fcler, C. (2012) in GPU Pro 3\n    // returns the equivalent of Ch(X+h,coschi) times exp2(-h)\n\n    float x = X + h;\n    float c = SQRTPILN2HALF * sqrt(x);\n    if( coschi >= 0. )\n        return c / ( ( c - 1. ) * coschi + 1. ) * exp2pp( -h );\n    else\n    {\n        float sinchi = sqrt( max( 0., 1. - coschi * coschi ) );\n        return c / ( ( c - 1. ) * coschi - 1. ) * exp2pp( -h ) +\n               2. * c * exp2pp( X - x * sinchi ) * sqrt( sinchi );\n    }\n}\n\n#if WITH_ATM_LAYER_A\nfloat atm_tau_layer_a( vec3 x, vec3 dir, AtmContext atm )\n{\n    float result = 0.;\n\tfloat mu = atm.alayer_shape.x + atm.X50;\n    float hw = safediv( ONEOVERSQRTTWOPI, atm.alayer_shape.y );\n    vec2 imp = sphere_impact( x, dir );\n    if( imp.x < square( mu + hw ) )\n    {\n        vec2 limits = max( vec2(0), sphere_limits( mu + hw, imp ) );\n        result += .5 * ( limits.y - limits.x ) / hw;\n        if( imp.x < square( mu - hw ) )\n        {\n            vec2 limits = max( vec2(0), sphere_limits( mu - hw, imp ) );\n            result -= .5 * ( limits.y - limits.x ) / hw;\n        }\n    }\n    return result;\n}\n#endif\n\n#if WITH_ATM_AMTL_CORRECTION\nfloat atm_airmass_correction( float x, float coschi, float a )\n{\n    coschi = abs( coschi );\n    float c = SQRTPILN2HALF * sqrt(x);\n\treturn a * ( ( c - 1. ) * coschi + a ) / ( ( a * c - 1. ) * coschi + a );\n}\n#endif\n\nvec3 atm_tau50_params( vec3 x, vec3 dir, AtmContext atm )\n{\n    float xsq = dot( x, x );\n    float invxr = inversesqrt( xsq );\n    float x50 = xsq * invxr;\n    float h50 = x50 - atm.X50;\n    float coschi = invxr * dot( x, dir );\n    return vec3( sqrt( max( 0., 1. - square( atm.X50 / x50 ) ) ), h50, coschi );\n}\n\nvec3 atm_tau50( vec3 x, vec3 dir, float h50, float coschi, AtmContext atm )\n{\n    // Analytical approximation to the optical depth along a path\n    // inside an exponentially decreasing, spherically symmetric\n    // atmosphere as seen from point x into direction dir\n    vec3 result = ZERO;\n#if WITH_ATMOSPHERE\n    float airmass = atm_chapman50_h( atm.X50, h50, coschi );\n    result += atm.tau50 * airmass;\n  #if WITH_ATM_LAYER_G\n    float airmass_g = atm_chapman50_h( atm.X50 * atm.glayer_scale, h50 * atm.glayer_scale, coschi );\n    result += atm.H * atm.glayer_k50 * ( airmass_g - airmass );\n  #endif\n  #if WITH_ATM_LAYER_A\n    float airmass_a = atm_tau_layer_a( x, dir, atm );\n    result += atm.H * atm.alayer_k50 * ( airmass_a - airmass );\n  #endif\n#endif\n    return result;\n}\n\nvec3 atm_transmittance( vec3 pos, vec3 dir, AtmContext atm, bool amtl )\n{\n    vec3 x = pos * atm.invH50;\n    vec3 params = atm_tau50_params( x, dir, atm );\n    vec3 tau50 = atm_tau50( x, dir, params.y, params.z, atm );\n#if WITH_ATM_AMTL_CORRECTION\n    if( amtl )\n \t\ttau50 *= atm_airmass_correction( atm.X50, params.x + params.z, ATM_AMTL_CORRECTION );\n#endif\n    return exp2pp( -tau50 );\n}\n\nvec3 atm_transmittance_finite( vec3 pos0, vec3 pos1, AtmContext atm )\n{\n    vec3 dir = normalize( pos1 - pos0 );\n    vec3 x0 = pos0 * atm.invH50;\n    vec3 x1 = pos1 * atm.invH50;\n    vec3 params0 = atm_tau50_params( x0, dir, atm );\n    vec3 params1 = atm_tau50_params( x1, dir, atm );\n\tvec3 tau50 = dot( x0, dir ) < 0. ?\n\t\tatm_tau50( x1, -dir, params1.y, -params1.z, atm ) - atm_tau50( x0, -dir, params0.y, -params0.z, atm ) :\n\t\tatm_tau50( x0, dir, params0.y, params0.z, atm ) - atm_tau50( x1, dir, params1.y, params1.z, atm );\n    return exp2( -tau50 );\n}\n\nfloat atm_planet_shadow( float coschi, float cosbeta )\n{\n    return clamp( SCN_RAYCAST_SHADOW_UMBRA * ( coschi + cosbeta ) + .5, 0., 1. );\n}\n\nfloat atm_delta_eddington_Fminus_direct( float g, float tau50, float mu )\n{\n    // Simplified Eddington downwelling flux component\n    // for direct light input at the top interface,\n    // assuming conservative scattering (omega0 = 1),\n    // and no bottom reflection.\n    float f = g * g;\n    g = g / ( g + 1. );\n    tau50 = ( 1. - f ) * tau50;\n    return ( 2. + 3. * mu + ( 2. - 3. * mu ) * exp2pp( -tau50 ) ) / ( 4. + 3. * LN2 * tau50 * mu * ( 1. - g ) );\n}\n\nfloat atm_delta_eddington_Fminus_diffuse( float g, float tau50 )\n{\n    // Simplified Eddington downwelling flux component\n    // for diffuse light input at the top interface,\n    // assuming conservative scattering (omega0 = 1),\n    // and no bottom reflection.\n    float f = g * g;\n    g = g / ( g + 1. );\n    tau50 = ( 1. - f ) * tau50;\n    return 4. / ( 4. + 3. * LN2 * tau50 * ( 1. - g ) );\n}\n\nfloat atm_dulimit( float invtau, float H50, float k50 )\n{\n    // maximum allowed advance to stay within 1/invtau mean free paths\n    // used as step size control\n    float s = invtau * k50;\n    return\n        H50 * s < .25 ? -H50 * log2( H50 * s ) :\n    \tH50 * s >= 4. ? 1. / s :\n    \tH50 * log2( 1. + 1. / ( H50 * s ) );\n}\n\n// ----------------------------------------------------------------------------\n// ANISOTROPICALLY ANTIALIASED ANALYTIC PRIMITIVES\n// ----------------------------------------------------------------------------\n\nfloat Linfinity( vec2 a )\n\t{ return max( abs( a.x ), abs( a.y ) ); }\n\nfloat aaa_cov( float a )\n\t{ return saturate( a ); }\n\nfloat aaa_step( float K, float u )\n\t{ return aaa_cov( .5 + u / K ); }\n\nvec2 aaa_step2( vec2 K, vec2 u )\n\t{ return vec2( aaa_step( K.x, u.x ), aaa_step( K.y, u.y ) ); }\n\nfloat aaa_interval( float K, float u, float size )\n\t{ return aaa_cov( K < size ? .5 + ( .5 * size - abs(u) ) / K : ( 1. - abs(u) / K ) * size / K ); }\n\nvec2 aaa_interval2( vec2 K, vec2 u, vec2 size )\n\t{ return vec2( aaa_interval( K.x, u.x, size.x ), aaa_interval( K.y, u.y, size.y ) ); }\n\nfloat aaa_stipple( float K, float u, float per, float x_duty )\n{\n    float duty = fract( x_duty );\n    float d = min( duty, 1. - duty );\n    float s = d * per;\n    u = abs( mod( u, per ) - per / 2. );\n\treturn floor( x_duty ) + aaa_cov( K < .5 * per ?\n        ( duty < .5 ? aaa_interval( K, u, s ) : 1. - aaa_interval( K, per / 2. - u, s ) ) :\n\t\tduty - ( u - per / 4. ) * d / K );\n}\n\nvec2 aaa_stipple2( vec2 K, vec2 u, vec2 per, vec2 x_duty )\n\t{ return vec2( aaa_stipple( K.x, u.x, per.x, x_duty.x ), aaa_stipple( K.y, u.y, per.y, x_duty.y ) ); }\n\nfloat aaa_box( mat2 K, vec2 uv, vec2 size, vec2 edge )\n{\n    return aaa_interval( max( edge.x, Linfinity( K[0] ) ), uv.x, size.x ) *\n\t\t   aaa_interval( max( edge.y, Linfinity( K[1] ) ), uv.y, size.y );\n}\n\nfloat aaa_rect( mat2 K, vec2 uv, vec2 size, vec2 d )\n{\n    return aaa_box( K, uv, size + d, vec2(0) ) * ( 1. - aaa_box( K, uv, size - d, vec2(0) ) );\n}\n\nfloat aaa_line( mat2 K, vec2 uv, vec2 dx, float width )\n{\n    vec3 dxn = length_normalize( dx );\n    mat2 M = mat2( dxn.xy, perp( dxn.xy ) );\n    uv = ( uv - dx / 2. ) * M;\n    return aaa_box( K * M, uv, vec2( dxn.z, width ), vec2(0) );\n}\n\nfloat aaa_line( mat2 K, vec2 uv, vec2 x0, vec2 x1, float width )\n\t{ return aaa_line( K, uv - x0, x1 - x0, width ); }\n\nfloat aaa_hline( mat2 K, vec2 uv, vec2 x0, float w, float width )\n{\n    uv = uv - vec2( w / 2., 0 );\n    return aaa_box( K, uv - x0, vec2( w, width ), vec2(0) );\n}\n\nfloat aaa_vline( mat2 K, vec2 uv, vec2 x0, float h, float width )\n{\n    uv = uv - vec2( 0, h / 2. );\n    return aaa_box( mat2( perp( K[0] ), perp( K[1] ) ), uv - x0, vec2( width, h ), vec2(0) );\n}\n\nfloat aaa_disk( mat2 K, vec2 uv, float size )\n{\n    vec3 uvn = length_normalize( uv );\n\treturn aaa_interval( Linfinity( K * uvn.xy ), uvn.z, size );\n}\n\nfloat aaa_ring( mat2 K, vec2 uv, float size, float d )\n{\n    vec3 uvn = length_normalize( uv );\n\treturn aaa_interval( Linfinity( K * uvn.xy ), abs( uvn.z - size / 2. ), d );\n}\n", "name": "Common", "description": "", "type": "common"}, {"inputs": [{"id": "4dXGRr", "filepath": "/presets/tex00.jpg", "previewfilepath": "/presets/tex00.jpg", "type": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "4dXGR8", "filepath": "/media/previz/buffer00.png", "previewfilepath": "/media/previz/buffer00.png", "type": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "XsXGR8", "filepath": "/media/previz/buffer01.png", "previewfilepath": "/media/previz/buffer01.png", "type": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "XdfGR8", "filepath": "/media/previz/buffer03.png", "previewfilepath": "/media/previz/buffer03.png", "type": "buffer", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dXGR8", "channel": 0}], "code": "/*\n *\t\t\t\tSPACE GLIDER 2020 SHADERTOY EDITION\n *\t\t\t\t\t   by Christian Sch\u00fcler\n *                       (c) 2001 - 2020\n *\n * Part 2 of 6: Buffer A shader (simulation and update logic)\n * This software comes with no warranty. Use it at your own risk.\n */\n\nPlanetData g_data;\nint g_msgindex = 0;\n\n// ----------------------------------------------------------------------------\n// START DATA\n// ----------------------------------------------------------------------------\n\nconst StartData[] g_start_data = StartData[](\n\n    // Init\n    StartData( uvec4(0), ivec4( 1, 1, 0, 0 ), vec4( 30, 120, 300, 120 ) ),\n\n    // Low orbit\n    StartData( uvec4( 0x4c6f7720, 0x90000000, 0, 5 ),\n               ivec4( 1, 0, 0, 7 ), vec4( 0, 30, 45, 60 ) ),\n\n    // Space center west\n    StartData( uvec4( 0x94959700, 0, 0, 3 ),\n               ivec4( 3, 0, 0, 7 ), vec4( 1, ZERO ) ),\n\n    // Space center east\n    StartData( uvec4( 0x94959600, 0, 0, 3 ),\n               ivec4( 3, 7, 0, 25 ), vec4( 1, ZERO ) ),\n\n    // Lucerne\n    StartData( uvec4( 0x4c756365, 0x726e6500, 0, 7 ),\n               ivec4( 3, 15, 0, 19 ), vec4( 1, ZERO ) ),\n\n    // Bensersiel\n    StartData( uvec4( 0x42656e73, 0x65727369, 0x656c0000, 10 ),\n               ivec4( 2, 0, 0, 19 ), vec4( 62.47, 152.0782, .0007, 250. ) ),\n\n    // North point (Kaffeklubben island)\n    StartData( uvec4( 0x4b616666, 0x656b6c75, 0x6262656e, 0x20a8000e ),\n               ivec4( 2, 0, 0, 19 ), vec4( 87.3323, 157.6711, -0.0001, 180 ) ),\n\n    // Spitsbergen\n    StartData( uvec4( 0x53706974, 0x73626572, 0x67656e00, 11 ),\n               ivec4( 2, 0, 0, 73 ), vec4( 72.4248, 79.5030, 1.8296, 270 ) ),\n\n    // Canc\u00fan\n    StartData( uvec4( 0xa1202020, 0, 0, 4 ),\n               ivec4( 3, 25, 0, 37 ), vec4( 1, ZERO ) ),\n\n    // Underwater primitive exhibition\n    StartData( uvec4( 0xa2a36578, 0x68696269, 0x74696f6e, 12 ),\n               ivec4( 2, 0, 0, 25 ), vec4( 28.9906, 156.4883, -0.0010, 350 ) ),\n\n    // Rocky Springs\n    StartData( uvec4( 0x526f636b, 0x79205370, 0x72696e67, 0x7300000d ),\n               ivec4( 3, 45, 0, 51 ), vec4( -1, ZERO ) ),\n\n    // Lake Victoria\n    StartData( uvec4( 0x4c616b65, 0x20566963, 0x746f7269, 0x6100000d ),\n               ivec4( 3, 51, 0, 45 ), vec4( 1, ZERO ) ),\n\n    // Hang gliding challenge\n    StartData( uvec4( 0x48616e67, 0x20676c69, 0x64696e67, 0x20a4000e ),\n               ivec4( 2, 0, 0, 58 ), vec4( -51.5485, -124.1851, 2.1878, 70 ) ),\n\n    // Hang gliding destination\n    StartData( uvec4( 0x48616e67, 0x20676c69, 0x64696e67, 0x20ad000e ),\n               ivec4( 3, 58, 0, 55 ), vec4( -1, ZERO ) ),\n\n    // South pole station\n    StartData( uvec4( 0x999a9b00, 0, 0, 3 ),\n               ivec4( 2, 0, 0, 69 ), vec4( -89.9883, 31.6990, 0.0124, 150. ) ),\n\n    // Gonder (Ethiopian highlands)\n    StartData( uvec4( 0x476f6e64, 0x65720000, 0, 6 ),\n               ivec4( 3, 70, 0, 0 ), vec4( -1, ZERO ) ),\n\n    // Dakhla oasis\n    StartData( uvec4( 0x44616b68, 0x6c61206f, 0x61736973, 12 ),\n               ivec4( 2, 0, 0, 70 ), vec4( 25.8881, -149.4194, 0.0030, 150 ) ),\n\n    // Ash island\n    StartData( uvec4( 0x41736820, 0x69736c61, 0x6e640000, 10 ),\n               ivec4( 3, 72, 0, 0 ), vec4( 1, ZERO ) ),\n\n    // Edge of the trench\n    StartData( uvec4( 0x45646765, 0x206f6620, 0x74686520, 0xa600000d ),\n               ivec4( 2, 0, 0, 0 ), vec4( 3.0093, 22.9312, -2.2686, 35 ) ),\n\n    // Towards sunrise\n    StartData( uvec4( 0x546f7761, 0x72647320, 0x73756e72, 0x6973650f ),\n               ivec4( 3, 73, 0, 0 ), vec4( 1, ZERO ) ),\n\n    // The north face\n    StartData( uvec4( 0x54686520, 0x98666163, 0x65000000, 9 ),\n               ivec4( 2, 0, 0, 0 ), vec4( 60.2080, 120.2213, 1.9845, 205 ) ),\n\n    // Continue high orbit\n    StartData( uvec4( 0x436f6e74, 0x696e7565, 0x20686967, 0x6820900f ),\n               ivec4(0), vec4(0) )\n);\n\n// ----------------------------------------------------------------------------\n// VEHICLE DATA\n// ----------------------------------------------------------------------------\n\nconst VehicleData[] g_vehicle_data = VehicleData[](\n\n\t// \"Super XR 7000\"\n    // blend of 3 parts F-16 and 1 part Shuttle orbiter ...\n    VehicleData(\n        vec4( 48.27, 11.62, 5.31, 10630. ),\t\t\t\t\t// Sbcm\n        vec4( 23700, 147800, 163000, 1100 ),\t\t\t\t// I\n        vec4(  0.0365,  1.8875,  1.0488,  0.0750 ),\t\t\t// CD\n        vec4(  0.1850,  3.8547, 23.0975,  0.4925 ),\t\t\t// CL\n        vec4( -0.0028, -0.1481, -5.2071, -0.4816 ),\t\t\t// Cm\n        vec4( -1.0047, -0.1717,  1.0391,  0.1715 ),\t\t\t// CY\n        vec4(  0.1906,  0.0597, -0.4233, -0.0826 ),\t\t\t// Cn\n        vec4( -0.0642, -0.3149,  0.0951,  0.1378 ),\t\t\t// Cl\n        vec2(  0.2500, -0.0250 ),\t\t\t\t\t\t\t// Cadot\n         0.2000,\n        -0.3082,\n         0.0844,\n        vec2( -0.5938, -3.0300 ),\n        vec2(  0.1786, -0.4419 ),\n        vec3(  0.8700,  0.0159, 0.0106 ),\n        mat3( 0.0350, 0.1805, 0, 0.0300, -0.0500, 0, 0.0204, 0.0075, 0 ),\n         0.0736,\n        vec4( 0.45, 0.98, 1.00, 0.55 ),\n        vec3( 0.4663, 0.3640, 0.5220 ),\n        136000.\n    ),\n\n    // B747\n    VehicleData(\n        vec4( 511.38, 59.67, 8.32, 162500. ),\n        vec4( 14415000, 25253000, 37922000, 0 ),\n        vec4(  0.0149,  0.8377,  0.3350,  0.0690 ),\n        vec4(  0.2195,  4.9966,  7.2544,  0.3253 ),\n        vec4(  0.0700, -1.1460,-22.5088, -1.2960 ),\n        vec4( -0.9553,  0.0000,  0.3000,  0.1477 ),\n        vec4(  0.1847, -0.1181, -0.3219, -0.1077 ),\n        vec4( -0.1433, -0.3828,  0.1742,  0.0318 ),\n        vec2(  6.7242, -3.6500 ),\n         0.2000,\n        -0.4104,\n         0.0000,\n        vec2( -1.5000, -3.7737 ),\n        vec2(  0.5267, -0.1129 ),\n        vec3(  0.7200,  0.0431, 0.0102 ),\n        mat3( 0.0980, 0.9750, -0.1700, 0.0240, -0.0800, -0.0100, 0.0270, 0, -0.0100 ),\n        -0.1719,\n        vec4( 0.15, 0.35, 1.00, 0.55 ),\n        vec3( 0.3640, 0.3640, 0.4663 ),\n        830000.\n    )\n);\n\nconst int USE_VEHICLE_INDEX = 0;\n\n// ----------------------------------------------------------------------------\n// MENU DATA\n// ----------------------------------------------------------------------------\n\nconst uvec4[] g_menu_data = uvec4[](\n\n    uvec4(0),\n    uvec4( 0x82810000, 0, 0, 0x00080602 ),\t\t\t\t// 'Command ...' -> 08\n    uvec4( 0x4d617020, 0x81000000, 0, 0x00400605 ),\t\t// 'Map ...' -> 40\n    uvec4(0),\n    uvec4(0),\n    uvec4(0),\n    uvec4(0),\n    uvec4( 0x53757265, 0x3f000000, 0, 5 ),\t\t\t\t// 'Sure?'\n\n    // 08 Command ...\n    uvec4( 0x86888100, 0, 0, 0x00100803 ),\t\t\t\t// 'Info page ...' -> 10\n    uvec4( 0x484d4420, 0x87810000, 0, 0x00180306 ),\t\t// 'HMD mode ...' -> 18\n    uvec4( 0x8d878100, 0, 0, 0x00200303 ),\t\t\t\t// 'Aero mode ...' -> 20\n    uvec4( 0x52435320, 0x87810000, 0, 0x00280406 ),\t\t// 'RCS mode ...' -> 28\n    uvec4( 0x83878100, 0, 0, 0x00380403 ),\t\t\t\t// 'Engine mode ...' -> 38\n    uvec4( 0x51756974, 0, 0, 0x00070104 ),\t\t\t\t// 'Quit' -> 07\n    uvec4(0),\n    uvec4(0),\n\n    // 10 Info page ...\n    uvec4( 0x866f6666, 0, 0, 4 ),\t\t\t\t\t\t// 'Info off'\n    uvec4( 0x91860000, 0, 0, 2 ),\t\t\t\t\t\t// 'Location info'\n    uvec4( 0xa7860000, 0, 0, 2 ),\t\t\t\t\t\t// 'Waypoint info'\n    uvec4( 0x90860000, 0, 0, 2 ),\t\t\t\t\t\t// 'Orbit info'\n    uvec4( 0x476c6964, 0x65208600, 0, 7 ),\t\t\t\t// 'Glide info'\n    uvec4( 0x84860000, 0, 0, 2 ),\t\t\t\t\t\t// 'Control info'\n    uvec4( 0x41697220, 0x86000000, 0, 5 ),\t\t\t\t// 'Air info'\n    uvec4( 0x54696d65, 0x20860000, 0, 6 ),\t\t\t\t// 'Time info'\n\n    // 18 HMD mode ...\n    uvec4( 0x484d4420, 0x6f666600, 0, 7 ),\t\t\t\t// 'HMD off'\n    uvec4( 0x8fa50000, 0, 0, 2 ),\t\t\t\t\t\t// 'Surface overlay'\n    uvec4( 0x90a50000, 0, 0, 2 ),\t\t\t\t\t\t// 'Orbit overlay'\n    uvec4(0),\n    uvec4(0),\n    uvec4(0),\n    uvec4(0),\n    uvec4(0),\n\n    // 20 Aero mode ...\n    uvec4( 0x8d6f6666, 0, 0, 4 ),\t\t\t\t\t\t// 'Aero off'\n    uvec4( 0x928e8400, 0, 0, 3 ),\t\t\t\t\t\t// 'Direct manual control'\n    uvec4( 0x466c7920, 0x627920af, 0x84000000, 9 ),\t\t// 'Fly by wire control'\n    uvec4(0),\n    uvec4(0),\n    uvec4(0),\n    uvec4(0),\n    uvec4(0),\n\n    // 28 RCS mode ...\n    uvec4( 0x52435320, 0x6f666600, 0, 7 ),\t\t\t\t// 'RCS off'\n    uvec4( 0x928e8400, 0, 0, 3 ),\t\t\t\t\t\t// 'Direct manual control'\n    uvec4( 0xae898400, 0, 0, 3 ),\t\t\t\t\t\t// 'Rotation rate control'\n    uvec4( 0xae89842b, 0x204c564c, 0x48000000, 9 ),\t\t// 'Rotation rate control + LVLH'\n    uvec4(0),\n    uvec4(0),\n    uvec4(0),\n    uvec4(0),\n\n    // 30 Throttle mode ...\n    uvec4( 0x856f6666, 0, 0, 4 ),\t\t\t\t\t\t// 'Throttle off'\n    uvec4( 0x928e8400, 0, 0, 3 ),\t\t\t\t\t\t// 'Manual'\n    uvec4(0),\n    uvec4(0),\n    uvec4(0),\n    uvec4(0),\n    uvec4(0),\n    uvec4(0),\n\n    // 38 Engine mode ...\n    uvec4( 0x836f6666, 0, 0, 4 ),\t\t\t\t\t\t// 'Engine off'\n    uvec4( 0x8a830000, 0, 0, 2 ),\t\t\t\t\t\t// 'Drive engine'\n    uvec4( 0x8b830000, 0, 0, 2 ),\t\t\t\t\t\t// 'Impulse engine'\n    uvec4( 0x8c830000, 0, 0, 2 ),\t\t\t\t\t\t// 'Nova engine'\n    uvec4(0),\n    uvec4(0),\n    uvec4(0),\n    uvec4(0),\n\n    // 40 Map ...\n\tuvec4( 0x50687973, 0x6963616c, 0, 8 ),\t\t\t\t// Physical\n\tuvec4( 0x456c6576, 0x6174696f, 0x6e000000, 9 ),\t\t// Elevation\n\tuvec4( 0x536c6f70, 0x65000000, 0, 5 ),\t\t\t\t// Slope\n\tuvec4( 0x45717561, 0x6c206172, 0x65610000, 10 ),\t// Equal area\n\tuvec4( 0x45717561, 0x6c20616e, 0x676c6500, 11 ),\t// Equal angle\n\tuvec4( 0x53657420, 0xa7000000, 0, 5 ),\t\t\t\t// Set waypoint\n    uvec4(0),\n    uvec4(0)\n);\n\nconst int MENU_HMD_BEGIN = 0x18;\nconst int MENU_HMD_SIZE = 3;\nconst int MENU_AERO_BEGIN = 0x20;\nconst int MENU_AERO_SIZE = 3;\nconst int MENU_RCS_BEGIN = 0x28;\nconst int MENU_RCS_SIZE = 4;\nconst int MENU_THR_BEGIN = 0x30;\nconst int MENU_THR_SIZE = 2;\nconst int MENU_ENG_BEGIN = 0x38;\nconst int MENU_ENG_SIZE = 4;\nconst int MENU_MMODE_BEGIN = 0x40;\nconst int MENU_MMODE_SIZE = 3;\nconst int MENU_MPROJ_BEGIN = 0x43;\nconst int MENU_MPROJ_SIZE = 2;\nconst int MENU_SET_WAYPOINT = 0x45;\n\n// ----------------------------------------------------------------------------\n// VEHICLE INPUTS\n// ----------------------------------------------------------------------------\n\nconst int KEY_BACK = 8;\nconst int KEY_TAB = 9;\nconst int KEY_SHIFT = 16;\nconst int KEY_CTRL = 17;\nconst int KEY_ALT = 18;\nconst int KEY_ESC = 27;\nconst int KEY_SPACE = 32;\nconst int KEY_LEFT = 37;\nconst int KEY_UP = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN = 40;\nconst int KEY_0 = 48;\nconst int KEY_1 = 49;\nconst int KEY_LESS = 60;\nconst int KEY_A = 65;\nconst int KEY_B = 66;\nconst int KEY_D = 68;\nconst int KEY_F = 70;\nconst int KEY_G = 71;\nconst int KEY_H = 72;\nconst int KEY_I = 73;\nconst int KEY_J = 74;\nconst int KEY_K = 75;\nconst int KEY_L = 76;\nconst int KEY_M = 77;\nconst int KEY_N = 78;\nconst int KEY_P = 80;\nconst int KEY_Q = 81;\nconst int KEY_R = 82;\nconst int KEY_S = 83;\nconst int KEY_T = 84;\nconst int KEY_V = 86;\nconst int KEY_W = 87;\nconst int KEY_Z = 90;\nconst int KEY_F1 = 112;\nconst int KEY_F2 = 113;\nconst int KEY_F3 = 114;\nconst int KEY_F4 = 115;\nconst int KEY_F5 = 116;\nconst int KEY_F12 = 123;\nconst int KEY_ACCENT_FIREFOX = 192;\nconst int KEY_ACCENT_CHROME = 226;\nconst int KEY_META_FIREFOX = 224;\nconst int KEY_META_CHROME = 91;\n\n#if KIOSK_MODE\n\nfloat keystate( int key )\n\t{ return 0.; }\n\nfloat keypress( int key )\n\t{ return 0.; }\n\nfloat keystatepress( int key )\n\t{ return 0.; }\n\n#else\n\nfloat keystate( int key )\n\t{ return texelFetch( iChannel3, ivec2( key, 0 ), 0 ).x; }\n\nfloat keypress( int key )\n\t{ return texelFetch( iChannel3, ivec2( key, 1 ), 0 ).x; }\n\nfloat keystatepress( int key )\n\t{ return max( keystate( key ), keypress( key ) ); }\n\n#endif\n\nstruct VehicleInputs\n{\n\tfloat flapsswitch;\n    float spoiltoggle;\n    float gearstoggle;\n    float gearbrake;\n    float lightstoggle;\n    float throttlecommand;\n  \tvec3 joycommand;\n    float trimcommand;\n    bool trimdisplay;\n    // vec3 rcscommand;\n    float tvecswitch;\n\n    // read only\n    vec3 vjoy_copy;\n};\n\nVehicleInputs vi_read_inputs( VehicleState vs )\n{\n\tVehicleInputs result;\n\n\tfloat shift = keystate( KEY_SHIFT );\n    float meta = max( keystate( KEY_CTRL ),\n                     max( keystate( KEY_META_FIREFOX ), keystate( KEY_META_CHROME ) ) );\n    vec2 arrows = vec2(\n\t\tkeystatepress( KEY_RIGHT ) - keystatepress( KEY_LEFT ),\n        keystatepress( KEY_UP ) - keystatepress( KEY_DOWN ) );\n    vec2 WASD = vec2(\n        max( keystatepress( KEY_A ), keystatepress( KEY_Q ) ) - keystatepress( KEY_D ),\n\t\tmax( keystatepress( KEY_W ), keystatepress( KEY_Z ) ) - keystatepress( KEY_S ) );\n\tfloat shiftmod = mix( 1., .25, shift );\n\n    result.flapsswitch = keypress( KEY_F ) * ( 1. - 2. * shift );\n    result.spoiltoggle = keypress( KEY_V );\n    result.gearstoggle = keypress( KEY_G );\n    result.gearbrake =\n        shiftmod * max( keystate( KEY_B ), keystate( KEY_SPACE ) );\n    result.lightstoggle = keypress( KEY_L );\n    result.throttlecommand =\n        keystate( KEY_SPACE ) > 0. ? -9999. :\n    \tvs.modes.z == VS_ENG_OFF ? 0. :\n        mix( 1., abs( vs.throttle ) < 0.1 ? .0625 : .25, shift ) * WASD.y;\n\n    result.joycommand = ZERO;\n    result.trimcommand = 0.;\n    result.trimdisplay = false;\n\n    if( vs.modes2.x != VS_AERO_OFF && meta > 0. )\n  \t{\n\t\tresult.trimdisplay = true;\n        result.trimcommand = mix( 1., .25, shift ) * -arrows.y;\n        arrows.y = 0.;\n\t}\n\n    result.joycommand =\n    \tshiftmod * vec3( -arrows.y, arrows.x, WASD.x );\n\n    result.tvecswitch = max( keypress( KEY_LESS ),\n\t\t\t\t        max( keypress( KEY_ACCENT_FIREFOX ),\n             \t\t\t\t keypress( KEY_ACCENT_CHROME ) ) ) * ( 2. * shift - 1. );\n\n    result.vjoy_copy = ZERO;\n    return result;\n}\n\n// ----------------------------------------------------------------------------\n// FRAME CONTEXT\n// ----------------------------------------------------------------------------\n\nstruct FrameContext\n{\n    float timeaccel;\n    int subframe_count;\n    float subframe_dt;\n    float dt;\n};\n\nFrameContext fr_init( vec4 dtime, bool local )\n{\n    FrameContext result;\n    float dt_frame = dot( dtime, vec4( 1, 2, 2, 1 ) / 6. );\n    result.timeaccel =\n        keystate( KEY_F4 ) > 0. && !local ? 10000. :\n        keystate( KEY_F3 ) > 0. ? 1000. :\n    \tkeystate( KEY_F2 ) > 0. ? 100. :\n        keystate( KEY_F1 ) > 0. ? 10. :\n    \t1.;\n\tresult.subframe_count = min( VS_MAX_ITER, int( ceil( sqrt( result.timeaccel ) ) ) );\n\tresult.subframe_dt = min( local ? VS_MAX_PACE_LOCAL : VS_MAX_PACE, dt_frame * result.timeaccel / float( result.subframe_count ) );\n    result.timeaccel = result.timeaccel == 1. ? 1. : float( result.subframe_count ) * safediv( result.subframe_dt, dt_frame );\n\tresult.dt = result.subframe_dt * float( result.subframe_count );\n    return result;\n}\n\n// ----------------------------------------------------------------------------\n// SCENE OBJECT\n// ----------------------------------------------------------------------------\n\nSceneObj so_init( vec4 navb, vec4 tybr )\n{\n\tSceneObj result;\n    result.r = nav2r( vec3( navb.xy, g_data.radius + navb.z ) );\n    result.B = bearing2B( result.r, navb.w );\n    result.tybr = tybr;\n\treturn result;\n}\n\nSceneObj so_init( const SceneData data )\n{\n\tSceneObj result = so_init( data.navb, data.tybr );\n    result.paramsA = data.paramsA;\n    result.paramsB = data.paramsB;\n    return result;\n}\n\nSceneObj so_end()\n{\n    SceneObj result = so_init( vec4(0), vec4( SCNOBJ_TYPE_INVALID, ZERO ) );\n    result.paramsA = result.paramsB = vec4(0);\n    return result;\n}\n\nint so_expand_to_primitives( SceneObj obj, int k, float timer, ivec2 addr, ivec2 sc, inout vec4 fc )\n{\n    int type = int( obj.tybr );\n    if( type == SCNOBJ_TYPE_TOWER )\n    {\n        obj.r -= obj.B[2] * obj.paramsB.z;\n        so_store( SceneObj( obj.B, obj.r, vec4( SCNOBJ_TYPE_PRIMITIVE, ZERO ), vec4( obj.paramsA.xyz, 2 ), obj.paramsB ), addr + ivec2( k, 0 ), sc, fc );\n        k++;\n        obj.r += obj.B * obj.paramsB.xyz;\n        obj.r -= obj.B[2] * obj.paramsA.w;\n        so_store( SceneObj( obj.B, obj.r, vec4( SCNOBJ_TYPE_PRIMITIVE, ZERO ), vec4( obj.paramsA.xyz, 2 ), vec4( obj.paramsB.ww, obj.paramsA.w, 0 ) ), addr + ivec2( k, 0 ), sc, fc );\n        k++;\n        obj.r -= obj.B[2] * ( obj.paramsA.w + 0.001 );\n        so_store( SceneObj( obj.B, obj.r, vec4( SCNOBJ_TYPE_PRIMITIVE, ZERO ), vec4( obj.paramsA.xyz, 2 ), vec4( obj.paramsB.ww + 0.001, 0.001, 0 ) ), addr + ivec2( k, 0 ), sc, fc );\n        k++;\n        obj.r -= obj.B[2] * ( 0.005 );\n        so_store( SceneObj( obj.B, obj.r, vec4( SCNOBJ_TYPE_PRIMITIVE, ZERO ), vec4( obj.paramsA.xyz, 2 ), vec4( obj.paramsB.ww + 0.002, 0.0005, 0 ) ), addr + ivec2( k, 0 ), sc, fc );\n        k++;\n        obj.r -= obj.B[2] * ( 0.003 );\n        float s = sin( timer ), c = cos( timer );\n        mat3 M = mat3( c, -s, 0, s, c, 0, 0, 0, 1 );\n        obj.B *= M;\n        so_store( SceneObj( obj.B, obj.r, vec4( SCNOBJ_TYPE_PRIMITIVE, ZERO ), vec4( obj.paramsA.xyz, 2 ), vec4( obj.paramsB.w, 0.0005, 0.0002, 0 ) ), addr + ivec2( k, 0 ), sc, fc );\n        k++;\n    }\n    else\n    if( type == SCNOBJ_TYPE_LIGHTHOUSE )\n    {\n        obj.r -= obj.B[2] * obj.paramsA.w;\n        so_store( SceneObj( obj.B, obj.r, vec4( SCNOBJ_TYPE_PRIMITIVE, ZERO ), vec4( -99, 10, 13, 3 ), vec4( obj.paramsB.w, obj.paramsA.w, 0, 0 ) ), addr + ivec2( k, 0 ), sc, fc );\n        k++;\n        obj.r += obj.B * vec3( obj.paramsB.xy, obj.paramsA.w );\n        obj.r -= obj.B[2] * obj.paramsB.z;\n        so_store( SceneObj( obj.B, obj.r, vec4( SCNOBJ_TYPE_PRIMITIVE, ZERO ), vec4( obj.paramsA.xyz, 2 ), obj.paramsB ), ADDR_SCENE_OBJECTS + ivec2( k, 0 ), sc, fc );\n        k++;\n        obj.r -= obj.B * vec3( obj.paramsB.xy, 2. * obj.paramsA.w );\n        obj.r -= obj.B[2] * ( 0.0005 - obj.paramsB.z );\n        so_store( SceneObj( obj.B, obj.r, vec4( SCNOBJ_TYPE_PRIMITIVE, ZERO ), vec4( obj.paramsA.xyz, 3 ), vec4( obj.paramsB.w + 0.0005, 0.0005, 0, 0 ) ), addr + ivec2( k, 0 ), sc, fc );\n        k++;\n        obj.r -= obj.B[2] * 0.0025;\n        so_store( SceneObj( obj.B, obj.r, vec4( SCNOBJ_TYPE_PRIMITIVE, ZERO ), vec4( obj.paramsA.xyz, 3 ), vec4( obj.paramsB.w - 0.0005, 0.0015, 0, 0 ) ), addr + ivec2( k, 0 ), sc, fc );\n        k++;\n        obj.r -= obj.B[2] * 0.0025;\n        so_store( SceneObj( obj.B, obj.r, vec4( SCNOBJ_TYPE_PRIMITIVE, ZERO ), vec4( obj.paramsA.xyz, 3 ), vec4( obj.paramsB.w, 0.00025, 0, 0 ) ), addr + ivec2( k, 0 ), sc, fc );\n        k++;\n    }\n    else\n    {\n        float offset =\n            type != SCNOBJ_TYPE_PRIMITIVE ? 0. :\n            obj.paramsA.w == 1. ? obj.paramsB.x :\n            obj.paramsA.w == 2. ? obj.paramsB.z :\n\t\t \tobj.paramsA.w == 3. ? obj.paramsB.y :\n        \t0.;\n\n        obj.r -= obj.B[2] * offset;\n        so_store( obj, addr + ivec2( k, 0 ), sc, fc );\n        k++;\n    }\n\n    return k;\n}\n\nvoid so_dynamic_bubblesort( int index, vec3 campos, ivec2 sc, inout vec4 fc )\n{\n    int phase = ( iFrame & 1 ) / 1;\n    int indexeven = ( ( index + phase ) & ~1 ) - phase;\n    SceneObj obj1 = so_load( iChannel0, ADDR_SCENE_DATA_OBJECTS + ivec2( indexeven + 0, 0 ) );\n    SceneObj obj2 = so_load( iChannel0, ADDR_SCENE_DATA_OBJECTS + ivec2( indexeven + 1, 0 ) );\n    float d1 = distance( campos, obj1.r ) * obj2.tybr.y;\n    float d2 = distance( campos, obj2.r ) * obj1.tybr.y;\n    bool inorder = int( obj1.tybr ) == SCNOBJ_TYPE_INVALID ||\n        \t\t   int( obj2.tybr ) == SCNOBJ_TYPE_INVALID ||\n         \t\t   d1 < d2;\n    so_store( obj1, ADDR_SCENE_DATA_OBJECTS + ivec2( indexeven + int( !inorder ), 0 ), sc, fc );\n    so_store( obj2, ADDR_SCENE_DATA_OBJECTS + ivec2( indexeven + int( inorder ), 0 ), sc, fc );\n}\n\n// ----------------------------------------------------------------------------\n// PLANET STATE\n// ----------------------------------------------------------------------------\n\nPlanetState ps_init( PlanetData data )\n{\n    PlanetState ps = PlanetState( ZERO, ZERO, 0., IDENTITY, ZERO, ZERO, 0., 0., 0., 0. );\n    ps.dnudt90 = safediv( TAU, data.orb_period * sqrt( abs( cube( 1. - data.orbit.e * data.orbit.e ) ) ) ) / 3600.;\n    ps.nu = PI - data.orbit.O - data.orbit.w;\n    ps.E = cvt_nu2E( ps.nu, data.orbit.e );\n\tps.M = cvt_E2M( ps.E, data.orbit.e );\n    ps.B[2] = vec3(\n\t\tcos( data.rot_northpole.x ) * cos( data.rot_northpole.y ),\n\t\tcos( data.rot_northpole.x ) * sin( data.rot_northpole.y ),\n\t\tsin( data.rot_northpole.x ) );\n    ps.B[0] = normalize( reject( -UNIT_X, ps.B[2] ) );\n    ps.B[1] = cross( ps.B[2], ps.B[0] );\n    ps.omega = safediv( TAU, data.rot_period * 3600. );\n    kepler_get_vectors( data.orbit, ps.nu, ps.dnudt90, ps.orbitr, ps.orbitv );\n    ps.r = ps.orbitr;\n    ps.v = ps.orbitv;\n    return ps;\n}\n\nvoid ps_pace( inout PlanetState ps, Kepler orbit, float dt )\n{\n    //*\n    ps.nu += dt * ps.dnudt90 * square( 1. + orbit.e * cos( ps.nu ) );\n    ps.E = cvt_nu2E( ps.nu, orbit.e );\n    ps.M = cvt_E2M( ps.E, orbit.e );\n    /*/\n\tps.M += ps.dMdt * dt;\n\tps.E = cvt_M2E( ps.M, orbit.e );\n\tps.nu = cvt_E2nu( ps.E, orbit.e );\n\t//*/\n\tps.B = spin( ps.B, dt * ps.omega * ps.B[2] );\n}\n\n// ----------------------------------------------------------------------------\n// FLIGHT DYNAMICS\n// ----------------------------------------------------------------------------\n\nfloat lift_efficiency_curve( float s, float c, vec4 config, float M )\n{\n    float z = mix( config.z, config.w, M / ( M + 3. ) );\n    return mix( z, config.w, c < 0. ? 1. : parabolstep( config.x, config.y, abs(s) ) );\n}\n\nfloat mach_curve( float M, float CD0, vec3 machcfg )\n{\n\tfloat c = safediv( machcfg.y - machcfg.z, CD0 + machcfg.z );\n\tfloat k = safediv( c, c + 1. );\n\tfloat b = ( 1. - machcfg.x ) * k;\n\treturn M < machcfg.x ? 0. : safediv( k * square( M - machcfg.x ), ( c * square( M - machcfg.x - b ) + b * b ) );\n}\n\nfloat delta_sincos( float s, float c, float ds, float dc )\n\t{ return ds * dc * ( c * c - s * s ) - 2. * ds * ds * s * c; }\n\nvoid compute_flight_dynamics(\n    const VehicleData vd,\n    float rho,\t\t\t// fluid density (TODO: Reynolds number)\n    float a,\t\t\t// local speed of sound\n    vec3 velo,\t\t\t// incoming wind velocity vector (= 'uvw' in body axes)\n    vec3 rates, \t\t// rotation rates (= 'pqr' in body axes)\n    vec3 ctrl,\t\t\t// control inputs 0..1 (de, da, dr)\n    vec3 fsg,\t\t\t// flaps/spoilers/gears\n    float wdelay,\t\t// time-lagged z component of the velo vector, must have an effective delay of c_bar/(2u) seconds\n    inout vec3 uvwdot,\t// = accelerations (body axes)\n    inout vec3 pqrdot,\t// = angular accelerations (body axes)\n\tinout vec3 info )\n{\n    vec3 XYZ = ZERO;\n    vec3 LMN = ZERO;\n\n    float S = vd.Sbcm.x;\n    float V2 = dot( velo, velo );\n    float QS = rho * V2 * S / 2.;\n\n    if( QS >= 1e-6 )\n    {\n        float V = sqrt( V2 );\n        float rcpV = 1. / V;\n\n        mat3x3 W; // wind axes frame\n        W[0] = velo * rcpV;\n\n        float b = vd.Sbcm.y,\tc_bar = vd.Sbcm.z;\n        float u = W[0].x, \t\tp = rates.x * rcpV * b / 2.;\n        float v = W[0].y,\t\tq = rates.y * rcpV * c_bar / 2.;\n        float w = W[0].z,\t\tr = rates.z * rcpV * b / 2.;\n        float sin_b = W[0].y,\tcos_b = length( W[0].xz );\n\n        W[2] = safediv( cross( W[0], UNIT_Y ), cos_b );\n        W[1] = cross( W[2], W[0] );\n\n        float sin_a = -W[2].x,\t\t\tcos_a = W[2].z;\n        float sin_b_cos_a = -W[1].x,\tadot_hat = w - wdelay * rcpV;\n\n    \tvec3 sinctrl = sinatan( ctrl * vd.dx_max );\n    \tvec3 cosctrl = cosatan( ctrl * vd.dx_max );\n        float d_wu_de = delta_sincos( w, u, sinctrl.x, cosctrl.x );\n\t\tfloat d_wu_da = delta_sincos( w, u, sinctrl.y, cosctrl.y );\n        float d_uv_dr = delta_sincos( sin_b_cos_a, u, sinctrl.z, cosctrl.z );\n\n        float M = V / a;\n        float eta = lift_efficiency_curve( sin_a, cos_a, vd.etaCL, M );\n        float invkD = 1. - vd.kD;\n\n        vec4 CD_inputs = vec4( 1, w*w, v*v, 0 );\n    \tvec4 CL_inputs = vec4( u, w*u, q*u, d_wu_de );\n    \tvec4 CY_inputs = vec4( u*v, p*u, r*u, d_uv_dr );\n    \tvec4 Cl_inputs = vec4( u*v * invkD, p*u, r*u, d_wu_da );\n        vec2 Cm90_inputs = vec2( w*w, q*w ) * w;\n        vec2 Cnside_inputs = vec2( v*v, r*v ) * v;\n\n    \tvec4 config = vec4( vd.dC_matrix * fsg, vd.dClb_g * fsg.z );\n\n        vec4 CD_coeffs = vec4( vd.CD.x + config.x, vd.CD.yzw );\n    \tvec4 CL_coeffs = vec4( vd.CL.x + config.y, vd.CL.yzw * eta );\n    \tvec4 Cm_coeffs = vec4( vd.Cm.x + config.z, vd.Cm.yzw * eta ) * cos_a;\n    \tvec4 Cn_coeffs = vd.Cn * u;\n    \tvec4 Cl_coeffs = vec4( vd.Cl.x + config.w, vd.Cl.yzw ) * vec4( u,u,u, eta * cos_a );\n        vec2 adot_coeffs = vd.Cadot * eta * vec2( 1, cos_a );\n\n        CD_inputs.w = square( dot( CD_coeffs.yzw, CD_inputs.yzw ) );\n        float machdrag = mach_curve( M, vd.CD.x, vd.mach );\n\n        float CD = dot( CD_coeffs, CD_inputs )\t\t\t\t\t// drag force coeff\n\t\t\t\t   \t+ vd.mach.y * machdrag;\t\t\t\t\t\t// + supersonic drag\n\n        float CL = dot( CL_coeffs, CL_inputs )\t\t\t\t\t// lift force coeff\n        \t  \t   \t+ adot_coeffs.x * adot_hat * u;\t\t\t\t// + wake delay for lift (CL_adot)\n\n        float Cm = dot( Cm_coeffs, CL_inputs )\t\t\t\t\t// pitching moment coeff\n        \t\t\t+ adot_coeffs.y * adot_hat * u       \t\t// + wake delay for pitch (Cm_adot)\n        \t\t\t+ dot( vd.Cm90, Cm90_inputs )\t\t\t\t// + pitching moment at high alpha\n        \t\t\t+ vd.Cmi * CD_inputs.w * sin_a;\t\t\t\t// + pitching moment from induced drag\n\n        float CY = dot( vd.CY, CY_inputs );\t\t\t\t\t\t// side force coeff\n\n    \tfloat Cn = dot( Cn_coeffs, CY_inputs )   \t\t\t\t// yawing moment coeff\n        \t\t\t+ dot( vd.Cnside, Cnside_inputs );\t\t\t// + yawing moment at high beta\n\n\t\tfloat ClCn = safediv( vd.Cl.x, vd.Cn.x ) * invkD;\n\n        float Cl = dot( Cl_coeffs, Cl_inputs )\t\t\t\t\t// rolling moment coeff\n        \t\t\t+ dot( vd.Cnside, Cnside_inputs ) * ClCn\t// + rolling moment at high beta\n        \t\t\t+ vd.Cl.x * eta * u*u * sin_b * vd.kD\t\t// + dihedral effect\n\t\t\t\t\t+ vd.Clab * eta * w*u * sin_b;\t    \t  \t// + wing sweep effect\n\n        vec3 CL_inputs_F = vec3( v, w*v, q*v ) * cos_b;\t\t\t// CL_inputs with u exchanged for v cos_b\n        vec3 CY_inputs_F = vec3( w*v, p*w, r*w );\t\t\t\t// CY_inputs with u exchanged for w\n\n        float CF = dot( CL_coeffs.xyz, CL_inputs_F ) \t\t\t// CF = ( CL * sin_b + CY * sin_a ) / cos_a\n            \t    + dot( vd.CY.xyz, CY_inputs_F );\t\t\t// rewritten to eliminate division by zero at a = 90\u00b0\n\n    \tfloat CQ = CY * cos_a + CF * sin_a;\t\t\t\t\t\t// combined lateral force coeff\n\n        XYZ += QS * W * vec3( -CD, CQ, -CL );\t\t\t\t\t// = forces\n\t\tLMN += QS * vec3( Cl, Cm, Cn ) * vec3( b, c_bar, b );\t// = moments\n\n    \tinfo.x = CL;\n        info.y = CD;\n        info.z = atan( sin_a, cos_a );\n\t}\n\n   \t// linear accelerations\n    float invm = safediv( FDM_MASS_SCALE, vd.Sbcm.w );\n    uvwdot = XYZ * invm /* + cross( uvw, pqr ) */;\n\n    // angular accelerations, incl inertia\n    LMN += ( rates.yzx * rates.zxy * ( vd.I.yzx - vd.I.zxy ) + cross( rates, vec3( rates.xz, 0 ).yzx ) * vd.I.w ) / FDM_MASS_SCALE;\n    pqrdot.y = safediv( LMN.y * FDM_MASS_SCALE, vd.I.y );\n    pqrdot.xz = - ( vd.I.zw * LMN.x + vd.I.wx * LMN.z ) * safediv( FDM_MASS_SCALE, determinant( mat2( vd.I.wx, vd.I.zw ) ) );\n}\n\n// ----------------------------------------------------------------------------\n// VEHICLE STATE\n// ----------------------------------------------------------------------------\n\nvoid vs_cvt_local2orbit( inout VehicleState vs, PlanetState ps )\n{\n    vec3 localpsomega = vec3( 0, 0, ps.omega );\n    vs.orbitr = ps.B * ( vs.localr );\n    vs.orbitv = ps.B * ( vs.localv + cross( localpsomega, vs.localr ) );\n    vs.B = ps.B * ( vs.localB );\n \tvs.omega = ps.B * ( vs.localomega + localpsomega );\n}\n\nvoid vs_cvt_orbit2local( inout VehicleState vs, PlanetState ps )\n{\n    vec3 localpsomega = vec3( 0, 0, ps.omega );\n    vs.localr = vs.orbitr * ps.B;\n    vs.localv = vs.orbitv * ps.B - cross( localpsomega, vs.localr );\n    vs.localB = transpose( ps.B ) * vs.B;\n\tvs.localomega = vs.omega * ps.B - localpsomega;\n}\n\nvoid vs_cvt_orbit2global( inout VehicleState vs, PlanetState ps )\n{\n    vs.r = vs.orbitr + ps.r;\n    vs.v = vs.orbitv + ps.v;\n}\n\nvoid vs_cvt_global2orbit( inout VehicleState vs, PlanetState ps )\n{\n    vs.orbitr = vs.orbitr - ps.r;\n    vs.orbitv = vs.orbitv - ps.v;\n}\n\nvoid vs_commit_local( inout VehicleState vs, PlanetState ps )\n{\n    vs_cvt_local2orbit( vs, ps );\n    vs_cvt_orbit2global( vs, ps );\n    vs.localr_diff = ZERO;\n    vs.localr_base = vs.localr;\n}\n\nvoid vs_reset_to_orbiting( inout VehicleState vs, PlanetState ps, vec4 navb, bool downfacing )\n{\n    vs = vs_init();\n    float R = navb.z + g_data.radius;\n    vs.localr = nav2r( vec3( navb.xy, R ) );\n    vs.localB = bearing2B( vs.localr, navb.w );\n    if( downfacing )\n\t    { rot90( vs.localB[1], vs.localB[0] ); rot90( vs.localB[0], vs.localB[2] ); }\n    vs.orbitr = ps.B * vs.localr;\n    vs.B = ps.B * vs.localB;\n    vs.orbitv = sqrt( g_data.GM / R ) * normalize( downfacing ? vs.B[1] : vs.B[0] );\n    vs.omega = cross( vs.orbitr, vs.orbitv ) / dot( vs.orbitr, vs.orbitr );\n    vs_cvt_orbit2local( vs, ps );\n    vs_cvt_orbit2global( vs, ps );\n    vs.modes = ivec3( VS_HMD_ORB, 0, VS_ENG_IMP );\n    vs.modes2 = ivec3( 0, VS_RCS_LVLH, VS_THR_MAN );\n}\n\nvoid vs_reset_to_offroad( inout VehicleState vs, PlanetState ps, vec4 navb )\n{\n    vs = vs_init();\n    float R = navb.z + g_data.radius;\n    vs.localr = nav2r( vec3( navb.xy, R ) );\n    vs.localB = bearing2B( vs.localr, navb.w );\n    vs_commit_local( vs, ps );\n    vs.FSG.z = 1.;\n    vs.modes = ivec3( VS_HMD_SFCE, 0, VS_ENG_DRV );\n    vs.modes2 = ivec3( VS_AERO_MAN, 0, VS_THR_MAN );\n    vs.switches |= VS_GEARS;\n}\n\nvoid vs_reset_to_threshold( inout VehicleState vs, PlanetState ps, SceneObj runway, float sense )\n{\n    vs = vs_init();\n\tvs.localr = runway.r - runway.B[0] * sense * ( runway.paramsB.x / 2. - 30. ) / 1000.;\n    vs.localB[0] = runway.B[0] * sense;\n    vs.localB[1] = cross( vs.localB[0], normalize( vs.localr ) );\n    vs.localB[2] = cross( vs.localB[0], vs.localB[1] );\n    vs_commit_local( vs, ps );\n    vs.FSG.z = 1.;\n    vs.modes = ivec3( VS_HMD_SFCE, 0, VS_ENG_IMP );\n    vs.modes2 = ivec3( VS_AERO_MAN, 0, VS_THR_MAN );\n    vs.switches |= VS_GEARS;\n}\n\nvoid vs_realize_startpos( inout GameState gs, inout VehicleState vs, PlanetState ps, StartData start )\n{\n#if WORKAROUND_03_SWITCH\n\tif( start.iparams.x == 1 )\n        vs_reset_to_orbiting( vs, ps, start.params * vec4( 1, 1, ATM_SCALE, 1 ), bool( start.iparams.y ) );\n\telse\n    if( start.iparams.x == 2 )\n        vs_reset_to_offroad( vs, ps, start.params * vec4( 1, 1, TRN_SCALE, 1 ) );\n    else\n\tif( start.iparams.x == 3 && start.iparams.y < ADDR_SCENE_DATA_COUNT )\n\t\tvs_reset_to_threshold( vs, ps,\n\t\t\tso_init( sd_load( iChannel1, ivec2( 0, ADDR_B_SCENEDATA + ADDR_SCENE_DATA_SIZE * start.iparams.y ) ) ),\n\t\t\tstart.params.x );\n#else\n   \tswitch( start.iparams.x )\n    {\n    case 1:\n        vs_reset_to_orbiting( vs, start.params * vec4( 1, 1, ATM_SCALE, 1 ), bool( start.iparams.y ) );\n        break;\n    case 2:\n        vs_reset_to_offroad( vs, start.params * vec4( 1, 1, TRN_SCALE, 1 ) );\n        break;\n    case 3:\n        if( start.iparams.y < g_scene_data_length )\n        \tvs_reset_to_threshold( vs,\n\t\t\t\tso_init( sd_load( iChannel1, ivec2( 0, ADDR_B_SCENEDATA + ADDR_SCENE_DATA_SIZE * start.iparams.y ) ) ),\n\t\t\t\tstart.params.x );\n        break;\n    }\n#endif\n\n    if( start.iparams.w > 0 && start.iparams.w < ADDR_SCENE_DATA_COUNT )\n        gs.waypoint = nav2r( sd_load( iChannel1, ivec2( 0, ADDR_B_SCENEDATA + ADDR_SCENE_DATA_SIZE * start.iparams.w ) ).navb.xyz + UNIT_Z * g_data.radius );\n}\n\nvoid vs_pace_switches( inout VehicleState vs, VehicleInputs vi )\n{\n    vs.switches = ( vs.switches & ~( VS_FLAPS_MASK | VS_TVEC_MASK ) ) |\n        ( uint( clamp( float( ( vs.switches & VS_FLAPS_MASK ) >> VS_FLAPS_SHIFT ) + vi.flapsswitch, 0., 3. ) ) << VS_FLAPS_SHIFT ) |\n        ( uint( clamp( float( ( vs.switches & VS_TVEC_MASK ) >> VS_TVEC_SHIFT ) + vi.tvecswitch, 0., 6. ) ) << VS_TVEC_SHIFT );\n\n    if( vi.spoiltoggle != 0. )\n    \tvs.switches ^= VS_SPOIL;\n\n    if( vi.gearstoggle != 0. )\n    \tvs.switches ^= VS_GEARS;\n\n    if( vi.lightstoggle != 0. )\n    \tvs.switches ^= VS_LIGHT;\n}\n\nvoid vs_pace_FSG( inout VehicleState vs, VehicleInputs vi, float dt )\n{\n    vec3 FSG_target = vec3(\n        float( square( ( vs.switches & VS_FLAPS_MASK ) >> VS_FLAPS_SHIFT ) ) / 9.,\n        float( ( vs.switches & VS_SPOIL ) == VS_SPOIL ),\n        float( ( vs.switches & VS_GEARS ) == VS_GEARS ) );\n\tvec3 FSG_move = vec3( .125, .5, .125 );\n    vec3 FSG_delta = dt * clamp( 8. * ( FSG_target - vs.FSG ), -FSG_move, FSG_move );\n    vs.FSG = clamp( vs.FSG + FSG_delta, -1., 1. );\n\n   \tfloat tvec = float( ( vs.switches & VS_TVEC_MASK ) >> VS_TVEC_SHIFT );\n    float tvec_target = tvec * ( 84. + tvec * ( tvec * 3. - 27. ) );\n    float tvec_move = 15.;\n    float tvec_delta = dt * clamp( 25. * ( tvec_target - vs.tvec ), -tvec_move, tvec_move );\n    vs.tvec = clamp( vs.tvec + tvec_delta, 0., 180. );\n}\n\nvoid vs_pace_throttle( inout VehicleState vs, VehicleInputs vi, float dt )\n{\n    if( vi.throttlecommand == -9999. )\n        vs.throttle = 0.;\n    else\n    {\n        float modelimit = vs.modes.z == VS_ENG_IMP ? -0.15 : -1.;\n    \tfloat tmin = ( vs.switches & VS_THROTTLE_EDGE ) == 0u ? modelimit :\n        \tvs.throttle >= 0. ? 0. : modelimit;\n    \tfloat tmax = ( vs.switches & VS_THROTTLE_EDGE ) == 0u ? 1. :\n        \tvs.throttle <= .00 ? .00 :\n        \tvs.throttle <= .15 ? .15 :\n        \tvs.throttle <= .35 ? .35 :\n        \tvs.throttle <= .70 ? .70 : 1.;\n    \tvs.switches = ( vs.switches & ~VS_THROTTLE_EDGE ) | ( VS_THROTTLE_EDGE * uint( vi.throttlecommand != 0. && vs.thr_hold < .5 ) );\n        float delta = .25 * dt * vi.throttlecommand;\n        vs.thr_hold = vs.throttle + delta > tmax ? vs.thr_hold + 4. * ( vs.throttle + delta - tmax ) : 0.;\n    \tvs.throttle = clamp( vs.throttle + delta, tmin, tmax );\n    }\n}\n\nvoid vs_pace_EAR_and_trim( inout VehicleState vs, VehicleInputs vi, float dt )\n{\n\n    vec3 target = ZERO;\n    if( vs.modes2.x == VS_AERO_MAN )\n    {\n\t\tvs.trim = clamp( vs.trim + dt * .0625 * vi.trimcommand, -1., 1. );\n    \ttarget = vi.vjoy_copy + vs.trim * UNIT_X;\n    }\n    else\n\tif( vs.modes2.x == VS_AERO_ATR )\n\t\ttarget = vec3( vs.aerostuff.yw, vi.vjoy_copy.z );\n\n\ttarget = clamp( target, -1., 1. );\n    vec3 delta = dt * clamp( 8. * ( target - vs.EAR ), -2., 2. );\n    vs.EAR = clamp( vs.EAR + delta, -1., 1. );\n}\n\nvoid vs_pace_RCS( VehicleState vs, VehicleInputs vi, PlanetState ps, float dt,\n                  inout vec3 dLout, bool localphysics, bool pausemode )\n{\n    const float MAX_RCS_THRUST = 0.06;\t// TODO: CONFIG\n\n    vec3 thrustercommand = ZERO;\n    vec3 joycmd = vi.joycommand.yxz * vec3( 1, 1, -1 );\n\n    if( vs.modes2.y == VS_RCS_MAN )\n        thrustercommand = joycmd * MAX_RCS_THRUST;\n    else\n\tif( vs.modes2.y != VS_RCS_OFF )\n    {\n        vec3 bodyomega = vs.omega * vs.B;\n        vec3 targetomega = radians( 12. ) * joycmd;\n\n        if( vs.modes2.y == VS_RCS_LVLH )\n        {\n        \tvec3 localpsomega = vec3( 0, 0, ps.omega );\n        \tif( !pausemode )\n        \t\ttargetomega += cross( vs.orbitr, vs.orbitv ) / dot( vs.orbitr, vs.orbitr ) * vs.B;\n        }\n\n        targetomega = length( targetomega ) < .25 ? targetomega : normalize( targetomega );\n      \tthrustercommand = clamp( targetomega - bodyomega, -MAX_RCS_THRUST, MAX_RCS_THRUST );\n    }\n\n\tvec3 dL = -expm1( -dt * 2. ) * thrustercommand;\n    dLout += ( localphysics ? vs.localB : vs.B ) * dL;\n}\n\nvoid vs_pace_thrust( VehicleState vs, float dt,\n                     inout vec3 dv, bool localphysics )\n{\n    if( vs.modes.z == VS_ENG_IMP )\n    {\n    \tconst float T_max = g_vehicle_data[ USE_VEHICLE_INDEX ].T_max;\n    \tconst float mass = g_vehicle_data[ USE_VEHICLE_INDEX ].Sbcm.w / FDM_MASS_SCALE;\n        vec2 sct = sincospi( vs.tvec / 180. );\n        vec3 tvec = vec3( sct.y, 0, -sct.x );\n    \tdv += 0.001 * dt * vs.throttle * T_max / mass * ( ( localphysics ? vs.localB : vs.B ) * tvec );\n    }\n}\n\nvoid vs_pace_flight_dynamics( inout VehicleState vs, LocalEnvironment env, float dt, inout vec3 dv, inout vec3 dL )\n{\n    vec3 uvw = 1000. * vs.localv * vs.localB;\n    vec3 pqr = vs.localomega * vs.localB;\n    vec3 uvwdot = ZERO, pqrdot = ZERO;\n    float invtau = 2. * abs( uvw.x ) / ( g_vehicle_data[ USE_VEHICLE_INDEX ].Sbcm.z );\n\n    compute_flight_dynamics(\n        g_vehicle_data[ USE_VEHICLE_INDEX ],\n        env.atm.z,\n        env.atm.w * 1000.,\n        uvw,\n        pqr,\n        vec3( -vs.EAR.x, vs.EAR.yz ),\n        vs.FSG,\n        vs.wdelay,\n        uvwdot,\n        pqrdot,\n        vs.info.xyz );\n\n    vs.wdelay -= expm1( -dt * invtau ) * ( uvw.z - vs.wdelay );\n    dv += dt * vs.localB * ( uvwdot /* - cross( uvw, pqr ) */ ) / 1000.;\n    dL += dt * vs.localB * pqrdot;\n}\n\nvec3 calc_gravity_relief( vec3 r, vec3 v )\n{\n    vec3 omega = cross( r, v ) / dot( r, r );\n\treturn cross( omega, cross( omega, r ) );\n}\n\nvec3 calc_gravity( vec3 r )\n{\n    float r2 = dot( r, r );\n    return r2 < square( g_data.radius ) ?\n        - g_data.GM / cube( g_data.radius ) * r :\n        - g_data.GM / ( r2 * sqrt( r2 ) ) * r;\n}\n\nvoid vs_pace_fly_by_wire( inout VehicleState vs, VehicleInputs vi, LocalEnvironment env, float dt )\n{\n    VehicleData vd = g_vehicle_data[ USE_VEHICLE_INDEX ];\n\n    float V2 = max( .0001, dot( vs.localv, vs.localv ) );\n    float Q = max( .02, .5 * ( 1e6 / 1e5 ) * env.atm.z * V2 );\n\n    float c = length( reject( normalize( vs.localv ), normalize( vs.localr ) ) );\n    float d = length( reject( normalize( vs.localB[1] ), normalize( vs.localr ) ) );\n    vec3 gr = calc_gravity( vs.orbitr );\n    vec3 gr_relief = calc_gravity_relief( vs.orbitr, vs.orbitv );\n    float g0 = length( gr - gr_relief ) * c / max( .65, d );\n    float thr = -0.0005 * vs.throttle * vd.T_max / vd.Sbcm.w * sin( radians( vs.tvec ) );\n    float cmd = ( ( vi.vjoy_copy.x < 0. ? -3. : 9. ) * FDM_STD_G / 1000. - g0 - thr ) * abs( vi.vjoy_copy.x );\n\n    float V = sqrt( V2 );\n    vec3 uvw = vs.localv * vs.localB / V;\n    vec3 pqr = vs.localomega * vs.localB * vd.Sbcm.yzy / ( 2000. * V );\n    float adot = ( dot( gr, vs.B[2] ) + vs.acc.z ) * vd.Sbcm.z / ( 2000. * V2 ) + pqr.y;\n    float eta = lift_efficiency_curve( uvw.z, uvw.x, vd.etaCL, V / env.atm.w );\n    vec3 config = vd.dC_matrix * vs.FSG;\n\n    const float ki = .25;\n    const float kp = .2;\n    const float kd = 18.;\n\n    vs.aerostuff.x = clamp( vs.aerostuff.x + dt * ( cmd + g0 + thr + vs.acc.z ), -.01, .01 );\n\n    float acctgt = ( cmd + g0 + thr + ki * vs.aerostuff.x );\n    float CLtgt = clamp( acctgt * vd.Sbcm.w / ( Q * vd.Sbcm.x * 100. ), -2., 2. );\n    float CLtgt_a = CLtgt - vd.CL.x - config.y + vd.CL.w * vs.EAR.x * vd.dx_max.x * eta;\n    float atgt = clamp( CLtgt_a / ( vd.CL.y * eta ), -.5, .5 );\n    float aerr = env.atm.z * ( atgt - uvw.z ) - kd * adot;\n    float adottgt = clamp( env.atm.z * kp * aerr, -2., 2. );\n    float qtgt = adottgt + pqr.y - adot;\n\n    float Cmtgt_de = vd.Cm.x + config.z + vd.Cm.y * atgt * eta + vd.Cm.z * qtgt * eta;\n    vs.aerostuff.y = Cmtgt_de / ( vd.Cm.w * vd.dx_max.x * eta );\n\n    float ptgt = 5. * vi.vjoy_copy.y * vd.Sbcm.y / ( 2000. * V );\n\n    vs.aerostuff.z = clamp( vs.aerostuff.z + dt * ( ptgt - pqr.x ), -.02, .02 );\n\n    ptgt += .5 * vs.aerostuff.z;\n\n    float Cltgt_da = ( vd.Cl.x + vd.dClb_g * vs.FSG.z ) * uvw.y * ( 1. - vd.kD ) + vd.Cl.y * ptgt + vd.Cl.z * pqr.z;\n    vs.aerostuff.w = -Cltgt_da / ( vd.Cl.w * vd.dx_max.y );\n}\n\nbool vs_pace_ground_interaction( VehicleState vs, VehicleInputs vi, TrnSampler ts, float dt,\n                                 inout vec3 dv, inout vec3 domega, inout vec3 dr )\n{\n    vec4 localterrain = ts_sample( ts, iChannel1, vs.localr );\n\n    bool result = false;\n    vec3 tentative_localv = vs.localv + dv;\n    vec3 N = normalize( localterrain.xyz );\n    float bN = dot( vs.localr_base, N );\n    float dN = dot( vs.localr_diff + dr, N );\n    float tN = dot( normalize( vs.localr ), N ) * ( localterrain.w + g_data.radius );\n   \tfloat gearcoord = - 0.0015 * vs.FSG.z;\n    float clearance = dN - FORCE_EVAL( tN - bN ) + gearcoord;\n\tfloat dotvN = dot( tentative_localv, N );\n    float error_in_r = 4. * length( vs.localr ) / 8388608.;\n\tfloat error_in_v = 4. * length( tentative_localv ) / 8388608.;\n\n    if( dotvN < -error_in_v && clearance < error_in_r - dt * dotvN )\n    {\n        result = true;\n\n       \t// handle friction, drive and steering\n\t\tvec3 T = reject( vs.localB[0], N );\n        if( dot( T, T ) >= 1e-6 )\n        {\n            T = normalize(T);\n        \tvec3 B = normalize( cross( T, N ) );\n        \tfloat dotvT = dot( tentative_localv, T );\n        \tfloat dotvB = dot( tentative_localv, B );\n           \tfloat dotomegaN = dot( vs.localomega, N );\n    \t\tfloat cT = vs.FSG.z >= .25 ? 0.90 : 0.60;\n        \tconst float cB = 0.60; // TODO: config\n        \tconst float comega = 600.; // TODO: config\n            const float cnb = 15.; // TODO: config\n            const float turnradius = 0.007; // TODO: config\n            const float maxspeed = 0.036; // TODO: config\n\n            float steer = 1. / turnradius * clamp( vs.EAR.z, -1., 1. ) * dotvT;\n            float maxdvup = dt * ( dotvT < 0. ? 0.045 : min( 0.045, 0.0004 / abs( dotvT ) ) );\n            float maxdvdn = dt * ( dotvT < 0. ? min( 0.045, 0.0004 / abs( dotvT ) ) : 0.045 );\n        \tfloat drive =\n                vs.FSG.z < .25 ? 0. :\n            \tvs.modes.z != VS_ENG_DRV || vi.gearbrake > 0. ?\n                   \tsign( dotvT ) * max( 0., abs( dotvT ) - mix( 0.001 * dt, -cT * dotvN, vi.gearbrake ) ) :\n                    clamp( vs.throttle * maxspeed, ( dotvT ) - maxdvdn, ( dotvT ) + maxdvup );\n\n            // friction works to reduce slip up to a maximum delta-v budget per frame\n            dv -= sign( dotvT - drive ) * min( abs( dotvT - drive ), -cT * dotvN ) * T;\n\t\t\tdv -= sign( dotvB ) * min( abs( dotvB ), -cB * dotvN ) * B;\n\n            float dotvB_new = dot( vs.localv + dv, B );\n            float domegatarget = dotomegaN - steer + cnb * dotvB_new;\n            domega -= sign( domegatarget ) * min( abs( domegatarget ), -comega * dotvN ) * N;\n        }\n\n\t\t// force vehicle to contact position\n        float u = -clearance / dotvN;\n        if( error_in_v > 0. )\n\t\t\tdr += u * tentative_localv;\n\n       \t// eliminate normal velocity component\n        dv -= dotvN * N;\n\n        // advance to end of frame using new v\n        dr += ( dt - u ) * ( vs.localv + dv );\n\n       \t// add spring and damping to align upwards (wheel springs)\n        float spring = min( 2. / dt, dt > 0. ? 1000. * max( 0., -dotvN / dt ) : 0. ); // TODO: config\n        domega -= dt * spring * cross( vs.localB[2], N );\n        domega -= dt * spring * cross( cross( N, vs.localomega ), N ) * .2;\n    }\n\n    return result;\n}\n\nvoid vs_pace_beginframe( inout VehicleState vs, bool localphysics )\n{\n    if( localphysics )\n    {\n        vec3 d = FORCE_EVAL( vs.localr - vs.localr_base );\n        if( dot( d, d ) >= 1. )\n        {\n\t        vs.localr_diff -= d;\n    \t    vs.localr_base = vs.localr;\n        }\n    }\n}\n\nvoid vs_pace_halfstep( inout VehicleState vs, VehicleInputs vi,\n                       float dt, bool localphysics, bool pausemode )\n{\n    vs_pace_FSG( vs, vi, dt );\n    vs_pace_throttle( vs, vi, dt );\n    vs_pace_EAR_and_trim( vs, vi, dt );\n\n    if( localphysics )\n    {\n        if( !pausemode )\n        {\n\t\t    vs.localr_diff += dt * vs.localv;\n            vs.localr = vs.localr_base + vs.localr_diff;\n        }\n    }\n    else\n    {\n\t\tif( !pausemode )\n        \tvs.orbitr += dt * vs.orbitv;\n    }\n}\n\nvoid vs_pace_midframe( inout VehicleState vs, VehicleInputs vi, LocalEnvironment env,\n                       TrnSampler ts, PlanetState ps, float dt, bool localphysics, bool pausemode )\n{\n    vec3 dvsum = ZERO;\n    if( localphysics )\n    {\n\t\tvec3 localpsomega = vec3( 0, 0, ps.omega );\n        vec3 gr_static = calc_gravity( vs.localr );\n        vec3 gr_centrifugal = cross( localpsomega, cross( localpsomega, vs.localr ) );\n\n        float min_dt = inversesqrt( 1. + 1000. * env.atm.z * ( 1. + env.atm.z * dot( vs.localv, vs.localv ) ) );\n        int n = clamp( int( ceil( dt / min_dt ) ), FDM_MIN_ITER, FDM_MAX_ITER );\n        float dt_inner = dt / float(n);\n\n        vec3 dr = ZERO;\n        for( int i = 0; i < n; ++i )\n        {\n            vec3 gr_coriolis = 2. * cross( localpsomega, vs.localv );\n            vec3 gr = gr_static - gr_centrifugal - gr_coriolis;\n            if( pausemode )\n                gr -= calc_gravity_relief( vs.localr, vs.localv );\n\t\t\tvec3 dv = dt_inner * gr;\n\t        vec3 domega = ZERO;\n\n            vs_pace_RCS( vs, vi, ps, dt_inner, domega, true, pausemode );\n            vs_pace_thrust( vs, dt_inner, dv, true );\n            vs_pace_flight_dynamics( vs, env, dt_inner, dv, domega );\n\t\t\tif( vs_pace_ground_interaction( vs, vi, ts, dt_inner, dv, domega, dr ) )\n                vs.info.w = 1.;\n\n            float dv_safety_limit = length( dv ) < 1e-12 ? 1. : min( 1., ( 0.25 + length( vs.localv ) ) / ( 4. * length( dv ) ) );\n            float domega_safety_limit = length( domega ) < 1e-12 ? 1. : min( 1., ( 0.25 + length( vs.localomega ) ) / ( 4. * length( domega ) ) );\n            float limit = min( dv_safety_limit, domega_safety_limit );\n\n            if( 2 * n < FDM_MAX_ITER + i && limit < 1. )\n            {\n            \tn += n - i;\n            \tdt_inner /= 2.;\n                continue;\n            }\n\n            dvsum += dv * limit - dt_inner * gr;\n            vs.localv += dv * limit;\n            vs.localomega += domega * limit;\n\t\t\tvs.localB = spin( vs.localB, dt_inner * vs.localomega );\n        }\n\n        if( dot( dr, dr ) > 0. )\n        {\n            vs.localr_diff += dr - dt * vs.localv;\n            vs.localr += vs.localr_base + vs.localr_diff;\n        }\n\n        if( vs.modes2.x == VS_AERO_ATR )\n        \tvs_pace_fly_by_wire( vs, vi, env, dt );\n    }\n    else\n    {\n\t\tvec3 gr = calc_gravity( vs.orbitr );\n        if( pausemode )\n        \tgr -= calc_gravity_relief( vs.orbitr, vs.orbitv );\n        vec3 dv = ZERO;\n        vec3 domega = ZERO;\n\t\tvs_pace_RCS( vs, vi, ps, dt, domega, false, pausemode );\n        vs_pace_thrust( vs, dt, dv, false );\n    \tvs.orbitv += ( dvsum = dv ) + dt * gr;\n        vs.omega += domega;\n        vs.B = spin( vs.B, dt * vs.omega );\n    }\n    vs.acc = safediv( dvsum, dt ) * ( localphysics ? vs.localB : vs.B );\n    vs.accz -= expm1( -dt * vec3( 8., 16., 32. ) ) * ( vs.acc.z - vs.accz );\n}\n\nvoid vs_pace_endframe( inout VehicleState vs, PlanetState ps, float dt, bool localphysics )\n{\n    if( localphysics )\n    {\n        vs.localr = vs.localr_base + vs.localr_diff;\n        vs_cvt_local2orbit( vs, ps );\n    }\n    else\n    {\n        vs_cvt_orbit2local( vs, ps );\n        vs.localr_diff = ZERO;\n        vs.localr_base = vs.localr;\n    }\n    vs_cvt_orbit2global( vs, ps );\n}\n\n// ----------------------------------------------------------------------------\n// MESSAGE QUEUE\n// ----------------------------------------------------------------------------\n\nvoid msg_push( inout MsgQueue msg, uvec4 phrase, vec4 argv )\n{\n    if( msg.state.x < float( TXT_MSG_MAX_PHRASES - 2 ) )\n    {\n        if( msg.state.x < 0. )\n            msg.state.x++;\n\t\tmsg.state.x++;\n        if( int( ceil( msg.state.x ) ) == g_msgindex )\n        {\n            msg.phrase = phrase;\n            msg.argv = argv;\n        }\n    }\n}\n\nvoid msg_push_if_empty( inout MsgQueue msg, uvec4 phrase, vec4 argv )\n{\n\tif( msg_empty( msg ) )\n\t\tmsg_push( msg, phrase, argv );\n}\n\nvoid msg_store( MsgQueue self, ivec2 addr, ivec2 sc, inout vec4 fc )\n{\n    memstore( self.state, addr, 0, sc, fc );\n    if( g_msgindex >= 0 && g_msgindex < TXT_MSG_MAX_PHRASES )\n    {\n    \tmemstore( pack_uvec4( self.phrase ), addr, g_msgindex + 1, sc, fc );\n    \tmemstore( self.argv, addr, g_msgindex + 1 + TXT_MSG_MAX_PHRASES, sc, fc );\n    }\n}\n\n// ----------------------------------------------------------------------------\n// GAME STATE\n// ----------------------------------------------------------------------------\n\nvoid gs_check_menu_item( inout GameState gs, int i, int p )\n{\n\tif( keypress( KEY_1 + i ) == 1. )\n\t{\n        int curr = p + i;\n        int next = int( md_load( iChannel0, p + i ).w >> 8 ) & 0xff;\n        gs.menustate.x = next == 0 ? 0 : curr;\n        gs.menustate.y = next == 0 ? curr : 0;\n        gs.menustate.z = gs.menustate.y;\n    }\n}\n\nvoid gs_process_menu( inout GameState gs )\n{\n    gs.menustate.y = 0;\n    if( gs.menustate.x > 0 )\n    {\n        uvec4 currmenu = md_load( iChannel0, gs.menustate.x );\n        int n = int( currmenu.w >> 8 ) & 0xff;\n        int p = int( currmenu.w >> 16 ) & 0xff;\n\n    #if WORKAROUND_02_FOR_IF\n        for( int i = 0, n = 8; i < n; ++i )\n            if( i < n )\n            \tgs_check_menu_item( gs, i, p );\n\t#else\n        n += NOUNROLL;\n\t\tfor( int i = 0; i < n; ++i )\n\t       \tgs_check_menu_item( gs, i, p );\n\t#endif\n    }\n}\n\nvoid gs_respond_to_menu( inout GameState gs, inout VehicleState vs, inout MsgQueue msg )\n{\n\tif( gs.menustate.y >= MENU_INFO_BEGIN && gs.menustate.y < MENU_INFO_BEGIN + MENU_INFO_SIZE )\n    \tgs.switches = ( gs.switches & ~GS_IPAGE_MASK ) | ( uint( gs.menustate.y - MENU_INFO_BEGIN ) << GS_IPAGE_SHIFT );\n    else\n\tif( gs.menustate.y >= MENU_HMD_BEGIN && gs.menustate.y < MENU_HMD_BEGIN + MENU_HMD_SIZE )\n       \tvs.modes.x = gs.menustate.y - MENU_HMD_BEGIN;\n    else\n\tif( gs.menustate.y >= MENU_ENG_BEGIN && gs.menustate.y < MENU_ENG_BEGIN + MENU_ENG_SIZE )\n    {\n        if( gs.menustate.y - MENU_ENG_BEGIN == int( VS_ENG_NOVA ) )\n            msg_push_if_empty( msg, uvec4( 0x8c836e6f, 0x7420a900, 0, 7 ), vec4(0) );\n        else\n        \tvs.modes.z = gs.menustate.y - MENU_ENG_BEGIN, vs.throttle = 0.;\n    }\n    else\n\tif( gs.menustate.y >= MENU_THR_BEGIN && gs.menustate.y < MENU_THR_BEGIN + MENU_THR_SIZE )\n        vs.modes2.z = gs.menustate.y - MENU_THR_BEGIN;\n    else\n\tif( gs.menustate.y >= MENU_AERO_BEGIN && gs.menustate.y < MENU_AERO_BEGIN + MENU_AERO_SIZE )\n    {\n        int newmode = gs.menustate.y - MENU_AERO_BEGIN;\n\t\tif( vs.modes2.x < VS_AERO_ATR && newmode >= VS_AERO_ATR )\n            vs.trim = 0.;\n        if( vs.modes2.x >= VS_AERO_ATR && newmode < VS_AERO_ATR )\n        \tvs.trim = vs.EAR.x, vs.aerostuff = vec4(0);\n        vs.modes2.x = newmode;\n    }\n    else\n\tif( gs.menustate.y >= MENU_RCS_BEGIN && gs.menustate.y < MENU_RCS_BEGIN + MENU_RCS_SIZE )\n        vs.modes2.y = gs.menustate.y - MENU_RCS_BEGIN;\n    else\n    if( gs.menustate.y >= MENU_MMODE_BEGIN && gs.menustate.y < MENU_MMODE_BEGIN + MENU_MMODE_SIZE )\n        gs.switches = ( gs.switches & ~GS_MMODE_MASK ) | ( uint( gs.menustate.y - MENU_MMODE_BEGIN ) << GS_MMODE_SHIFT );\n    else\n    if( gs.menustate.y >= MENU_MPROJ_BEGIN && gs.menustate.y < MENU_MPROJ_BEGIN + MENU_MPROJ_SIZE )\n        gs.switches = ( gs.switches & ~GS_MPROJ_MASK ) | ( uint( gs.menustate.y - MENU_MPROJ_BEGIN ) << GS_MPROJ_SHIFT );\n\telse\n    if( gs.menustate.y == MENU_SET_WAYPOINT )\n        gs.waypoint = gs.mapmarker, gs.mapmarker = ZERO;\n}\n\nbool gs_pace_camera_transition( inout GameState gs, VehicleState vs, float dt )\n{\n    float u = -expm1( -1.00 * dt * min( 1., .5 * gs.timer ) );\n    float v = -expm1( -1.50 * dt * min( 1., .5 * gs.timer ) );\n    vec3 a = normalize( mix( gs.camframe[0], normalize( vs.localr - gs.campos ), v ) );\n    vec3 b = normalize( mix( normalize( gs.camframe[1] - a * dot( gs.camframe[1], a ) ),\n                             normalize( vs.localB[1] - a * dot( vs.localB[1], a ) ), v ) );\n    vec3 target = vs.localr - 0.03 * vs.localB[0];\n    float alt = mix( length( gs.campos ), length( target ) + .150 * length( target - gs.campos ), u );\n    gs.campos = normalize( mix( gs.campos, target, u ) ) * alt;\n    gs.camframe = mat3( a, b, cross( a, b ) );\n    return dot( normalize( vs.localr - gs.campos ), vs.localB[0] ) >= FRACT_15_16;\n    // return distance( gs.campos, vs.localr ) < ( length( target ) - g_data.radius < 25. ? 0.0305 : 0.3 );\n}\n\nvoid gs_enter_map_mode( inout GameState gs )\n{\n    gs.switches |= GS_TRMAP;\n    gs.switches &= ~GS_IRCAM;\n\tgs.mouselook = vec3(\n        normalize( -gs.campos.xy ),\n        atan( -gs.campos.z, length( gs.campos.xy ) ) );\n    gs.camzoom = 16.;\n    gs.mapmarker = ZERO;\n}\n\nvoid gs_leave_map_mode( inout GameState gs )\n{\n    gs.switches &= ~GS_TRMAP;\n    gs.mouselook = UNIT_X;\n    gs.camzoom = 1.;\n}\n\nvoid gs_mouselook( inout GameState gs )\n{\n\tif( keystate( KEY_BACK ) > 0. )\n        if( ( gs.switches & GS_TRMAP ) == 0u )\n\t\t\tgs.mouselook = UNIT_X, gs.camzoom = 1.;\n\t\telse\n            gs_enter_map_mode( gs );\n\telse\n    if( iMouse.z > 0. )\n    {\n        float zoomres = gs.camzoom * CAM_FOCUS * iResolution.y;\n        vec2 dragdelta = 2. * ( iMouse.xy - gs.dragstate ) / zoomres;\n        gs.dragstate = iMouse.xy;\n        float l = PI / 2. - 0.001 / gs.camzoom;\n        float q = cos( gs.mouselook.z ) + 0.25 / gs.camzoom;\n        vec2 sc = sincospi( dragdelta.x / ( q * PI ) );\n        gs.mouselook.xy = normalize( gs.mouselook.xy * mat2( sc.yx, -sc.x, sc.y ) );\n        gs.mouselook.z = clamp( gs.mouselook.z + dragdelta.y, -l, l );\n    }\n}\n\nvoid gs_update_camera( inout GameState gs, VehicleState vs )\n{\n    vec2 sc = sincospi( gs.mouselook.z / PI );\n    vec3 forward = vec3( gs.mouselook.xy * sc.y, sc.x );\n    vec3 right = normalize( cross( UNIT_Z, forward ) );\n    vec3 down = cross( forward, right );\n    gs.camframe = mat3( forward, right, down );\n    if( ( gs.switches & GS_TRMAP ) == 0u )\n    {\n        if( keypress( KEY_R ) == 1. )\n\t\t\tgs.camzoom = gs.camzoom < 3. ? 3. : gs.camzoom < 8. ? 8. : 1.;\n        gs.campos_diff = vs.localB * vec3( .001, 0, -.0015 );\n    \tgs.campos = vs.localr + gs.campos_diff;\n    \tgs.camframe = vs.localB * gs.camframe;\n    }\n}\n\nvoid gs_pace_hud( inout GameState gs, float dt )\n{\n    if( gs.exposure.x > 0. )\n    {\n        uint hudbright = ( gs.switches & GS_HMD_BRIGHT_MASK ) >> GS_HMD_BRIGHT_SHIFT;\n\t\tgs.hudbright += -expm1( -4. * dt ) * ( exp2pp( 2. * float( hudbright ) - 6. ) * sqrt( gs.exposure.x + 0.00005 ) - gs.hudbright );\n    }\n}\n\nvoid gs_pace_first_person_mode( inout GameState gs, float dt )\n{\n    if( keypress( KEY_T ) == 1. )\n        gs.switches ^= GS_TRDAR;\n\n    if( keypress( KEY_I ) == 1. )\n    {\n        gs.switches ^= GS_IRCAM;\n        if( ( gs.switches & GS_IRCAM ) != 0u )\n\t\t\tgs.switches &= ~GS_NVISN;\n    }\n\n    if( keypress( KEY_N ) == 1. )\n    {\n        gs.switches ^= GS_NVISN;\n        if( ( gs.switches & GS_NVISN ) != 0u )\n\t\t\tgs.switches &= ~GS_IRCAM;\n    }\n\n    if( keypress( KEY_P ) == 1. )\n        gs.switches ^= GS_PAUSE;\n\n    if( keypress( KEY_TAB ) == 1. )\n        gs.menustate.x = gs.menustate.x != 0 ? 0 : MENU_COMMAND;\n\n    uint hudbright = ( gs.switches & GS_HMD_BRIGHT_MASK ) >> GS_HMD_BRIGHT_SHIFT;\n    if( keypress( KEY_H ) == 1. )\n        hudbright = ( hudbright - 1u ) & 3u;\n    gs.switches = ( gs.switches & ~GS_HMD_BRIGHT_MASK ) | ( hudbright << GS_HMD_BRIGHT_SHIFT );\n}\n\nvoid gs_process_map_mode( inout GameState gs )\n{\n    if( keypress( KEY_TAB ) == 1. )\n        gs.menustate.x = gs.menustate.x != 0 ? 0 : MENU_MAP;\n\n\tfloat zoomspeed = max( keystatepress( KEY_W ), keystatepress( KEY_Z ) ) -\n                           keystatepress( KEY_S );\n    zoomspeed *= ( keystate( KEY_SHIFT ) > 0. ? .25 : 1. );\n\tgs.camzoom = clamp( gs.camzoom * exp2pp( iTimeDelta * zoomspeed ), 0.5, 2048. * TRN_SCALE );\n\n    if( iMouse.z < 0. && gs.dragstate.xy == -iMouse.zw )\n    {\n        vec4 marker = gs_map_unproject( gs, iMouse.xy + .5, iResolution.xy );\n        if( abs( marker.w ) < 1. )\n        {            \n            marker *= ( g_data.radius + texelFetch( iChannel1, ivec2( iMouse.xy ), 0 ).w );\n            if( marker.xyz == gs.mapmarker )\n                gs.mapmarker = ZERO;\n            else\n                gs.mapmarker = marker.xyz;\n        }\n        gs.dragstate.xy = vec2(0);        \n    }\n}\n\nvoid gs_pace_running_state( inout GameState gs, float dt )\n{\n    if( abs( iMouse.x - iMouse.z ) < 6. &&\n        abs( iMouse.y - iMouse.w ) < 6. && iMouse.z > 0. )\n    {\n        gs.dragstate = iMouse.xy;\n    }\n\n    if( keypress( KEY_M ) == 1. )\n        if( ( gs.switches & GS_TRMAP ) == 0u )\n      \t\tgs_enter_map_mode( gs );\n        else\n            gs_leave_map_mode( gs );\n\n\tif( ( gs.switches & GS_TRMAP ) == 0u )\n    \tgs_pace_first_person_mode( gs, dt );\n\telse\n      \tgs_process_map_mode( gs );\n\n\tgs_process_menu( gs );\n    if( gs.menustate.y == MENU_QUIT )\n        gs = gs_init();\n}\n\nvoid gs_pace_exposure( inout GameState gs, float dt )\n{\n    if( gs.stage != GS_INIT )\n    {\n        vec4 sum = vec4(0);\n\n        for( int i = 0; i < 8; ++i )\n            for( int j = 0; j < 8; ++j )\n                sum += texelFetch( iChannel0, ADDR_EXPOSURE.yx + ivec2( i, j ), 0 );\n\n        float mu = safediv( sum.x, sum.z );\n        float sigma = sqrt( max( 0., safediv( sum.y, sum.z ) - mu * mu ) );\n        float sigmaswitch = mu / ( 0.03 + mu );\n        float level = max( mu, mix( -2., 2., sigmaswitch ) * sigma );\n\n      #if WITH_ILLUM_TEST\n        gs.exposure.x -= expm1( -dt * ( gs.exposure.x < level ? 4. : 2. ) ) * ( level - gs.exposure.x );\n        gs.exposure.y = 0.;\n      #else\n        gs.exposure.x -= expm1( -dt * ( gs.exposure.x < level ? 4. : 2. ) ) * ( level - gs.exposure.x );\n        gs.exposure.y -= expm1( -dt * ( gs.exposure.y < level ? 1. : .5 ) ) * ( level - gs.exposure.y );\n      #endif\n    }\n    else\n\t\tgs.exposure = vec2(1);\n}\n\nvoid gs_pace_vjoy( inout GameState gs, inout VehicleInputs vi, float urgency, float dt )\n{\n    vec3 sc = sign( vi.joycommand );\n    vec3 ac = abs( vi.joycommand );\n    vec3 asc = abs( sc );\n    vec3 sense = sign( vi.joycommand ) * gs.vjoy;\n    vec3 move = urgency * mix(\n        mix( vec3( .05 ), vec3( .5 ), step( .5, gs.vjoy_hold ) ),\n        mix( vec3( 2 ), vec3( .25 ) * ac, step( -FRACT_1_64, sense ) ),\n        asc );\n    gs.vjoy += dt * clamp( 8. * ( sc - gs.vjoy ), -move, move );\n    gs.vjoy_hold = ( gs.vjoy_hold + dt ) * ( 1. - asc );\n    vi.vjoy_copy = gs.vjoy;\n}\n\n// ----------------------------------------------------------------------------\n// ACHIEVEMENT DETECTOR\n// ----------------------------------------------------------------------------\n\nvoid ad_pace( inout AchievementDetector ad, inout MsgQueue msg, VehicleState vs,\n              vec4 localterrain, float dt )\n{\n    bool contact = bool( vs.info.w );\n    switch( ad.LT_state )\n    {\n    case AD_LT_INIT:\n        ad.LT_state = contact ? AD_LT_LANDED : AD_LT_AIRBORNE;\n        ad.LT_timer = 0.;\n        ad.LT_localv = ZERO;\n        break;\n    case AD_LT_LANDED:\n        if( !contact )\n        {\n            ad.LT_timer -= dt;\n        \tif( ad.LT_timer < -2. )\n            {\n                ad.LT_state = AD_LT_AIRBORNE;\n                ad.LT_timer = 0.;\n\t            ad.LT_localv = vs.localv;\n                msg_push_if_empty( msg, uvec4( 0x41697262, 0x6f726e65, 0, 8 ), vec4(0) );\n            }\n    \t}\n        else\n            ad.LT_timer = 0.;\n        break;\n    case AD_LT_AIRBORNE:\n        ad.LT_timer -= dt;\n        if( ad.LT_timer < -5. && contact )\n        {\n            vec3 N = localterrain.xyz;\n            vec3 T = normalize( reject( vs.localB[0], N ) );\n            vec3 B = normalize( reject( vs.localB[1], N ) );\n            ad.LT_localv = 1000. * ad.LT_localv * mat3( T, B, -N );\n            if( abs( ad.LT_localv.x ) < 250. &&\n                abs( ad.LT_localv.y ) < 10. &&\n                ad.LT_localv.z < 6. &&\n                dot( vs.localB[0], N ) < .342 &&\n                dot( vs.localB[0], N ) >= -.087 &&\n                abs( dot( vs.localB[1], N ) ) < .342 )\n            {\n                ad.LT_state = vs.FSG.z >= FRACT_63_64 ? AD_LT_TOUCHDOWN : AD_LT_BELLYDOWN;\n                ad.LT_timer = 0.;\n                msg_push( msg, uvec4( 0xaa000000, 0, 0, 1 ), vec4(0) );\n            }\n            else\n            {\n                ad.LT_state = AD_LT_CRASH;\n                ad.LT_timer = 0.;\n                msg_push( msg, uvec4( 0x43726173, 0x68000000, 0, 5 ), vec4(0) );\n            }\n        }\n        else\n\t\t\tad.LT_localv = vs.localv;\n        break;\n    case AD_LT_TOUCHDOWN:\n    case AD_LT_BELLYDOWN:\n        if( contact )\n        {\n        \tad.LT_timer += dt;\n\t        if( ad.LT_timer >= 5. )\n    \t    {\n                bool wasempty = msg_empty( msg );\n                msg_push( msg, ad.LT_state == AD_LT_TOUCHDOWN ?\n                         \t\tuvec4( 0xab6c616e, 0x64696e67, 0, 8 ) :\n                         \t\tuvec4( 0x42656c6c, 0x79206c61, 0x6e64696e, 0x6700000d ),\n                          vec4(0) );\n                if( wasempty )\n                {\n\t\t\t\t\tmsg_push( msg, uvec4( 0xaa737065, 0x656420f7, 0, 8 ), vec4( ad.LT_localv.x, ZERO ) );\n            \t\tmsg_push( msg, uvec4( 0x44657363, 0x656e7420, 0x72617465, 0x20f6000e ), vec4( ad.LT_localv.z, ZERO ) );\n                    if( ad.LT_localv.z >= 4. )\n                    \tmsg_push( msg, uvec4( 0x54686174, 0x20776173, 0x20686172, 0x6400000d ), vec4(0) );\n                    else\n                    if( ad.LT_localv.x >= 80. )\n                    \tmsg_push( msg, uvec4( 0x54686174, 0x20776173, 0x20666173, 0x7400000d ), vec4(0) );\n                    else\n                    if( ad.LT_localv.z < 2. )\n                        msg_push( msg, uvec4( 0x54686174, 0x20776173, 0x20ac0000, 10 ), vec4(0) );\n                }\n                ad.LT_state = AD_LT_LANDED;\n                ad.LT_timer = 0.;\n            }\n\t\t}\n        else\n        {\n        \tad.LT_timer -= dt;\n            if( ad.LT_timer < 0. )\n            {\n                ad.LT_state = AD_LT_AIRBORNE;\n                ad.LT_timer = 0.;\n                ad.LT_localv = vs.localv;\n            }\n    \t}\n        break;\n    case AD_LT_CRASH:\n        ad.LT_timer += dt;\n\t\tif( ad.LT_timer >= 5. )\n        \tad.LT_state = AD_LT_INIT;\n        break;\n    }\n\n    // circular orbit detector\n   \t// extreme slow flying detector\n    // reverse flying detector\n}\n\n// ----------------------------------------------------------------------------\n// AUTO EXPOSURE\n// ----------------------------------------------------------------------------\n\nvec4 sample_exposure( ivec2 tileindex )\n{\n    float M1 = 0.;\n    float M2 = 0.;\n    float wsum = 0.;\n\n    vec2 tilesize = SCN_SUBSAMPLE_INV * iResolution.xy / 16.;\n    vec2 tilebase = vec2( tileindex ) * tilesize;\n    int N = min( IMG_EXPOSURE_SAMPLES, int( tilesize.x * tilesize.y ) );\n    uint rnd = 7u * uint( iFrame ) + 17u * uint( tileindex.x ) + 11u * uint( tileindex.y );\n    bool vrmode = bool( texelFetch( iChannel2, ivec2(0,0), 0 ).w );\n    for( int i = 0; i < N; ++i )\n    {\n        vec2 uv = tilebase + tilesize * vec2( rnd *= RNG32, rnd *= RNG32 ) * SHR32;\n        float weight = square( ( 1. - square( 4. * uv.x / iResolution.x - 1. ) ) *\n                               ( 1. - square( 4. * uv.y / iResolution.y - 1. ) ) );\n        if( vrmode )\n            uv.x = .5 * uv.x + .5 * float( i < N / 2 );\n        vec3 col = texelFetch( iChannel2, ivec2(uv), 1 ).xyz;\n        col = clamp( col, 0., IMG_EXPOSURE_MAX );\n\t  #if WITH_ILLUM_TEST\n        float L = dot( col, COL_YWEIGHTS );\n      #else\n        float L = hmax( col );\n      #endif\n        L = min( L, IMG_EXPOSURE_MAX );\n        M1 += L * weight;\n        M2 += L * L * weight;\n        wsum += weight;\n    }\n\n    return vec4( M1, M2, wsum, 0 );\n}\n\n// ----------------------------------------------------------------------------\n// MAIN\n// ----------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fcolor, in vec2 fcoord )\n{\n    fcolor = vec4( ZERO, 0 );\n\n#if BUFFER_RUNLEVEL >= 1\n\n    if( fcoord.x >= 128. || fcoord.y >= 128. )\n        discard;\n\n    bool init = iFrame == 0;\n    bool resolutionchange = iResolution.xy != memload( iChannel0, ADDR_RESOLUTION, 0 ).xy;\n\tvec4 dtime = vec4( iTimeDelta, memload( iChannel0, ADDR_DTIME, 0 ).xyz );\n\n\tGameState gs = gs_load( iChannel0, ADDR_GAMESTATE );\n\tVehicleState vs = vs_load( iChannel0, ADDR_VEHICLE );\n    TrnSampler ts = ts_load( iChannel0, ADDR_TSAMPLER );\n\n    int localplanetindex = 1;\n    g_data = g_planet_data[ localplanetindex ];\n\n    bool locallimit = length( vs.orbitr ) <\n\t\t12. * g_data.atm_scale + log( g_data.atm_profile.ref.z ) + g_data.radius;\n    FrameContext fr = fr_init( dtime, locallimit );\n\n    if( init )\n    {\n        gs = gs_init();\n\t\tvs = vs_init();\n    }\n\n   \tivec2 sc = ivec2( fcoord );\n    g_msgindex = ( sc.x - ADDR_MESSAGES.y - 1 ) % TXT_MSG_MAX_PHRASES;\n    MsgQueue msg = msg_load_and_pace( iChannel0, ADDR_MESSAGES, g_msgindex, fr.dt );\n\n\tAchievementDetector ad = ad_load( iChannel0, ADDR_ACHIEVEMENTS );\n    VehicleInputs vi = vi_read_inputs( vs );\n\n    bool irmode = ( gs.switches & GS_IRCAM ) != 0u;\n\n#if KIOSK_MODE\n    if( gs.stage == GS_RUNNING )\n    {\n        bool airborne = ad.LT_state == AD_LT_AIRBORNE;\n        float alt = ( length( vs.localr ) - g_data.radius ) * 1000.;\n        float trimerror = (\n            !airborne ? \t\t\tKSK_TRIM_TAKEOFF :\n        \talt < KSK_CRUISE_ALT ? \tKSK_TRIM_CLIMB :\n        \t\t\t\t\t\t\tKSK_TRIM_CRUISE ) - vs.trim;\n        float throttleerror = (\n            !airborne ? \t\t\tKSK_THROTTLE_TAKEOFF :\n            alt < KSK_CRUISE_ALT ? \tKSK_THROTTLE_CLIMB :\n        \t\t\t\t\t\t\tKSK_THROTTLE_CRUISE ) - vs.throttle;\n        float gain = safediv( 1., fr.dt );\n    \tvi.trimcommand = clamp( trimerror * gain, -1., 1. );\n    \tvi.throttlecommand = clamp( throttleerror * gain, -1., 1. );\n        if( airborne )\n\t\t\tvi.trimcommand *= .25,\n            vi.throttlecommand *= .25;\n        vs.switches = ( vs.switches & ~VS_GEARS ) | ( airborne ? 0u : VS_GEARS );\n    }\n#endif\n\n    if( in_addr_range( sc, ADDR_RESOLUTION, 1, 1 ) )\n       memstore( iResolution.xyxy, ADDR_RESOLUTION, 0, sc, fcolor );\n    else\n    if( in_addr_range( sc, ADDR_DTIME, 1, 1 ) )\n       memstore( dtime, ADDR_DTIME, 0, sc, fcolor );\n    else\n    if( in_addr_range( sc, ADDR_EXPOSURE, 8, 8 ) )\n    {\n        ivec2 tileindex = sc - ADDR_EXPOSURE.yx;\n        fcolor = init ? vec4(0) : sample_exposure( tileindex );\n    }\n    else\n    if( in_addr_range( sc, ADDR_PLANETS, 32, NUM_PLANETS ) )\n    {\n        int index = sc.y - ADDR_PLANETS.x;\n        PlanetData data = g_planet_data[ index ];\n        PlanetData parentdata = g_planet_data[ int( data.parent ) ];\n        PlanetState ps, parent;\n        if( gs.stage == GS_INIT )\n        {\n            ps = ps_init( data );\n            parent = ps_init( parentdata );\n        }\n        else\n        {\n            ps = ps_load( iChannel0, ADDR_PLANETS + ivec2( index, 0 ) );\n            parent = ps_load( iChannel0, ADDR_PLANETS + ivec2( data.parent, 0 ) );\n        }\n        if( gs.stage != GS_TRANSITION )\n            if( ts_is_valid( ts ) )\n        \t\tps_pace( ps, data.orbit, fr.dt );\n        kepler_get_vectors( data.orbit, ps.nu, ps.dnudt90, ps.orbitr, ps.orbitv );\n        ps.r = ps.orbitr + parent.orbitr;\n        ps.v = ps.orbitv + parent.orbitv;\n        ps_store( ps, ADDR_PLANETS + ivec2( index, 0 ), sc, fcolor );\n        AtmContext atm = atm_init( data, irmode );\n        atm_store( atm, ADDR_ATMCONTEXTS + ivec2( index, 0 ), sc, fcolor );\n    }\n    else\n    if( in_addr_range( sc, ADDR_SCENE_OBJECTS, ADDR_SCENE_OBJECT_SIZE, SCN_MAX_PRIMITIVES ) ||\n        in_addr_range( sc, ADDR_DATASIZES, 1, 1 ) )\n    {\n        int k = 0;\n        float distthres = .25 * gs.camzoom * CAM_FOCUS_INNER * iResolution.x * SCN_SUBSAMPLE_INV;\n\t\tbool notmapmode = ( gs.switches & GS_TRMAP ) == 0u;\n\n        if( iFrame >= 4 )\n        for( int i = 0, n = ADDR_SCENE_DATA_COUNT; i < n && k < SCN_MAX_PRIMITIVES; ++i )\n        {\n         \tSceneObj obj = so_load( iChannel0, ADDR_SCENE_DATA_OBJECTS + ivec2( i, 0 ) );\n            if( int( obj.tybr.x ) != SCNOBJ_TYPE_INVALID )\n            {\n                if( notmapmode && distance( gs.campos, obj.r ) >= obj.tybr.y * distthres )\n                    break;\n\n                if( notmapmode || int( obj.tybr.x ) < SCNOBJ_TYPE_3D )\n                \tk = so_expand_to_primitives( obj, k, gs.timer, ADDR_SCENE_OBJECTS, sc, fcolor );\n            }\n        }\n\t    memstore( vec4( 0, 0, 0, k ), ADDR_DATASIZES, 0, sc, fcolor );\n\t}\n    else\n    if( in_addr_range( sc, ADDR_GAMESTATE, 24, 16 ) )\n    {\n\t    PlanetState ps;\n        LocalEnvironment env;\n        if( gs.stage == GS_INIT )\n        {\n            ps = ps_init( g_data );\n            env = env_init();\n            ps_pace( ps, g_data.orbit, fr.dt );\n        }\n        else\n        {\n            ps = ps_load( iChannel0, ADDR_PLANETS + ivec2( localplanetindex, 0 ) );\n            env = env_load( iChannel0, ADDR_LOCALENV );\n        }\n\n\t    env.L = normalize( -ps.r * ps.B );\n\t    env.sunlight = irselect( COL_SUNLIGHT, irmode );\n        env.starlight = irselect( COL_STARLIGHT, irmode );\n\t    env.radius = g_data.radius;\n\n        if( resolutionchange )\n            ts = ts_init();\n\n        uint lastswitches = gs.switches;\n\n\t\tswitch( gs.stage )\n        {\n        case GS_INIT:\n            vs_realize_startpos( gs, vs, ps, g_start_data[0] );\n\t\t\tvs.modes = ivec3(0);\n            vs.modes2 = ivec3(0);\n            ts = ts_init();\n\t\t\tmsg_push( msg, uvec4( 0x949cf220, 0x9d9e0000, 0, 6 ), vec4( 2020, ZERO ) );\n        \tmsg_push( msg, uvec4( 0x939f9100, 0, 0, 3 ), vec4(0) );\n            gs.stage = GS_SELECT_LOCATION;\n            gs.timer = 0.;\n            gs.datetime.y = 14.;\n            // fallthrough\n\n        case GS_SELECT_LOCATION:\n            gs.timer += fr.dt;\n            int selected = 0;\n        #if KIOSK_MODE\n            if( gs.timer >= KSK_TRANSITION_DELAY )\n                selected = KSK_START_LOCATION;\n        #else\n            for( int i = 1, n = ADDR_START_DATA_COUNT; i < n; ++i )\n            {\n            #if WORKAROUND_07_KEYPRESS\n                if( keypress( KEY_A - 1 + i ) == 1. )\n            #else\n                if( keypress( KEY_A + i - 1 ) == 1. )\n            #endif\n                    selected = i;\n\t\t\t}\n\t\t#endif\n\t\t\tif( selected > 0 )\n            {\n                StartData start = st_load( iChannel0, ADDR_START_DATA + ivec2( selected, 0 ) );\n                vs_realize_startpos( gs, vs, ps, start );\n                if( dot( vs.localr, env.L ) < 0. || length( vs.orbitr ) < g_data.radius - 0.03 )\n                    vs.switches |= VS_LIGHT;\n\t\t\t\tmsg_push( msg, uvec4( 0xa0746f20, 0x2e2e2e00, 0, 7 ), vec4(0) );\n                msg_push( msg, start.name, vec4(0) );\n                gs.stage = GS_TRANSITION;\n                gs.timer = 0.;\n            }\n            break;\n\n\t\tcase GS_TRANSITION:\n\t\t\tgs.timer += fr.dt;\n            bool high = length( gs.campos ) >= g_data.radius * ( 1. + g_data.trn_levels.y );\n            if( !high && ts_is_valid( ts ) && ts_is_uv_safe( ts, vs.localr ) )\n            {\n                vs.localr = normalize( vs.localr ) * ( ts_sample( ts, iChannel1, vs.localr ).w + 0.0015 + g_data.radius );\n                vs_commit_local( vs, ps );\n\t\t\t}\n            if( gs_pace_camera_transition( gs, vs, fr.dt ) )\n            {\n            \tgs.stage = GS_RUNNING;\n\t\t\t\tgs.mouselook = UNIT_X;\n            #if KIOSK_MODE\n\t\t\t\tvs.modes = KSK_MODES;\n                vs.modes2 = KSK_MODES2;\n            #endif\n            }\n            break;\n\n        case GS_RUNNING:\n\t\t\tgs.timer += fr.dt;\n            gs_pace_running_state( gs, fr.dt );\n\t\t\tgs_respond_to_menu( gs, vs, msg );\n            gs_mouselook( gs );\n            gs_pace_vjoy( gs, vi, vs.modes.z == VS_ENG_DRV ? 2. : 1., fr.dt );\n            vs_pace_switches( vs, vi );\n \t\t\tfloat wp_elev = texelFetch( iChannel1, ivec2( ADDR_B_WAYPOINT_SAMPLE, 0 ), 0 ).w;\n            if( wp_elev > 0. )\n                    gs.waypoint = normalize( gs.waypoint ) * wp_elev;\n\t\t\tbreak;\n        }\n\n        if( gs.stage != GS_RUNNING || ( lastswitches & GS_TRMAP ) == 0u )\n        {\n            gs_pace_exposure( gs, fr.dt );\n            gs_pace_hud( gs, fr.dt );\n        }\n\n        if( gs.stage != GS_TRANSITION )\n        {\n            vs.info = vec4(0);\n\t\t\tif( ts_is_valid( ts ) )\n            {\n\t\t\t\tfor( int i = 0; i < fr.subframe_count; ++i )\n                {\n                    float dt = fr.subframe_dt;\n                    float Q = .5 * ( 1e6 / 1e5 ) * env.atm.z * dot( vs.localv, vs.localv );\n                    float rmax = g_data.radius * ( 1. + g_data.trn_levels.y );\n                    vec4 rn = length_normalize( vs.localr );\n                    bool localphysics = Q >= 0.00005 || rn.w < rmax;\n                    bool pausemode = ( gs.switches & GS_PAUSE ) == GS_PAUSE;\n    \t\t\t\tvs_pace_beginframe( vs, localphysics );\n    \t\t\t\tvs_pace_halfstep( vs, vi, dt / 2., localphysics, pausemode );\n                    {\n                        vec3 rnxy = length_normalize( rn.xy );\n                        vec3 psrn = normalize( ps.r );\n                        vec3 pshn = normalize( cross( ps.r, ps.v ) );\n                        vec3 pshB = normalize( reject( ps.B[2], pshn ) );\n                        vec2 Lnxy = normalize( ( -ps.r * ps.B ).xy );\n                        vec2 lphase = vec2( rnxy.z, rn.z );\n                        vec2 sphase = vec2( dot( pshB, psrn ), dot( pshB, pshn ) );\n                        vec2 dphase = vec2( dot( perp( Lnxy ), rnxy.xy ), dot( Lnxy, rnxy.xy ) );\n                        float terrain = texelFetch( iChannel1, ivec2(4,0), 0 ).w - g_data.radius;\n                        float att = parabolstep( -.25, .75, terrain );\n                        vec4 atm = ap_eval_profile( g_data.atm_profile, rn.w, g_data.radius, lphase, sphase, dphase * att );\n                        float u = parabolstep( 0., 0.0015, -atm.w );\n                        atm.x = mix( atm.x, g_data.ocn_T, max( 0., -atm.w ) / ( .05 + max( 0., -atm.w ) ) );\n                        atm.y = mix( atm.y, g_data.atm_profile.ref.y - g_data.ocn_dens * FDM_STD_G * atm.w / 100., u );\n                        atm.z = mix( atm.z, g_data.ocn_dens, u );\n                        env.atm.xyz = atm.xyz;\n                        env.atm.w = g_data.atm_profile.ssref * sqrt( atm.x / g_data.atm_profile.ref.x );\n                        env.phases = fract( vec2( atan( -sphase.x, -sphase.y ), atan( -dphase.x, -dphase.y ) ) / TAU );\n                        env.atm2.y = 0.000000068 * g_data.atm_profile.ref.z / env.atm.z;\n                        vs_pace_midframe( vs, vi, env, ts, ps, dt, localphysics, pausemode );\n\t\t\t\t    }\n                    env.H = float( localphysics );\n    \t\t\t\tvs_pace_halfstep( vs, vi, dt / 2., localphysics, pausemode );\n    \t\t\t\tvs_pace_endframe( vs, ps, dt, localphysics );\n                }\n\t\t\t}\n            gs_update_camera( gs, vs );\n        }\n\n        const float solar_day = 1440. * SECONDS_PER_MINUTE;\n        gs.datetime.x += fr.dt / solar_day;\n        if( gs.datetime.x >= 1. )\n        {\n            gs.datetime.x--;\n            gs.datetime.y++;\n            float days_per_year = 61. + ( mod( gs.datetime.z, 3. ) == 0. ? 1. : 0. );\n            if( gs.datetime.y >= days_per_year )\n            {\n                gs.datetime.y -= days_per_year;\n                gs.datetime.z++;\n            }\n        }\n\n\t\tvec4 localterrain = texelFetch( iChannel1, ivec2(0), 0 );\n        if( localterrain.w == 0. )\n            localterrain = vec4( normalize( gs.campos ), g_data.radius );\n\n       \tif( gs.stage == GS_RUNNING && ( gs.switches & GS_TRMAP ) == 0u )\n\t\t\tad_pace( ad, msg, vs, localterrain, fr.dt );\n        ad_store( ad, ADDR_ACHIEVEMENTS, sc, fcolor );\n\n        gs.switches &= ~GS_CHEES;\n        gs.switches |= GS_CHEES * uint( keystate( KEY_F12 ) );\n\n        gs_store( gs, ADDR_GAMESTATE, sc, fcolor );\n        vs_store( vs, ADDR_VEHICLE, sc, fcolor );\n        ts_store( ts, ADDR_TSAMPLER_LAST, sc, fcolor );\n\n        if( ( gs.switches & GS_TRMAP ) == 0u )\n            ts_update_stable( ts, gs.campos, localterrain.w, iResolution.y );\n        else\n            ts = ts_init();\n        ts_store( ts, ADDR_TSAMPLER, sc, fcolor );\n\n        msg_store( msg, ADDR_MESSAGES, sc, fcolor );\n        env_store( env, ADDR_LOCALENV, sc, fcolor );\n    }\n    else\n    if( in_addr_range( sc, ADDR_SCENE_DATA_OBJECTS, ADDR_SCENE_OBJECT_SIZE, ADDR_SCENE_DATA_COUNT ) )\n    {\n        int index = sc.y - ADDR_SCENE_DATA_OBJECTS.x;\n        if( iFrame >= 3 && keypress( KEY_F5 ) == 0. )\n            so_dynamic_bubblesort( index, gs.campos, sc, fcolor );\n        else\n        {\n            SceneData sd = sd_load( iChannel1, ivec2( 0, ADDR_B_SCENEDATA + ADDR_SCENE_DATA_SIZE * index ) );\n        \tSceneObj obj = so_init( sd );\n        \tso_store( obj, ADDR_SCENE_DATA_OBJECTS + ivec2( index, 0 ), sc, fcolor );\n        }\n    }\n    else\n    if( in_addr_range( sc, ADDR_MENU_DATA, 2, g_menu_data_length ) )\n    {\n        int index = sc.y - ADDR_MENU_DATA.x;\n        fcolor = pack_uvec4( g_menu_data[ index ] );\n    }\n    else\n    if( in_addr_range( sc, ADDR_START_DATA, ADDR_START_DATA_SIZE, ADDR_START_DATA_COUNT ) )\n    {\n        int index = sc.y - ADDR_MENU_DATA.x;\n        StartData start = g_start_data[ index ];\n        st_store( start, ADDR_START_DATA + ivec2( index, 0 ), sc, fcolor );\n    }\n\n#endif // RUNLEVEL\n}\n", "name": "Buffer A", "description": "", "type": "buffer"}, {"inputs": [{"id": "4dXGRr", "filepath": "/presets/tex00.jpg", "previewfilepath": "/presets/tex00.jpg", "type": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "4dXGR8", "filepath": "/media/previz/buffer00.png", "previewfilepath": "/media/previz/buffer00.png", "type": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "XsXGR8", "filepath": "/media/previz/buffer01.png", "previewfilepath": "/media/previz/buffer01.png", "type": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "XdfGR8", "filepath": "/media/previz/buffer03.png", "previewfilepath": "/media/previz/buffer03.png", "type": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "XsXGR8", "channel": 0}], "code": "/*\n *\t\t\t\tSPACE GLIDER 2020 SHADERTOY EDITION\n *\t\t\t\t\t   by Christian Sch\u00fcler\n *                       (c) 2001 - 2020\n *\n * Part 3 of 6: Buffer B shader (terrain elevation model)\n * This software comes with no warranty. Use it at your own risk.\n */\n\nGameState g_game;\nVehicleState g_vehicle;\nPlanetState g_planet;\nPlanetData g_data;\nLocalEnvironment g_env;\nTrnSampler g_ts;\n\nvec2 g_textres;\n\n// ----------------------------------------------------------------------------\n// LOCATION DATA\n// ----------------------------------------------------------------------------\n\nLocData[] g_loc_data = LocData[](\n\t// 0\n    LocData( vec4(  34.342,  117.332, 1.200, 80 ), \tuvec4(0u) ),\n    LocData( vec4(  15.882,  167.539,  .800, 98 ), \tuvec4(0u) ),\n    LocData( vec4(  52.529,  115.867,  .450, 60 ), \tuvec4(0u) ),\n    LocData( vec4(  62.133,  150.955,  .500, 57 ), \tuvec4(0u) ),\n    LocData( vec4(  62.468,  152.073,  .030, 0 ),  \tuvec4(0u) ),\n    // 5\n    LocData( vec4(  29.907,  156.418,  .800, 191 ), uvec4(0u) ),\n    LocData( vec4(  28.970,  156.660,  .300, 0 ), \tuvec4(0u) ),\n    LocData( vec4(  28.994,  156.489,  .050, 0 ), \tuvec4(0u) ),\n    LocData( vec4(  17.449,  117.416,  .400, 82 ), \tuvec4(0u) ),\n    LocData( vec4(  -5.083,  107.220,  .400, 3 ), \tuvec4(0u) ),\n\t// 10\n    LocData( vec4( -51.548, -124.185,  .015, 70 ), \tuvec4(0u) ),\n    LocData( vec4( -50.465, -119.586,  .400, 82 ), \tuvec4(0u) ),\n    LocData( vec4( -90.000,    0.000,  .600, 10 ), \tuvec4(0u) ),\n    LocData( vec4(  34.275, -152.626,  .500, 0 ), \tuvec4(0u) ),\n    LocData( vec4( -26.900,   28.262,  .400, 0 ), \tuvec4(0u) ),\n   \t// 15\n    LocData( vec4(  65.652,   61.718,  .350, 0 ), \tuvec4(0u) )\n);\n\n\n// ----------------------------------------------------------------------------\n// SCENE DATA\n// ----------------------------------------------------------------------------\n\nSceneData[] g_scene_data = SceneData[](\n\n    // 00 - Space center west\n    SceneData( vec4( SCNOBJ_TYPE_RUNWAY,   1.200, 0, 0 ), vec4(   .060, -.430, 0, 102 ),   \tvec4( 20, 0, 0, .12 ), \t\tvec4( 2400, 65, 15, 5 ) ),\n    SceneData( vec4( SCNOBJ_TYPE_RUNWAY,    .700, 0, 0 ), vec4(  -.810,  .230, 0, 31 ),    \tvec4( 20, 0, 0, .12 ), \t\tvec4( 1500, 65, 12, 4 ) ),\n    SceneData( vec4( SCNOBJ_TYPE_RUNWAY,    .125, 0, 0 ), vec4(      0,     0, 0, 80 ),    \tvec4( 21, 0, 0, 0 ),  \t\tvec4( 137, 150, 5, 4 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_TOWER,     .028, 0, 0 ), vec4(  -.305,  .165, 0, 80 ),    \tvec4( 3, 0, 0, .015 ),\t\tvec4( .009, .012, .004, .003 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .060, 0, 0 ), vec4(  -.090,  .200, 0, 80 ),    \tvec4( 3, 0, 0, 2 ),   \t\tvec4( .040, .060, .006, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .060, 0, 0 ), vec4(   .075,  .200, 0, 80 ),    \tvec4( 3, 0, 0, 2 ),   \t\tvec4( .040, .060, .006, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .060, 0, 0 ), vec4(   .290, -.015, 0, 80 ),\t\tvec4( 3, 0, 0, 2 ),   \t\tvec4( .040, .060, .006, 0 ) ),\n\n    // 07 - Space center east\n    SceneData( vec4( SCNOBJ_TYPE_RUNWAY,    .900, 0, 1 ), vec4(      0,  .975, 0, 98 ),\t\tvec4( 1, 0, 0, .6 ),  \t    vec4( 1800, 55, 0, 0 ) ),\n    SceneData( vec4( SCNOBJ_TYPE_RUNWAY,    .300, 0, 1 ), vec4(  -.700,  .540, 0, 188 ),  \tvec4( 2, 0, 0, 0 ),  \t    vec4( 350, 350, 0, 0 ) ),\n    SceneData( vec4( SCNOBJ_TYPE_RUNWAY,    .300, 0, 1 ), vec4(  -.300, -.375, 0, 92 ),    \tvec4( 1, 0, 0, 0 ),  \t    vec4( 700, 35, 0, 0 ) ),\n    SceneData( vec4( SCNOBJ_TYPE_RUNWAY,    .080, 0, 1 ), vec4(   .410, -.300, 0, 92 ),    \tvec4( 1, 0, 0, 0 ),  \t    vec4(  88, 160, 0, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_TOWER,     .028, 0, 1 ), vec4(  -.920,  .150, 0, 278 ),  \tvec4( 22, 0, 0, .012 ),\t\tvec4( .025, .015, .002, .003 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .050, 0, 1 ), vec4( -1.000, -.200, 0, 92 ),    \tvec4( 11, 0, 0, 2 ),   \t\tvec4( .100, .070, .005, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .040, 0, 1 ), vec4(  -.890, -.505, 0, 92 ),    \tvec4( 11, 0, 0, 2 ),   \t\tvec4( .030, .035, .040, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .040, 0, 1 ), vec4(  -.790, -.495, 0, 92 ),    \tvec4( 11, 0, 0, 2 ),   \t\tvec4( .030, .035, .040, 0 ) ),\n\n    // 15 - Lucerne\n    SceneData( vec4( SCNOBJ_TYPE_RUNWAY,\t.360, 0, 2 ), vec4(      0,  .025, 0, 60 ),  \tvec4( 2, 0, 0, .6 ),       \tvec4( 720, 25, 0, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_RUNWAY, \t.060, 0, 2 ), vec4(  -.015, -.050, 0, 60 ),\t\tvec4( 2, 0, 0, 0 ),       \tvec4( 66, 50, 0, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_TOWER,  \t.015, 0, 2 ), vec4(   .015, -.090, 0, 330 ), \tvec4( 3, 0, 0, .006 ),     \tvec4( .012, .010, .002, .002 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .018, 0, 2 ), vec4(  -.040, -.090, 0, 60 ),  \tvec4( 4, 0, 0, 2 ),        \tvec4( .018, .012, .003, 0 ) ),\n\n    // 19 - Bensersiel airfield\n    SceneData( vec4( SCNOBJ_TYPE_RUNWAY,    .450, 0, 3 ),  vec4(  .349, -.000, 0, 57 ),  \tvec4( 8, 0, 0,\t.7 ),  \t\tvec4( 900, 35, 0, 0 ) ),\n    SceneData( vec4( SCNOBJ_TYPE_RUNWAY,    .125, 0, 3 ),  vec4(  .192,  .067, 0, 57 ),  \tvec4( 23, 0, 0, 0 ),\t\tvec4( 137, 50, 50, 10 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_TOWER,  \t.012, 0, 3 ),  vec4(  .288,  .111, 0, 147 ), \tvec4( 3, 0, 0, .007 ),\t\tvec4( .012, .010, .002, .002 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .012, 0, 3 ),  vec4(  .219,  .108, 0, 57 ),  \tvec4( 14, 0, 0, 2 ),   \t    vec4( .012, .012, .004, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .012, 0, 3 ),  vec4(  .253,  .110, 0, 57 ),  \tvec4( 14, 0, 0, 2 ),   \t    vec4( .012, .012, .004, 0 ) ),\n\n    // 24 - Bensersiel Lighthouse\n    SceneData( vec4( SCNOBJ_TYPE_LIGHTHOUSE,.015, 0, 4 ),  vec4( ZERO, 120 ), \t\t\t\tvec4( 3, 0, 0, .010 ),\t    vec4( .004, .004, .002, .0025 ) ),\n\n    // 25 - Cancun airfield\n    SceneData( vec4( SCNOBJ_TYPE_RUNWAY,    .300, 0, 5 ),  vec4( -.102,  .549, 0, 173 ),\tvec4( 7, 0, 0, 0 ),\t\t\tvec4( 600, 25, 60, 10 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_RUNWAY,    .525, 0, 5 ),  vec4(  .019, -.385, 0, 191 ),   \tvec4( 5, 0, 0, .5 ),   \t    vec4( 1050, 35, 0, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_RUNWAY,    .300, 0, 5 ),  vec4( -.323,     0, 0, 191 ),\tvec4( 5, 0, 0, 0 ),   \t    vec4( 137, 150, 0, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_RUNWAY,    .300, 0, 5 ),  vec4(  .290,     0, 0, 191 ),\tvec4( 5, 0, 0, 0 ),   \t    vec4( 137, 150, 0, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_TOWER,     .028, 0, 5 ),  vec4( -.041, -.131, 0, 191 ),\tvec4( 3, 0, 0, .010 ), \t    vec4( .026, .038, .007, .003 ) ),\n    SceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .025, 0, 5 ),  vec4( -.016,     0, 0, 191 ),    vec4( 11, 0, 0, 2 ),    \tvec4( .095, .025, .010, 0 ) ),\n\n    // 31 - Cancun hotels\n    SceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .025, 0, 6 ),  vec4( -.230, -.105, 0, 0 ),    \tvec4( 11, 0, 0, 2 ),    \tvec4( .025, .005, .013, 0 ) ),\n    SceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .025, 0, 6 ),  vec4( -.140, -.060, 0, 0 ),    \tvec4( 11, 0, 0, 2 ),    \tvec4( .025, .005, .013, 0 ) ),\n    SceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .025, 0, 6 ),  vec4( -.050, -.015, 0, 0 ),    \tvec4( 11, 0, 0, 2 ),    \tvec4( .025, .005, .013, 0 ) ),\n    SceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .025, 0, 6 ),  vec4(  .060, -.030, 0, 0 ),    \tvec4( 11, 0, 0, 2 ),    \tvec4( .025, .005, .013, 0 ) ),\n    SceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .025, 0, 6 ),  vec4(  .150,  .015, 0, 0 ),    \tvec4( 11, 0, 0, 2 ),    \tvec4( .025, .005, .013, 0 ) ),\n    SceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .025, 0, 6 ),  vec4(  .240,  .060, 0, 0 ),    \tvec4( 11, 0, 0, 2 ),    \tvec4( .025, .005, .013, 0 ) ),\n\n    // 37 - Cancun underwater museum\n    SceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .002, 0, 7 ),  vec4( -.0255, -.0085, 0, 0 ), \tvec4( 15, 0, 0, 1 ),   \t \tvec4( .002, ZERO ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .002, 0, 7 ),  vec4( -.0230,  .0012, 0, 0 ), \tvec4( 16, 0, 0, 1 ),\t    vec4( .002, ZERO ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .002, 0, 7 ),  vec4( -.0218, -.0030, 0, 0 ), \tvec4( 17, 0, 0, 1 ),\t    vec4( .002, ZERO ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .001, 0, 7 ),  vec4(  .0020, -.0147, 0, 64 ),\tvec4( 28, 0, 0, 2 ),    \tvec4( .001, .001, .001, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .001, 0, 7 ),  vec4(  .0091, -.0219, 0, 31 ),\tvec4( 28, 0, 0, 2 ),    \tvec4( .001, .001, .001, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .001, 0, 7 ),  vec4(  .0080, -.0177, 0, 22 ),\tvec4( 28, 0, 0, 2 ),    \tvec4( .001, .001, .001, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .003, 0, 7 ),  vec4(  .0245,  .0365, 0, 0 ), \tvec4( 18, 0, 0, 3 ),    \tvec4( .001, .003, 0, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .003, 0, 7 ),  vec4(  .0267,  .0281, 0, 0 ), \tvec4( 19, 0, 0, 3 ),    \tvec4( .001, .003, 0, 0 ) ),\n\n    // 45 - Rocky springs\n    SceneData( vec4( SCNOBJ_TYPE_RUNWAY,\t.375, 0, 8 ),  vec4( -.003, -.064, 0, 82 ),  \tvec4( 6, 0, 0, .6 ),   \t    vec4( 750, 30, 0, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_RUNWAY, \t.060, 0, 8 ),  vec4( -.209, -.002, 0, 82 ),  \tvec4( 6, 0, 0, 0 ),    \t    vec4( 66, 50, 0, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_RUNWAY, \t.100, 0, 8 ),  vec4( -.116,  .085, 0, 172 ), \tvec4( 6, 0, 0, 0 ),    \t    vec4( 120, 15, 0, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_RUNWAY, \t.100, 0, 8 ),  vec4(  .017,  .121, 0, 82 ),  \tvec4( 6, 0, 0, 0 ),    \t    vec4( 110, 150, 0, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_TOWER,     .015, 0, 8 ),  vec4( -.160,  .063, 0, 82 ),  \tvec4( 3, 0, 0, .007 ), \t    vec4( .012, .016, .0025, .003 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .022, 0, 8 ),  vec4(  .010,  .222, 0, 82 ),  \tvec4( 12, 0, 0, 2 ),    \tvec4( .045, .012, .004, 0 ) ),\n\n    // 51 - Lake Victoria\n    SceneData( vec4( SCNOBJ_TYPE_RUNWAY,    .300, 0, 9 ),  vec4(  .045,  .050, 0, 3 ),   \tvec4( 24, 0, 0, 0 ),\t\tvec4( 600, 25, 70, 10 ) ),\n    SceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .025, 0, 9 ),  vec4( -.160,  .200, 0, 0 ),   \tvec4( 29, 0, 0, 3 ),   \t\tvec4( .012, .003, 0, 0 ) ),\n    SceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .025, 0, 9 ),  vec4( -.140,\t .240, 0, 0 ),   \tvec4( 29, 0, 0, 3 ),   \t\tvec4( .012, .003, 0, 0 ) ),\n    SceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .025, 0, 9 ),  vec4( -.120,\t .280, 0, 0 ),   \tvec4( 29, 0, 0, 3 ),   \t\tvec4( .012, .003, 0, 0 ) ),\n\n\t// 55 - Hang gliding summit station\n    SceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .002, 0, 10 ), vec4(  .00592,.00382, 0, 0 ), \tvec4( 25, 0, 0, 3 ), \t\tvec4( .00005, .0015, 0, 0 ) ),\n    SceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .002, 0, 10 ), vec4(  .00408,.00618, 0, 0 ), \tvec4( 25, 0, 0, 3 ), \t\tvec4( .00005, .0015, 0, 0 ) ),\n    SceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .002, 0, 10 ), vec4(  .005,  .005, .0025, 122 ),vec4( 11, 0, 0, 2 ), \t\tvec4( .002, .00002, .0015, 0 ) ),\n\n    // 58 - Hang gliding base\n    SceneData( vec4( SCNOBJ_TYPE_RUNWAY, \t.225, 0, 11 ), vec4( -.026, -.147, 0, 82 ),  \tvec4( 23, 0, 0, 0 ),\t\tvec4( 450, 25, 10, 2 ) ),\n    SceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .006, 0, 11 ), vec4(  .225, -.182, 0, 82 ),  \tvec4( 26, 0, 0, 2 ),\t \tvec4( .005, .006, .002, 0 ) ),\n\n    // 60 - South pole station\n    SceneData( vec4( SCNOBJ_TYPE_RUNWAY,\t.525, 0, 12 ),  vec4( .628, -.362, 0, 150.3 ),\tvec4( 27, 0, 0, .2 ),   \tvec4( 1050, 40, 0, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_RUNWAY,\t.550, 0, 12 ),  vec4( .122, -.087, 0, 324.7 ),\tvec4( 3, 0, 0, 0 ),    \t\tvec4( 16.4, 50, 2, 2 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .025, 0, 12 ),  vec4( .122, -.087, .0035, 324.7 ), vec4( 11, 0, 0, 2 ),    \tvec4( .015, .025, .004, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .025, 0, 12 ),  vec4( .112, -.067, 0, -30.3 ),\tvec4( 30, 0, 0, 2 ),\t  \tvec4( .0005, .0005, .003, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .025, 0, 12 ),  vec4( .112, -.107, 0, -43.5 ),\tvec4( 30, 0, 0, 2 ),  \t\tvec4( .0005, .0005, .003, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .025, 0, 12 ),  vec4( .132, -.107, 0, -38.6 ),\tvec4( 30, 0, 0, 2 ),  \t\tvec4( .0005, .0005, .003, 0 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_PRIMITIVE, .025, 0, 12 ),  vec4( .132, -.067, 0, -26.5 ),\tvec4( 30, 0, 0, 2 ),  \t\tvec4( .0005, .0005, .003, 0 ) ),\n    SceneData( vec4( SCNOBJ_TYPE_PRIMITIVE,\t.002, 0, 12 ),  vec4(0),    \t\t\t\t\tvec4( 30, 0, 0, 3 ),    \tvec4( .001, .0002, 0, 0 ) ),\n    SceneData( vec4( SCNOBJ_TYPE_PRIMITIVE,\t.002, 0, 12 ),  vec4(0),    \t\t\t\t\tvec4( 30, 0, 0, 3 ), \t\tvec4( .00005, .001, 0, 0 ) ),\n    SceneData( vec4( SCNOBJ_TYPE_PRIMITIVE,\t.002, 0, 12 ),  vec4( 0, 0, .002, 0 ),   \t\tvec4( 31, 0, 0, 1 ),\t    vec4( .0005, ZERO ) ),\n\n    // 70 - Gonder scenery\n\tSceneData( vec4( SCNOBJ_TYPE_RUNWAY,    .310, 0, 13 ), vec4( -.059, -.038, 0, 213 ),  \tvec4( 6, 0, 0, .45 ),  \t\tvec4( 720, 30, 5, 2 ) ),\n\tSceneData( vec4( SCNOBJ_TYPE_TOWER,     .015, 0, 13 ), vec4(  .067,\t .044, 0, 123 ), \tvec4( 3, 0, 0, .006 ), \t\tvec4( .012, .010, .002, .002 ) ),\n\n    // 72 - Ash island\n    SceneData( vec4( SCNOBJ_TYPE_RUNWAY, \t.345, 0, 14 ), vec4( ZERO, 28 ),\t\t\t\tvec4( 20, 0, 0, 0 ),\t \tvec4( 690, 25, 80, 10 ) ),\n\n    // 73 - Whitelands scenery\n    SceneData( vec4( SCNOBJ_TYPE_RUNWAY,\t.330, 0, 15 ), vec4( ZERO, 72 ),   \t\t\t\tvec4( 23, 0, 0, .4 ),      \tvec4( 660, 25, 10, 10 ) ),\n\n    //\n    SceneData( vec4( SCNOBJ_TYPE_INVALID, ZERO ), vec4(0), vec4(0), vec4(0) )\n);\n\n// ----------------------------------------------------------------------------\n// TEXT DATA\n// ----------------------------------------------------------------------------\n\nconst uvec4[] g_text_data = uvec4[](\n    // 80\n    uvec4(0),\n    uvec4( 0x2e2e2e00, 0, 0, 3 ),\t\t\t\t\t\t// '...'\n    uvec4( 0x636f6d6d, 0x616e6400, 0, 7 ),\t\t\t\t// 'command'\n    uvec4( 0x656e6769, 0x6e650000, 0, 6 ),\t\t\t\t// 'engine'\n    uvec4( 0x636f6e74, 0x726f6c00, 0, 7 ),\t\t\t\t// 'control'\n    uvec4( 0x7468726f,\t0x74746c65, 0, 8 ),\t\t\t\t// 'throttle'\n    uvec4( 0x696e666f, 0, 0, 4 ),\t\t\t\t\t\t// 'info'\n    uvec4( 0x6d6f6465, 0, 0, 4 ),\t\t\t\t\t\t// 'mode'\n\t\n    // 88\t\n    uvec4( 0x70616765, 0, 0, 4 ),\t\t\t\t\t\t// 'page'\n    uvec4( 0x72617465, 0, 0, 4 ),\t\t\t\t\t\t// 'rate'\n    uvec4( 0x64726976, 0x65000000, 0, 5 ),\t\t\t\t// 'drive'\n    uvec4( 0x696d7075, 0x6c736500, 0, 7 ),\t\t\t\t// 'impulse'\n\tuvec4( 0x6e6f7661, 0, 0, 4 ),\t\t\t\t\t\t// 'nova'\n    uvec4( 0x6165726f, 0, 0, 4 ),\t\t\t\t\t\t// 'aero'\n    uvec4( 0x6d616e75, 0x616c0000, 0, 6 ),\t\t\t\t// 'manual'\n    uvec4( 0x73757266, 0x61636500, 0, 7 ),\t\t\t\t// 'surface'\n\n    // 90\n    uvec4( 0x6f726269, 0x74000000, 0, 5 ),\t\t\t\t// 'orbit'\n    uvec4( 0x6c6f6361, 0x74696f6e, 0, 8 ),\t\t\t\t// 'location'\n    uvec4( 0x64697265, 0x63740000, 0, 6 ),\t\t\t\t// 'direct'\n    uvec4( 0x73656c65, 0x63740000, 0, 6 ),\t\t\t\t// 'select'\n    uvec4( 0x73706163, 0x65000000, 0, 5 ),\t\t\t\t// 'space'\n    uvec4( 0x63656e74, 0x65720000, 0, 6 ),\t\t\t\t// 'center'\n    uvec4( 0x65617374, 0, 0, 4 ),\t\t\t\t\t\t// 'east'\n    uvec4( 0x77657374, 0, 0, 4 ),\t\t\t\t\t\t// 'west'\n\n    // 98\n    uvec4( 0x6e6f7274, 0x68000000, 0, 5 ),\t\t\t\t// 'north'\n    uvec4( 0x736f7574, 0x68000000, 0, 5 ),\t\t\t\t// 'south'\n    uvec4( 0x706f6c65, 0, 0, 4 ),\t\t\t\t\t\t// 'pole'\n    uvec4( 0x73746174, 0x696f6e00, 0, 7 ),\t\t\t\t// 'station'\n    uvec4( 0x476c6964, 0x65720000, 0, 6 ),\t\t\t\t// 'Glider'\n    uvec4( 0x53686164, 0x6572746f, 0x79000000, 9 ),\t\t// 'Shadertoy'\n    uvec4( 0x45646974, 0x696f6e00, 0, 7 ),\t\t\t\t// 'Edition'\n    uvec4( 0x73746172, 0x74000000, 0, 5 ),\t\t\t\t// 'start'\n\n    // a0\n    uvec4( 0x7472616e, 0x73666572, 0x696e6700, 8 ),\t\t// 'transfer'\n    uvec4( 0x43616e63, 0xfa6e0000, 0, 6 ),\t\t\t\t// 'Canc\u00fan'\n    uvec4( 0x756e6465, 0x72776174, 0x65720000, 10 ),\t// 'underwater'\n    uvec4( 0x7072696d, 0x69746976, 0x65000000, 9 ),\t\t// 'primitive'\n    uvec4( 0x6368616c, 0x6c656e67, 0x65000000, 9 ), \t// 'challenge'\n    uvec4( 0x6f766572, 0x6c617900, 0, 7 ), \t\t\t\t// 'overlay'\n    uvec4( 0x7472656e, 0x63680000, 0, 6 ),   \t\t\t// 'trench'\n    uvec4( 0x77617970, 0x6f696e74, 0, 8 ),   \t\t\t// 'waypoint'\n\n    // a8\n    uvec4( 0x69736c61, 0x6e640000, 0, 6 ),\t\t\t\t// 'island'\n    uvec4( 0x696d706c, 0x656d656e, 0x74656400, 11 ),\t// 'implemented'\n    uvec4( 0x746f7563, 0x68646f77, 0x6e000000, 9 ),\t\t// 'touchdown'\n    uvec4( 0x73756363, 0x65737366, 0x756c0000, 10 ),\t// 'successful'\n    uvec4( 0x65786365, 0x6c6c656e, 0x74000000, 9 ),\t\t// 'excellent'\n    uvec4( 0x64657374, 0x696e6174, 0x696f6e00, 11 ),\t// 'destination'\n\tuvec4( 0x726f7461, 0x74696f6e, 0, 8 ),\t\t\t\t// 'rotation'\n\tuvec4( 0x77697265, 0, 0, 4 ),\t\t\t\t\t\t// 'wire'\n\n    // b0\n    uvec4( 0x80000000, 0, 0, 1 ),\t\t\t\t\t\t// '\u03b1' (alpha)\n    uvec4( 0x85000000, 0, 0, 1 ),\t\t\t\t\t\t// '\u03b8' (theta)\n    uvec4( 0x8a000000, 0, 0, 1 ),\t\t\t\t\t\t// '\u03c1' (rho)\n    uvec4( 0xb0000000, 0, 0, 1 ),\t\t\t\t\t\t// '\u00b0' (degrees)\n    uvec4( 0xb3000000, 0, 0, 1 ),\t\t\t\t\t\t// '\u00b3' (super 3)\n    uvec4( 0x91680000, 0, 0, 2 ),\t\t\t\t\t\t// '\u0394h' (Delta h)\n    uvec4(0)\n);\n\n// ----------------------------------------------------------------------------\n// VEHICLE INPUT STATE\n// ----------------------------------------------------------------------------\n\nconst int KEY_CTRL = 17;\nconst int KEY_ALT = 18;\nconst int KEY_F1 = 112;\nconst int KEY_F2 = 113;\nconst int KEY_F3 = 114;\nconst int KEY_F4 = 115;\nconst int KEY_META = 224;\n\n#if KIOSK_MODE\n\nfloat keystate( int key )\n\t{ return 0.; }\n\nfloat keypress( int key )\n\t{ return 0.; }\n\nfloat keystatepress( int key )\n\t{ return 0.; }\n\n#else\n\nfloat keystate( int key )\n\t{ return texelFetch( iChannel3, ivec2( key, 0 ), 0 ).x; }\n\nfloat keypress( int key )\n\t{ return texelFetch( iChannel3, ivec2( key, 1 ), 0 ).x; }\n\nfloat keystatepress( int key )\n\t{ return max( keystate( key ), keypress( key ) ); }\n\n#endif\n\n// ----------------------------------------------------------------------------\n// FRAME CONTEXT\n// ----------------------------------------------------------------------------\n\nstruct FrameContext\n{\n    float timeaccel;\n    int subframe_count;\n    float subframe_dt;\n    float dt;\n};\n\nFrameContext fr_init( vec4 dtime, bool local )\n{\n    FrameContext result;\n    float dt_frame = dot( dtime, vec4( 1, 2, 2, 1 ) / 6. );\n    result.timeaccel =\n        keystate( KEY_F4 ) > 0. && !local ? 10000. :\n        keystate( KEY_F3 ) > 0. ? 1000. :\n    \tkeystate( KEY_F2 ) > 0. ? 100. :\n        keystate( KEY_F1 ) > 0. ? 10. :\n    \t1.;\n\tresult.subframe_count = min( VS_MAX_ITER, int( ceil( sqrt( result.timeaccel ) ) ) );\n\tresult.subframe_dt = min( local ? VS_MAX_PACE_LOCAL : VS_MAX_PACE, dt_frame * result.timeaccel / float( result.subframe_count ) );\n    result.timeaccel = result.timeaccel == 1. ? 1. : float( result.subframe_count ) * safediv( result.subframe_dt, dt_frame );\n\tresult.dt = result.subframe_dt * float( result.subframe_count );\n    return result;\n}\n\n// ----------------------------------------------------------------------------\n// TEXT PROCESSING\n// ----------------------------------------------------------------------------\n\nint ipow( int b, int e )\n{\n    int result = 1;\n    if( e >= 0 )\n    {\n        if( bool( e & 1 ) ) result *= b; b *= b;\n    \tif( bool( e & 2 ) ) result *= b; b *= b;\n    \tif( bool( e & 4 ) ) result *= b; b *= b;\n    \tif( bool( e & 8 ) ) result *= b; b *= b;\n    }\n    return result;\n}\n\nvec4 text_format( int index, vec4 params, uvec4 phrase, vec4 argv )\n{\n#define CHROUT(p,chr) if( (p) >= 0 && (p) < 4 ) result[p] = chr;\n    vec4 result = vec4(0);\n    int argc = 0;\n    int nchars = 0;\n    int nwords = int( phrase.w & TXT_FMT_LENGTH_MASK );\n    for( int i = 0, n = nwords; i < n; ++i )\n    {\n        int pbase = nchars + 5 - 4 * index;\n        int code = int( ( phrase[ i >> 2 ] >> ( ( ~i & 3 ) << 3 ) ) & 0xffu );\n        if( code >= 0xf0 && argc < 4 )\n        {\n            // numeric conversion\t\t\tintegers\tdecimals\n            // -------------------------------------------------\n            // 0xf0 .. 0xf2: \tunsigned \t2,3,4\t\t0\n            // 0xf3 .. 0xf5: \tsigned\t\t2,3,4\t\t0\n            // 0xf6 .. 0xf8: \tsigned\t\t2,3,4\t\t1\n            // 0xf9 .. 0xfb: \tsigned\t\t2,3,4\t\t2\n            // 0xfc .. 0xfe: \tsigned\t\t2,3,4\t\t4\n            // 0xff: \t\t\tsigned\t\t2\t\t\t6\n\n            const int base = 10;\n            float arg = argv[ argc ];\n            int p = ( code - 0xf0 ) % 3 + 2;\n            int m = ipow( base, p );\n\t\t\tint q = ( code - 0xf0 ) / 3;\n            bool overflow = abs(arg) >= float(m);\n            bool signed = q > 0;\n            if( signed )\n            {\n                q = q * q / 4;\n                int r = ipow( base, q );\n                m *= r;\n                arg *= float(r);\n                arg += .5 * sign( arg );\n            }\n            else\n                arg *= float( base );\n            int a = int( arg );\n            int k = pbase;\n\t\t\tint jend = min( TXT_FMT_MAX_LEN - nchars - int( signed ), p + q + int( q > 0 ) );\n            bool dout = !signed;\n            for( int j = -int( signed ); j < jend; ++j )\n            {\n                int digit = abs(a) / m;\n            \tfloat chr = 32.;\n            \tif( j == p )\n                {\n                    chr = 46.;\n                    dout = true;\n                }\n                else\n\t\t\t\tif( !dout && arg < 0. && ( abs(a) * base >= m || j + 2 >= p ) )\n                {\n                    chr = 45.;\n                    a *= base;\n                    dout = true;\n                }\n                else\n                if( overflow )\n                {\n                \tchr = j >= 0 ? 42. : 32.;\n                }\n                else\n\t\t\t\t{\n                    a -= sign(a) * m * digit;\n                    a *= base;\n                \tif( digit > 0 || j + 1 >= p )\n                        dout = true;\n                    if( dout )\n  \t            \t\tchr = float( digit ) + 48.;\n\t\t\t\t}\n                CHROUT( k, chr );\n                k++;\n            }\n            nchars += jend + int( signed );\n            argc++;\n        }\n       \telse\n        if( code >= 0x80 && ( code & 0x7f ) < g_text_data.length() )\n        {\n            // word substitution for bytes 0x80..0xef\n            uvec4 word = g_text_data[ code & 0x7f ];\n            int wlen = min( TXT_FMT_MAX_LEN - nchars, int( word.w & 0xffu ) );\n            if( pbase >= -wlen && pbase < 4 )\n                for( int j = 0; j < wlen; ++j )\n                {\n                    int chr = int( ( word[ j >> 2 ] >> ( ( ~j & 3 ) << 3 ) ) & 0xffu );\n                    if( i == 0 && j == 0 )\n                        chr = int( chr ) & ~0x20;\n                    CHROUT( pbase + j, float( chr ) );\n                }\n            nchars += wlen;\n            if( i + 1 < nwords )\n            { CHROUT( pbase + wlen, 32. ); nchars++; }\n        }\n        else\n        if( code > 0 && nchars < TXT_FMT_MAX_LEN )\n        {\n            // literal character\n            CHROUT( pbase, float( code ) ); nchars++;\n        }\n    }\n\n    if( index == 0 )\n    {\n        result = params;\n        if( ( phrase.w & TXT_FMT_FLAG_CENTER ) == TXT_FMT_FLAG_CENTER )\n            result.x -= abs( result.w ) * float( nchars ) * TXT_FONT_SPACING / 2.;\n        else\n        if( ( phrase.w & TXT_FMT_FLAG_RIGHT ) == TXT_FMT_FLAG_RIGHT )\n            result.x -= abs( result.w ) * float( nchars ) * TXT_FONT_SPACING;\n    }\n    else\n    if( index == 1 )\n    {\n        result.x = float( nchars );\n        if( ( phrase.w & TXT_FMT_FLAG_HUDCLIP ) == TXT_FMT_FLAG_HUDCLIP )\n        \tresult.x = -result.x;\n    }\n\treturn result;\n#undef CHROUT\n}\n\nvoid process_text_message_line( int i, inout int N,\n                            \tinout vec4 params, inout uvec4 phrase, inout vec4 argv )\n{\n    float x = ( 1. + 2. * ( 1. - fract( 1. - memload( iChannel0, ADDR_MESSAGES, 0 ).x ) ) ) * g_textres.x / 2.;\n    float y = g_textres.y / 4. + 16.;\n    switch( i - N )\n    {\n    case 0:\n        params = vec4( x - g_textres.x, y, 1, 15 );\n        phrase = unpack_uvec4( memload( iChannel0, ADDR_MESSAGES, 1 ) );\n        phrase.w |= TXT_FMT_FLAG_CENTER | TXT_FMT_FLAG_HUDCLIP;\n        argv = memload( iChannel0, ADDR_MESSAGES, 1 + TXT_MSG_MAX_PHRASES );\n        break;\n    case 1:\n        params = vec4( x, y, 1, 15 );\n        phrase = unpack_uvec4( memload( iChannel0, ADDR_MESSAGES, 2 ) );\n        phrase.w |= TXT_FMT_FLAG_CENTER | TXT_FMT_FLAG_HUDCLIP;\n        argv = memload( iChannel0, ADDR_MESSAGES, 2 + TXT_MSG_MAX_PHRASES );\n        break;\n    }\n    N += 2;\n}\n\nvoid process_text_select_location( int i, inout int N,\n                                   inout vec4 params, inout uvec4 phrase,\n                                   GameState gs )\n{\n\tint n = ADDR_START_DATA_COUNT - 1;\n    int index = i - N + 1;\n    if( index >= 1 && index < n )\n    {\n        StartData start = st_load( iChannel0, ADDR_START_DATA + ivec2( index, 0 ) );\n\t\tvec3 nav = start.iparams.x == 3 && start.iparams.y < ADDR_SCENE_DATA_COUNT ?\n\t        sd_load( iChannel1, ivec2( 0, ADDR_B_SCENEDATA + ADDR_SCENE_DATA_SIZE * start.iparams.y ) ).navb.xyz :\n\t    \tstart.params.xyz * vec3( 1, 1, TRN_SCALE );\n        vec3 r = nav2r( vec3( nav.xy, nav.z + g_data.radius ) );\n        vec3 v = normalize( r - g_vehicle.localr ) * gs.camframe;\n        v = round( 2047.5 * v + 2047.5 );\n        params = vec4( v.x + v.y / 4096., v.z, 1, -12 );\n      #if WORKAROUND_05_UVEC4\n        phrase = uvec4( uint( 64 + index ) << 24u, 0u, 0u, 1u );\n      #else\n        phrase = uvec4( uint( 64 + index ) << 24u, 0, 0, 1 );\n      #endif\n    }\n    N += n - 1;\n}\n\nvoid process_text_command_menu( int i, inout int N,\n                                inout vec4 params, inout uvec4 phrase,\n                                GameState gs )\n{\n    uvec4 currmenu = md_load( iChannel0, gs.menustate.x );\n    if( i == N )\n        params = vec4( 24, g_textres.y - 24., -1, 15 ),\n        phrase = currmenu;\n    N++;\n    int j = i - N;\n    int n = int( currmenu.w >> 8 ) & 0xff;\n    int p = int( currmenu.w >> 16 ) & 0xff;\n    if( n > 0 && j >= 0 )\n    {\n        float y = g_textres.y - 48. - float( j % n ) * 16.;\n        if( j < n )\n            params = vec4( 24, y, 1, 15 ), phrase = uvec4( ( ( j + 49 ) << 24 ) | 0x2e2000, 0, 0, 3 );\n        else\n        if( j < 2 * n )\n            params = vec4( 48, y, 1, 15 ), phrase = md_load( iChannel0, p + j - n );\n    }\n    N += 2 * n;\n}\n\nvoid process_text_conj_gradients( int i, inout int N,\n                                  inout vec4 params, inout uvec4 phrase )\n{\n    vec3 r_ = g_vehicle.orbitr;\n    vec3 v_ = g_vehicle.orbitv;\n    float invGM = 1. / g_data.GM;\n\n    float r2 = dot( r_, r_ );\n    float v2 = dot( v_, v_ );\n    float rv = dot( r_, v_ );\n    vec3 h_ = cross( r_, v_ );\n\tfloat h2 = dot( h_, h_ );\n    float h = sqrt( h2 );\n    float r = sqrt( r2 );\n    float epsilon = v2 * invGM - 1. / r;\n    vec3 e_ = epsilon * r_ - rv * invGM * v_;\n    float e2 = dot( e_, e_ );\n    float e = sqrt( e2 );\n    vec3 f_ = e_ + epsilon * r_;\n\n\tvec3[5] dirs = vec3[5](\n        cross( v_, h_ ) * sign( 1. - e ),\n        f_,\n        2. * e * ( 1. + e ) * r_ - invGM * h2 * f_,\n        2. * e * ( 1. - e ) * r_ + invGM * h2 * f_,\n        h_\n    );\n\n    if( lensq( dirs[2] ) * 1e8 < r2 * e )\n   \t    dirs[2] = abs( rv ) / r2 * r_ + sign( rv ) * e * v_;\n\n    if( lensq( dirs[3] ) * 1e8 < r2 * e )\n        dirs[3] = abs( rv ) / r2 * r_ - sign( rv ) * e * v_;\n\n    uvec4[5] phrases = uvec4[5](\n        uvec4( 0x00650000, 0, 0, 2 ),\t\t// e\n        uvec4( 0x00610000, 0, 0, 2 ),\t\t// a\n        uvec4( 0x00417000, 0, 0, 3 ),\t\t// Ap\n        uvec4( 0x00506500, 0, 0, 3 ),\t\t// Pe\n\t\tuvec4( 0x00680000, 0, 0, 2 ) \t\t// h\n\t);\n\n    vec2 tsc = sincospi( g_vehicle.tvec / 180. );\n    mat3 tvecrot = g_vehicle.B * \n        mat3( tsc.y, 0, tsc.x, 0, g_vehicle.tvec < 105. ? 1 : -1, 0, -tsc.x, 0, tsc.y ) * \n        transpose( g_vehicle.B );\n\n    for( int j = 0; j < 5; ++j )\n    if( lensq( dirs[j] ) * 1e12 >= r2 && i == N++ )\n    {\n        vec3 dir = tvecrot * normalize( dirs[j] );\n        if( dot( dir, g_planet.B * g_game.camframe[0] ) < 0. )\n\t\t\tdir = -dir;\n\t\tbool plus = dot( dir, tvecrot * ( j >= 4 ? h_ : cross( h_, dirs[ j ^ 1 ] ) ) ) >= 0.;\n        dir = round( 2047.5 * dir * g_planet.B * g_game.camframe + 2047.5 );\n        params = vec4( dir.x + dir.y / 4096., dir.z, 1, -12 );\n        phrase = phrases[j];\n\t\tphrase[0] |= plus ? 0x2b000000u : 0x2d000000u;\n    }\n}\n\n#define CW(a,b) ( (a) * (b) * TXT_FONT_SPACING )\n\nvoid process_text_hud_numbers( int i, inout int N,\n                               inout vec4 params, inout uvec4 phrase, inout vec4 argv,\n                               GameState gs, PlanetState ps )\n{\n    float left = g_textres.x / 4.;\n    float right = g_textres.x * 3. / 4.;\n    float y = g_textres.y / 2.;\n\tvec3 localv = ( g_vehicle.localv + \n\t\tcross( vec3( 0, 0, g_vehicle.modes.x == VS_HMD_ORB ? ps.omega : 0. ), g_vehicle.localr ) );\n    float spd =  length( localv );\n    if( spd >= 0.0005 && i == N++ )\n    {\n        // speed\n        params = vec4( left - CW(4.,15.), y, 1, 15 );       \n        if( spd < 9.9995 )\n        \tphrase = uvec4( 0x202020f5, 0, 0, 4 ), argv.x = 1000. * spd;\n        else\n\t\tif( spd < 9999.995 )\n        \tphrase = uvec4( 0xfb6b0000, 0, 0, 2 ), argv.x = spd;\n        else\n        \tphrase = uvec4( 0xfb4d0000, 0, 0, 2 ), argv.x = spd / 1000.;\n\t}\n    if( g_env.H != 0. )\n\t{\n        // mach \n        float mach = length( g_vehicle.localv ) / g_env.atm.w;\n        if( mach >= 0.005 && i == N++ )\n        {\n\t        params = vec4( left - CW(2.,12.), y - 16., 1, 12 );\n    \t    phrase = uvec4( 0x4df90000, 0, 0, 2 );\n            argv.x = mach;\n        }       \n\t\t// dyn pressure\n        float Q = .5 * ( 1e6 / 1e5 ) * g_env.atm.z * dot( g_vehicle.localv, g_vehicle.localv );\n        if( Q >= 0.005 && i == N++ )\n        {            \n\t        params = vec4( left -CW(2.,12.), y - 32., 1, 12 );            \n            phrase = uvec4( 0x51f90000, 0, 0, 2 );\n\t\t\targv.x = Q;\n        }\n    }\n    if( i == N++ )\n    {\n\t    // altitude\n    \tfloat alt = length( g_vehicle.localr ) - g_data.radius;\n        params = vec4( right - CW(8.,15.), y, 1, 15 );\n        if( alt < 9.9995 )\n        \tphrase = uvec4( 0x202020f5, 0, 0, 4 ), argv.x = 1000. * alt;\n        else\n        if( alt < 9999.995 )\n        \tphrase = uvec4( 0xfb6b0000, 0, 0, 2 ), argv.x = alt;\n        else\n        \tphrase = uvec4( 0xfb4d0000, 0, 0, 2 ), argv.x = alt / 1000.;\n\t}\n    float vs = dot( localv, normalize( g_vehicle.localr ) );\n    if( abs( vs ) >= 0.0000005 && i == N++ )\n    {    \n        // vertical speed\n        params = vec4( right - CW(8.,12.), y - 15., 1, 12 );\n        if( abs( vs ) < 9.9995 )\n        \tphrase = uvec4( abs( vs ) < 0.00995 ? 0x202020f6 : 0x202020f5, 0, 0, 4 ), argv.x = 1000. * vs;\n        else\n\t\tif( abs( vs ) < 9999.5 )\n        \tphrase = uvec4( 0xfb6b0000, 0, 0, 2 ), argv.x = vs;\n        else\n        \tphrase = uvec4( 0xfb4d0000, 0, 0, 2 ), argv.x = vs / 1000.;\n\t}\n    if( i == N++ )\n    {\n        // heading\n        params = vec4( g_textres.x / 2. - CW(1.5,12.), g_textres.y / 4., 1, 12 );\n        phrase = uvec4( 0xf1000000, 0, 0, 1 );\n        argv.x = B2bearing( g_vehicle.localr, g_vehicle.localB[0] ) + .5;\n    }\n    if( i == N++ )\n    {\n        // g-load\n       \tparams = vec4( g_textres.x / 2. - CW(3.5,12.), g_textres.y / 4. - 18., 1, 12 );\n\t   \tphrase = uvec4( 0x47f90000, 0, 0, 2 );\n\t    argv.x = -1000. / FDM_STD_G * g_vehicle.acc.z;\n    }\n}\n\nvoid process_text_time_accel( int i, inout int N,\n                              inout vec4 params, inout uvec4 phrase, inout vec4 argv, FrameContext fr )\n{\n    float y = 3. * g_textres.y / 4.;\n    if( ( g_game.switches & GS_PAUSE ) == GS_PAUSE )\n    {\n        if( i == N )\n            params = vec4( g_textres.x / 2., y, step( .5, fract( iTime ) ), 12 ),\n            phrase = uvec4( 0x50415553, 0x45000000, 0, 5u | TXT_FMT_FLAG_CENTER );\n        N++;\n    }\n    else\n    if( fr.timeaccel > 1.0625 )\n    {\n        if( i == N )\n            params = vec4( g_textres.x / 2., y, step( .5, fract( iTime ) ), 12 ),\n            phrase = uvec4( 0x54494d45, 0x20d7f500, 0, 7u | TXT_FMT_FLAG_CENTER ),\n            argv.x = fr.timeaccel;\n        N++;\n    }\n\n    if( g_game.camzoom > 1. )\n    {\n        if( i == N )\n            params = vec4( g_textres.x / 2., y - 18., 1, 12 ),\n            phrase = uvec4( 0x5a4f4f4d, 0, 0, 4u | TXT_FMT_FLAG_CENTER );\n        N++;\n    }\n}\n\nvoid process_text_console( int i, inout int N,\n                           inout vec4 params, inout uvec4 phrase, inout vec4 argv )\n{\n    vec3 FSG_distance = abs( g_vehicle.FSG - ONE );\n    FSG_distance.x = min( FSG_distance.x, abs( g_vehicle.FSG.x - 1./9. ) );\n    FSG_distance.x = min( FSG_distance.x, abs( g_vehicle.FSG.x - 4./9. ) );\n\n    vec3 FSG_light = max( vec3( .25 ),\n                          min( step( FRACT_1_64, g_vehicle.FSG ),\n                          \t   max( vec3( step( .5, fract( iTime ) ) ),\n                                    1. - step( FRACT_1_64, FSG_distance ) ) ) );\n\n    const uvec2 aero_modes[] = uvec2[] (\n        uvec2( 0x4f464600, 3u | TXT_FMT_FLAG_CENTER ),\n        uvec2( 0x4d414e00, 3u | TXT_FMT_FLAG_CENTER ),\n        uvec2( 0x46425700, 3u | TXT_FMT_FLAG_CENTER )\n    );\n\n    const uvec2 rcs_modes[] = uvec2[] (\n        uvec2( 0x4f464600, 3u | TXT_FMT_FLAG_CENTER ),\n        uvec2( 0x4d414e00, 3u | TXT_FMT_FLAG_CENTER ),\n        uvec2( 0x52415445, 4u | TXT_FMT_FLAG_CENTER ),\n        uvec2( 0x4c564c48, 4u | TXT_FMT_FLAG_CENTER )\n    );\n\n    const uvec2 thr_modes[] = uvec2[] (\n        uvec2( 0x4f464600, 3u | TXT_FMT_FLAG_CENTER ),\n        uvec2( 0x4d414e00, 3u | TXT_FMT_FLAG_CENTER )\n    );\n\n    const uvec2 eng_modes[] = uvec2[] (\n        uvec2( 0x4f464600, 3u | TXT_FMT_FLAG_CENTER ),\n        uvec2( 0x44525600, 3u | TXT_FMT_FLAG_CENTER ),\n        uvec2( 0x494d5000, 3u | TXT_FMT_FLAG_CENTER ),\n        uvec2( 0x4e4f5641, 4u | TXT_FMT_FLAG_CENTER )\n    );\n    \n    bool trimdisplay =\n        max( keystate( KEY_CTRL ), keystate( KEY_META ) ) > 0. && ( g_vehicle.modes2.x != VS_AERO_OFF );\n\n#if WORKAROUND_08_UINT2FLOAT\n    float tvec = float( int( ( g_vehicle.switches & VS_TVEC_MASK ) >> VS_TVEC_SHIFT ) );\n#else\n    float tvec = float( ( g_vehicle.switches & VS_TVEC_MASK ) >> VS_TVEC_SHIFT );\n#endif\n    float tvec_target = tvec * ( 84. + tvec * ( tvec * 3. - 27. ) );\n    float tvec_distance = abs( g_vehicle.tvec - tvec_target );\n    float tvec_light = max( step( .5, fract( iTime ) ), 1. - step( 2.5, tvec_distance ) );\n\n    switch( i - N )\n    {\n    case 0:\n        argv.x = 100. * g_vehicle.throttle;\n\t#if WORKAROUND_04_VEC4\n        params = vec4( 32, 8., abs( sign( g_vehicle.throttle ) ), 12 );\n\t#else\n        params = vec4( 32, 8, abs( sign( g_vehicle.throttle ) ), 12 );\n\t#endif\n        phrase = uvec4( abs( argv.x ) < 9.95 ? 0xf6000000 : 0xf4000000, 0, 0, 1 );\n        break;\n    case 1:\n\t\tparams = vec4( 96, 8, 1, 12 );\n\t#if WORKAROUND_05_UVEC4\n        phrase = uvec4( 0x13131313u, 0u, 0u, ( g_vehicle.switches & VS_FLAPS_MASK ) >> VS_FLAPS_SHIFT | TXT_FMT_FLAG_RIGHT );\n\t#else\n\t\tphrase = uvec4( 0x13131313, 0, 0, ( g_vehicle.switches & VS_FLAPS_MASK ) >> VS_FLAPS_SHIFT | TXT_FMT_FLAG_RIGHT );\n\t#endif\n        break;\n\tcase 2: params = vec4( 104, 8, FSG_light.x, 15 ); phrase = uvec4( 0x46000000, 0, 0, 1 ); break;\n    case 3: params = vec4( 120, 8, FSG_light.y, 15 ); phrase = uvec4( 0x53000000, 0, 0, 1 ); break;\n    case 4: params = vec4( 136, 8, FSG_light.z, 15 ); phrase = uvec4( 0x47000000, 0, 0, 1 ); break;\n    case 5: params = vec4( 168, 8, g_vehicle.modes2.x == 0 ? .25 : 1., 12 ); phrase = aero_modes[ clamp( g_vehicle.modes2.x, 0, 2 ) ].xxxy; break;\n    case 6: params = vec4( 200, 8, g_vehicle.modes2.y == 0 ? .25 : 1., 12 ); phrase = rcs_modes[ clamp( g_vehicle.modes2.y, 0, 3 ) ].xxxy; break;\n    // case 7: params = vec4( 232, 8, g_vehicle.modes2.z == 0 ? .25 : 1., 12 ); phrase = thr_modes[ clamp( g_vehicle.modes2.z, 0, 1 ) ].xxxy; break;\n    case 8: params = vec4( 264, 8, g_vehicle.modes.z == 0 ? .25 : 1., 12 ); phrase = eng_modes[ clamp( g_vehicle.modes.z, 0, 3 ) ].xxxy; break;\n    case 9:\n        argv.x = 100. * g_vehicle.trim;\n        params = vec4( g_textres.x * .5, 8, float( trimdisplay ), 12 );\n        phrase = uvec4( 0x5452494d, abs( argv.x ) < 9.95 ? 0xf6000000 : 0xf4000000, 0, 5 );\n        break;\n    case 10:\n        argv.x = tvec_target;\n        params = vec4( g_textres.x * .5 + 80., 8, g_vehicle.tvec >= 2.5 ? 1. : 0., 12 );\n        phrase = uvec4( tvec_light > 0. ? 0x564543f4 : 0x202020f4, 0, 0, 4 );\n    \tbreak;\n    }\n    N += 11;\n}\n\nvec3 fmt_time( int arg )\n{\n    int hours = arg / 3600;\n    int minutes = ( arg - 3600 * hours ) / 60;\n    int seconds = arg - 60 * minutes - 3600 * hours;\n    return vec3( hours, minutes, seconds );\n}\n\nvoid process_text_info_page( int i, inout int N,\n                          \t inout vec4 params, inout uvec4 phrase, inout vec4 argv,\n                             int pageno, GameState gs )\n{\n#define INFO1( a, b, c, d, arg ) if( i == N++ ) { phrase = uvec4( (a), (b), (c), (d) ); argv.x = (arg); }\n#define INFO2( a, b, c, d, arg ) if( i == N++ ) { phrase = uvec4( (a), (b), (c), (d) ); argv.xy = (arg); }\n#define INFO3( a, b, c, d, arg ) if( i == N++ ) { phrase = uvec4( (a), (b), (c), (d) ); argv.xyz = (arg); } \n    float x = g_textres.x - 128.;\n    float y = 64.;\n    if( i == N++ )\n        params = vec4( x, y, -1, 12 ), phrase = md_load( iChannel0, MENU_INFO_BEGIN + pageno );\n\tif( i < N )\n\t\treturn;    \n    y -= 20. + 12. * float( ( i - N ) & 3 );\n    params = vec4( x, y, 1, 12 );\n    if( pageno == GS_INFO_LOCATION )\n    {\n\t    vec4 loc = navb( g_vehicle.localr, g_vehicle.localB[0] ) - vec4( 0, 0, g_data.radius, 0 );    \n        INFO1( 0x6c617420, 0xfeb30000, 0, 6, loc.x );\n        INFO1( 0x6c6f6e67, 0xfeb30000, 0, 6, loc.y );\n        INFO1( 0x616c7420, abs( loc.z ) < 9999.99995 ? 0xfe206b6d : ( loc.z /= 1000., 0xfe204d6d ), 0, 8, loc.z );\n        INFO1( 0x68646720, 0xfeb30000, 0, 6, loc.w );\n    }\n    else\n\tif( pageno == GS_INFO_WAYPOINT && gs.waypoint != ZERO )\n\t{\n        vec2 arcdist = arcdistance( gs.waypoint, g_vehicle.localr );\n        float eta = length( arcdist ) / length( g_vehicle.localv );\n        INFO1( 0x62726720, 0xfeb30000, 0, 6, B2bearing( g_vehicle.localr, gs.waypoint - g_vehicle.localr ) );\n        INFO1( 0x64737420, 0xfe206b6d, 0, 8, arcdist.x );\n        INFO1( 0xb520fe20, 0x6b6d0000, 0, 6, arcdist.y );\n        if( dot( g_vehicle.localv, g_vehicle.localv ) >= .25e-6 )\n            if( eta < 8640000. )\n            \t{ INFO3( 0x65746120, 0x2020f33a, 0xf03af020, 12, fmt_time( int( floor( eta ) ) ) ) }\n            else\n                INFO1( 0x65746120, 0xfe206400, 0, 7, eta / 86400. );\n\t}\n    else\n\tif( pageno == GS_INFO_ORBIT )\n    {\n        Kepler K = Kepler( 0., 0., 0., 0., 0. );\n        float nu = kepler_init( K, g_vehicle.orbitr, g_vehicle.orbitv, g_data.GM );\n        float ap = K.p / ( 1. - K.e ) - g_data.radius;\n        float pe = K.p / ( 1. + K.e ) - g_data.radius;\n        if( K.e < 0.99995 )\n            INFO1( 0x41702020, abs( ap ) < 10000. ? 0xfe206b6d : ( ap /= 1000., 0xfe204d6d ), 0, 8, ap );\n        INFO1( 0x50652020, abs( pe ) < 10000. ? 0xfe206b6d : ( pe /= 1000., 0xfe204d6d ), 0, 8, pe );\n        INFO1( 0x65202020, 0xfe000000, 0, 5, K.e );\n        if( K.e >= .00005 )\n            INFO1( 0xb12020fe, 0xb3000000, 0, 5, degrees( nu ) );\n    }\n    else\n\tif( pageno == GS_INFO_GLIDE )\n    {\n        INFO1( 0x434c2020, 0xfe000000, 0, 5, g_vehicle.info.x );\n        INFO1( 0x43442020, 0xfe000000, 0, 5, g_vehicle.info.y );\n        INFO1( 0x4c2f4420, 0xfe000000, 0, 5, safediv( g_vehicle.info.x, g_vehicle.info.y ) );\n\t\tINFO1( 0xb02020fe, 0xb3000000, 0, 5, degrees( g_vehicle.info.z ) );\n    }\n    else\n\tif( pageno == GS_INFO_CONTROLS )\n    {\n        INFO1( 0x656c6576, 0xfe000000, 0, 5, g_vehicle.EAR.x * 100. );\n        INFO1( 0x61696c20, 0xfe000000, 0, 5, g_vehicle.EAR.y * 100. );\n        INFO1( 0x72756464, 0xfe000000, 0, 5, g_vehicle.EAR.z * 100. );\n        INFO1( 0x7472696d, 0xfe000000, 0, 5, g_vehicle.trim * 100. );\n    }\n    else\n\tif( pageno == GS_INFO_AIR )\n    {\n        INFO1( 0x54202020, 0xfeb34300, 0, 7, g_env.atm.x - 273.15 );\n        INFO1( 0x50202020, 0xfe206261, 0x72000000, 9, g_env.atm.y );\n        INFO1( 0x51202020, 0xfe206261, 0x72000000, 9, \n\t\t\t.5 * ( 1e6 / 1e5 ) * g_env.atm.z * dot( g_vehicle.localv, g_vehicle.localv ) );\n        INFO1( 0xb22020fe, 0x206b672f, 0x6db40000, 10, g_env.atm.z );\n    }\n    else\n    if( pageno == GS_INFO_TIME )\n    {\n        float tzone = round( navb( g_vehicle.localr, g_vehicle.localB[0] ).y / 15. );\n        bool dots = fract( g_game.datetime.x * 1440. * SECONDS_PER_MINUTE ) < .5;\n        INFO2( 0x64617465, 0x2020f22d, 0xf0000000, 9, g_game.datetime.zy + 1. );\n        INFO2( 0x74696d65, 0x20202020, dots ? 0xf03af000 : 0xf020f000, 11, \n\t\t\tfmt_time( int( mod( 86400. * g_game.datetime.x, 86400. ) ) ).xy );\n        INFO3( 0x6c6f6361, 0x6c202020, dots ? 0xf03af020 : 0xf020f020, \n            ( tzone == 0. ? 11 : tzone < 0. ? 0x202df00f : 0x202bf00f ),\n            vec3( fmt_time( int( mod( 86400. * g_game.datetime.x + 3600. * tzone, 86400. ) ) ).xy, abs( tzone ) ) );\n    }\n#undef INFO1\n#undef INFO2\n#undef INFO3\n}\n\nvoid process_text_map_markers( int i, inout int N,\n                          \t   inout vec4 params, inout uvec4 phrase, inout vec4 argv,\n                               GameState gs )\n{\n    if( i == N )\n    {\n        params = vec4( g_textres.x / 2. - CW(19.,15.) / 2., g_textres.y / 6., 1, 15 );\n        phrase = uvec4( 0x102020fb, 0x206b6d20, 0x20202012, 12 );\n        float ls = 2. * g_textres.x / g_textres.y * CW(19.,15.) / g_textres.x * g_data.radius / gs.camzoom;\n        argv.x = ls;\n    }\n    N++;\n    float x = g_textres.x - 160.;\n    float y = g_textres.y - 24.;\n    if( gs.waypoint != ZERO )\n    {\n        vec4 loc = navb( gs.waypoint, ZERO );\n        switch( i - N )\n        {\n        case 0: params = vec4( x, y,       1, 12 ); phrase = uvec4( 0xa7000000, 0, 0, 1 ); break;\n        case 1: params = vec4( x, y - 16., 1, 12 ); phrase = uvec4( 0x6c617420, 0xfeb30000, 0, 6 ); argv.x = loc.x; break;\n        case 2: params = vec4( x, y - 32., 1, 12 ); phrase = uvec4( 0x6c6f6e67, 0xfeb30000, 0, 6 ); argv.x = loc.y; break;\n        case 3: params = vec4( x, y - 48., 1, 12 ); phrase = uvec4( 0x616c7420, 0xfe206b6d, 0, 8 ), argv.x = loc.z - g_data.radius; break;\n        }\n        N += 4;\n        y -= 80.;\n    }\n    if( gs.mapmarker != ZERO )\n    {\n        vec4 loc = navb( gs.mapmarker, ZERO );\n        switch( i - N )\n        {\n        case 0: params = vec4( x, y,       1, 12 ); phrase = uvec4( 0x4d61726b, 0x65720000, 0, 6 ); break;\n        case 1: params = vec4( x, y - 16., 1, 12 ); phrase = uvec4( 0x6c617420, 0xfeb30000, 0, 6 ); argv.x = loc.x; break;\n        case 2: params = vec4( x, y - 32., 1, 12 ); phrase = uvec4( 0x6c6f6e67, 0xfeb30000, 0, 6 ); argv.x = loc.y; break;\n        case 3: params = vec4( x, y - 48., 1, 12 ); phrase = uvec4( 0x616c7420, 0xfe206b6d, 0, 8 ), argv.x = loc.z - g_data.radius; break;\n        }\n        N += 4;\n    }\n}\n\nvec4 process_text( int index,\n                   int offs,\n                   FrameContext fr,\n                   GameState gs,\n                   PlanetState ps )\n{\n    int N = 0, i = index;\n\tvec4 params = vec4(0), argv = vec4(0);\n    uvec4 phrase = uvec4(0);\n\n    process_text_message_line( i, N, params, phrase, argv );\n\n\tif( gs.stage == GS_SELECT_LOCATION && gs.timer >= 3.5 )\n    \tprocess_text_select_location( i, N, params, phrase, gs );\n\n    if( gs.stage == GS_RUNNING )\n    {\n        if( gs.menustate.x > 0 )\n            process_text_command_menu( i, N, params, phrase, gs );\n\n        if( ( gs.switches & GS_TRMAP ) == 0u )\n        {\n            if( g_vehicle.modes.x > VS_HMD_OFF )\n            {\n            \tprocess_text_hud_numbers( i, N, params, phrase, argv, gs, ps );\n\n                if( g_vehicle.modes.x >= VS_HMD_ORB )\n                \tprocess_text_conj_gradients( i, N, params, phrase );\n            }\n\n           \tprocess_text_time_accel( i, N, params, phrase, argv, fr );\n\t\t    process_text_console( i, N, params, phrase, argv );\n\n\t\t\tint infopage = int( gs.switches & GS_IPAGE_MASK ) >> GS_IPAGE_SHIFT;\n    \t\tif( infopage > 0 && infopage < MENU_INFO_SIZE )\n                process_text_info_page( i, N, params, phrase, argv, infopage, gs );\n        }\n        else\n        \tprocess_text_map_markers( i, N, params, phrase, argv, gs );\n   \t}\n\n    /*\n    // debug numbers\n\t{\n        vec4 debug = vec4(0);\n\n        // AtmContext atm = atm_load( iChannel0, ADDR_ATMCONTEXTS + ivec2(1,0) );\n        // debug = vec4( atm.r0, atm.htop, atm.r0 + atm.htop, length( gs.campos ) - g_data.radius );\n        // debug = vec4( log( g_game.exposure ) / LN10, 0, 0 );\n        // debug = g_vehicle.info;\n        // debug.xyz = g_vehicle.acc * 1000. / FDM_STD_G;\n        // debug.xyz = g_vehicle.accz * 1000. / FDM_STD_G;        \n\t\t// debug = g_vehicle.aerostuff;\n        // debug.xyz = g_vehicle.rcsstuff;\n        // debug = vec4( g_env.phases, g_env.atm2 );\n        // debug.xyz = log( g_env.atm.xyz ) / LN10;\n        // debug.xyz = g_game.vjoy;\n        // debug.xyz = vec3( 1000. * iTimeDelta, 1. / iTimeDelta, iFrameRate ); \n\n        float x = g_textres.x - 240.;\n\t\tfloat y = 64. - 20. - 12. * float( ( i - N ) & 3 );\n        if( i >= N && i < N + 4 )\n        {\n        \tparams = vec4( x, y, 1, 12 );\n\t\t\tswitch( i - N )\n    \t\t{\n    \t\tcase 0: phrase = uvec4( 0xfe000000, 0, 0, 1 ); argv.x = debug.x; break;\n    \t\tcase 1: phrase = uvec4( 0xfe000000, 0, 0, 1 ); argv.x = debug.y; break;\n    \t\tcase 2: phrase = uvec4( 0xfe000000, 0, 0, 1 ); argv.x = debug.z; break;\n    \t\tcase 3: phrase = uvec4( 0xfe000000, 0, 0, 1 ); argv.x = debug.w; break;\n    \t\t}\n        }\n    \tN += 4;\n    }\n\t//*/\n\n    return text_format( offs, params, phrase, argv );\n}\n\n\n// ----------------------------------------------------------------------------\n// MAIN\n// ----------------------------------------------------------------------------\n\nconst int MODE_NONE  \t\t= 0;\nconst int MODE_HEIGHT  \t\t= 1;\nconst int MODE_RADIUS\t\t= 2;\nconst int MODE_NORMAL\t\t= 4;\nconst int MODE_ZONEINDEX\t= 8;\nconst int MODE_SCENEDATA\t= 16;\nconst int MODE_AO\t\t\t= 32;\n\nstruct TerrainEvalParams\n{\n    int mode;\n    vec3 r;\n    float lod;\n    mat2x3 TB;\n    float eps;\n    vec3 r_hat;\n};\n\n\nint get_zone_index( vec3 r )\n{\n    int k = -1;\n    float mind = 1e36;\n    vec3 rn = normalize(r);\n    for( int i = 0; i < ADDR_LOC_DATA_COUNT; ++i )\n    {\n        vec4 zone = texelFetch( iChannel1, ivec2( ADDR_B_ZONEDATA + i, 0 ), 0 );\n        float d = lensq( zone.xyz - rn );\n        if( d < mind )\n            mind = d, k = i;\n    }\n    return k;\n}\n\nvoid mainImage( out vec4 fcolor, in vec2 fcoord )\n{\n    fcolor = vec4( ZERO, 0 );\n\n#if BUFFER_RUNLEVEL >= 2\n#if WITH_TERRAIN\n\n    g_game = gs_load( iChannel0, ADDR_GAMESTATE );\n    g_vehicle = vs_load( iChannel0, ADDR_VEHICLE );\n    g_planet = ps_load( iChannel0, ADDR_PLANETS + ivec2( 1, 0 ) );\n    g_data = g_planet_data[1];\n    g_env = env_load( iChannel0, ADDR_LOCALENV );\n\n    bool vrmode = bool( texelFetch( iChannel2, ivec2(0,0), 0 ).w );\n    g_textres = vrmode ?\n        iResolution.xy * inversesqrt( iResolution.y / 150. ) :\n    \tiResolution.xy * inversesqrt( iResolution.y / 450. );\n\n    ivec2 sc = ivec2( fcoord );\n    TerrainEvalParams trneval = TerrainEvalParams( 0, ZERO, 0., mat2x3(0), 0., ZERO );\n\n    if( sc.y < 2 )\n    {\n        // bottom letterbox space\n\t\tif( sc.x >= ADDR_B_SCENEDATA && sc.x < ADDR_B_SCENEDATA + ADDR_SCENE_DATA_COUNT * ADDR_SCENE_DATA_SIZE )\n        {\n            // scene data\n            int index = ( sc.x - ADDR_B_SCENEDATA ) / ADDR_SCENE_DATA_SIZE;\n            SceneData sd = g_scene_data[ index ];\n            int locindex = int( sd.tybr.w );\n            LocData ld = g_loc_data[ locindex ];\n            vec3 locr = nav2r( vec3( ld.zone.xy, g_data.radius ) );\n            mat3 locB = bearing2B( locr, ld.zone.w );\n            sd.navb.xy = r2nav( locr + locB[0] * sd.navb.x - locB[1] * sd.navb.y ).xy;\n            if( int( sd.tybr.x ) == SCNOBJ_TYPE_RUNWAY )\n            {\n                sd.tybr.y *= sqrt( SCN_SCALE );\n                sd.paramsB.x *= sqrt( SCN_SCALE );\n            }\n            sd_store( sd, ivec2( fcoord.y, ADDR_B_SCENEDATA + ADDR_SCENE_DATA_SIZE * index ), sc, fcolor );\n            if( sc.x - ADDR_B_SCENEDATA - ADDR_SCENE_DATA_SIZE * index == 1 )\n            {\n            \ttrneval.mode = MODE_SCENEDATA;\n\t\t\t\ttrneval.r = nav2r( vec3( sd.navb.xy, 1. ) );\n            \ttrneval.lod = TRN_MAX_LEVELS;\n            }\n\t\t}\n        else\n\t\tif( sc.x >= ADDR_B_ZONEDATA && sc.x < ADDR_B_ZONEDATA + ADDR_LOC_DATA_COUNT )\n        {\n            // zone data\n            int index = sc.x - ADDR_B_ZONEDATA;\n    \t\tvec3 zonedata = g_loc_data[ index ].zone.xyz;\n            fcolor = vec4( nav2r( vec3( zonedata.xy, 1 ) ), zonedata.z * SCN_SCALE / g_data.radius );\n        }\n        else\n\t\tif( sc.x >= ADDR_B_LOCDATA && sc.x < ADDR_B_LOCDATA + ADDR_LOC_DATA_COUNT * ADDR_LOC_DATA_SIZE )\n        {\n            // location data\n            int index = ( sc.x - ADDR_B_LOCDATA ) / ADDR_LOC_DATA_SIZE;\n    \t\tLocData ld = g_loc_data[ index ];\n            ld_store( ld, ivec2( fcoord.y, ADDR_B_LOCDATA + ADDR_LOC_DATA_SIZE * index ), sc, fcolor );\n        }\n        else\n        if( sc.x >= ADDR_B_WAYPOINT_SAMPLE )\n        {\n            // terrain sample at waypoint (if available)\n            if( g_game.waypoint != ZERO )\n            {\n                trneval.mode = MODE_HEIGHT | MODE_RADIUS;\n                trneval.r = g_game.waypoint;\n                trneval.lod = TRN_MAX_LEVELS - 2. * float( sc.x - ADDR_B_WAYPOINT_SAMPLE );\n            }\n            // also the effective text resolution for this frame\n            fcolor.xy = g_textres;\n        }\n        else // if( fcoord.x >= ADDR_B_CAMPOS_SAMPLE )\n        {\n            // terrain sample at camera position\n            if( g_game.campos != ZERO )\n            {\n                trneval.mode = MODE_HEIGHT | MODE_RADIUS | MODE_NORMAL;\n                trneval.r = g_game.campos;\n                trneval.lod = TRN_MAX_LEVELS - 2. * fcoord.x;\n            \tvec3 rn = normalize( g_game.campos );\n            \ttrneval.TB[0] = normalize( reject( UNIT_Z, rn ) );\n                trneval.TB[1] = cross( rn, trneval.TB[0] );\n\t\t\t\ttrneval.eps = 0.004 * SCN_SCALE;\n            }\n        }\n    }\n    else\n    if( fcoord.y >= iResolution.y - 2. )\n    {\n        // top letterbox space: text processing\n        int index = 2 * ( int( fcoord.x ) >> 4 ) + ( int( fcoord.y ) & 1 );\n        int offs = int( fcoord.x ) & 15;\n      \tvec4 dtime = vec4( iTimeDelta, memload( iChannel0, ADDR_DTIME, 0 ).xyz );\t    \n    \tbool locallimit = length( g_vehicle.orbitr ) <\n\t\t\t12. * g_data.atm_scale + log( g_data.atm_profile.ref.z ) + g_data.radius;  \n        FrameContext fr = fr_init( dtime, locallimit );\n\t\tVehicleState vs = vs_load( iChannel0, ADDR_VEHICLE );\n     \tfcolor = process_text( index, offs, fr, g_game, g_planet );\n    }\n    else\n    if( ( g_game.switches & GS_TRMAP ) == GS_TRMAP )\n    {\n        // main area: map display        \n\t    vec4 r = gs_map_unproject( g_game, fcoord, iResolution.xy );\n        if( abs( r.w ) < 1. )\n        {\n            r.xyz *= g_data.radius;\n            float vrmode = texelFetch( iChannel2, ivec2(0,0), 0 ).w;\n            trneval.mode = MODE_HEIGHT | MODE_NORMAL;\n            trneval.r = r.xyz;\n            trneval.lod = log2( iResolution.y * g_game.camzoom ) - TRN_LOD_BIAS - 2.5 * vrmode;\n            vec3 rn = normalize( r.xyz );\n            trneval.TB[0] = normalize( reject( UNIT_Z, rn ) );\n            trneval.TB[1] = cross( rn, trneval.TB[0] );\n            trneval.eps = 0.004 * SCN_SCALE;\n        }\n    }\n   \telse\n   \t{\n\t\t// main area: terrain buffers\n        vec2 uv = fcoord.xy / iResolution.y;\n        vec2 uvshadow = ( uv - vec2( 1, 0 ) ) / ts_aspect_shadow;\n\n        TrnSampler ts = ts_load( iChannel0, ADDR_TSAMPLER );\n        TrnSampler tslast = ts_load( iChannel0, ADDR_TSAMPLER_LAST );\n\n        bool samplestate_equal =\n            \tiFrame >= 2 &&\n            \tts_is_valid( tslast ) &&\n                ts.r_hat == tslast.r_hat &&\n                ts.e_over_b == tslast.e_over_b;\n\n        if( uv.x < 1. )\n        {\n            // elevation buffer\n            if( samplestate_equal )\n                fcolor = texelFetch( iChannel1, ivec2( fcoord ), 0 );\n            else\n            {\n\t\t\t    vec4 poslod = ts_uv_inverse_lod( ts, uv );\n\t\t\t\tif( poslod.w > 0. )\n    \t\t\t{\n\t\t\t\t\ttrneval.mode = MODE_HEIGHT | MODE_NORMAL | MODE_ZONEINDEX;\n                    trneval.r = poslod.xyz;\n                    trneval.lod = log2( iResolution.y * poslod.w ) - TRN_LOD_BIAS;\n        \t\t\tvec3 rn = normalize( poslod.xyz );\n        \t\t\ttrneval.TB = ts.TB;\n\t\t\t\t\ttrneval.eps = max( SCN_SCALE * 0.004, 2. * distance( poslod.xyz, g_game.campos ) / ( iResolution.y * poslod.w ) );\n                    trneval.r_hat = ts.r_hat;\n                }\n            }\n        }\n\t#if WITH_TRN_SHADOW\n        else\n        if( uvshadow.x < 1. && uvshadow.y < 1. )\n        {\n            // shadow buffer\n            vec3 L = env_load( iChannel0, ADDR_LOCALENV ).L;\n\n            bool resolutionchange =\n                texelFetch( iChannel1, ivec2( iResolution.y + 2., 2. ), 0 ).xy != iResolution.xy;\n\n            bool irchange =\n                texelFetch( iChannel1, ivec2( iResolution.y + 2., 2. ), 0 ).z != g_env.sunlight.y;\n\n\t\t\tbool lightdirchange =\n                dot( texelFetch( iChannel1, ivec2( iResolution.y + 4., 2. ), 0 ).xyz, L ) < 0.99995;\n\n            bool shadowupdate = iFrame < 4 || !samplestate_equal || resolutionchange || irchange || lightdirchange;\n\n            if( !ts_is_valid( tslast ) )\n                fcolor = vec4( -SCN_ZFAR, -SCN_ZFAR + 1., 1, 1 );\n            else\n            if( fcoord.x < iResolution.y + 2. && fcoord.y < 4. )\n\t\t\t\tfcolor = vec4( shadowupdate );\n            else\n            if( !shadowupdate )\n                fcolor = texelFetch( iChannel1, ivec2( fcoord ), 0 );\n            else\n            if( fcoord.x < iResolution.y + 4. && fcoord.y < 4. )\n            \tfcolor.xyz = vec3( iResolution.xy, g_env.sunlight.y );\n            else\n\t\t\tif( fcoord.x < iResolution.y + 6. && fcoord.y < 4. )\n\t\t\t\tfcolor.xyz = L;\n            else\n            {\n\t\t\t\tvec4 poslodshadow = ts_uv_inverse_lod( ts, uvshadow );\n                if( poslodshadow.w > 0. )\n                {\n                    vec3 result = ZERO;\n                    vec3 Z = normalize( poslodshadow.xyz );\n                    float camheight = length( g_game.campos );\n                    float lod = log2( iResolution.y * poslodshadow.w ) - TRN_LOD_BIAS;\n                    float elev = ts_sample( tslast, iChannel1, Z ).w;\n                    vec3 targetpoint = Z * ( elev + g_data.radius );\n                    vec3 T = normalize( reject( L, Z ) );\n                    float dotLT = dot( L, T );\n                    float dotLZ = dot( L, Z );\n                    result.x = result.y = elev;\n                    result.z = 1.;\n                    if( dotLZ < FRACT_15_16 )\n                    {\n                        vec2 slopes = ( dotLZ + vec2( 1, -.1 ) / SCN_RAYCAST_SHADOW_UMBRA ) / dotLT;\n                        float t = SCN_RAYCAST_SHADOW_TBIAS;\n                        for( int i = 0, n = SCN_RAYCAST_SHADOW_MAX_ITER; i < n; ++i )\n                        {\n                            vec3 x = targetpoint + t * L;\n                            vec4 r = length_normalize( x );\n                            vec4 tsmpl = ts_sample( tslast, iChannel1, r.xyz );\n                            vec2 f = dot( r.xyz, Z ) - dot( r.xyz, T ) * slopes;\n                            vec2 umbra = tsmpl.w * f + g_data.radius * ( f - vec2(1) );\n                            if( result.y < umbra.y )\n                            {\n                                result.x = mix( max( umbra.x, result.x ), umbra.x, saturate( result.z ) );\n                                result.y = umbra.y;\n                                result.z = ( elev - umbra.x ) / ( umbra.y - umbra.x );\n                            }\n                            t += ( 1. + .25 * dot( tsmpl.xyz, L ) ) * max( t / SCN_RAYCAST_SHADOW_UMBRA, SCN_RAYCAST_SHADOW_MIN_ADVANCE + SCN_RAYCAST_SHADOW_MIN_ADVANCE_SCALE * t );\n                            if( t >= SCN_ZFAR || ( dot( L, r.xyz ) >= 0. && tsmpl.w >= g_data.radius * g_data.trn_levels.y ) )\n                                break;\n                        }\n                    }\n\n                    // x: min height of umbra\n                    // y: max height of umbra\n                    // z: AO\n                    float D = max( SCN_RAYCAST_SHADOW_HBIAS, SCN_RAYCAST_SHADOW_HSCALE * distance( targetpoint, g_game.campos ) );\n                    fcolor.xy = result.xy - D * vec2( 1. + FRACT_1_64, 1 ) + g_data.radius;\n                    fcolor.z = elev;\n\t        \t\ttrneval.mode = MODE_AO;\n                    trneval.r = Z;\n                    trneval.lod = lod - TRN_AO_LOD_OFFSET;\n                }\n            }\n        }\n\t#endif // TRN_SHADOW\n   \t}\n\n    if( trneval.mode != 0 )\n    {\n        int zoneindex = get_zone_index( trneval.r );\n        vec4 zone = texelFetch( iChannel1, ivec2( ADDR_B_ZONEDATA + zoneindex, 0 ), 0 );\n        float h = trn_elevation( trneval.r, trneval.lod, g_data, zone );\n\n        if( ( trneval.mode & MODE_HEIGHT ) != 0 )\n        \tfcolor.w = h;\n\n        if( ( trneval.mode & MODE_RADIUS ) != 0 )\n            fcolor.w += g_data.radius;\n\n        if( ( trneval.mode & MODE_NORMAL ) != 0 )\n        {\n\t\t\tvec2 dhdp = vec2(\n        #if WITH_TRN_CENTRAL_DIFF\n                trn_elevation( trneval.r + .5 * trneval.eps * trneval.TB[0], trneval.lod, g_data, zone ) - trn_elevation( trneval.r - .5 * trneval.eps * trneval.TB[0], trneval.lod, g_data, zone ),\n           \t\ttrn_elevation( trneval.r + .5 * trneval.eps * trneval.TB[1], trneval.lod, g_data, zone ) - trn_elevation( trneval.r - .5 * trneval.eps * trneval.TB[1], trneval.lod, g_data, zone )\n        #else\n           \t\ttrn_elevation( trneval.r + trneval.eps * trneval.TB[0], trneval.lod, g_data, zone ) - h,\n            \ttrn_elevation( trneval.r + trneval.eps * trneval.TB[1], trneval.lod, g_data, zone ) - h\n        #endif\n \t\t\t) / trneval.eps;\n\n         \tvec3 rn = normalize( trneval.r );\n            fcolor.xyz = normalize( rn - trneval.TB * dhdp );\n        }\n\n        if( ( trneval.mode & MODE_ZONEINDEX ) != 0 )\n        {\n        \tfcolor.xy = reject_max( fcolor.xyz, trneval.r_hat ) * trneval.TB;\n        \tfcolor.z = float( zoneindex );\n        }\n\n        if( ( trneval.mode & MODE_SCENEDATA ) != 0 )\n            fcolor.z += h;\n\n        if( ( trneval.mode & MODE_AO ) != 0 )\n        {\n        \tfloat aoscale = g_data.radius * exp2( - TRN_AO_LOD_OFFSET / 2. - trneval.lod );\n\t\t    fcolor.z = aoscale / ( aoscale + max( 0., h - fcolor.z ) );\n        }\n    }\n\n#endif // TERRAIN\n#endif // RUNLEVEL\n}\n", "name": "Buffer B", "description": "", "type": "buffer"}, {"inputs": [{"id": "XdX3Rr", "filepath": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "previewfilepath": "/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "type": "volume", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "4dXGR8", "filepath": "/media/previz/buffer00.png", "previewfilepath": "/media/previz/buffer00.png", "type": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "XsXGR8", "filepath": "/media/previz/buffer01.png", "previewfilepath": "/media/previz/buffer01.png", "type": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "4sXGR8", "filepath": "/media/previz/buffer02.png", "previewfilepath": "/media/previz/buffer02.png", "type": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4sXGR8", "channel": 0}], "code": "/*\n *\t\t\t\tSPACE GLIDER 2020 SHADERTOY EDITION\n *\t\t\t\t\t   by Christian Sch\u00fcler\n *                       (c) 2001 - 2020\n *\n * Part 4 of 6: Buffer C shader (atmospheric scattering)\n * This software comes with no warranty. Use it at your own risk.\n */\n\n// ----------------------------------------------------------------------------\n\n#if WITH_ATM_TWEAKS\nconst float TWEAK1 = .25;\nconst float TWEAK2 = 4.;\nconst float TWEAK3 = .5;\nconst float TWEAK4 = .25;\nconst float TWEAK5 = .25;\nconst float TWEAK6 = .25;\nconst float TWEAK7 = 32.;\nconst float TWEAK8 = .25;\n#else\nconst float TWEAK1 = .5;\nconst float TWEAK2 = 6.0;\nconst float TWEAK3 = .7;\nconst float TWEAK4 = .5;\nconst float TWEAK5 = .25; \t// 0.125\nconst float TWEAK6 = .125;\nconst float TWEAK7 = 48.;\nconst float TWEAK8 = .5;\n#endif\n\nGameState g_game;\nLocalEnvironment g_env;\nTrnSampler g_ts;\nAtmContext g_atm;\nPlanetData g_data;\nfloat g_pixelscale;\n\nbool g_vrmode = false;\nmat3 g_vrframe = mat3(0);\nuniform vec4 unViewport;\nuniform vec3 unCorners[5];\n\n// ----------------------------------------------------------------------------\n// CLOUD NOISE SHAPE\n// ----------------------------------------------------------------------------\n\nconst float cld_alt = 2.2;\nconst float cld_k50max = 65.;\nconst float cld_g = 0.85;\nconst float cld_f = cld_g * cld_g;\nconst vec4  cld_noise = vec4( 20, -8, -31, 8 );\t\t\t\t\t// const/sin3lat2/noise/vertical\nconst vec2  cld_size = vec2( 32, 1.5 );\t\t\t\t\t\t\t// noise size/fluff size\nconst vec3  cld_fluff = vec3( 3, 9, 1 );\t\t\t\t\t\t// bottom/top strength, fade range\nconst vec4  cld_move = vec4( .42, .000045, .000015, .00002 );\t// phase/move/fluff move/fluff rotate\n\nmat2 cld_fluff_rot = mat2(1);\n\n#if WITH_CLOUDS\nfloat atm_cloudnoise1( vec4 r, bool lowfreq )\n{\n    float lod = log2( r.w );\n\tfloat y = ( textureLod( iChannel3, r.xyz / 32., lod ).x + 2. * textureLod( iChannel3, r.xyz / 64., lod - 1. ).x ) / 3.;\n    if( !lowfreq )\n\t\ty = 4. / 5. * y + ( textureLod( iChannel3, r.xyz / 8., lod + 2. ).x + 2. * textureLod( iChannel3, r.xyz / 16., lod + 1. ).x ) / 15.;\n\treturn y;\n}\nvec3 atm_cloudnoise1_offs( vec4 r, bool lowfreq )\n{\n    float lod = log2( r.w );\n    const vec2 offs = vec2( 1, 0 );\n    vec3 offs_y = vec3(\n\t\ttextureLod( iChannel3, ( r.xyz + offs.xyy ) / 32., lod ).x + 2. * textureLod( iChannel3, ( r.xyz + offs.xyy ) / 64., lod - 1. ).x,\n\t\ttextureLod( iChannel3, ( r.xyz + offs.yxy ) / 32., lod ).x + 2. * textureLod( iChannel3, ( r.xyz + offs.yxy ) / 64., lod - 1. ).x,\n\t\ttextureLod( iChannel3, ( r.xyz + offs.yyx ) / 32., lod ).x + 2. * textureLod( iChannel3, ( r.xyz + offs.yyx ) / 64., lod - 1. ).x ) / 3.;\n    if( !lowfreq )\n        offs_y = 4. / 5. * offs_y + vec3(\n        \ttextureLod( iChannel3, ( r.xyz + offs.xyy ) / 8., lod + 2. ).x + 2. * textureLod( iChannel3, ( r.xyz + offs.xyy ) / 16., lod + 1. ).x,\n\t\t\ttextureLod( iChannel3, ( r.xyz + offs.yxy ) / 8., lod + 2. ).x + 2. * textureLod( iChannel3, ( r.xyz + offs.yxy ) / 16., lod + 1. ).x,\n\t\t\ttextureLod( iChannel3, ( r.xyz + offs.yyx ) / 8., lod + 2. ).x + 2. * textureLod( iChannel3, ( r.xyz + offs.yyx ) / 16., lod + 1. ).x ) / 15.;\n    return offs_y;\n}\nfloat atm_cloudnoise2( vec4 r, bool lowfreq )\n{\n    float lod = log2( r.w );\n    float y = textureLod( iChannel3, r.xyz / 64., lod - 1. ).x;\n \tif( !lowfreq )\n    \ty = 2. / 3. * y + textureLod( iChannel3, r.xyz / 32., lod ).x / 3.;\n    return y;\n}\nvec3 atm_cloudnoise2_offs( vec4 r, bool lowfreq )\n{\n    float lod = log2( r.w );\n    const vec2 offs = vec2( 1, 0 );\n    vec3 offs_y = vec3(\n        textureLod( iChannel3, ( r.xyz + offs.xyy ) / 64., lod - 1. ).x,\n\t\ttextureLod( iChannel3, ( r.xyz + offs.yxy ) / 64., lod - 1. ).x,\n        textureLod( iChannel3, ( r.xyz + offs.yyx ) / 64., lod - 1. ).x );\n\tif( !lowfreq )\n    {\n        offs_y = 2. / 3. * offs_y + vec3(\n        \ttextureLod( iChannel3, ( r.xyz + offs.xyy ) / 32., lod ).x,\n\t\t\ttextureLod( iChannel3, ( r.xyz + offs.yxy ) / 32., lod ).x,\n\t\t\ttextureLod( iChannel3, ( r.xyz + offs.yyx ) / 32., lod ).x ) / 3.;\n    }\n    return offs_y;\n}\nvec4 atm_cloudnoise1_d( vec4 r, float scale, bool lowfreq )\n{\n    float invscale = 1. / scale;\n    float y = atm_cloudnoise1( invscale * r, lowfreq );\n    return vec4( invscale * ( atm_cloudnoise1_offs( invscale * r, lowfreq ) - y ), y );\n}\nvec4 atm_cloudnoise2_d( vec4 r, float scale, bool lowfreq )\n{\n    float invscale = 1. / scale;\n    float y = atm_cloudnoise2( invscale * r, lowfreq );\n    return vec4( invscale * ( atm_cloudnoise2_offs( invscale * r, lowfreq ) - y ), y );\n}\n\nvec4 atm_cloudbeta_d( vec4 r, bool lowfreq )\n{\n    vec4 rn = length_normalize( r.xyz );\n    vec4 h = rn - const_d( g_atm.r0 ) - const_d( cld_alt );\n    vec4 fluff = mix_d( const_d( cld_fluff.x ), const_d( cld_fluff.y ), saturate_d( h / cld_fluff.z ) );\n    vec3 y = rn.xyz;\n    y.xy = ( y.xy /* + 0. * cld_move.z * g_game.timer */ ) * cld_fluff_rot;\n    float sin2lat = rn.z * rn.z * 2. - 1.;\n    float sin3lat = sin2lat * rn.z * 2. - rn.z;\n    vec3 x = vec3( rn.xy, sin3lat / 3. + cld_move.y * g_game.timer + cld_move.x );\n    vec4 n1 = atm_cloudnoise1_d( vec4( g_data.radius * x, r.w ), cld_size.x, lowfreq );\n\tvec4 n2 = atm_cloudnoise2_d( vec4( g_data.radius * y, r.w ), cld_size.y, lowfreq );\n    vec4 c = + const_d( cld_noise.x )\n             + const_d( cld_noise.y * sin3lat * sin3lat )\n             + cld_noise.z * n1\n             - 6. * sqrt_d( ONE_D + square_d( cld_noise.w * h / 6. ) )\n\t\t\t + mul_d( fluff, n2 * 2. - ONE_D );\n    return min_d( const_d(0.), c );\n}\n\nfloat cld_tau50( vec4 x, vec4 dx, float tau50limit, bool lowfreq )\n{\n    vec4 dxdu = dx / length( dx.xyz );\n    float tau50 = 0.;\n    float beta = atm_cloudbeta_d( x, lowfreq ).w;\n    float dens = exp2pp( LOG2E * beta );\n    float betachange = 1. / cld_noise.w;\n    for( int i = 0, n = ATM_CLOUD_MAX_ITER; i < n; ++i )\n    {\n        float du = TWEAK3 * atm_dulimit( TWEAK4, betachange, cld_k50max * dens );\n        du = du * min( TWEAK7, 1. + tau50 * tau50 / 8. );\n        du = max( 0.005, du );\n        x += du * dxdu;\n\t\tfloat betanext = atm_cloudbeta_d( x, lowfreq ).w;\n    \tfloat densnext = exp2pp( LOG2E * betanext );\n        tau50 += cld_k50max * mix( dens, densnext, .5 ) * du;\n        betachange = du / max( du * ( TWEAK5 * cld_noise.w ), abs( betanext - beta ) );\n        beta = betanext;\n        dens = densnext;\n        if( tau50 >= tau50limit )\n        \tbreak;\n        float alt = length( x.xyz );\n        if( dot( x.xyz, dxdu.xyz ) >= 0. && alt >= g_data.radius * ( 1. + g_data.trn_levels.y ) )\n        \tbreak;\n        if( dot( x.xyz, dxdu.xyz ) < 0. && alt < g_data.radius * ( 1. + g_data.trn_levels.x ) )\n        \tbreak;\n    }\n    return tau50;\n}\n#endif\n\n// ----------------------------------------------------------------------------\n// ATMOSPHERE MODEL\n// ----------------------------------------------------------------------------\n\nstruct AtmQuadraturePoint\n{\n    float coschi;\t\t\t// light zenith angle\n    float dens;\t\t\t\t// density relative to reference\n    float amtl;\t\t\t\t// airmass towards lightsource (sun)\n  #if WITH_ATM_LAYER_G\n    float densg;\t\t\t// same for ground layer\n    float amtlg;\n  #endif\n  #if WITH_ATM_LAYER_A\n    float densa;\t\t\t// same for absorbtion layer\n    float amtla;\n  #endif\n  #if WITH_ATM_LAYER_E\n    float dense;\t\t\t// same for emission layer\n  #endif\n    float shadow;\t\t\t// amount of terrain shadowing\n    float h50;\n};\n\nfloat eval_gaussian50( float x, vec3 shape )\n\t{ return shape.y * exp2pp( -shape.z * square( x - shape.x ) ); }\n\nAtmQuadraturePoint atm_quadrature_point( vec3 x, vec3 L, vec3 dxn )\n{\n    AtmQuadraturePoint result;\n\tvec4 xn = length_normalize( x );\n    float x50 = xn.w * g_atm.invH50;\n    float h50 = x50 - g_atm.X50;\n    result.coschi = dot( xn.xyz, L );\n#if WITH_ATMOSPHERE\n    result.dens = exp2pp( -h50 );\n    float s = g_atm.X50 / x50;\n    float c = sqrt( max( 0., 1. - s * s ) );\n    float planetshadow = atm_planet_shadow( result.coschi, c );\n    result.shadow = planetshadow * ts_shadow_sample( g_ts, iChannel1, x );\n\tresult.amtl = planetshadow >= 0.003 ? atm_chapman50_h( g_atm.X50, h50, result.coschi ) : 1e6;\n  #if WITH_ATM_LAYER_G\n    result.densg = g_atm.glayer_scale * exp2pp( -h50 * g_atm.glayer_scale );\n\tresult.amtlg = planetshadow >= 0.003 ? atm_chapman50_h( g_atm.X50 * g_atm.glayer_scale, h50 * g_atm.glayer_scale, result.coschi ) : 1e6;\n  #endif\n  #if WITH_ATM_LAYER_A\n    result.densa = eval_gaussian50( h50, g_atm.alayer_shape );\n    result.amtla = atm_tau_layer_a( x * g_atm.invH50, L, g_atm );\n  #endif\n  #if WITH_ATM_LAYER_E\n    result.dense = eval_gaussian50( h50, g_atm.elayer_shape );\n  #endif\n    result.h50 = h50;\n#else\n    result.dens = 0.;\n\tresult.shadow = 1.;\n#endif\n\treturn result;\n}\n\nAtmQuadraturePoint atm_quadrature_mix( AtmQuadraturePoint a, AtmQuadraturePoint b,\n                                       float t )\n{\n    AtmQuadraturePoint result;\n    result.coschi = mix( a.coschi, b.coschi, t );\n    result.dens = mix( a.dens, b.dens, t );\n    result.amtl = mix( a.amtl, b.amtl, t );\n  #if WITH_ATM_LAYER_G\n    result.densg = mix( a.densg, b.densg, t );\n    result.amtlg = mix( a.amtlg, b.amtlg, t );\n  #endif\n  #if WITH_ATM_LAYER_A\n    result.densa = mix( a.densa, b.densa, t );\n    result.amtla = mix( a.amtla, b.amtla, t );\n  #endif\n  #if WITH_ATM_LAYER_E\n    result.dense = mix( a.dense, b.dense, t );\n  #endif\n    result.shadow = mix( a.shadow, b.shadow, t );\n    result.h50 = mix( a.h50, b.h50, t );\n    return result;\n}\n\nstruct AtmQuadratureSegment\n{\n    vec3 mu0;\t\t\t\t// cosine of light incidence angle\n    vec3 omega0;\t\t\t// local single-scattering albedo\n    vec3 k50;\t\t\t\t// half-value extinction efficiency\n    vec3 tau50;\t\t\t\t// half-value optical depth\n    vec3 T;\t\t\t\t\t// transmittance\n    vec3 TL;\t\t\t\t// transmittance in light direction\n    vec3 TZ;\t\t\t\t// transmittance in zenith direction\n    vec3 TZs;\t\t\t\t// transmittance in zenith direction, diffusion-scaled\n    vec3 Is;\t\t\t\t// single scatter contribution\n    vec3 Im;\t\t\t\t// multi scatter contribution\n    vec3 Ie;\t\t\t\t// emission\n#if WITH_CLOUDS\n    vec3 skylight;\t\t\t// analytical skylight estimate\n#endif\n};\n\nAtmQuadratureSegment atm_quadrature_segment( AtmQuadraturePoint avg,\n                                             float du,\n                                             float rayleigh_phase,\n                                             float aerosol_phase,\n                                             bool infinite )\n{\n    AtmQuadratureSegment result;\n    vec3 mu_stretch = g_atm.mu_stretch * mix( 1.25, 1., saturate( avg.h50 ) );\n    result.mu0 = log2( 1. + exp2pp( mu_stretch * avg.coschi ) ) / mu_stretch;\n#if WITH_ATMOSPHERE\n    vec3 k50 = g_atm.k50 * avg.dens;\n    vec3 k50_s = g_atm.k50_s * avg.dens;\n  #if WITH_ATM_LAYER_G\n    k50 += ( avg.densg - avg.dens ) * g_atm.glayer_k50;\n    k50_s += ( avg.densg - avg.dens ) * g_atm.glayer_k50_s;\n  #endif\n  #if WITH_ATM_LAYER_A\n    k50 += ( avg.densa - avg.dens ) * g_atm.alayer_k50;\n  #endif\n    result.omega0 = k50_s / k50;\n    result.k50 = k50;\n\tresult.tau50 = result.k50 * du;\n    result.T = exp2pp( -result.tau50 );\n    result.TL = g_atm.k50 * avg.amtl;\n  #if WITH_ATM_LAYER_G\n    result.TL += g_atm.glayer_k50 * ( avg.amtlg - avg.amtl );\n  #endif\n  #if WITH_ATM_LAYER_A\n    result.TL += g_atm.alayer_k50 * ( avg.amtla - avg.amtl );\n  #endif\n  #if WITH_ATM_AMTL_CORRECTION\n \tresult.TL *= atm_airmass_correction( g_atm.X50, avg.coschi, ATM_AMTL_CORRECTION );\n  #endif\n    result.TL = exp2pp( -g_atm.H * result.TL );\n  \tresult.Is = result.omega0 / 4.;\n  #if WITH_ATM_LAYER_G\n    result.Is += avg.dens * ( g_atm.k50_s - g_atm.glayer_k50_s ) * ( rayleigh_phase - 1. ) / ( 4. * k50 );\n    result.Is += avg.densg * g_atm.glayer_k50_s * ( aerosol_phase - 1. ) / ( 4. * k50 );\n  #endif\n    result.Is *= result.TL * g_env.sunlight * avg.shadow;\n    result.TZ = exp2pp( -g_atm.tau50 * avg.dens );\n    result.TZs = exp2pp( -g_atm.tau50s * avg.dens );\n    result.Im = result.TZs * ( g_env.sunlight * ( 1. - result.TL ) * result.mu0 * g_atm.omega0 + g_env.starlight + g_atm.elayer_emiss ) * result.omega0;\n\tresult.Ie = ZERO;\n  #if WITH_ATM_LAYER_E\n    result.Ie += g_atm.elayer_emiss * avg.dense * g_atm.invH50 / k50;\n  #endif\n#else\n    result.k50 = ZERO;\n    result.tau50 = ZERO;\n    result.T = ONE;\n    result.TL = ONE;\n    result.TZ = ONE;\n    result.TZs = ONE;\n  \tresult.Is = ZERO;\n    result.Im = ZERO;\n    result.Ie = ZERO;\n#endif\n#if WITH_CLOUDS\n    vec3 ht = g_atm.ht0s50 + g_atm.X50 * avg.coschi * min( 0., avg.coschi ) / 2.;\n    result.skylight = ( result.TZ * g_env.sunlight * exp2pp( -ht ) * g_atm.omega0 / 4. + result.Im * 2. ) * ( 1. - result.TZ );\n\tresult.skylight += ( g_env.starlight + g_atm.elayer_emiss ) * result.TZs;\n#endif\n    return result;\n}\n\n#if WITH_CLOUDS\nstruct CldQuadraturePoint\n{\n    vec4 beta;\t\t\t\t// log2 relative density, xyz = gradients\n    float dens;\t\t\t\t// relative density\n    float tau50L;\t\t\t// optical half-value depth in light direction\n    float tau50Z;\t\t\t// optical half-value depth in zenith direction\n};\n\nCldQuadraturePoint cld_quadrature_point( vec4 x, vec3 L, float coschi )\n{\n    CldQuadraturePoint result;\n    result.beta = atm_cloudbeta_d( x, false );\n    result.dens = exp2pp( LOG2E * result.beta.w );\n    float taulimit = mix( ATM_CLOUD_SHADOW_MIN_TAU, ATM_CLOUD_SHADOW_MAX_TAU, coschi );\n    vec3 xn = normalize( x.xyz );\n    vec3 Lc = normalize( reject_min( L, xn ) );\n    vec3 Z = normalize( L + xn );\n    result.tau50L = cld_tau50( x, vec4( Lc, SCN_RAYCAST_SHADOW_UMBRA_INV ), taulimit, false );\n    result.tau50Z = cld_tau50( x, vec4( Z, 4. ), ATM_CLOUD_SHADOW_MIN_TAU, true );\n    return result;\n}\n\nCldQuadraturePoint cld_quadrature_mix( CldQuadraturePoint a,\n                                       CldQuadraturePoint b, float t )\n{\n    CldQuadraturePoint result;\n    result.beta = mix( a.beta, b.beta, t );\n    result.dens = mix( a.dens, b.dens, t );\n    result.tau50L = mix( a.tau50L, b.tau50L, t );\n    result.tau50Z = mix( a.tau50Z, b.tau50Z, t );\n    return result;\n}\n\nstruct CldQuadratureSegment\n{\n    float k50s;\t\t\t\t// half-value extinction efficiency, delta-scaled\n    float tau50s;\t\t\t// half-value optical depth, delta-scaled\n    float Ts;\t\t\t\t// segment transmittance, delta-scaled\n    float TL;\t\t\t\t// transmittance in light direction\n    float TLs;\t\t\t\t// same, delta-scaled\n    float TZs;\t\t\t\t// transmittance in zenith direction, delta scaled\n    float FminusL;\t\t\t// Eddington downwelling flux component for direct sunlight\n    float FminusZ;\t\t\t// Eddington downwelling flux component for diffuse skylight\n    vec3 Is;\t\t\t\t// single scatter contribution\n    vec3 Im;\t\t\t\t// multi scatter contribution\n    vec3 Ii;\t\t\t\t// indirect scattered skylight contribution\n};\n\nCldQuadratureSegment cld_quadrature_segment( CldQuadraturePoint avg,\n                                             AtmQuadraturePoint atmavg,\n                                             AtmQuadratureSegment atmseg,\n                                             vec3 L,\n                                             vec3 V,\n                                             float du,\n                                             float cloud_phase )\n{\n    CldQuadratureSegment result;\n    result.k50s = cld_k50max * avg.dens * ( 1. - cld_f );\n    result.tau50s = result.k50s * du;\n    result.Ts = exp2pp( -result.tau50s );\n    result.TL = exp2pp( -avg.tau50L );\n    result.TLs = exp2pp( -avg.tau50L * ( 1. - cld_f ) );\n    result.TZs = exp2pp( -avg.tau50Z * ( 1. - cld_f ) );\n    result.FminusL = atm_delta_eddington_Fminus_direct( cld_g, avg.tau50L, atmseg.mu0.y );\n    result.FminusZ = atm_delta_eddington_Fminus_diffuse( cld_g, avg.tau50Z );\n    vec3 N = softnormalize( -avg.beta.xyz, 1. / cld_noise.w );\n    float H = .5 + 1. * mu_stretch( -dot( N, V ), .125 );\n    // float H = 1.;\n    vec3 mu0 = vec3( mu_stretch( dot( N, L ), .125 ) );\n    mu0 = mix( atmseg.mu0, mu0, .5 );\n\tresult.Is = atmseg.TL * g_env.sunlight * atmavg.shadow * result.TL * cloud_phase / 4.;\n    result.Im = H * atmseg.TL * g_env.sunlight * atmavg.shadow * result.FminusL * mu0;\n    result.Ii = H * atmseg.skylight * result.FminusZ;\n    if( ( g_game.switches & GS_IRCAM ) != 0u )\n    {\n        result.Is *= 0.85;\n        result.Im *= 0.85;\n        result.Ii *= 0.85;\n    }\n    return result;\n}\n\nvec3 cld_atm_interaction( inout AtmQuadratureSegment atmseg,\n                          AtmQuadraturePoint atmavg,\n                          CldQuadratureSegment cldseg,\n                          float coschi )\n{\n    vec3 illum = atmseg.omega0 * ( cldseg.Is + cldseg.Im + cldseg.Ii ) / 2.;\n    atmseg.Is = mix( illum, atmseg.Is, cldseg.TLs );\n    atmseg.Im = atmseg.Im * cldseg.TZs;\n    return cldseg.k50s / ( atmseg.k50 + cldseg.k50s );\n}\n\nfloat cld_betachange( CldQuadraturePoint a, CldQuadraturePoint b, float du )\n\t{ return du / max( du * ( TWEAK5 * cld_noise.w ), b.beta.w - a.beta.w ); }\n\n#endif // WITH_CLOUDS\n\nfloat phase_function( float a, float mu )\n{\n    /*\n    float k = a + 1.;\n    return 2. * LOG2E / ( k * ( 1. + exp2(-a) - mu ) );\n\t/*/\n    float k = a - log2( a * LN2 * .6968 );\n    return 2. * LOG2E / ( k * ( 1. + exp2(-a) - mu ) ) * exp2( ( mu - 1. ) * a / 2. );\n\t//*/\n}\n\nfloat atm_compute_scatter( inout vec3 T, inout vec3 I,\n\t\t\t\t\t\t   vec4 x0, vec4 dx,\n\t\t\t\t\t\t   bool infinite,\n                           bool low_aerosol_phase,\n\t\t\t\t\t\t   bool low_cloud_phase )\n{\n    vec4 dxn = length_normalize( dx.xyz );\n    vec4 dxdu = dx / dxn.w;\n    vec2 sph = sphere_impact( x0.xyz, dxn.xyz );\n    float R = g_atm.r0 + g_atm.htop;\n    if( R * R < sph.x )\n    \treturn 1. - ATM_CLOUD_T_CUTOFF;\n    vec2 limits = max( vec2(0), sphere_limits( R, sph ) );\n    if( !infinite )\n        limits = min( vec2( dxn.w ), limits );\n    float urange = limits.y - limits.x;\n    if( urange < .001 )\n        return 1. - ATM_CLOUD_T_CUTOFF;\n    float u = limits.x;\n    vec4 x = x0 + u * dxdu;\n    AtmQuadraturePoint atm1 = atm_quadrature_point( x.xyz, g_env.L, dxn.xyz );\n    bool ir = ( g_game.switches & GS_IRCAM ) != 0u;\n    float mu_L = dot( dxn.xyz, g_env.L );\n    float rayleigh_phase = .75 * ( 1. + mu_L * mu_L );\n    float aerosol_phase = low_aerosol_phase ? 1. : min( 350., phase_function( ir ? 5. : 6., mu_L ) );\n#if WITH_CLOUDS\n    CldQuadraturePoint cld1 = cld_quadrature_point( x, g_env.L, atm1.coschi );\n    float cloud_phase = low_cloud_phase ? 1. : min( 350., phase_function( ir ? 14. : 17., mu_L ) );\n    float betachange = 1. / cld_noise.w;\n#endif\n    float dumax = urange / float( ATM_SCATTER_MIN_ITER );\n    float CT50s = 0.;\n    for( int i = 0, n = ATM_SCATTER_MAX_ITER; i < n; ++i )\n    {\n        float du = dumax;\n        du = min( du, TWEAK1 * atm_dulimit( TWEAK2, g_atm.H, g_atm.k50max * atm1.dens ) );\n\t#if WITH_CLOUDS\n        du = min( du, TWEAK3 * atm_dulimit( TWEAK4, betachange, cld_k50max * cld1.dens ) );\n\t#endif\n        du = min( dumax, du / max( TWEAK6, T.y ) );\n\t    du = min( max( 0.003, du ), limits.y - u );\n        float unext = u + du;\n        vec4 xnext = x0 + unext * dxdu;\n        AtmQuadraturePoint atm2 = atm_quadrature_point( xnext.xyz, g_env.L, dxn.xyz );\n      #if WITH_ATM_QUADRATURE\n        AtmQuadraturePoint atmavg = atm_quadrature_mix( atm1, atm2, .5 );\n      #else\n        AtmQuadraturePoint atmavg = atm2;\n\t  #endif\n        AtmQuadratureSegment atmseg = atm_quadrature_segment( atmavg, du, rayleigh_phase, aerosol_phase, infinite );\n        atm1 = atm2;\n    #if WITH_CLOUDS\n        CldQuadraturePoint cld2 = cld_quadrature_point( xnext, g_env.L, atm2.coschi );\n\t  #if WITH_ATM_QUADRATURE\n        CldQuadraturePoint cldavg = cld_quadrature_mix( cld1, cld2, .5 );\n\t  #else\n        CldQuadraturePoint cldavg = cld2;\n      #endif\n        CldQuadratureSegment cldseg = cld_quadrature_segment( cldavg, atmavg, atmseg, g_env.L, dxdu.xyz, du, cloud_phase );\n        vec3 cloud_mix = cld_atm_interaction( atmseg, atmavg, cldseg, atmavg.coschi );\n        vec3 segment_I = mix( atmseg.Is + atmseg.Im + atmseg.Ie, cldseg.Is + cldseg.Im + cldseg.Ii, cloud_mix );\n        vec3 segment_T = atmseg.T * cldseg.Ts;\n        vec3 segment_tau50 = atmseg.tau50 + cldseg.tau50s;\n\t\tCT50s += cldseg.tau50s;\n        betachange = cld_betachange( cld1, cld2, du );\n     \tcld1 = cld2;\n    #else\n        vec3 segment_I = atmseg.Is + atmseg.Im + atmseg.Ie;\n        vec3 segment_T = atmseg.T;\n        vec3 segment_tau50 = atmseg.tau50;\n\t#endif\n        segment_I *= mix( 1. - segment_T, LN2 * segment_tau50, lessThan( segment_tau50, vec3( FRACT_1_4096 ) ) );\n        I = I + T * segment_I;\n        T = T * segment_T;\n        u = unext;\n\t\tif( u >= limits.y )\n        \tbreak;\n        x = xnext;\n        if( CT50s >= ATM_CLOUD_TAU50_CUTOFF )\n        \tbreak;\n        // debug:\n       \t// float value = float( i - ATM_SCATTER_MIN_ITER ) / float( ATM_SCATTER_MAX_ITER - ATM_SCATTER_MIN_ITER );\n\t\t// float value = betachange;\n        // float value = log2(35.*du)/10.;\n        // float value = u / limits.y;\n        // float value = CT50s / 1.;\n        // I = mix( vec3(0,0,1), vec3(1,0,0), saturate( value ) );\n        // vec3 value = T;\n        // vec3 value = segment_T;\n\t\t// vec3 value = atm_transmittance( x0, dxn.xyz );\n\t\t// vec3 value = T / atm_transmittance( x0, dxn.xyz );\n        // vec3 value = 1. - T;\n\t\t// I = value;\n        // if( i == -1 )\n       \t//     break;\n    }\n\n    float Tc = clamp( ( exp2pp( -CT50s ) - ATM_CLOUD_T_CUTOFF ) / ( 1. - ATM_CLOUD_T_CUTOFF ), 0., 1. );\n\n    /*\n    float K = .7 * fwidth( CT50s * LN2 );\n    I.r *= 1. - aaa_interval( K, CT50s * LN2 - 1., K );\n    I.rg *= 1. - aaa_interval( K, CT50s * LN2 - 3., K );\n    I.rgb *= 1. - aaa_interval( K, CT50s * LN2 - 10., K );\n    //*/\n\n\treturn Tc;\n}\n\n// ----------------------------------------------------------------------------\n// SCENE\n// ----------------------------------------------------------------------------\n\nvec4 texturenoise( vec3 r )\n{\n    vec3 uvw = r / iChannelResolution[3];\n    return texture( iChannel3, uvw ) * 2. - 1.;\n}\n\nvec4 texturenoiseLod( vec3 r, float lod )\n{\n    vec3 uvw = r / iChannelResolution[3];\n    return textureLod( iChannel3, uvw, lod ) * 2. - 1.;\n}\n\nvec3 trn_ripplemap( vec3 pos )\n{\n    return .20 * texturenoise( pos / .01 ).xyz +\n           .30 * texturenoise( pos / .003 ).xyz +\n           .30 * texturenoise( pos / .001 ).xyz +\n           .20 * texturenoise( pos / .0003 ).xyz;\n}\n\nvec3 trn_ripplemapLod( vec3 pos, float scale )\n{\n    float lod = log2( scale / 0.001 );\n    return .20 * texturenoiseLod( pos / .01, lod - 3.322 ).xyz +\n           .30 * texturenoiseLod( pos / .003, lod - 1.585 ).xyz +\n           .30 * texturenoiseLod( pos / .001, lod ).xyz +\n           .20 * texturenoiseLod( pos / .0003, lod + 1.585 ).xyz;\n}\n\nvec3 ndist( vec3 Z, float k, vec3 dZ )\n{\n    float b = dot( Z, dZ );\n    return normalize( Z * square( 1. - k + k * b ) + k * ( dZ - Z * b ) );\n}\n\nfloat scene_raycast_terrain( Ray ray, float wlevel,\n                             inout float t0, inout vec3 r, int mode )\n{\n\tbool submerged = length( ray.o ) - g_data.radius < wlevel;\n    float t = 0., h = 0., alt = 0.;\n    float lasth = 0., lastt = 0., lasta = 0.;\n    vec4 tsmpl = vec4(0);\n    float t_switch = pow( 0.0000005 * square( g_data.radius ), .333333333 );\n    float C0 = length( ray.o ) - g_data.radius;\n    float C1 = dot( ray.o, ray.d ) / length( ray.o );\n    float C2 = ( lensq( ray.o ) * lensq( ray.d ) - square( dot( ray.o, ray.d ) ) ) / ( length( ray.o ) * lensq( ray.o ) );\n    for( int i = 0, n = SCN_RAYCAST_MAX_ITER; i < n; ++i )\n    {\n        r = ray.o + t * ray.d;\n        tsmpl = ts_sample( g_ts, iChannel1, r );\n        lasta = alt;\n        alt =\n#if WITH_TRN_HIGHP_RAYCAST\n            t < t_switch ? C0 + t * C1 + t * t * C2 :\n#endif\n        \tlength(r) - g_data.radius;\n        lasth = h;\n        h = alt - ( submerged ? tsmpl.w : max( wlevel, tsmpl.w ) );\n        if( h < 0. )\n        {\n            t = mix( lastt, t, safediv( 0. - lasth, h - lasth ) );\n        \tr = ray.o + t * ray.d;\n    \t\treturn t;\n        }\n        else\n        if( submerged && alt >= wlevel )\n        {\n            if( t0 > 0. )\n                break;\n            t = mix( lastt, t, safediv( wlevel - lasta, alt - lasta ) );\n\t\t\tr = ray.o + t * ray.d;\n            vec3 Z = normalize( r );\n            vec3 N = ndist( Z, .25, trn_ripplemap( r + 0.002 * iTime * Z ) );\n            if( mode == 1 )\n            {\n\t            r = normalize( simple_refract( ray.d, N ) );\n            \tbreak;\n        \t}\n            ray.d = normalize( ray.d - 2. * N * dot( ray.d, N ) );\n            ray.d = normalize( ray.d - Z * max( 0., dot( ray.d, Z ) ) );\n           \tray.o = r;\n            t0 = t;\n            t = 0.;\n\t\t#if WITH_TRN_HIGHP_RAYCAST\n    \t\tC0 = length( ray.o ) - g_data.radius;\n    \t\tC1 = dot( ray.o, ray.d ) / length( ray.o );\n    \t\tC2 = sqdiff( length( ray.o ) * length( ray.d ), dot( ray.o, ray.d ) ) / ( length( ray.o ) * lensq( ray.o ) );\n\t\t#endif\n            alt = wlevel;\n            h = wlevel - ts_sample( g_ts, iChannel1, r ).w;\n        }\n        lastt = t;\n        t += max( .85 * ( .75 + .25 * dot( tsmpl.xyz, ray.d ) ) * h, SCN_RAYCAST_MIN_ADVANCE + SCN_RAYCAST_MIN_ADVANCE_SCALE * t );\n        if( t >= SCN_ZFAR || ( dot( ray.d, r ) >= 0. && alt + g_data.radius >= g_data.radius * ( 1. + g_data.trn_levels.y ) ) )\n        \tbreak;\n    }\n    return SCN_ZFAR;\n}\n\n// ----------------------------------------------------------------------------\n// MAIN\n// ----------------------------------------------------------------------------\n\nconst int MODE_NONE  =\t\t\t0;\nconst int MODE_INSCATTER = \t\t1;\t\t// trace inscatter ray along view direction\nconst int MODE_SKYLIGHT = \t\t2;\t\t// trace skylight sample for a terrain position\nconst int MODE_REFLECTION = \t3;\t\t// trace ocean reflection sample from view hitpoint\nconst int MODE_OBJECTS = \t\t4;\t\t// trace inscatter and skylight for scene objects\nconst int MODE_PRESERVE = \t\t99;\t\t// preserve previous value (do not overwrite)\n\nstruct RenderParams\n{\n    int mode;\n    vec4 x0;\n    vec4 dx;\n    float scale;\n    bool infinite;\n    bool low_aerosol_phase;\n\tbool low_cloud_phase;\n    float t;\n};\n\nRenderParams get_render_params( Ray ray, int mode, vec2 fcoord )\n{\n    RenderParams result = RenderParams( MODE_NONE, vec4(0), vec4(0), 1., true, false, false, 0. );\n\tfloat r0 = g_data.radius;\n    float lod = sqrt( g_pixelscale ) * 2.;\n\n    if( mode == MODE_OBJECTS )\n    {\n        if( fcoord.y >= iResolution.y - 8. )\n   \t\t{\n            vec3 r = g_game.campos;\n        \tvec3 Z = normalize(r);\n            vec3 sampledir = Z * 4. + g_env.L;\n            vec3 x = Z * max( r0, length(r) );\n\t\t\t// skylight sample at camera position\n        \tresult.mode = MODE_SKYLIGHT;\n            result.x0 = vec4( x, lod * length( x - ray.o ) );\n        \tresult.dx = vec4( sampledir, 4. );\n            result.low_aerosol_phase = true;\n            result.low_cloud_phase = true;\n\n\t\t}\n        else\n        {\n\t\t\tint index = int( fcoord.y ) / 2 - int( iResolution.y ) / 4;\n            if( index >= 0 && index < int( memload( iChannel0, ADDR_DATASIZES, 0 ).w ) )\n            {\n\t\t\t\tSceneObj obj = so_load( iChannel0, ADDR_SCENE_OBJECTS + ivec2( index, 0 ) );\n                if( int( obj.tybr.x ) >= SCNOBJ_TYPE_3D )\n                {\n\t\t        \tif( fcoord.x < iResolution.x - 6. )\n\t\t\t\t\t{\n            \t\t\t// in-scatter towards object position\n           \t\t\t\tresult.mode = MODE_INSCATTER;\n                        result.x0 = vec4( ray.o, 0 );\n            \t\t\tresult.dx = vec4( obj.r - ray.o, lod * length( obj.r - ray.o ) );\n            \t\t\tresult.infinite = false;\n                        result.t = 0.;\n                    }\n            \t    else\n    \t\t\t    {\n        \t    \t\tvec3 r = obj.r;\n        \t    \t\tvec3 Z = normalize(r);\n\n                        vec3 sampledir = normalize(\n                            fcoord.x < iResolution.x - 4. ? Z * .125 + normalize( reject( g_env.L, Z ) ) :\n                        \tfcoord.x < iResolution.x - 2. ? Z * .125 - normalize( reject( g_env.L, Z ) ) :\n                        \tZ );\n\n                        vec3 x = Z * max( r0, length(r) );\n        \t\t\t    // skylight sample at object position\n                        result.mode = MODE_SKYLIGHT;\n        \t\t\t\tresult.x0 = vec4( x, length( x - ray.o ) );\n\t\t\t\t\t\tresult.dx = vec4( sampledir, 4 );\n\t\t\t\t\t\tresult.low_aerosol_phase = true;\n        \t    \t\tresult.low_cloud_phase = true;\n\n                    }\n                }\n\t\t\t}\n        }\n\t}\n    else\n    if( mode == MODE_SKYLIGHT )\n    {\n        vec2 uv = 2. * fcoord / iResolution.y - vec2( 0, 1 );\n        vec4 poslod = ts_uv_inverse_lod( g_ts, uv );\n        if( poslod.w > 0. )\n        {\n            vec3 Z = normalize( poslod.xyz );\n            vec4 tsmpl = ts_unpack_normal( g_ts, textureLod( iChannel1, uv * ts_aspect, 0. ) );\n            vec3 N = normalize( tsmpl.xyz );\n            vec3 sampledir = normalize( N * 2. + g_env.L );\n            vec3 x = Z * ( max( 0., tsmpl.w ) + r0 );\n            // skylight sample on terrain map\n            result.mode = MODE_SKYLIGHT;\n            result.x0 = vec4( x, lod * length( x - ray.o ) );\n            result.dx = vec4( sampledir, 4 );\n            result.scale = .5 + .5 * dot( sampledir, N );\n            result.low_aerosol_phase = true;\n            result.low_cloud_phase = true;\n        }\n    }\n    else\n    if( dot( ray.d, ray.d ) > 0. )\n\t{\n        bool submerged = length( ray.o ) < r0;\n        vec3 r = ZERO;\n        float t0 = 0.;\n    \tfloat t = scene_raycast_terrain( ray, 0., t0, r, mode );\n    \tfloat h = SCN_ZFAR;\n\n        if( t >= SCN_ZFAR )\n        {\n            if( mode == MODE_INSCATTER )\n            {\n                // in-scatter along ray direction (terrain miss)\n                result.mode = MODE_INSCATTER;\n                result.x0 = vec4( submerged ? ray.o + t0 * ray.d : ray.o, 0 );\n                result.dx = vec4( submerged ? r : ray.d, lod );\n                result.t = t;\n            }\n        }\n        else\n        {\n            vec4 tsmpl = ts_sample( g_ts, iChannel1, r );\n            tsmpl.xyz = normalize( tsmpl.xyz );\n            vec3 Z = normalize(r);\n            vec3 V = normalize( -ray.d );\n            h = tsmpl.w;\n            if( mode == MODE_INSCATTER && !submerged )\n            {\n                // in-scatter along ray direction (terrain hit)\n                result.mode = MODE_INSCATTER;\n                result.x0 = vec4( ray.o, 0 );\n                result.dx = vec4( r - ray.o, lod * t );\n                result.infinite = false;\n                result.t = t;\n            }\n            else\n            if( mode == MODE_REFLECTION && !submerged && h - FRACT_1_64 < 4. * fwidth(h) )\n\t\t\t{\n                vec3 N = normalize( Z + .25 * trn_ripplemap( r + 0.002 * iTime * Z ) );\n                N = normalize( N - V * min( 0., dot( N, V ) ) );\n                vec3 R = 2. * dot( N, V ) * N - V + .25 * Z * parabolstep( 0., .250, t - t * dot( V, Z ) );\n                R = normalize( R - Z * min( 0., dot( R, Z ) ) );\n                vec3 H = normalize( R + V );\n                float fr = fresnel_schlick( .02, max( 0., dot( R, H ) ) );\n\t\t\t\t// reflection sample in view direction (ocean hit)\n                result.mode = MODE_REFLECTION;\n                result.x0 = vec4( r, lod * t );\n                result.dx = vec4( R, 4 );\n                result.low_cloud_phase = true;\n                result.scale = fr;\n            }\n        }\n    }\n    return result;\n}\n\nvec4 render( Ray ray, int mode, vec2 fcoord )\n{\n    RenderParams params = get_render_params( ray, mode, fcoord );\n    vec4 result = vec4( ZERO, 1 );\n\n    if( params.dx != vec4(0) )\n    {\n        vec3 T = ONE, I = ZERO;\n\t#if WITH_ATMOSPHERE\n    \tfloat Tc = atm_compute_scatter(\n            T,\n            I,\n            params.x0,\n            params.dx,\n            params.infinite,\n            params.low_aerosol_phase,\n            params.low_cloud_phase );\n    #else\n        float Tc = 1.;\n\t#endif\n        switch( params.mode )\n        {\n        case MODE_INSCATTER:\n            result.xyz = I;\n        \tresult.w = Tc;\n\t\t#if WITH_ATM_BILATERAL_UPSAMPLE\n            if( params.t != 0. )\n            {\n            \tresult.xz = round( log2( clamp( result.xz, 5.96046448e-8, 254.617452 ) ) * 128. + 3072. );\n            \tresult.x = result.x + result.z / 4096.;\n            \tresult.z = log2( params.t );\n            }\n\t\t#endif\n            break;\n        case MODE_SKYLIGHT:\n            result.xyz = I * params.scale + T * g_env.starlight;\n        #if WITH_CLOUDS\n\t        result.w = clamp( ( exp2pp( -cld_tau50( params.x0, vec4( g_env.L, SCN_RAYCAST_SHADOW_UMBRA_INV ), ATM_CLOUD_SHADOW_MIN_TAU, false ) * ( 1. - cld_f ) ) - ATM_CLOUD_T_CUTOFF ) / ( 1. - ATM_CLOUD_T_CUTOFF ), 0., 1. );\n\t    #endif\n            break;\n        case MODE_REFLECTION:\n            result.xyz = ( I + T * g_env.starlight ) * params.scale;\n            result.w = params.scale;\n            break;\n        }\n    }\n\n    return result;\n}\n\nint get_render_mode( vec2 fcoord, inout vec2 sc )\n{\n\tvec2 halfres = iResolution.xy / 2.;\n    int mode = MODE_NONE;\n\n    if( fcoord.y < halfres.y )\n    {\n    \tvec2 uv = g_vrmode ? ( fcoord - unViewport.xy ) / unViewport.zw : fcoord / iResolution.xy;\n    \tif( uv.x < .5 )\n    \t{\n        \tsc = 2. * ATM_SUBSAMPLE * uv - 1.;\n        \tmode = MODE_INSCATTER;\n    \t}\n    \telse\n\t\tif( uv.x >= .5 && fcoord.y < halfres.y )\n    \t{\n        \tuv.x -= .5;\n        \tsc = 2. * ATM_SUBSAMPLE * uv - 1.;\n        \tmode = MODE_REFLECTION;\n    \t}\n    }\n    else\n    if( fcoord.x < halfres.y )\n    {\n        bool mustupdate = bool( texelFetch( iChannel1, ivec2( iResolution.y, 2 ), 0 ).x );\n        mode = mustupdate ? MODE_SKYLIGHT : MODE_PRESERVE;\n    }\n    else\n    if( fcoord.x >= iResolution.x - 8. )\n    \tmode = MODE_OBJECTS;\n    return mode;\n}\n\nbool get_render_ray( int mode, vec2 sc, inout Ray ray )\n{\n    if( g_vrmode )\n    {\n        vec2 uv = ( sc + 1. ) / ATM_SUBSAMPLE;\n        vec3 cc = ( mix( mix( unCorners[0], unCorners[1], uv.x ),\n                         mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - unCorners[4] ).zxy * vec3( -1, 1, -1 );\n        vec3 dir = cc * g_vrframe;\n        if( dot( dir.yz, dir.yz ) >= 1.55 / g_game.camzoom * dir.x * dir.x )\n            return false;\n        dir.yz /= g_game.camzoom;\n        cc = normalize( g_vrframe * dir );\n        g_pixelscale = .25 * abs( dir.x * dFdx( dir.y / dir.x ) * dFdy( dir.z / dir.x ) );\n        vec3 dp = unCorners[4].zxy * vec3( -1, 1, -1 ) / 1000.;\n        ray.o = g_game.campos + g_game.camframe * dp;\n        ray.d = g_game.camframe * cc;\n    }\n    else\n    {\n        vec2 ec = sc * vec2( 1, iResolution.y / iResolution.x );\n        vec3 cc = normalize( vec3( CAM_FOCUS, barrel_distort( vec2( ec.x, -ec.y ) / g_game.camzoom, CAM_DISTORT ) ) );\n        g_pixelscale = .25 * abs( cc.x * dFdx( cc.y / cc.x ) * dFdy( cc.z / cc.x ) );\n        ray.o = g_game.campos;\n        ray.d = g_game.camframe * cc;\n    }\n    return true;\n}\n\nvoid main_image_worker( out vec4 fcolor, in vec2 fcoord )\n{\n    fcolor = vec4( ZERO, 1 );\n\n#if BUFFER_RUNLEVEL >= 3\n\n   \tg_game = gs_load( iChannel0, ADDR_GAMESTATE );\n    g_env = env_load( iChannel0, ADDR_LOCALENV );\n    g_ts = ts_load( iChannel0, ADDR_TSAMPLER );\n    g_atm = atm_load( iChannel0, ADDR_ATMCONTEXTS + ivec2(1,0) );\n    g_data = g_planet_data[1];\n\n    if( ( g_game.switches & GS_TRMAP ) == 0u )\n    {\n        vec2 sc = vec2(0);\n\t\tint mode = get_render_mode( fcoord, sc );\n\n        if( mode == MODE_PRESERVE )\n        \tfcolor = texelFetch( iChannel2, ivec2( fcoord - .5 ), 0 );\n        else\n        if( mode > 0 && sc.x < 1. && sc.y < 1. )\n        {\n            vec2 sct = sincospi( g_game.timer * cld_move.w );\n    \t\tcld_fluff_rot = mat2( sct.yx, -sct.x, sct.y );\n            Ray ray = Ray( ZERO, ZERO );\n\t\t\tbool ok = get_render_ray( mode, sc, ray );\n            if( ok )\n    \t\t\tfcolor = render( ray, mode, fcoord );\n        }\n    }\n#endif // RUNLEVEL\n}\n\nvoid mainImage( out vec4 fcolor, in vec2 fcoord )\n\t{ main_image_worker( fcolor, fcoord ); }\n\nvoid mainVR( out vec4 fcolor, in vec2 fcoord, in vec3 _ro_dummy_, in vec3 _rd_dummy_ )\n{\n    g_vrmode = true;\n    vec3 horz = ( unCorners[1] + unCorners[2] - unCorners[0] - unCorners[3] ).zxy * vec3( -1, 1, -1 );\n    vec3 down = ( unCorners[0] + unCorners[1] - unCorners[2] - unCorners[3] ).zxy * vec3( -1, 1, -1 );\n    vec3 forw = ( unCorners[0] + unCorners[1] + unCorners[2] + unCorners[3] - 4. * unCorners[4] ).zxy * vec3( -1, 1, -1 );\n    g_vrframe[1] = normalize( horz );\n    g_vrframe[2] = normalize( down );\n    g_vrframe[0] = cross( g_vrframe[1], g_vrframe[2] );\n    main_image_worker( fcolor, gl_FragCoord.xy );\n}\n\n#define unViewport _unViewport_dummy_\n#define unCorners _unCorners_dummy_\n", "name": "Buffer C", "description": "", "type": "buffer"}, {"inputs": [{"id": "XdX3Rr", "filepath": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "previewfilepath": "/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "type": "volume", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "4dXGR8", "filepath": "/media/previz/buffer00.png", "previewfilepath": "/media/previz/buffer00.png", "type": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "XsXGR8", "filepath": "/media/previz/buffer01.png", "previewfilepath": "/media/previz/buffer01.png", "type": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "4sXGR8", "filepath": "/media/previz/buffer02.png", "previewfilepath": "/media/previz/buffer02.png", "type": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "XdfGR8", "channel": 0}], "code": "/*\n *\t\t\t\tSPACE GLIDER 2020 SHADERTOY EDITION\n *\t\t\t\t\t   by Christian Sch\u00fcler\n *                       (c) 2001 - 2020\n *\n * Part 5 of 6: Buffer D shader (main rendering)\n * This software comes with no warranty. Use it at your own risk.\n */\n\n// ----------------------------------------------------------------------------\n\nGameState g_game;\nVehicleState g_vehicle;\nLocalEnvironment g_env;\nTrnSampler g_ts;\nAtmContext g_atm;\nPlanetData g_data;\nvec3 g_ocn_beta50;\nvec3 g_ocn_omega;\nfloat g_pixelscale;\n\nbool g_vrmode = false;\nmat3 g_vrframe = mat3( 0 );\nvec4 g_vrfocus = vec4( 0 );\nuniform vec4 unViewport;\nuniform vec3 unCorners[5];\n\n// ----------------------------------------------------------------------------\n// MATERIALS\n// ----------------------------------------------------------------------------\n\nfloat phase_curve( float cosphase )\n{ return .85 + .15 * ( 8. + 1. ) * pow( max( 0., .5 - .5 * cosphase ), 8. ); }\n\nvec3 lunar_lambert( vec3 omega, float mu, float mu_0 )\n{\n    // non-lambertian diffuse shading used for terrain land masses\n    // mix Lambert and Lommel-Seeliger based on single scattering albedo omega_0,\n\n    // return omega / ( mu + mu_0 );\n    // return omega;\n\n    /*\n    vec3 omega_0 = 4. * omega / ( 3. * omega + 1. );\n    return omega_0 * ( omega + .25 * ( 1. - omega ) / max( 0.0001, mu + mu_0 ) );\n    /*/\n    vec3 omega_0 = 244. * omega / ( 184. * omega + 61. );\n    return omega_0 * ( ( 1. + sqrt( mu * mu_0 ) ) / 2. * omega + .25 / max( 0.0001, mu + mu_0 ) );\n    //*/\n}\n\n    //\t\tomega\t\t\t1\t\t\t\t\t\t\t\t\t0.7\t\t\t\t\t\t\t\t\t0.2\n    //\t\tomega_0\t\t\t1\t\t1\t\t\t1\t\t\t\t0.9\t\t0.9\t\t0.975\t\t\t\t0.5\t\t0.5\t\t\t0.7\n    //\n    // \t\tmu + mu_0\t\tV1\t\tV2\t\t\texact\t\t\tV1\t\tV2\t\texact\t\t\t\tV1\t\tV2\t\t\texact\n    //\n    //\t\t0.2\t\t\t\t1.00\t1.75..1.80\t1.81..1.95\t\t1.08\t1.60..1.64\t1.71..1.83\t\t1.20\t1.35..1.36\t1.42..1.49\n    //\t\t0.5\t\t\t\t1.00\t1.00..1.13\t1.01..1.20\t\t0.85\t0.85..0.94\t0.88..1.04\t\t0.60\t0.60..0.63\t0.66..0.73\n    //\t\t1.0\t\t\t\t1.00\t0.75..1.00\t0.73..1.02\t\t0.78\t0.60..0.78\t0.57..0.78\t\t0.40\t0.35\t\t0.36..0.43\n    //\t\t1.5\t\t\t\t1.00\t1.02..1.06\t0.98..1.01\t\t0.75\t0.76..0.79\t0.67..0.69\t\t0.33\t0.34\t\t0.32\n    //\t\t2.0\t\t\t\t1.00\t1.13\t\t1.05\t\t\t0.74\t0.83\t\t0.64\t\t\t0.30\t0.33\t\t0.26\n    //\n    // \t\tmu + mu_0\n    //\n    //\t\t0.2\t\t\t   -48.7\t-7.7\t\t\t\t\t   -59.0   -10.4\t\t\t\t\t   -19.5\t-8.7\n    //\t\t0.5\t\t\t   -16.7\t-5.8\t\t\t\t\t   -18.2\t-9.6\t\t\t\t\t   -17.8   -13.7\n    //\t\t1.0\t\t\t\t37.0\t 2.3\t\t\t\t\t\t36.8\t 5.2\t\t\t\t\t\t11.1   -18.6\n    //\t\t1.5\t\t\t\t 2.0\t 4.9\t\t\t\t\t\t11.9\t13.4\t\t\t\t\t\t 3.1\t 6.3\n    //\t\t2.0\t\t\t\t-4.7     7.6\t\t\t\t\t\t15.6\t29.7\t\t\t\t\t\t15.3\t26.9\n\n\nfloat NDFphase( float xi, float a )\n{ return 1. / ( ( LN2 + a ) * ( 1. + exp( -a ) - xi ) ); }\n\nfloat NDF( float xi, float a )\n{ return 1. / ( max( SQRTTWO, a - SQRTHALF ) * ( 1. + exp( -a ) - xi ) ); }\n\nfloat NDFintegral( float xi0, float xi1, float a )\n{\n    float k0 = 1. + exp( -a ) - xi0;\n    float k1 = 1. + exp( -a ) - xi1;\n    return ( ( k0 > 0. ? log( k0 ) : -a ) - ( k1 > 0. ? log( k1 ) : -a ) ) / max( SQRTTWO, a - SQRTHALF );\n}\n\nfloat NDFdisk( float xi, float a, float b )\n{\n    // disk-integrated normal distribution function\n    // using the distribution 1/((a-1)*(1+exp(-a)-xi))\n    float xi0 = xi - b / 2.;\n    float xi1 = xi + b / 2.;\n    return ( NDFintegral( max( 0., xi0 ), min( 1., xi1 ), a ) +\n        ( xi1 >= 1. ? NDFintegral( 2. - xi1, 1., a ) : 0. ) ) / b;\n}\n\nstruct MaterialData\n{\n    vec4 omega;\n};\n\nMaterialData[] g_matdata = MaterialData[](\n    // 0\n    MaterialData( vec4(0) ),\n    MaterialData( vec4( .33, .31, .27, .45 ) ),\t\t\t// concrete 1\n    MaterialData( vec4( .27, .25, .23, .41 ) ),\t\t\t// concrete 2\n    MaterialData( vec4( .28, .26, .24, .39 ) ),\t\t\t// concrete 3\n    MaterialData( vec4( .25, .21, .17, .40 ) ),\t\t\t// concrete 4\n    // 5\n    MaterialData( vec4( .27, .23, .19, .43 ) ),\t\t\t// concrete 5\n    MaterialData( vec4( .24, .21, .15, .46 ) ),\t\t\t// concrete 6\n    MaterialData( vec4( .29, .21, .12, .47 ) ), \t\t// concrete 7\n    MaterialData( vec4( .07, .08, .09, .12 ) ),\t\t\t// asphalt\n    MaterialData( vec4(0) ),\n    // 10\n    MaterialData( vec4( .3919, .0616, .0180, .71 ) ),\t// RAL 3020 traffic red\n    MaterialData( vec4( .5832, .5931, .5815, .65 ) ),\t// RAL 7035 light grey\n    MaterialData( vec4( .1579, .0805, .0469, .29 ) ),\t// RAL 8024 beige brown\n    MaterialData( vec4( .8852, .8830, .8532, .77 ) ),\t// RAL 9016 traffic white\n    MaterialData( vec4( .0440, .0820, .1473, .56 ) ),\t// RAL 5000 violet blue\n    // 15\n    MaterialData( vec4( .0069, .0827, .2402, .52 ) ),\t// RAL 5002 ultramarine blue\n    MaterialData( vec4( .3601, .0531, .0332, .42 ) ),\t// RAL 3000 fire red\n    MaterialData( vec4( .6001, .3250, .0472, .55 ) ),\t// RAL 1005 honey yellow\n    MaterialData( vec4( .2414, .3557, .1122, .39 ) ),\t// RAL 6018 yellow green\n    MaterialData( vec4( .0838, .2669, .1433, .41 ) ),\t// RAL 6024 traffic green\n    // 20\n    MaterialData( vec4( .29, .19, .10, .35 ) ),\t\t\t// desert sand dark\n    MaterialData( vec4( .34, .25, .18, .37 ) ),\t\t\t// desert sand light\n    MaterialData( vec4( .42, .40, .38, .48 ) ),\t\t\t// light concrete\n    MaterialData( vec4( .20, .19, .08, .31 ) ),\t\t\t// muddy grass light\n    MaterialData( vec4( .15, .11, .10, .21 ) ), \t\t// muddy grass dark\n    // 25\n    MaterialData( vec4( .11, .06, .01, .26 ) ),\t\t\t// dark wood\n    MaterialData( vec4( .16, .11, .05, .36 ) ),\t\t\t// medium wood\n    MaterialData( vec4( .74, .73, .72, .25 ) ),\t\t\t// compressed snow\n    MaterialData( vec4( .33, .22, .14, .43 ) ),\t\t\t// sandstone\n    MaterialData( vec4( .3079, .2515, .1929, .32 ) ),\t// RAL 7002 olive grey\n    // 30\n    MaterialData( vec4( .3259, .3259, .3290, .31 ) ),\t// RAL 7004 signal grey\n    MaterialData( vec4( .0608, .2021, .2066, .35 ) )\t// RAL 5021 water blue\n);\n\n// ----------------------------------------------------------------------------\n// TERRAIN\n// ----------------------------------------------------------------------------\n\nvec4 texturenoise( vec3 r )\n{\n    vec3 uvw = r / iChannelResolution[3];\n    return texture( iChannel3, uvw ) * 2. - 1.;\n}\n\nfloat trn_detailmap( vec3 pos )\n{\n    return 1. + .10 * texturenoise( pos / .01 ).x +\n        .12 * texturenoise( pos / .003 ).x +\n        .15 * texturenoise( pos / .001 ).x +\n        .17 * texturenoise( pos / .0003 ).x;\n}\n\nfloat trn_blendmask( vec3 pos )\n{\n    pos *= g_data.trn_slope.x;\n    return clamp( .40 * texturenoise( pos / 10. ).x +\n                  .50 * texturenoise( pos / 3. ).x +\n                  .40 * texturenoise( pos / 1. ).x +\n                  .30 * texturenoise( pos / 0.3 ).x + .5, 0., 1. );\n}\n\nvec3 trn_ripplemap( vec3 pos )\n{\n    return .20 * texturenoise( pos / .01 ).xyz +\n        .30 * texturenoise( pos / .003 ).xyz +\n        .30 * texturenoise( pos / .001 ).xyz +\n        .20 * texturenoise( pos / .0003 ).xyz;\n}\n\nvec4 texturenoiseLod( vec3 r, float lod )\n{\n    vec3 uvw = r / iChannelResolution[3];\n    return textureLod( iChannel3, uvw, lod ) * 2. - 1.;\n}\n\nfloat trn_detailmapLod( vec3 pos, float scale )\n{\n    float lod = log2( scale / 0.001 );\n    return 1. + .10 * texturenoiseLod( pos / .01, lod - 3.322 ).x +\n        .12 * texturenoiseLod( pos / .003, lod - 1.585 ).x +\n        .15 * texturenoiseLod( pos / .001, lod ).x +\n        .17 * texturenoiseLod( pos / .0003, lod + 1.585 ).x;\n}\n\nfloat trn_blendmaskLod( vec3 pos, float scale )\n{\n    float lod = log2( scale );\n    return clamp( .40 * texturenoiseLod( pos / 10., lod - 3.322 ).x +\n                  .50 * texturenoiseLod( pos / 3., lod - 1.585 ).x +\n                  .40 * texturenoiseLod( pos / 1., lod ).x +\n                  .30 * texturenoiseLod( pos / 0.3, lod + 1.585 ).x + .5, 0., 1. );\n}\n\nvec3 trn_ripplemapLod( vec3 pos, float scale )\n{\n    float lod = log2( scale / 0.001 );\n    return .20 * texturenoiseLod( pos / .01, lod - 3.322 ).xyz +\n        .30 * texturenoiseLod( pos / .003, lod - 1.585 ).xyz +\n        .30 * texturenoiseLod( pos / .001, lod ).xyz +\n        .20 * texturenoiseLod( pos / .0003, lod + 1.585 ).xyz;\n}\n\nvec3 trn_normalmapLod( vec3 pos, float scale )\n{\n    float lod = log2( scale / 0.001 );\n    return .15 * texturenoiseLod( pos / 0.01, lod - 3.322 ).xyz +\n        .35 * texturenoiseLod( pos / 0.003, lod - 1.585 ).xyz +\n        .35 * texturenoiseLod( pos / 0.001, lod ).xyz +\n        .15 * texturenoiseLod( pos / 0.0003, lod + 1.585 ).xyz;\n}\n\nvec3 trn_albedo( vec3 r, float Krwidth, float alt, float slope, float sinlat, bool detail )\n{\n    float coslat = sqrt( max( 0., 1. - sinlat * sinlat ) );\n    float cos2lat = coslat * coslat * 2. - 1.;\n    float cos3lat = cos2lat * coslat * 2. - coslat;\n    float cos3lat2 = cos3lat * cos3lat;\n\n    bool ir = ( g_game.switches & GS_IRCAM ) == GS_IRCAM;\n\n    vec3 snow = irselect( vec4( .76, .75, .74, .45 ), ir );\n    vec3 gras = irselect( vec4( .15, .16, .05, .55 ), ir );\n    vec3 tree = irselect( vec4( .06, .07, .03, .65 ), ir );\n    vec3 sand = irselect( vec4( .35, .24, .13, .40 ), ir );\n    vec3 rock = irselect( vec4( .19, .18, .17, .30 ), ir );\n    vec3 tide = irselect( vec4( .15, .12, .08, .25 ), ir );\n\n    if( detail )\n    {\n        float m = trn_detailmapLod( r, Krwidth );\n        float m4 = trn_detailmapLod( r / 4., Krwidth / 4. );\n        gras *= m;\n        tree *= m;\n        sand *= m;\n        rock *= m;\n        tide *= m;\n        snow = mix( snow, rock, parabolstep( 1.10, 1.20, m ) );\n        sand = mix( sand, gras, parabolstep( 0.85, 0.75, m ) );\n        gras = mix( gras, rock, parabolstep( 0.90, 0.80, m ) );\n        rock = mix( rock, 1.5 * rock, parabolstep( 1.05, 1.15, m4 ) );\n    }\n\n    vec4 factors = vec4( alt * ( 1.8 + 5.2 / TRN_SCALE ) / 7., coslat, cos3lat2, SCN_SCALE / ( 0.833333333 * TRN_SCALE ) * slope );\n\n    float gr = clamp( .5 + 1.50 + dot( vec4( 1.00, -0.50, -1.00, -25.00 ), factors ), .05, .95 );\n    float ti = clamp( .5 + 0.00 + dot( vec4( -500.00, 0.00, 0.00, 0.00 ), factors ), .00, 1.00 );\n    float sa = clamp( .5 + 0.55 + dot( vec4( -1.00, 0.25, -2.00, -5.00 ), factors ), .05, .85 );\n    float sn = clamp( .5 + 0.80 + dot( vec4( 1.30, -3.30, 0.00, -1.00 ), factors ), .00, 1.00 );\n    float ro = clamp( .5 - 0.35 + dot( vec4( 0.25, -0.25, -0.50, 1.00 ), factors ), .00, 1.00 );\n\n    float b = trn_blendmaskLod( r * 0.837324 / SCN_SCALE, Krwidth * 0.837324 / SCN_SCALE );\n    float c = 8.;\n\n    vec3 col = tree;\n    col = mix( col, gras, saturate( mix( b, gr, c ) ) );\n    col = mix( col, tide, saturate( mix( b, ti, c ) ) );\n    col = mix( col, sand, saturate( mix( b, sa, c ) ) );\n    col = mix( col, snow, saturate( mix( b, sn, c ) ) );\n    col = mix( col, rock, saturate( mix( b, ro, c ) ) );\n\n    if( alt >= 10.3135 )\n        col = irselect( vec4( COL_PRIMARYRED, .35 ), ir );;\n\n    return col;\n}\n\n// ----------------------------------------------------------------------------\n// ATMOSPHERE\n// ----------------------------------------------------------------------------\n\nvec4 atm_inscatter_sample( sampler2D ch, vec2 uv, float t )\n{\n    uv = uv * SCN_SUBSAMPLE * ATM_SUBSAMPLE_INV;\n    uv.x = g_vrmode ? uv.x : min( uv.x, 1. - .4999 / float( textureSize( ch, 0 ).x ) );\n#if WITH_ATM_BILATERAL_UPSAMPLE\n    vec2 tc = vec2( textureSize( ch, 0 ).xy ) * uv;\n    vec2 rtc = round( tc );\n    ivec2 itc = ivec2( rtc ) - 1;\n    vec4 sa = texelFetchOffset( ch, itc, 0, ivec2( 0, 0 ) );\n    vec4 sb = texelFetchOffset( ch, itc, 0, ivec2( 1, 0 ) );\n    vec4 sc = texelFetchOffset( ch, itc, 0, ivec2( 0, 1 ) );\n    vec4 sd = texelFetchOffset( ch, itc, 0, ivec2( 1, 1 ) );\n    float wx0 = abs( rtc.x + .5 - tc.x );\n    float wx1 = abs( rtc.x - .5 - tc.x );\n    float wy0 = abs( rtc.y + .5 - tc.y );\n    float wy1 = abs( rtc.y - .5 - tc.y );\n    float wta = abs( t - sa.z ) + .25;\n    float wtb = abs( t - sb.z ) + .25;\n    float wtc = abs( t - sc.z ) + .25;\n    float wtd = abs( t - sd.z ) + .25;\n    float wa = wx0 * wy0 * wtb * wtc * wtd;\n    float wb = wx1 * wy0 * wta * wtc * wtd;\n    float wc = wx0 * wy1 * wta * wtb * wtd;\n    float wd = wx1 * wy1 * wta * wtb * wtc;\n    sa.xz = exp2( vec2( floor( sa.x ) / 128., fract( sa.x ) * 32. ) - 24. );\n    sb.xz = exp2( vec2( floor( sb.x ) / 128., fract( sb.x ) * 32. ) - 24. );\n    sc.xz = exp2( vec2( floor( sc.x ) / 128., fract( sc.x ) * 32. ) - 24. );\n    sd.xz = exp2( vec2( floor( sd.x ) / 128., fract( sd.x ) * 32. ) - 24. );\n    return ( sa * wa + sb * wb + sc * wc + sd * wd ) / ( wa + wb + wc + wd + 1e-6 );\n#else\n    return textureLod( ch, uv, 0. );\n#endif\n}\n\nvec4 atm_reflection_sample( sampler2D ch, vec2 uv )\n{\n    uv = uv * SCN_SUBSAMPLE * ATM_SUBSAMPLE_INV;\n    uv.x = g_vrmode ? uv.x + .25 : max( uv.x, .5001 / float( textureSize( ch, 0 ).x ) ) + .5;\n#if WITH_ATM_BILATERAL_UPSAMPLE\n    vec2 tc = vec2( textureSize( ch, 0 ).xy ) * uv;\n    vec2 rtc = round( tc );\n    ivec2 itc = ivec2( rtc ) - 1;\n    vec4 sa = texelFetchOffset( ch, itc, 0, ivec2( 0, 0 ) );\n    vec4 sb = texelFetchOffset( ch, itc, 0, ivec2( 1, 0 ) );\n    vec4 sc = texelFetchOffset( ch, itc, 0, ivec2( 0, 1 ) );\n    vec4 sd = texelFetchOffset( ch, itc, 0, ivec2( 1, 1 ) );\n    float wx0 = abs( rtc.x + .5 - tc.x );\n    float wx1 = abs( rtc.x - .5 - tc.x );\n    float wy0 = abs( rtc.y + .5 - tc.y );\n    float wy1 = abs( rtc.y - .5 - tc.y );\n    float wa = wx0 * wy0 * float( sa != vec4(0,0,0,1) );\n    float wb = wx1 * wy0 * float( sb != vec4(0,0,0,1) );\n    float wc = wx0 * wy1 * float( sc != vec4(0,0,0,1) );\n    float wd = wx1 * wy1 * float( sd != vec4(0,0,0,1) );\n    return ( sa * wa + sb * wb + sc * wc + sd * wd ) / ( wa + wb + wc + wd + 1e-6 );\n#else\n    return textureLod( ch, uv, 0. );\n#endif\n}\n\nvec4 atm_skylight_sample( TrnSampler ts, sampler2D ch, vec3 x )\n{\n    vec2 res = vec2( textureSize( ch, 0 ) );\n    vec2 aspect = vec2( res.y / res.x, 1 );\n    vec2 uv = ts_uv( ts, x ) / 2. * aspect + vec2( 0, .5 );\n    return textureLod( ch, uv, 0. );\n}\n\n// ----------------------------------------------------------------------------\n// SCENE\n// ----------------------------------------------------------------------------\n\nfloat scene_primitive_sphere( Ray ray, float R, inout float t, inout vec3 N )\n{\n    vec2 sph = sphere_impact( ray.o, ray.d );\n    if( sph.x < R * R )\n    {\n        float to = sphere_limits( R, sph ).x;\n        if( to >= 0. && to < t )\n        {\n            t = to;\n            N = normalize( ray.o + t * ray.d );\n        }\n    }\n    float shadow = 1.;\n    if( sph.y < 0. )\n    {\n        float K = -2. * sph.y * SCN_RAYCAST_SHADOW_UMBRA_INV;\n        float u = sqrt( sph.x );\n        shadow = 1. - aaa_interval( K, u, 2. * R );\n    }\n    return shadow;\n}\n\nfloat scene_primitive_cube( Ray ray, vec3 size, inout float t, inout vec3 N )\n{\n    vec3 dn = ray.o + sign( ray.d ) * size;\n    vec3 to = -dn / ray.d;\n    if( to.x >= 0. && to.x < t &&\n        hmax( abs( ray.o.yz + ray.d.yz * to.x ) - size.yz ) < 0. )\n    {\n        t = to.x;\n        N = sign( ray.o.x ) * UNIT_X;\n    }\n    if( to.y >= 0. && to.y < t &&\n        hmax( abs( ray.o.zx + ray.d.zx * to.y ) - size.zx ) < 0. )\n    {\n        t = to.y;\n        N = sign( ray.o.y ) * UNIT_Y;\n    }\n    if( to.z >= 0. && to.z < t &&\n        hmax( abs( ray.o.xy + ray.d.xy * to.z ) - size.xy ) < 0. )\n    {\n        t = to.z;\n        N = sign( ray.o.z ) * UNIT_Z;\n    }\n    float shadow = 1.;\n    if( hmax( to ) >= 0. )\n    {\n        vec3 K = 2. * max( ZERO, max( to.yzx, to.zxy ) ) * SCN_RAYCAST_SHADOW_UMBRA_INV;\n        vec3 R = size.yzx * abs( ray.d ).zxy + size.zxy * abs( ray.d ).yzx;\n        vec3 u = cross( ray.o, ray.d );\n        shadow = 1. - aaa_interval( K.x, u.x, 2. * R.x )\n            * aaa_interval( K.y, u.y, 2. * R.y )\n            * aaa_interval( K.z, u.z, 2. * R.z );\n    }\n    return shadow;\n}\n\nfloat scene_primitive_cylinder( Ray ray, vec2 size, inout float t, inout vec3 N )\n{\n    float R = size.x;\n    float omzz = max( 0., 1. - ray.d.z * ray.d.z );\n    float ooomzz = 1. / omzz;\n    float od = dot( ray.o.xy, ray.d.xy );\n    float u = square( dot( ray.o.xy, perp( ray.d.xy ) ) ) * ooomzz;\n    float v = max( 0., R * R - u );\n    float to = -od * ooomzz - sqrt( v * ooomzz );\n    float dz = ray.o.z + sign( ray.d.z ) * size.y;\n    float tz = -dz / ray.d.z;\n    if( u < R * R )\n    {\n        if( to >= 0. && to < t && abs( ray.o.z + ray.d.z * to ) < size.y )\n        {\n            t = to;\n            N = vec3( normalize( ray.o.xy + t * ray.d.xy ), 0. );\n        }\n        vec2 xy = ray.o.xy + ray.d.xy * tz;\n        if( tz >= 0. && tz < t && dot( xy, xy ) < R * R )\n        {\n            t = tz;\n            N = sign( ray.o ) * UNIT_Z;\n        }\n    }\n    float shadow = 1.;\n    if( ( od < 0. || -sign( ray.d.z ) * ray.o.z >= size.y ) &&\n                      sign( ray.d.z ) * ray.o.z < size.y * 0.95 )\n    {\n        float somzz = sqrt( omzz );\n        float K = 2. * max( 0., max( to, tz ) * SCN_RAYCAST_SHADOW_UMBRA_INV );\n        float u1 = sqrt( u );\n        float u2 = ( od * ray.d.z * ooomzz - ray.o.z ) * somzz;\n        float R2 = sqrt( v ) * abs( ray.d.z ) + size.y * somzz;\n        shadow = 1. - aaa_interval( K, u1, 2. * R ) *\n            aaa_interval( K, u2, 2. * R2 );\n    }\n    return shadow;\n}\n\nfloat scene_obj_primitive( SceneObj obj, Ray ray, inout float t, inout vec3 albedo, inout vec3 out_N )\n{\n    float to = t, shadow = 1.;\n    vec3 N = ZERO;\n    switch( int( obj.paramsA.w ) )\n    {\n    case SCNOBJ_PRIMITIVE_SPHERE:\n    shadow = scene_primitive_sphere( ray, obj.paramsB.x, to, N );\n    break;\n    case SCNOBJ_PRIMITIVE_CUBE:\n    shadow = scene_primitive_cube( ray, obj.paramsB.xyz, to, N );\n    break;\n    case SCNOBJ_PRIMITIVE_CYLINDER:\n    shadow = scene_primitive_cylinder( ray, obj.paramsB.xy, to, N );\n    break;\n    }\n    if( to < t )\n    {\n        t = to;\n        out_N = N;\n        bool ir = ( g_game.switches & GS_IRCAM ) != 0u;\n        if( obj.paramsA.x == -99. )\n        {\n            float u = ray.o.z + ray.d.z * t;\n            float Ku = 2. * sqrt( g_pixelscale ) * t * mix( 1., 1. / dot( -ray.d.xy, N.xy ), square( ray.d.z ) );\n            albedo = mix( irselect( g_matdata[ int( obj.paramsA.y ) ].omega, ir ),\n                         irselect( g_matdata[ int( obj.paramsA.z ) ].omega, ir ),\n                         aaa_stipple( Ku, u - .001, .004, .5 ) );\n        }\n        else\n            albedo = irselect( g_matdata[ int( abs( obj.paramsA.x ) ) ].omega, ir );\n    }\n\n    return shadow;\n}\n\nint scene_raycast_objects( Ray ray, inout float t, inout vec3 albedo, inout vec3 out_N )\n{\n    int result = -1;\n    for( int i = 0, n = int( memload( iChannel0, ADDR_DATASIZES, 0 ).w ); i < n; ++i )\n    {\n        float to = t;\n        vec3 N = ZERO;\n        SceneObj obj = so_load( iChannel0, ADDR_SCENE_OBJECTS + ivec2( i, 0 ) );\n        Ray localray = Ray( ( ray.o - obj.r ) * obj.B, ray.d * obj.B );\n        switch( int( obj.tybr.x ) )\n        {\n        case SCNOBJ_TYPE_PRIMITIVE:\n        scene_obj_primitive( obj, localray, to, albedo, N );\n        break;\n        }\n        if( to < t )\n            result = i, t = to, out_N = obj.B * N;\n    }\n    return result;\n}\n\nfloat scene_raycast_object_shadows( Ray ray )\n{\n    float result = 1.;\n    float t = SCN_ZFAR;\n    vec3 albedo, N;\n    for( int i = 0, n = int( memload( iChannel0, ADDR_DATASIZES, 0 ).w ); i < n; ++i )\n    {\n        SceneObj obj = so_load( iChannel0, ADDR_SCENE_OBJECTS + ivec2( i, 0 ) );\n        Ray localray = Ray( ( ray.o - obj.r ) * obj.B, ray.d * obj.B );\n        switch( int( obj.tybr.x ) )\n        {\n        case SCNOBJ_TYPE_PRIMITIVE:\n        result *= scene_obj_primitive( obj, localray, t, albedo, N );\n        break;\n        }\n    }\n    return max( 0., result );\n}\n\nvec3 scene_object_lighting( vec3 albedo, vec3 N, vec3 L, vec3 V, vec3 Z, vec3 F,\n                            vec3 skyZ, vec3 skyL, vec3 skyR, vec3 ground )\n{\n    float mu_0 = mu_stretch( dot( N, L ), .01 );\n    float mu = mu_stretch( dot( N, V ), .01 );\n    float cosi = dot( N, Z );\n    float cosp = dot( L, V );\n    float cost = dot( normalize( reject( N, Z ) ), normalize( reject( L, Z ) ) );\n    vec3 kd = lunar_lambert( albedo, mu, mu_0 );\n    float kl = phase_curve( cosp );\n    vec3 E = F * mu_0;\n    //*\n    vec3 sky = mix( mix( skyR, skyL, .5 + .5 * cost ), skyZ, cosi * .3333 + .6667 );\n    return E * kd * kl + albedo * mix( ground, sky, cosi * .5 + .5 );\n    /*/\n    float cosi2 = cosi * cosi;\n    vec3 skyH = ( skyL + skyR ) / 2.;\n    vec3 skyJ = ( skyL - skyR ) / 2.;\n    vec3 sky = skyZ / 8. * ( 2.6667 + cosi * ( 3.5 + cosi2 * ( -0.3333 + cosi2 * ( -0.5 + cosi2 ) ) ) ) +\n               skyH / 8. * ( 1.3333 + cosi * ( 0.5 + cosi2 * ( +0.3333 + cosi2 * ( +0.5 + cosi2 ) ) ) ) +\n               skyJ * cost / ( 105. * PI ) * ( 30. - cosi2 * ( 6. + cosi2 * ( 8. + cosi2 * 16. ) ) );\n    return E * kd * kl + albedo * ( sky + ground * ( 1. - cosi ) / 2. );\n    //*/\n}\n\nvec4 scene_ocean_normal_and_lensing( vec3 r, float t, float h, float d, vec3 V, vec3 Z )\n{\n    vec3 A = normalize( V - Z * dot( V, Z ) );\n    vec3 B = cross( A, Z );\n    vec3 M = normalize( Z + .25 * trn_normalmapLod( r + 0.002 * iTime * Z, d ) );\n    float dMdA = dot( A, normalize( Z + .25 * trn_normalmapLod( r + 0.002 * iTime * Z + d * A, d ) ) - M );\n    float dMdB = dot( B, normalize( Z + .25 * trn_normalmapLod( r + 0.002 * iTime * Z + d * B, d ) ) - M );\n    float lens = 1. + h / d * ( dMdA + dMdB );\n    return vec4( M, 1. / max( FRACT_1_64, lens * lens ) );\n}\n\nvec3 scene_object_color( vec3 r, mat2x3 Kr, float t, float r0, vec3 N, vec3 V, vec3 albedo,\n                         bool submerged, int index )\n{\n    float h = length( r ) - r0;\n    vec3 Z = normalize( r );\n    vec3 skyL = texelFetch( iChannel2, ivec2( iResolution.x - 6., int( iResolution.y ) / 2 + 2 * index ), 0 ).xyz;\n    vec3 skyR = texelFetch( iChannel2, ivec2( iResolution.x - 4., int( iResolution.y ) / 2 + 2 * index ), 0 ).xyz;\n    vec4 skyZ = texelFetch( iChannel2, ivec2( iResolution.x - 2., int( iResolution.y ) / 2 + 2 * index ), 0 );\n    vec3 TL = atm_transmittance( Z * max( g_data.radius, length( r ) ), g_env.L, g_atm, true );\n    vec3 F = g_env.sunlight;\n    vec3 L = g_env.L;\n    if( submerged )\n    {\n        float d = max( 0.001, -.25 * h );\n        vec4 M = scene_ocean_normal_and_lensing( r, t, h, d, V, Z );\n        F = F * M.w;\n        F = F * saturate( 1. - fresnel_schlick( .02, dot( M.xyz, L ) ) );\n        L = normalize( -simple_refract( -L, Z ) );\n    }\n    F *= ts_shadow_sample( g_ts, iChannel1, r ) * TL * skyZ.w;\n    float objshadow = scene_raycast_object_shadows( Ray( r, L ) );\n    float slope = length( N / dot( N, Z ) - Z );\n    vec3 ground = trn_albedo( r, 4. * h, h, slope, Z.z, false ) * ( F * dot( L, Z ) + skyZ.xyz );\n    if( submerged )\n    {\n        skyZ.xyz = .75 * skyZ.xyz + .125 * skyL + .125 * skyR;\n        skyL = .125 * skyL + .375 * ( skyZ.xyz + ground );\n        skyR = .125 * skyR + .375 * ( skyZ.xyz + ground );\n    }\n    return scene_object_lighting( albedo, N, L, V, Z, F * objshadow, skyZ.xyz, skyL, skyR, ground );\n}\n\nfloat scene_obj_runway_centerline( mat2 K, vec2 uv, vec2 size )\n{\n    float l = floor( size.x / 60. - 1.5 ) * 60.;\n    return aaa_stipple( Linfinity( K[0] ), uv.x, 60., .5 ) *\n        aaa_box( K, uv, vec2( l, .7 ), vec2( 0 ) );\n}\n\nfloat scene_obj_runway_threshold_markers( mat2 K, vec2 uv, vec2 size )\n{\n    uv = abs( uv ) - size / 2. + vec2( 30, size.y / 4. );\n    float w = floor( size.y / 9. ) * 3.;\n    return aaa_stipple( Linfinity( K[1] ), uv.y - fract( w / 6. ) * 3., 3., .5 ) *\n        aaa_box( K, uv, vec2( 30., w ), vec2( 0 ) );\n}\n\nvec4 scene_obj_runway( vec4 col, SceneObj obj, vec3 r, mat2x3 Kr )\n{\n    vec3 dr = 1000. * ( r - obj.r );\n    if( dot( dr, dr ) < 2. * dot( obj.paramsB.xy, obj.paramsB.xy ) )\n    {\n        vec2 uv = ( dr * obj.B ).xy;\n        mat2 K = 1000. * mat2( obj.B[0] * Kr, obj.B[1] * Kr );\n\n        // tarmac\n        float d;\n        d = aaa_box( K, uv, obj.paramsB.xy, obj.paramsB.zw );\n        vec3 albedo = irselect( g_matdata[int( abs( obj.paramsA.x ) )].omega, ( g_game.switches & GS_IRCAM ) != 0u );\n        col = mix( col, vec4( albedo, 1 ), d );\n\n        // paintings\n        if( obj.paramsA.w > 0. )\n        {\n            d = ( scene_obj_runway_centerline( K, uv, obj.paramsB.xy ) +\n                  scene_obj_runway_threshold_markers( K, uv, obj.paramsB.xy ) );\n            col = mix( col, vec4( obj.paramsA.www, 1 ), d );\n        }\n    }\n    return col;\n}\n\nvec3 scene_surface_albedo( vec3 r, mat2x3 Kr, float h, float slope, float sinlat, bool detail )\n{\n    vec4 col = vec4( 0 );\n    for( int i = 0, n = int( memload( iChannel0, ADDR_DATASIZES, 0 ).w ); i < n; ++i )\n    {\n        ivec2 addr = ADDR_SCENE_OBJECTS + ivec2( i, 0 );\n        SceneObj obj = so_load( iChannel0, addr );\n        switch( int( obj.tybr.x ) )\n        {\n        case SCNOBJ_TYPE_RUNWAY:\n        col = scene_obj_runway( col, obj, r, Kr );\n        break;\n        }\n        if( col.w >= 1. )\n            break;\n    }\n    float Krwidth = sqrt( max( dot( Kr[0], Kr[0] ), dot( Kr[1], Kr[1] ) ) );\n    return trn_albedo( r, Krwidth, h, slope, sinlat, detail ) * ( 1. - col.w ) + col.xyz;\n}\n\nvec3 scene_lighting_terrain( vec3 albedo, vec3 N, vec3 L, vec3 V, vec3 Z, vec3 F,\n                             vec3 sky, vec2 shadow )\n{\n#if WITH_ILLUM_TEST\n    float mu0 = max( 0., dot( N, L ) );\n    return F * mu0 + sky;\n#else\n    float mu_0 = mu_stretch( dot( N, L ), .01 );\n    float mu = mu_stretch( dot( N, V ), .01 );\n    float cosi = dot( N, Z );\n    float cosp = dot( L, V );\n    vec3 kd = lunar_lambert( albedo, mu, mu_0 );\n    float kl = phase_curve( cosp );\n    float kj = cosi * .5 + .5;\n    vec3 E = F * mu_0 * shadow.x;\n    vec3 backbounce = .5 * albedo * F * shadow.y * mu_stretch( dot( N, -L ), .125 )\n        * mu_stretch( dot( L, Z ), .005 );\n    return E * kd * kl + albedo * ( sky * kj + backbounce );\n#endif\n}\n\nvec3 scene_lighting_ocean( vec3 albedo, vec3 Z, vec3 N, vec3 M, vec3 L, vec3 V, vec3 F,\n                           float a, vec3 sky,\n                           vec4 refl, float extra_T )\n{\n#if WITH_ILLUM_TEST\n    float mu0 = max( 0., dot( N, L ) );\n    return F * mu0 + refl.xyz;\n#else\n    // variation of the KSK microfacet model\n    vec3 L_refract = normalize( -simple_refract( -L, Z ) );\n    float mu0_refract = max( 0., dot( N, L_refract ) ) * max( 0., dot( L, Z ) );\n    float mu0 = max( 0., dot( M, L ) );\n    float mu = max( 0., dot( M, V ) );\n    vec3 H = normalize( L + V );\n    float cosxi = max( 0., dot( M, H ) );\n    float cospsi = max( .0625, dot( L, H ) );\n    float fr_mu = refl.w;\n    float fr_psi = fresnel_schlick( .02, cospsi );\n    float kd = ( 1. - fr_mu );\n    float ks = extra_T * NDFdisk( cosxi, a, .5 * square( 7487. / 321226. ) ) / ( 4. * cospsi * cospsi );\n    return F * mix( mu0_refract * albedo * kd, mu0 * vec3( ks ), fr_psi ) +\n        albedo * sky * ( 1. - fr_mu ) + refl.xyz;\n#endif\n}\n\nvec3 ndist( vec3 Z, float k, vec3 dZ )\n{\n    float b = dot( Z, dZ );\n    return normalize( Z * square( 1. - k + k * b ) + k * ( dZ - Z * b ) );\n}\n\nvec3 scene_surface_color( vec3 r, mat2x3 Kr, float t, vec3 V, vec2 uv, bool submerged,\n                          inout vec3 albedo, inout vec3 N )\n{\n    float Krwidth = sqrt( max( dot( Kr[0], Kr[0] ), dot( Kr[1], Kr[1] ) ) );\n    vec4 tsample = ts_sample_fine( g_ts, iChannel1, g_data, r, Krwidth );\n    vec2 tshadow = ts_shadow_sample_ao( g_ts, iChannel1, r );\n    N = normalize( tsample.xyz );\n    vec3 Z = normalize( r );\n    float h = tsample.w;\n    float pshadow = atm_planet_shadow( dot( g_env.L, Z ), sqrt( max( 0., 1. - g_env.radius * g_env.radius / dot( r, r ) ) ) );\n    vec4 sky = atm_skylight_sample( g_ts, iChannel2, r );\n    vec3 TL = atm_transmittance( Z * max( g_data.radius, length( r ) ), g_env.L, g_atm, true );\n    vec3 F = g_env.sunlight * TL * sky.w * pshadow;\n    float slope = length( N / dot( N, Z ) - Z );\n    albedo = scene_surface_albedo( r, Kr, h, slope, Z.z, h >= 0. || submerged );\n    float d = submerged ?\n        max( 0.001, -.25 * h ) :\n        max( max( 0.001, 125. * h * h ), 4. * t * sqrt( g_pixelscale ) );\n    vec4 M = scene_ocean_normal_and_lensing( r, t, h, d, V, Z );\n    vec3 L = g_env.L;\n    if( submerged )\n    {\n        F = F * M.w;\n        F = F * saturate( 1. - fresnel_schlick( .02, dot( M.xyz, L ) ) );\n        L = normalize( -simple_refract( -L, Z ) );\n    }\n    float oshadow = scene_raycast_object_shadows( Ray( r, L ) );\n    vec3 col = ZERO;\n    if( h < 0. && !submerged )\n    {\n        // water surface\n        vec3 To = exp2pp( 1000. * h * g_ocn_beta50 );\n        vec4 rsample = atm_reflection_sample( iChannel2, uv );\n        vec3 albedo = mix( g_ocn_omega, To * albedo, To );\n        F = F * M.w;\n        F = F * mix( ONE, vec3( tshadow.x * oshadow ), To );\n        const float cld_g = 0.85;\n        const float cld_f = cld_g * cld_g;\n        float extra_T = pow( sky.w, inversesqrt( 1. - cld_f ) - 1. );\n        float a = sqrt( ( .0003 * inversesqrt( g_pixelscale ) + t ) / t ) * 0.8 / g_data.ocn_s2;\n        vec3 M = ndist( Z, .25, trn_ripplemap( r + 0.002 * iTime * Z ) );\n        col = scene_lighting_ocean( albedo, Z, N, M.xyz, g_env.L, V, F, a, sky.xyz, rsample, extra_T );\n    }\n    else\n        if( t < SCN_ZFAR )\n        {\n            // land surface\n            col = scene_lighting_terrain( albedo, N, L, V, Z, F * oshadow, sky.xyz, tshadow );\n        }\n    return col;\n}\n\nfloat scene_raycast_terrain( Ray ray, float wlevel, float tmax2nd, inout float t0, inout vec3 r )\n{\n    bool submerged = length( ray.o ) - g_data.radius < wlevel;\n    float t = 0., h = 0., alt = 0.;\n    float lasth = 0., lastt = 0., lasta = 0.;\n    vec4 tsmpl = vec4( 0 );\n    float t_switch = pow( 0.0000005 * square( g_data.radius ), .333333333 );\n    float C0 = length( ray.o ) - g_data.radius;\n    float C1 = dot( ray.o, ray.d ) / length( ray.o );\n    float C2 = sqdiff( length( ray.o ) * length( ray.d ), dot( ray.o, ray.d ) ) / ( length( ray.o ) * lensq( ray.o ) );\n    for( int i = 0, n = SCN_RAYCAST_MAX_ITER; i < n; i++ )\n    {\n        r = ray.o + t * ray.d;\n        tsmpl = ts_sample( g_ts, iChannel1, r );\n        lasta = alt;\n        alt =\n        #if WITH_TRN_HIGHP_RAYCAST\n            t < t_switch ? C0 + t * C1 + t * t * C2 :\n        #endif\n            length( r ) - g_data.radius;\n        lasth = h;\n        h = alt - ( submerged ? tsmpl.w : max( wlevel, tsmpl.w ) );\n        if( h < 0. )\n        {\n            t = mix( lastt, t, safediv( 0. - lasth, h - lasth ) );\n            r = ray.o + t * ray.d;\n            return t;\n        }\n        else\n            if( submerged && alt >= wlevel )\n            {\n                if( t0 > 0. )\n                    break;\n                t = mix( lastt, t, safediv( wlevel - lasta, alt - lasta ) );\n                r = ray.o + t * ray.d;\n                vec3 Z = normalize( r );\n                vec3 N = ndist( Z, .25, trn_ripplemap( r + 0.002 * iTime * Z ) );\n                ray.d = normalize( ray.d - 2. * N * dot( ray.d, N ) );\n                ray.d = normalize( ray.d - Z * max( 0., dot( ray.d, Z ) ) );\n                ray.o = r;\n                t0 = t;\n                t = 0.;\n            #if WITH_TRN_HIGHP_RAYCAST\n                C0 = length( ray.o ) - g_data.radius;\n                C1 = dot( ray.o, ray.d ) / length( ray.o );\n                C2 = sqdiff( length( ray.o ) * length( ray.d ), dot( ray.o, ray.d ) ) / ( length( ray.o ) * lensq( ray.o ) );\n            #endif\n                alt = wlevel;\n                h = wlevel - ts_sample( g_ts, iChannel1, r ).w;\n            }\n        lastt = t;\n        t += max( .85 * ( .75 + .25 * dot( tsmpl.xyz, ray.d ) ) * h, SCN_RAYCAST_MIN_ADVANCE + SCN_RAYCAST_MIN_ADVANCE_SCALE * t );\n        if( t >= SCN_ZFAR || ( dot( ray.d, r ) >= 0. && alt + g_data.radius >= g_data.radius * ( 1. + g_data.trn_levels.y ) ) || ( t0 > 0. && t + t0 >= tmax2nd ) )\n            break;\n    }\n    return SCN_ZFAR;\n}\n\n// ----------------------------------------------------------------------------\n// STARFIELD / SUNDISK\n// ----------------------------------------------------------------------------\n\nvec3 starfield_worker( vec4 params, float pixelscale )\n{\n    // about 336 visible cells, 27 stars per cell = 9072 stars\n    // simulate the actual magnitude distribution up to 6.5 mag as a power law\n\n    const float power = -0.7684;\n    const float powersum = 31.8768;\t\t\t\t\t\t// = sum( i^-0.7684, i=1..9072 )\n\n    float n = min( 8344508., 2. / pixelscale );\n    float scale = 2. * ( n + 2. ) / powersum * pow( length( params.xyz ), -n );\n    vec3 cell = vec3( floor( asin( params.xy ) * 5.09393754 ), params.w + sign( params.z ) );\n    vec3 col = ZERO; // vec3( cell.xy / 7. + .5, cell.z / 5. );\n    int k = 1 + int( mod( 233. * dot( cell, vec3( 1, 8, 64 ) ), 384. ) );\n    uint rnd = uint( 13 * k );\n    for( int i = 0, N = 27; i < N; ++i )\n    {\n        vec2 phi = sin( ( cell.xy + vec2( rnd *= 3934873077u, rnd *= 3934873077u ) / 4294967296. ) / 5.09393754 );\n        vec3 dir = vec3( phi, sign( params.z ) * sqrt( 1. - dot( phi, phi ) ) );\n        col += scale * pow( float( k + 384 * i ), power ) * pow( dot( dir, params.xyz ), n );\n    }\n    return g_env.starlight * mix( col, ONE, COL_STARLIGHT_ISL );\n}\n\nvec3 starfield( vec3 raydir, float pixelscale )\n{\n    PlanetState ps = ps_load( iChannel0, ADDR_PLANETS + ivec2( 1, 0 ) );\n    raydir = ps.B * raydir;\n\n#if WITH_STARS\n    vec3 absdir = abs( raydir );\n    vec4 params = absdir.x < absdir.y ?\n        absdir.y < absdir.z ?\n        vec4( raydir.xyz, 0 ) :\n        vec4( raydir.zxy, 2 ) :\n        absdir.z < absdir.x ?\n        vec4( raydir.yzx, 4 ) :\n        vec4( raydir.xyz, 0 );\n    return starfield_worker( params, pixelscale );\n#else\n    return ZERO;\n#endif\n}\n\nvec3 sundisk( float cosphase )\n{\n    float L = square( kepler_semimajor( g_planet_data[1].orbit ) / g_planet_data[0].radius );\n    float c = 1. - 1. / L;\n    return irselect( COL_SUNLIGHT, ( g_game.switches & GS_IRCAM ) != 0u ) * 1.333 * L * parabolstep( c, ( 1. + c ) / 2., cosphase );\n}\n\n// ----------------------------------------------------------------------------\n// MAIN\n// ----------------------------------------------------------------------------\n\nvec4 render( Ray ray, vec2 uv )\n{\n    float t0 = 0., Tc = 1.;\n    float r0 = g_data.radius;\n    bool submerged = length( ray.o ) < r0;\n    vec3 r = ray.o, N = ZERO, col = ZERO, albedo = ZERO, I = ZERO;\n    float t = scene_raycast_terrain( ray, 0., .012 / hmin( g_data.ocn_beta50 ), t0, r );\n    float tx = t0 > 0. ? t0 : t;\n    int index = scene_raycast_objects( ray, tx, albedo, N );\n    mat2x3 Kr = mat2x3( dFdx( r ), dFdy( r ) );\n\n    if( index >= 0 )\n    {\n        Tc = texelFetch( iChannel2, ivec2( iResolution.x - 8., int( iResolution.y ) / 2 + 2 * index ), 0 ).w;\n        I = texelFetch( iChannel2, ivec2( iResolution.x - 8., int( iResolution.y ) / 2 + 2 * index ), 0 ).xyz;\n        t = tx;\n        r = ray.o + t * ray.d;\n        col = scene_object_color( r, Kr, t, g_data.radius, N, -ray.d, albedo, submerged, index );\n    }\n    else\n    {\n        vec4 asmpl = atm_inscatter_sample( iChannel2, uv, log2( t ) );\n        Tc = asmpl.w;\n        I = asmpl.xyz;\n        if( t < SCN_ZFAR )\n        {\n            vec3 V = t0 > 0. ? normalize( r - ray.o ) : -ray.d;\n            col = scene_surface_color( r, Kr, t, V, uv, submerged, albedo, N );\n        }\n    }\n\n    if( t >= SCN_ZFAR && !submerged )\n    {\n        // outer space\n        const float cld_g = 0.85;\n        const float cld_f = cld_g * cld_g;\n        float extra_T = pow( Tc, inversesqrt( 1. - cld_f ) - 1. );\n        float cosphase = saturate( dot( ray.d, g_env.L ) );\n        col = starfield( ray.d, g_pixelscale ) + extra_T * irselect( COL_SUNLIGHT, ( g_game.switches & GS_IRCAM ) != 0u ) * sundisk( cosphase );\n        vec3 Ta = atm_transmittance( ray.o, ray.d, g_atm, false );\n        col = col * Tc * Ta + I;\n    }\n    else\n    {\n        // surface hit\n        // headlights\n        vec3 collight = ZERO;\n        if( ( g_vehicle.switches & VS_LIGHT ) == VS_LIGHT )\n        {\n            // Xenon arc landing lights 3 MCd with double beam pattern\n            vec3 axis = normalize( g_vehicle.localB[0] + .05 * g_vehicle.localB[2] );\n            vec3 L = normalize( g_vehicle.localr - r );\n            vec3 V = normalize( ray.o - r );\n            float beam1 = square( saturate( 2. * dot( -axis, L ) - 1. ) );\n            float beam2 = square( saturate( 20. * dot( -axis, L ) - 19. ) );\n            float mu0 = max( 0., dot( N, L ) );\n            float mu = max( 0., dot( N, V ) );\n            float cosphase = dot( L, V );\n            /*\n            vec3 omega0 = 4. * albedo / ( 3. * albedo + 1. );\n            vec3 kd = ( albedo + .25 * ( 1. - albedo ) / max( 0.0001, mu + mu0 ) );\n            /*/\n            vec3 omega0 = 244. * albedo / ( 184. * albedo + 61. );\n            vec3 kd = ( albedo * ( 1. + sqrt( mu * mu0 ) ) / 2. + .25 / max( 0.0001, mu + mu0 ) );\n            //*/\n            float kl = phase_curve( cosphase );\n            float d = max( .002, distance( g_vehicle.localr, r ) );\n            vec3 col = irselect( COL_XENONARC, ( g_game.switches & GS_IRCAM ) != 0u );\n            vec3 E = .000056 * col / square( d ) * mu0;\n            if( submerged )\n                E *= exp2pp( -d * g_ocn_beta50 * 1000. );\n            collight += omega0 * E * kd * kl * mix( beam1, beam2, .75 );\n        }\n\n        if( submerged )\n        {\n            vec3 surfacepoint = normalize( ray.o ) * g_data.radius;\n\n            vec3 surfacelight = g_env.sunlight\n                * atm_transmittance( surfacepoint, g_env.L, g_atm, true )\n                * ( 1. - fresnel_schlick( .02, dot( normalize( surfacepoint ), g_env.L ) ) )\n                * texelFetch( iChannel2, ivec2( iChannelResolution[2].xy ) - 1, 0 ).w\n                + texelFetch( iChannel2, ivec2( iChannelResolution[2].xy ) - 1, 0 ).xyz;\n\n            float z0 = g_data.radius - length( ray.o );\n            float z1 = max( 0., g_data.radius - length( r ) );\n            vec3 W0 = exp2pp( -z0 * g_ocn_beta50 * 1000. );\n            vec3 W1 = exp2pp( -z1 * g_ocn_beta50 * 1000. );\n\n            if( t0 > 0. && index == -1 )\n            {\n                vec3 r0 = ray.o + t0 * ray.d;\n                vec3 Z = normalize( r0 );\n                vec3 M = ndist( Z, .25, trn_ripplemap( r0 + 0.002 * iTime * Z ) );\n                vec3 refrac = normalize( simple_refract( ray.d, M ) );\n                float pixelscale_refrac = 4. * g_pixelscale;\n                float cosxi = dot( M, normalize( simple_refract_inv( ray.d, g_env.L, Z ) ) );\n                float a = sqrt( ( .0003 * inversesqrt( pixelscale_refrac ) + t0 ) / t0 ) * 0.8 / g_data.ocn_s2;\n                vec3 Ta = atm_transmittance( surfacepoint, refrac, g_atm, false );\n                vec3 outercol = I + Tc * Ta * (\n                    starfield( refrac, pixelscale_refrac ) +\n                    g_env.sunlight * max( 0., NDFdisk( cosxi, a, .5 * square( 7487. / 321226. ) ) ) * max( 0., dot( Z, g_env.L ) ) );\n\n                vec3 WX = exp2pp( -t0 * g_ocn_beta50 * 1000. );\n                vec3 WI = t0 - z0 >= 0.0001 ? W0 - ( W0 - WX ) * t0 / ( t0 - z0 ) : W0 - W0 * t0 * g_ocn_beta50 * 1000. * LN2;\n                vec3 WY = exp2pp( -t * g_ocn_beta50 * 1000. );\n                vec3 WJ = WY * t / ( t + z1 );\n                float fr = max( 0., 1. - pow( 1.6666667 - dot( M, ray.d ), 8. ) );\n                col = WX * mix( WY * ( collight + W1 * col ), outercol, fr ) + ( W0 - WI * WJ ) * g_ocn_omega * surfacelight;\n            }\n            else\n            {\n                vec3 WT = exp2pp( -t * g_ocn_beta50 * 1000. );\n                vec3 WI = ( W0 - WT * W1 ) * t / ( t + z1 - z0 );\n                col = WT * ( collight + W1 * col ) + WI * g_ocn_omega * surfacelight;\n            }\n        }\n        else\n        {\n            vec3 Ta = atm_transmittance_finite( ray.o, r, g_atm );\n            col = ( collight + col ) * Tc * Ta + I;\n        }\n    }\n    return vec4( col, t0 > 0. && ( index == -1 || t0 < t ) ? 1. : t > 0. ? t / ( 1. + t ) : 1. );\n}\n\nfloat expand_flatten( float h )\n{\n    float flevel = g_data.trn_flatten.x * g_data.radius;\n    float frange = g_data.trn_flatten.y * g_data.radius;\n    float fstrenth = g_data.trn_flatten.z;\n    float compress = ( fstrenth / 3. - fstrenth + 1. );\n    float compressed_top = flevel + frange * compress;\n    float compressed_bottom = flevel - frange * compress;\n    float expanded_top = flevel + frange;\n    float expanded_bottom = flevel - frange;\n    float minh = g_data.trn_levels.x * g_data.radius;\n    float maxh = g_data.trn_levels.y * g_data.radius;\n\n    if( h > compressed_top )\n        return ( h - compressed_top ) / ( maxh - compressed_top ) * ( maxh - expanded_top ) + expanded_top;\n    else\n        if( h < compressed_bottom )\n            return ( h - minh ) / ( compressed_bottom - minh ) * ( expanded_bottom - minh ) + minh;\n        else\n            return ( h - compressed_bottom ) / ( compressed_top - compressed_bottom ) * ( expanded_top - expanded_bottom ) + expanded_bottom;\n}\n\nfloat mapgrid_coverage( vec3 r, mat2x3 Kr, float zoom )\n{\n    vec3 north = normalize( reject( UNIT_Z, r ) );\n    vec3 east = cross( north, r );\n    float lat = degrees( atan( r.z, length( r.xy ) ) );\n    float lng = degrees( atan( r.y, r.x ) );\n    float sz = sqrt( 1. - r.z * r.z );\n    float Ku = degrees( Linfinity( north * Kr ) );\n    float Kv = degrees( Linfinity( east * Kr ) ) / sz;\n    const float n = 5.;\n    const float log2n = log2( n );\n    float levels[] = float[]( 90., 30., 5., 1., .2 );\n    int l = zoom < 1. ? 0 : zoom < 6. ? 1 : zoom < 30. ? 2 : 3;\n    float grid1 = levels[l];\n    float grid2 = levels[l + 1];\n    int m = min( l, abs( lat ) >= 90. - grid2 ? 0 :\n                    abs( lat ) >= 90. - grid1 ? 1 :\n                    abs( lat ) >= 85. ? 2 : 3 );\n    float grid1h = levels[m];\n    float grid2h = levels[m + 1];\n    float latitudes = aaa_stipple( Ku, grid1 / 2. + lat, grid1, .25 * Ku / grid1 );\n    float meridians = aaa_stipple( Kv, grid1h / 2. + lng, grid1h, .25 * Kv / grid1h );\n    float sub_latitudes = aaa_stipple( Ku, grid2 / 2. + lat, grid2, .0625 * Ku / grid2 );\n    float sub_meridians = aaa_stipple( Kv, grid2h / 2. + lng, grid2h, .0625 * Kv / grid2h );\n    float meridian_mask = aaa_interval( Ku, lat, 180. - 2. * grid2 / 5. );\n\n    return max(\n        latitudes, max(\n            meridians * meridian_mask, max(\n                sub_latitudes,\n                sub_meridians * meridian_mask ) ) );\n}\n\nfloat isocontour_coverage( float h, float Kh )\n{\n    float grid1 = 1.;\n    float grid2 = .1;\n    float grid3 = .01;\n    float super_contours = aaa_stipple( Kh, grid1 / 2. + h, grid1, min( .25, Kh / grid1 ) );\n    float contours = aaa_stipple( Kh, grid2 / 2. + h, grid2, min( .125, .5 * Kh / grid2 ) );\n    float sub_contours = aaa_stipple( Kh, grid3 / 2. + h, grid3, min( .0625, .25 * Kh / grid3 ) );\n    float result = max( super_contours, max( contours, sub_contours ) );\n    return result;\n}\n\nvec2 vr_unproject( vec3 r )\n{ return unViewport.zw * ( g_vrfocus.xy + .5 * g_vrfocus.zw * r.yz / r.x * vec2( 1, -1 ) ); }\n\nvec2 fix_fcoord_for_vr( vec2 fcoord )\n{\n    if( g_vrmode )\n    {\n        vec2 xy = vr_unproject( vec3( 1.35, -1, +iResolution.y / iResolution.x ) );\n        vec2 zw = vr_unproject( vec3( 1.35, +1, -iResolution.y / iResolution.x ) );\n        fcoord = ( fcoord - unViewport.xy - xy ) * iResolution.xy / ( zw - xy );\n    }\n    return fcoord;\n}\n\nvoid main_image_worker( out vec4 fcolor, in vec2 fcoord )\n{\n    fcolor = vec4( ZERO, 1. );\n\n#if BUFFER_RUNLEVEL >= 4\n\n    g_game = gs_load( iChannel0, ADDR_GAMESTATE );\n    g_vehicle = vs_load( iChannel0, ADDR_VEHICLE );\n    g_env = env_load( iChannel0, ADDR_LOCALENV );\n    g_ts = ts_load( iChannel0, ADDR_TSAMPLER );\n    g_atm = atm_load( iChannel0, ADDR_ATMCONTEXTS + ivec2( 1, 0 ) );\n    g_data = g_planet_data[1];\n    bool ir = ( g_game.switches & GS_IRCAM ) != 0u;\n    g_ocn_beta50 = irselect( g_data.ocn_beta50, ir );\n    g_ocn_omega = irselect( g_data.ocn_omega, ir );\n\n    // direct sun visibility and vr flag\n    if( fcoord.x < 2. && fcoord.y < 2. )\n    {\n        vec3 T =\n            atm_transmittance( g_game.campos, g_env.L, g_atm, true ) *\n            texelFetch( iChannel2, ivec2( iChannelResolution[2].xy ) - 1, 0 ).w;\n        float shadow =\n            ts_shadow_sample( g_ts, iChannel1, g_game.campos ) *\n            scene_raycast_object_shadows( Ray( g_game.campos, g_env.L ) ) *\n            atm_planet_shadow( dot( g_env.L, normalize( g_game.campos ) ), sqrt( max( 0., 1. - g_env.radius * g_env.radius / dot( g_game.campos, g_game.campos ) ) ) );\n        bool submerged = length( g_game.campos ) < g_data.radius;\n        fcolor.xyz = submerged ? ZERO : T * max( 0., 2. * shadow - 1. ) / IMG_MIPMAP_HIDE;\n        fcolor.w = float( g_vrmode );\n    }\n\n    // feed forward of text formatting data\n    else\n    if( fcoord.x < 4. && fcoord.y < 2. )\n        { fcolor = texelFetch( iChannel1, ivec2( 8, 0 ), 0 ) / IMG_MIPMAP_HIDE; }\n\n    // feed forward of text formatting data\n    else\n    if( fcoord.y >= iResolution.y - 2. )\n        fcolor = texelFetch( iChannel1, ivec2( fcoord ), 0 ) / IMG_MIPMAP_HIDE;\n\n\t// terrain map\n\telse\n    if( ( g_game.switches & GS_TRMAP ) == GS_TRMAP )\n    {\n        vec2 fc = fix_fcoord_for_vr( fcoord );\n        if( fc.x < 0. || fc.y < 0. || fc.x > iResolution.x || fc.y > iResolution.y )\n            return;\n        vec3 drdx = ZERO, drdy = ZERO;\n        vec4 r = gs_map_unproject_d( g_game, fc, iResolution.xy, drdx, drdy );\n        vec4 tsmpl = texelFetch( iChannel1, ivec2( fc ), 0 );\n        float h = tsmpl.w;\n        mat2x3 Kr = mat2x3( drdx, drdy );\n        float Kh = Linfinity( vec2( dFdx(h), dFdy(h) ) );\n        float s = degrees( acos( dot( tsmpl.xyz, r.xyz ) ) ) / 100.;\n        float Ks = Linfinity( vec2( dFdx(s), dFdy(s) ) );\n        float z = 0.;\n        float Kz = 0.;\n        float cut = 0.;\n\n        if( abs( r.w ) >= 1. )\n            return;\n        \n        tsmpl.w += g_data.radius;\n\n        vec3 col = ZERO;\n        int mode = int( ( g_game.switches & GS_MMODE_MASK ) >> GS_MMODE_SHIFT );\n        vec3 oceanI = mix( square( g_data.ocn_omega.xyz ), g_data.ocn_omega.xyz, exp2( -h * 5. / ( g_data.radius * g_data.trn_levels.x ) ) );\n        vec3 oceanT = h < 0. ? 0.95 * exp2pp( min( 0., h ) * g_data.ocn_beta50.xyz * 1000. ) : ONE;\n\n        vec3 gridcol = ZERO;\n        if( mode == GS_MAP_PHYSICAL )\n        {\n            vec3 N = tsmpl.xyz;\n            vec3 Z = r.xyz;\n            float slope = length( N / dot( N, Z ) - Z );\n            vec3 albedo = scene_surface_albedo( tsmpl.w * r.xyz, tsmpl.w * Kr, h, slope, r.z, true );\n            col = mix( oceanI, oceanT * albedo, oceanT );\n            gridcol = col.y < .5 ? ONE : ZERO;\n            cut = .125;\n        }\n        else\n        if( mode == GS_MAP_ELEVATION )\n        {\n            float e = expand_flatten( h ) / ( g_data.radius * g_data.trn_slope.x * abs( h < 0. ? g_data.trn_levels.x : g_data.trn_levels.y ) );\n            col = vec3( cos( e * 3. - PI / 2. ), cos( e * 3. ), cos( e * 3. + PI / 2. ) ) * .3 * saturate( 4. * abs( h ) ) + .4;\n            col = mix( oceanI, col, .5 + .5 * oceanT );\n            // col = vec3( pow( - .5 * h / ( data.radius * data.trn_slope.x * data.trn_levels.x ) + .5, 2.2 ) );\n            z = h;\n            Kz = Kh;\n            cut = .25;\n        }\n        else \n        if( mode == GS_MAP_SLOPE )\n        {\n            col = vec3( cos( s * 9. ), cos( s * 9. + PI * 0.6667 ), cos( s * 9. + PI * 1.3333 ) ) * .3 * saturate( 4. * s ) + .4;\n            col = mix( oceanI, col, .5 + .5 * oceanT );\n            // col = vec3( pow( max( 0., log2( tan( radians( 100. * s ) ) ) / 8. + 1. ), 2.2 ) );\n            z = max( s, Ks );\n            Kz = Ks;\n            cut = .75;\n        }\n\n        if( mode != GS_MAP_PHYSICAL )\n            col = mix( col, ZERO, isocontour_coverage( z, Kz ) );\n\n        vec3 L = normalize( r.xyz - normalize( Kr[0] ) + normalize( Kr[1] ) );\n        col = col * max( cut, 1.5 * dot( tsmpl.xyz, L ) ) * mix( COL_RODVISION, COL_SUNLIGHT.xyz, parabolstep( -.01, .01, dot( r.xyz, g_env.L ) ) );\n        col = mix( col, gridcol, mapgrid_coverage( r.xyz, Kr, g_game.camzoom ) );\n        fcolor = vec4( col, 1 );\n    }\n\n    // main image\n    else\n    {\n        // Buffer A\n        // fcolor.xyz = saturate( .25 + .125 * texelFetch( iChannel0, ivec2( fcoord / 4. ), 0 ).xyz );\n        // return;\n\n        // Buffer B\n        // fcolor.xyz = saturate( ts_unpack_normal( g_ts, texelFetch( iChannel1, ivec2( fcoord ), 0 ) ).xyz * .5 + .5 );\n        // fcolor.xyz = saturate( texelFetch( iChannel1, ivec2( fcoord ), 0 ).zzz / 16. );\n        // fcolor.xyz = saturate( ( texelFetch( iChannel1, ivec2( fcoord ), 0 ).xyz / g_data.radius - 1. ) / data.trn_levels.y );\n        // fcolor.xyz = saturate( texelFetch( iChannel1, ivec2( fcoord ), 0 ).www / ( g_data.radius * data.trn_levels.y ) );\n        // fcolor.xyz = saturate( texelFetch( iChannel1, ivec2( fcoord.x, fcoord.y / 16. + iResolution.y * 15. / 16. ), 0 ).xyz );\n        // return;\n\n        // Buffer C\n        // fcolor.xyz = texelFetch( iChannel2, ivec2( fcoord * SCN_SUBSAMPLE ), 0 ).xyz;\n        // fcolor.xyz = texelFetch( iChannel2, ivec2( fcoord * SCN_SUBSAMPLE * ATM_SUBSAMPLE_INV ), 0 ).xyz;\n        // #if WITH_ATM_BILATERAL_UPSAMPLE\n        //\tfcolor.xz = exp2( vec2( floor( fcolor.x ) / 128., fract( fcolor.x ) * 32. ) - 24. );\n        // #endif\n        // fcolor.xyz = texelFetch( iChannel2, ivec2( fcoord * SCN_SUBSAMPLE * ATM_SUBSAMPLE_INV + vec2( 0, iResolution.y / 2. ) ), 0 ).xyz;\n        // fcolor.xyz = texelFetch( iChannel2, ivec2( fcoord * SCN_SUBSAMPLE * ATM_SUBSAMPLE_INV + vec2( iResolution.x / 2., 0 ) ), 0 ).xyz;\n        // fcolor.xyz = texelFetch( iChannel2, ivec2( fcoord * SCN_SUBSAMPLE * ATM_SUBSAMPLE_INV + iResolution.xy / 2. ), 0 ).xyz;\n        // return;\n\n        vec2 uv = vec2( 0. );\n        vec3 rayorg = ZERO;\n        vec3 raydir = ZERO;\n        if( g_vrmode )\n        {\n            uv = SCN_SUBSAMPLE * ( fcoord - unViewport.xy ) / unViewport.zw;\n            vec3 cc = ( mix( mix( unCorners[0], unCorners[1], uv.x ),\n                            mix( unCorners[3], unCorners[2], uv.x ), uv.y ) - unCorners[4] ).zxy * vec3( -1, 1, -1 );\n            vec3 dir = cc * g_vrframe;\n            if( dot( dir.yz, dir.yz ) >= 1.55 / g_game.camzoom * dir.x * dir.x )\n                return;\n            dir.yz /= g_game.camzoom;\n            cc = normalize( g_vrframe * dir );\n            g_pixelscale = .25 * abs( dir.x * dFdx( dir.y / dir.x ) * dFdy( dir.z / dir.x ) );\n            uv.x /= 2.;\n            if( fcoord.x * 2. >= iResolution.x )\n                uv.x += 1.;\n            vec3 dp = unCorners[4].zxy * vec3( -1, 1, -1 ) / 1000.;\n            rayorg = g_game.campos + g_game.camframe * dp;\n            raydir = g_game.camframe * cc;\n        }\n        else\n        {\n            vec2 sc = 2. * SCN_SUBSAMPLE * fcoord / iResolution.xy - 1.;\n            if( sc.x >= 1. || sc.y >= 1. )\n                return;\n            uv = fcoord / iResolution.xy;\n            vec2 ec = sc * vec2( 1, iResolution.y / iResolution.x );\n            vec3 cc = normalize( vec3( CAM_FOCUS, barrel_distort( vec2( ec.x, -ec.y ) / g_game.camzoom, CAM_DISTORT ) ) );\n            g_pixelscale = .25 * abs( cc.x * dFdx( cc.y / cc.x ) * dFdy( cc.z / cc.x ) );\n            rayorg = g_game.campos;\n            raydir = g_game.camframe * cc;\n        }\n        vec4 col = render( Ray( rayorg, raydir ), uv );\n        if( g_vrmode )\n            col /= g_game.camzoom;\n        fcolor = clamp( col / max( 1., hmax( col ) / IMG_EXPOSURE_MAX ), 0., IMG_EXPOSURE_MAX );\n    }\n#endif // RUNLEVEL\n}\n\nvoid mainImage( out vec4 fcolor, in vec2 fcoord )\n{ main_image_worker( fcolor, fcoord ); }\n\nvoid mainVR( out vec4 fcolor, in vec2 fcoord, in vec3 _ro_dummy_, in vec3 _rd_dummy_ )\n{\n    g_vrmode = true;\n    vec3 horz = ( unCorners[1] + unCorners[2] - unCorners[0] - unCorners[3] ).zxy * vec3( -1, 1, -1 );\n    vec3 down = ( unCorners[0] + unCorners[1] - unCorners[2] - unCorners[3] ).zxy * vec3( -1, 1, -1 );\n    vec3 forw = ( unCorners[0] + unCorners[1] + unCorners[2] + unCorners[3] - 4. * unCorners[4] ).zxy * vec3( -1, 1, -1 );\n    g_vrframe[1] = normalize( horz );\n    g_vrframe[2] = normalize( down );\n    g_vrframe[0] = cross( g_vrframe[1], g_vrframe[2] );\n    vec3 cent = g_vrframe[0] * dot( forw, g_vrframe[0] ) - 2. * ( unCorners[0] - unCorners[4] ).zxy * vec3( -1, 1, -1 );\n    g_vrfocus.xy = vec2( dot( cent, g_vrframe[1] ) / dot( horz, g_vrframe[1] ), dot( cent, g_vrframe[2] ) / dot( -down, g_vrframe[2] ) );\n    g_vrfocus.zw = dot( forw, g_vrframe[0] ) / vec2( dot( horz, g_vrframe[1] ), dot( down, g_vrframe[2] ) );\n    main_image_worker( fcolor, gl_FragCoord.xy );\n}\n\n#define unViewport _unViewport_dummy_\n#define unCorners _unCorners_dummy_\n", "name": "Buffer D", "description": "", "type": "buffer"}]}