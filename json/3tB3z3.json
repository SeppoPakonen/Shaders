{"ver":"0.1","info":{"id":"3tB3z3","date":"1560380171","viewed":1550,"name":"Hilbert R1 Blue Noise","username":"paniq","description":"mapping each pixel to a hilbert curve index, then taking a value from the Roberts R1 quasirandom sequence for it.","likes":49,"published":3,"flags":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define LEVEL 15U\n#define WIDTH ( (1U << LEVEL) )\n#define AREA ( WIDTH * WIDTH )\n\nuint part1by1 (uint x) {\n    x = (x & 0x0000ffffu);\n    x = ((x ^ (x << 8u)) & 0x00ff00ffu);\n    x = ((x ^ (x << 4u)) & 0x0f0f0f0fu);\n    x = ((x ^ (x << 2u)) & 0x33333333u);\n    x = ((x ^ (x << 1u)) & 0x55555555u);\n    return x;\n}\n    \nuint pack_morton2x16(uvec2 v) {\n\treturn part1by1(v.x) | (part1by1(v.y) << 1);\n}\n\n// from https://www.shadertoy.com/view/XtGBDW\nuint HilbertIndex( uvec2 Position )\n{   \n    uvec2 Regions;\n    uint Index = 0U;\n    for( uint CurLevel = WIDTH/2U; CurLevel > 0U; CurLevel /= 2U )\n    {\n        uvec2 Region = uvec2(greaterThan((Position & uvec2(CurLevel)), uvec2(0U)));\n        Index += CurLevel * CurLevel * ( (3U * Region.x) ^ Region.y);\n        if( Region.y == 0U )\n        {\n            if( Region.x == 1U )\n            {\n                Position = uvec2(WIDTH - 1U) - Position;\n            }\n            Position.xy = Position.yx;\n        }\n    }\n    \n    return Index;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    #if 1\n    uint x = HilbertIndex( uvec2(fragCoord) ) % (1u << 17u);\n    #else\n    uint x = pack_morton2x16( uvec2(fragCoord) ) % (1u << 17u);    \n    #endif\n\n    const float phi = 2.0/(sqrt(5.0)+1.0);\n\tfloat c = fract(0.5+phi*float(x));\n    \n    if (uv.x > 0.5) {\n    \tc = step(c, uv.y);\n    }\n    \n    fragColor = vec4(vec3(c),1.0);\n}","name":"Image","description":"","type":"image"}]}