{"ver":"0.1","info":{"id":"wdByDW","date":"1586637777","viewed":155,"name":"Lava Rocks","username":"DoubleRedGaming","description":"Very hot... Beware...\nI know this looks very much something from the early 20's, just because of the bad usage of the noise function.\nIf anyone has any recommendations, please let me know!","likes":3,"published":3,"flags":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n\nfloat GetDist(vec3 p) {\n    float v = -voronoi(p.xz*0.1, 100.0);\n    v *= voronoi(p.xz*0.15*rot(3.141*0.125), 251.0);\n    v *= voronoi(p.xz*0.2*rot(3.141*0.125), 529.0);\n    v *= 0.75;\n    v += 0.5;\n    \n    float pd = smoothstep(p.y, 0.0, v);\n    \n    return pd*p.y;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-(0.5*iResolution.xy))/iResolution.y;\n    vec4 col = vec4(0.0);\n    \n    float t = iTime*0.5;\n    \n    //Raymarching camera variables\n    \n    vec3 ro = vec3(0.0, 6.0, -10.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y-0.1, 1.0));\n    rd.x += sin((uv.y*3.141*8.0)+(t*3.141))*0.02; //Heat distortion\n    float no = ((snoise(rd.xx+t)*2.0)-1.0)*0.05;\n    \n    //Raymarching origin rotation\n    \n    ro.zx *= rot((t*3.141*0.125)+3.141); //Y axis rotation\n    \n    //Raymarching direction rotation\n    \n    rd.zy *= rot(sin(t*3.141*0.5)*3.141*0.01); //X axis rotation\n    rd.xy *= rot(3.141*sin(t*3.141*0.2)*0.01); //Z axis rotation\n    rd.zx *= rot((t*3.141*0.125)+3.141); //Y axis rotation\n    \n    //Raymarch processing\n    \n    float d = RayMarch(ro, rd);\n    \n    //Raymarch hit-point\n    \n    vec3 p = ro + rd * d;\n    \n    //Diffuse lighting, (Just ambience lighting)\n    \n    vec4 dif = vec4(0.7, 0.2, 0.0, 0.0);\n    \n    //Modifying color variable\n    \n    float fog = smoothstep(25.0, MAX_DIST, d);\n    \n    col = dif*smoothstep(1.0, 0.0, pow(p.y, 0.001))*300000.0; //Color depth; The lower, the darker; The higher, the brighter. This adds a lot of detail on the color.\n    col = mix(col, vec4(0.8, 0.25, 0.1, 0.0), fog); //Add a little lovely fog effect in the background\n    \n    col.xyz += ((h22(uv.xy+t).x*2.0)-1.0)*0.05;\n    col.xyz += no*fog*2.0;\n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"mat2 rot(float r) {\n    float s = sin(r);\n    float c = cos(r);\n    return mat2(c, -s, s, c);\n}\n\nvec2 h22(vec2 p)\n{\n    vec3 a = fract(p.xyx * vec3(123.34, 234.34, 345.65));\n    a += dot(a, a + 34.45);\n    return fract(vec2(a.x * a.y, a.y * a.z));\n}\n\nfloat voronoi(vec2 uv, float t) {\n    float minDist = 100.0;\n    float cellIndex = 0.0;\n    \n    uv *= 3.0;\n\n    vec2 gv = fract(uv)-0.5;\n    vec2 id = floor(uv);\n    vec2 cid = vec2(0.0);\n\n    for(float y = -1.0; y <= 1.0; y++)\n    {\n        for(float x = -1.0; x <= 1.0; x++)\n        {\n            vec2 offs = vec2(x, y);\n\n            vec2 n = h22(id+offs);\n            vec2 p = offs+sin(n*t)*0.5;\n            float d = length(gv-p);\n\n            if(d<minDist)\n            {\n                minDist = d;\n                cid = id+offs;\n            }\n        }\n    }\n    \n    return minDist;\n}\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.211324865405187,\n                        0.366025403784439,\n                        -0.577350269189626,\n                        0.024390243902439);\n    \n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n    \n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n    \n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n    \n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n    \n    m = m*m ;\n    m = m*m ;\n    \n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    \n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n    \n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);\n    \n    return 130.0 * dot(m, g);\n}","name":"Common","description":"","type":"common"}]}