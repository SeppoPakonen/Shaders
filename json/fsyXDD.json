{"ver": "0.1", "info": {"id": "fsyXDD", "date": "1634644443", "viewed": 175, "name": "Moon Light", "username": "Marth3th", "description": "This effect formed casually when I am learning how to use FBM and noise\uff0cI think it is interesting", "likes": 8, "published": 1, "flags": 0, "usePreview": 0, "tags": [], "requires": ["imagebuf"]}, "renderpass": [{"inputs": [], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "#define MAX_STEP 100\n#define MIN_SURFACE 0.1\n#define MAX_DIST 100.\n#define SAMPLE_DEPTH 5.\n\nvec3 moonDir = normalize(vec3(0., -0.3, -1.));\nvec3 moonCol = vec3(0.7, 0.75, 0.6);\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\n\nfloat PlaneSDF(vec3 p, vec3 point, vec3 normal) {\n    float sdf = dot(p - point, normal);\n    return sdf;\n}\n\nfloat SphereSDF(vec3 p, vec4 sphere) {\n    return length(p - sphere.xyz) - sphere.w - 5. * fbm((p.xz + vec2(0., iTime)) * 0.2);\n}\n\nfloat Map(vec3 p) {\n    vec4 sphere = vec4(0., -1000., 100., 1000.);\n    return (SphereSDF(p, sphere));\n}\n/*\nvec3 GetNormal(vec3 p) {\n    float sdf = Map(p);\n    vec2 delta = vec2(0.01, 0.);\n    \n    vec3 normal = vec3(\n        Map(p + delta.xyy) - sdf\n        , Map(p + delta.yxy) - sdf\n        , Map(p + delta.yyx) - sdf\n    );\n    return normalize(normal);\n}\n\nvec3 Lighting(vec3 normal, vec3 rd) {\n    vec3 diffuse = clamp(dot(normal, -moonDir), 0., 1.) * moonCol;\n    vec3 specular = pow(clamp(dot(normalize(-(rd + moonDir)), normal), 0., 1.), 8.) \n        * moonCol;\n    return diffuse + specular;\n}\n*/\nvec3 RayMarching(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0., 0., 0);\n    float d = 0.;\n    for (int i = 0; i < MAX_STEP; i ++) {\n        float sdf = Map(ro + d * rd);\n        if (sdf < MIN_SURFACE) {\n            d += 0.5;\n            col += vec3(0.01, 0.01, 0.01) * moonCol;\n            if (sdf < MIN_SURFACE - SAMPLE_DEPTH) break;\n        } else {\n            d += sdf;\n        }\n        if (sdf > MAX_DIST) break;\n    }\n    return col;\n}\n\nvec3 Render(vec3 ro, vec3 rd) {\n    vec3 skyCol = vec3(0.5, 0.5, 0.7);\n    skyCol *= (0.5 - rd.y);\n    skyCol += pow(clamp(dot(-moonDir, rd) + 0.01, 0., 1.), 64.) * moonCol;\n    vec3 starCol = vec3(fbm(rd.xy));\n    \n    vec3 col = RayMarching(ro, rd);\n    return col + skyCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n    vec3 ro = vec3(0., 0., 0.);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n    \n    fragColor = vec4(Render(ro, rd), 1.);\n    //fragColor = vec4(fragCoord.x, fragCoord.y, 0., 1.);\n    //fragColor = vec4(rd, 1.);\n}", "name": "Image", "description": "", "type": "image"}]}