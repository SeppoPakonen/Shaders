{"ver":"0.1","info":{"id":"NtSGWm","date":"1623980544","viewed":59,"name":"Thin Lens Depth of Field","username":"Yusef28","description":"First try at some physically accurate depth of field using a unit circle to approximate a thin lens and pulling random offsets from all over it. It also allows some control of the focus distance which I've placed at 5. Lot's of camera math and tweaking.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//17.06.2021\n\n//THIN LENS DEPTH OF FIELD\n\n//This is my messy attempt at the depth of field camera as seen\n//in the \"Raytracing in a weekend\" online free book. \n//All the camera related stuff happens in main image which is the last\n//function in the program.\n\n//This is definitly more of a proof of math than a anything else.\n//It's a raytracer technique used in a raymarch so it's not very efficient\n//or accurate. \n\n//Unfortunalty the color changes after about 5 or 10 min.\n//it's like my shader just get's old and starts dying lol.\n\n//Anways I'd love to hear any thoughts anyone has on this.\n\n//UPDATES\n//~~~~~~~~~~~~~~~~~~~\n\n// - 17.06.2021 23:50 - I swapped out my adhock random functions for \n//some that work at the bit level. The result is a amore even distribution\n\n//CAMERA CONSTANTS \n//You can play around with these.\n\n//putting the smaples up to 100  doesn't make much difference\n#define SAMPLES 8 // <--- this is an Int. No decimal.\n//you can go 40 or 80 it's cool\n#define FOV 60.\n\n//These next three variabls are very finicky:\n\n//focal length is like the distance from back of camera to lens\n//so when we determin the origin of the camera, this is the z \n//for that.\n#define FOCAL_LENGTH 2.\n//this is like the scope of horizontal and vertical for the camera. \n//So it helps establish how far left, how far right, how far up, and down\n//we shoot our rays.\n#define FOCUS_DIST 8.\n//This is used to calculuate lens radius (appeutre/2.) and lens radius multiplies\n//random points found in a unit circle to get offsets for shooting\n//rays for each sample.\n#define APPETURE 0.5\n  \n//degree to radian conversion constant\n//probably don't play around with this\n#define deg_zu_rad 0.01745329\n   \n/*\n//A bunch of adhock random functions that probably suck\nfloat rnd(vec2 p)\n{\n //return fract(sin(dot(p, vec2(13.234, 72.1849))*43251.1234));   \n return fract(sin(dot(p, vec2(13.234, 72.1849)))*43251.1234);    \n}\n\nvec2 rnd22(vec2 p)\n{\n //return fract(sin(dot(p, vec2(13.234, 72.1849))*43251.1234));   \n return vec2(fract(sin(dot(p*1000., vec2(13.234, 72.1849)))*43251.1234),\n fract(sin(dot(p*1000., vec2(94.234, 22.1849)))*43251.1234));    \n}\n\nvec3 rnd33(vec3 id)\n{\n //return fract(sin(dot(p, vec2(13.234, 72.1849))*43251.1234));   \n return vec3(fract(sin(dot(id, vec3(13.234, 132., 72.1849)))*43251.1234),\n fract(sin(dot(id, vec3(53.234, 32., 12.1849)))*43251.1234),\n fract(sin(dot(id, vec3(93.234, 132., 32.1849)))*43251.1234));}\n*/\n\n\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat g_seed = 0.;\n\nfloat rnd(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)*(1.0/float(0xffffffffU));\n}\n\nvec2 rnd22(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 rnd33(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n//Just spheres with mod 5 spacing\nfloat map(vec3 p)\n{\n\n  vec3 fp = mod(p.xyz, 5.)-2.5;  \n  float balle = length(fp)-1.;\n  return balle; \n      \n}\n\n//I had to turn the step size way down\nfloat trace(vec3 ro, vec3 rd)\n{\n    float eps = 0.000001;\n    float dist;\n   \tfloat t = 0.0;\n    \n    for(int i=0; i<96; i++)\n    {\n     dist = map(ro + rd*t);\n        if(abs(dist)<eps || t > 120.)\n            break;\n        \n      t += dist*0.07;\n        \n    }\n    \n return t;   \n}\n\n\n//can find explaination in my earlier shaders\n//but it's basically finding the slope of the geometry in each dimetion\n//at that pixels ray hit point but it's more like the derivative?\n//because you retunr the differences not the actual slope.\nvec3 normal(vec3 sp)\n{\n    vec3 eps = vec3(.0001, 0.0, 0.0);\n    \n    vec3 normal = normalize (vec3( map(sp+eps) - map(sp-eps)\n                       ,map(sp+eps.yxz) - map(sp-eps.yxz)\n                       ,map(sp+eps.yzx) - map(sp-eps.yzx) ));\n    \n    \n return normal;   \n}\n\n//Shanes Ambient Occlution\nfloat calculateAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n//based on shanes lighting function but i added reflections using a cubemap\nvec3 lighting(vec3 sp, vec3 sn, vec3 lp, vec3 rd)\n{\nvec3 color;\n\n    //get id's for coloring spheres\n    vec3 fp = sp/vec3(5.);\n    vec3 id = floor(fp);\n    \n    \n    vec3 lv = lp - sp;\n    float ldist = max(length(lv), 0.001);\n    vec3 ldir = lv/ldist;\n    float atte = 1.0/(1.0 + 0.002*ldist*ldist );\n    float diff = dot(ldir, sn);\n    //I couldn't get specular to work properly on this so it's out\n    //float spec = pow(max(dot(reflect(-ldir, sn), -rd), 0.0), 10.);\n\tfloat ao = calculateAO(sp, sn);\n    vec3 refl = reflect(rd, sn);\n    float s = id.x*id.y*id.z;\n    vec3 colorRand = 0.5 + 0.5*cos(vec3(rnd33(s))+vec3(0,2,4)/5.);\n    //getting reflected color from a cubemap\n    vec4 reflColor = texture(iChannel0, refl);\n     \n    //apply color and add refl\n    color = (diff*colorRand  + reflColor.xyz*0.2 )*atte;\n    //apply ambient occlusion and return.\n return color*ao;   \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    vec2 uv = (fragCoord.xy/iResolution.xy);//*.5)*1./iResolution.y;\n \n    //ALL THE CAMERA CALCULATIONS START HERE\n    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    float aspect = iResolution.y/iResolution.x;\n    float fov = FOV;//60.;\n    float theta = fov*deg_zu_rad;\n    float focal_lange = FOCAL_LENGTH;//2.;\n    float h = tan(theta/2.)*focal_lange;\n    \n    float focus_dist = FOCUS_DIST;//5.;\n    //lens\n    \n    float appeture = APPETURE;//.6;//*(abs(sin(iTime)));\n    \n    \n    float lens_size = appeture/2.;\n    \n    float vpb = h*2.;\n    float vph = vpb*aspect;\n    \n    vec3 origin = vec3(0.,2.,0.+iTime*2.);\n    vec3 fwd = vec3(0.,0.,focal_lange);\n    vec3 H = vec3(vpb,0.,0.)*focus_dist;\n    vec3 V = vec3(0.,vph,0.)*focus_dist;\n    \n    vec3 LL = origin - H/2. - V/2. + fwd*focus_dist;\n    vec3 ro = origin;\n    vec3 rd = LL + uv.x*H + uv.y*V - origin;\n\n\n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(0, 3., 4.);// Put it a bit in front of the camera.\n\n    //ALL THE THINGS I WANT TO USE AFTER THE LOOP\n    vec3 color = vec3(0.);\n    vec3 sp,sn;\n    float t;\n    int numSamples = SAMPLES;\n    vec4 cubeColor;\n    float far;\n    \n    //THIS IS THE LOOP FOR GETTING BLUR SAMPLES\n    for(int i = 0; i < numSamples; i++){\n    \n    float s = float(base_hash(floatBitsToUint(uv)));\n    //I CALCULATE THE OFFSET HERE\n     vec2 offset = rnd22(s)*lens_size;\n     \n     //I ADD OFFSET TO RO and SUBTRACT IT FROM RD\n     t = trace(ro+vec3(offset,0.), rd-vec3(offset,0.0));\n     \n     \n     //END OF CAMERA CALCULATIONS (BUT STILL IN LOOP SO...)\n    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    \n    \n     sp = ro + rd*t;\n     sn = normal(sp);\n   \t\n     far = smoothstep(0.0, 1.0, t/10.);\n    \n    //get cube color from cubemap again this time to apply to the sky,\n    //really just so that the reflections on the ground make sense\n    \n    \n    vec3 col = lighting(sp, sn, lp, rd);//mix(stripes(ro+rd*t),vec3(t), far);\n    color += abs(col)/float(numSamples);\n    \n    }\n    \n    //background stuff\n    //getting cube colour for background\n    cubeColor = texture(iChannel0, rd);\n    vec3 sky = vec3(0.8);\n    sky += cubeColor.xyz*0.9;\n    color = mix(color, sky, far);\n    \n\t//vignette\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    \n    vig = pow(vig, 0.15); // change pow for modifying the extend of the  vignette\n\n    fragColor = vec4(color*vig,1.0);\n}","name":"Image","description":"","type":"image"}]}