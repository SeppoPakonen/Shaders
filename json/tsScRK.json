{"ver": "0.1", "info": {"id": "tsScRK", "date": "1587042330", "viewed": 429, "name": "another synthwave sunset thing", "username": "stduhpf", "description": "I was thinking of a way to make pseudo tesselation noise and i made this to illustrate it, i might not be the first one to come up with this solution.", "likes": 12, "published": 3, "flags": 0, "tags": ["sunset", "synth", "synthwave"], "requires": ["texture", "imagebuf", "texturebuf"]}, "renderpass": [{"inputs": [{"id": "4dXGzn", "filepath": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "type": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "//#define VAPORWAVE\n//#define AA 2 //The antialiasing breaks the stars, because those are just fancy aliasing\n//#define stereo\n\nfloat jTime;\n\nfloat amp(vec2 p){\n    return smoothstep(1.,8.,abs(p.x));\n    \n}\nfloat pow512(float a){\n    a*=a;//^2\n    a*=a;//^4\n    a*=a;//^8\n    a*=a;//^16\n    a*=a;//^32\n    a*=a;//^64\n    a*=a;//^128\n    a*=a;//^256\n    return a*a;\n}\nfloat pow1d5(float a){\n    return a*sqrt(a);\n}\nfloat hash(vec2 uv){\n    float a = amp(uv);\n    float w = a>0.?(1.-.4*pow512(.51+.49*sin((.02*(uv.y+.5*uv.x)-jTime)*2.))):0.;\n    return a>0.?\n        a*pow1d5(texture(iChannel0,uv/iChannelResolution[0].xy).r)*w\n        :0.;\n}\n\nvec2 trinoise(vec2 uv){\n    const float sq = sqrt(3./2.);\n    uv.x *= sq;\n    uv.y -= .5*uv.x;\n    vec2 d = fract(uv);\n    uv -= d;\n    if(dot(d,vec2(1))<1.){\n        float n1 = hash(uv);\n        float n2 = hash(uv+vec2(1,0));\n        float n3 = hash(uv+vec2(0,1));\n        float nmid = mix(n2,n3,d.y);\n        float ng = mix(n1,n3,d.y);\n        float dx = d.x/(1.-d.y);\n        return vec2(mix(ng,nmid,dx),min(min((1.-dx)*(1.-d.y),d.x),d.y));\n\t}else{\n    \tfloat n2 = hash(uv+vec2(1,0));\n        float n3 = hash(uv+vec2(0,1));\n        float n4 = hash(uv+1.);\n        float nmid = mix(n2,n3,d.y);\n        float nd = mix(n2,n4,d.y);\n        float dx = (1.-d.x)/(d.y);\n        return vec2(mix(nd,nmid,dx),min(min((1.-dx)*d.y,1.-d.x),1.-d.y));\n\t}\n    return vec2(0);\n}\n\n\nvec2 map(vec3 p){\n    vec2 n = trinoise(p.xz);\n    return vec2(p.y-2.*n.x,n.y);\n}\n\nvec3 grad(vec3 p){\n    const vec2 e = vec2(.005,0);\n    float a =map(p).x;\n    return vec3(map(p+e.xyy).x-a\n                ,map(p+e.yxy).x-a\n                ,map(p+e.yyx).x-a);\n\n}\n\nvec2 intersect(vec3 ro,vec3 rd){\n    float d =0.,h=0.;\n    for(int i = 0;i<500;i++){\n        vec3 p = ro+d*rd;\n        vec2 s = map(p);\n        h = s.x;\n        d+= h*.5;\n        if(abs(h)<.003*d)\n            return vec2(d,s.y);\n        if(d>150.|| p.y>2.) break;\n    }\n    \n    return vec2(-1);\n}\n\n\nvec3 sun(vec3 rd,vec3 ld,vec3 base){\n    \n\tfloat sun = smoothstep(.21,.2,distance(rd,ld));\n    \n    if(sun>0.){\n        float yd = (rd.y-ld.y);\n\n        float a =sin(3.1*exp(-(yd)*14.)); \n\n        sun*=smoothstep(-.8,0.,a);\n\n        base = mix(base,vec3(1.,.8,.4)*.75,sun);\n    }\n    return base;\n}\nvec3 gsky(vec3 rd,vec3 ld,bool mask){\n    float haze = exp2(-5.*(abs(rd.y)-.2*dot(rd,ld)));\n    float st = mask?pow512(texture(iChannel0,(rd.xy+vec2(300.1,100)*rd.z)*10.).r)*(1.-min(haze,1.)):0.;\n    vec3 col=clamp(mix(vec3(.4,.1,.7),vec3(.7,.1,.4),haze)+st,0.,1.);\n    return mask?sun(rd,ld,col):col;\n   \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor=vec4(0);\n    #ifdef AA\n    for(float x = 0.;x<1.;x+=1./float(AA)){\n    for(float y = 0.;y<1.;y+=1./float(AA)){\n    #else\n        const float AA=1.,x=0.,y=0.;\n    #endif\n    vec2 uv = (2.*(fragCoord+vec2(x,y))-iResolution.xy)/iResolution.x;\n\t\n    float dt = fract(texture(iChannel0,float(AA)*(fragCoord+vec2(x,y))/iChannelResolution[0].xy).r+iTime);\n    jTime = iTime-dt*iTimeDelta*.25;\n    vec3 ro = vec3(0.,1,(-2000.+jTime)*10.);\n    \n        #ifdef stereo\n            ro+=vec3(.2*(float(uv.x>0.)-.5),0.,0.);\n            uv.x=uv.x+.5*(uv.x>0.?-1.:1.);\n            uv*=2.;\n\t\t#endif\n        \n    vec3 rd = normalize(vec3(uv,.75));//vec3(uv,sqrt(1.-dot(uv,uv)));\n    \n    vec2 i = intersect(ro,rd);\n    float d = i.x;\n    \n    vec3 ld = normalize(vec3(0,.125+.05*sin(.1*jTime),1));\n\n    float fog = d>0.?exp2(-d*.14):0.;\n    vec3 sky = gsky(rd,ld,d<0.);\n    \n    vec3 p = ro+d*rd;\n    vec3 n = normalize(grad(p));\n    \n    float diff = dot(n,ld)+.1*n.y;\n    vec3 col = vec3(.1,.11,.18)*diff;\n    \n    vec3 rfd = reflect(rd,n); \n    vec3 rfcol = gsky(rfd,ld,true);\n    \n    col = mix(col,rfcol,.05+.95*pow(max(1.+dot(rd,n),0.),5.));\n    #ifdef VAPORWAVE\n    col = mix(col,vec3(.4,.5,1.),smoothstep(.05,.0,i.y));\n    col = mix(sky,col,fog);\n    col = sqrt(col);\n    #else\n    col = mix(col,vec3(.8,.1,.92),smoothstep(.05,.0,i.y));\n    col = mix(sky,col,fog);\n    //no gamma for that old cg look\n    #endif\n    fragColor += vec4(clamp(col,0.,1.),1.);\n     #ifdef AA\n    }\n    }\n    fragColor/=float(AA*AA);\n    #endif\n    \n}", "name": "Image", "description": "", "type": "image"}]}