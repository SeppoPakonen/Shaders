{"ver":"0.1","info":{"id":"td2yzm","date":"1586370220","viewed":180,"name":"Plain Seas'","username":"DoubleRedGaming","description":"Artistic way to draw a sea.","likes":6,"published":3,"flags":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n#define pi 3.141\n\nfloat GetDist(vec3 p) {\n    float v = voronoi(p.xz*0.1, (iTime*1.5)+100.0);\n    v *= voronoi(p.xz*0.15*rot(3.141*0.125), (iTime*1.952)+251.0);\n    v *= 0.75;\n    v += 0.5;\n    \n    float pd = smoothstep(p.y, 0.0, v);\n    \n    return pd*p.y;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-(0.5*iResolution.xy))/iResolution.y;\n    vec4 col = vec4(0.0);\n    \n    float t = iTime*0.5;\n    \n    //Raymarching camera variables\n    \n    vec3 ro = vec3(0.0, 6.0, -10.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y-0.1, 1.0));\n    \n    //Raymarching origin rotation\n    \n    ro.zx *= rot((t*pi*0.125)+pi); //Y axis rotation\n    \n    //Raymarching direction rotation\n    \n    rd.zy *= rot(sin(t*pi*0.5)*pi*0.01); //X axis rotation\n    rd.xy *= rot(pi*sin(t*pi*0.2)*0.01); //Z axis rotation\n    rd.zx *= rot((t*pi*0.125)+pi); //Y axis rotation\n    \n    //Raymarch processing\n    \n    float d = RayMarch(ro, rd);\n    \n    //Raymarch hit-point\n    \n    vec3 p = ro + rd * d;\n    \n    //Diffuse lighting, (Just ambience lighting)\n    \n    vec4 dif = vec4(0.2, 0.4, 0.6, 0.0);\n    \n    //Modifying color variable\n    \n    col = dif*(p.y+1.25); //Color depth; The lower, the darker; The higher, the brighter. This adds a lot of detail on the color.\n    col = mix(col, vec4(0.8, 0.9, 1.0, 0.0), smoothstep(25.0, MAX_DIST, d)); //Add a little lovely fog effect in the background\n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"mat2 rot(float r) {\n    float s = sin(r);\n    float c = cos(r);\n    return mat2(c, -s, s, c);\n}\n\nvec2 h22(vec2 p)\n{\n    vec3 a = fract(p.xyx * vec3(123.34, 234.34, 345.65));\n    a += dot(a, a + 34.45);\n    return fract(vec2(a.x * a.y, a.y * a.z));\n}\n\nfloat voronoi(vec2 uv, float t) {\n    float minDist = 100.0;\n    float cellIndex = 0.0;\n    \n    uv *= 3.0;\n\n    vec2 gv = fract(uv)-0.5;\n    vec2 id = floor(uv);\n    vec2 cid = vec2(0.0);\n\n    for(float y = -1.0; y <= 1.0; y++)\n    {\n        for(float x = -1.0; x <= 1.0; x++)\n        {\n            vec2 offs = vec2(x, y);\n\n            vec2 n = h22(id+offs);\n            vec2 p = offs+sin(n*t)*0.5;\n            float d = length(gv-p);\n\n            if(d<minDist)\n            {\n                minDist = d;\n                cid = id+offs;\n            }\n        }\n    }\n    \n    return minDist;\n}\n\nfloat d3voronoi(vec3 p, float t) {\n    float vxy = voronoi(p.xy, t);\n    float vzx = voronoi(p.zx, t);\n    float vyz = voronoi(p.yz, t);\n    return (vxy + vzx + vyz) / 3.0;\n}","name":"Common","description":"","type":"common"}]}