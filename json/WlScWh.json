{"ver":"0.1","info":{"id":"WlScWh","date":"1595530948","viewed":49,"name":"EarthBound Coffee Break","username":"MakiXx","description":"https://www.youtube.com/watch?v=QTsHiAzWweU","likes":2,"published":1,"flags":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Cellular noise (\"Worley noise\") in 3D in GLSL.\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n\n// Permutation polynomial: (34x^2 + x) mod 289\nvec4 permute(vec4 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\nvec3 permute(vec3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\n// Cellular noise, returning F1 and F2 in a vec2.\n// Speeded up by using 2x2x2 search window instead of 3x3x3,\n// at the expense of some pattern artifacts.\n// F2 is often wrong and has sharp discontinuities.\n// If you need a good F2, use the slower 3x3x3 version.\nvec2 cellular2x2x2(vec3 P) {\n\t#define K 0.142857142857 // 1/7\n\t#define Ko 0.428571428571 // 1/2-K/2\n\t#define K2 0.020408163265306 // 1/(7*7)\n\t#define Kz 0.166666666667 // 1/6\n\t#define Kzo 0.416666666667 // 1/2-1/6*2\n\t#define jitter 0.8 // smaller jitter gives less errors in F2\n\tvec3 Pi = mod(floor(P), 289.0);\n \tvec3 Pf = fract(P);\n\tvec4 Pfx = Pf.x + vec4(0.0, -1.0, 0.0, -1.0);\n\tvec4 Pfy = Pf.y + vec4(0.0, 0.0, -1.0, -1.0);\n\tvec4 p = permute(Pi.x + vec4(0.0, 1.0, 0.0, 1.0));\n\tp = permute(p + Pi.y + vec4(0.0, 0.0, 1.0, 1.0));\n\tvec4 p1 = permute(p + Pi.z); // z+0\n\tvec4 p2 = permute(p + Pi.z + vec4(1.0)); // z+1\n\tvec4 ox1 = fract(p1*K) - Ko;\n\tvec4 oy1 = mod(floor(p1*K), 7.0)*K - Ko;\n\tvec4 oz1 = floor(p1*K2)*Kz - Kzo; // p1 < 289 guaranteed\n\tvec4 ox2 = fract(p2*K) - Ko;\n\tvec4 oy2 = mod(floor(p2*K), 7.0)*K - Ko;\n\tvec4 oz2 = floor(p2*K2)*Kz - Kzo;\n\tvec4 dx1 = Pfx + jitter*ox1;\n\tvec4 dy1 = Pfy + jitter*oy1;\n\tvec4 dz1 = Pf.z + jitter*oz1;\n\tvec4 dx2 = Pfx + jitter*ox2;\n\tvec4 dy2 = Pfy + jitter*oy2;\n\tvec4 dz2 = Pf.z - 1.0 + jitter*oz2;\n\tvec4 d1 = dx1 * dx1 + dy1 * dy1 + dz1 * dz1; // z+0\n\tvec4 d2 = dx2 * dx2 + dy2 * dy2 + dz2 * dz2; // z+1\n\n\t// Sort out the two smallest distances (F1, F2)\n#if 0\n\t// Cheat and sort out only F1\n\td1 = min(d1, d2);\n\td1.xy = min(d1.xy, d1.wz);\n\td1.x = min(d1.x, d1.y);\n\treturn sqrt(d1.xx);\n#else\n\t// Do it right and sort out both F1 and F2\n\tvec4 d = min(d1,d2); // F1 is now in d\n\td2 = max(d1,d2); // Make sure we keep all candidates for F2\n\td.xy = (d.x < d.y) ? d.xy : d.yx; // Swap smallest to d.x\n\td.xz = (d.x < d.z) ? d.xz : d.zx;\n\td.xw = (d.x < d.w) ? d.xw : d.wx; // F1 is now in d.x\n\td.yzw = min(d.yzw, d2.yzw); // F2 now not in d2.yzw\n\td.y = min(d.y, d.z); // nor in d.z\n\td.y = min(d.y, d.w); // nor in d.w\n\td.y = min(d.y, d2.x); // F2 is now in d.y\n\treturn sqrt(d.xy); // F1 and F2\n#endif\n}\n\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat noise(float p){\n\tfloat fl = floor(p);\n  float fc = fract(p);\n\treturn mix(rand(fl), rand(fl + 1.0), fc);\n}\n\n// Copyright (c) 2020 Maki. All rights reserved.\n\n// precision mediump float;\n\nvec2 wobbly(vec2 uv, float speed, float repetition, float amount, float offset) {\n    return vec2(\n        uv.x,\n        uv.y + sin(uv.y * repetition + (iTime+offset) * speed) / amount\n    );\n}\n\nfloat bubbles(vec2 uv, float offset, float direction) {\n\tfloat zoom = 6.0;\n\n    uv*=zoom;\n\n    uv = wobbly(uv, 0.8, 0.17*zoom, 0.2*zoom, offset);\n    uv.x -= iTime * 0.3 * direction;\n    uv.y -= iTime * 0.8;\n\n\tvec2 F = cellular2x2x2(\n\t\tvec3(\n\t\t\tuv,\n\t\t\t(iTime + offset) * 0.2\n\t\t)\n\t);\n\n\tfloat maxSs = 0.33;\n\tfloat minSs = maxSs - 0.0001;\n\n\tfloat _size = 0.0;\n\tfloat ringVisibleWidth = 0.02;\n\tfloat ringInvisibleWidth = 0.045;\n\n\tfloat final = 1.0 - smoothstep(minSs, maxSs, F.x);\n\n\t_size += ringVisibleWidth;\n\tfinal -= 1.0 - smoothstep(minSs-_size, maxSs-_size, F.x);\n\t\n\tfor (int i=0; i<3; i++) {\n\t\t_size += ringInvisibleWidth;\n\t\tfinal += 1.0 - smoothstep(minSs-_size, maxSs-_size, F.x);\n\n\t\t_size += ringVisibleWidth;\n\t\tfinal -= 1.0 - smoothstep(minSs-_size, maxSs-_size, F.x);\n\t}\n\n\treturn clamp(final, 0.0, 1.0);\n}\n\nvec2 pixelateUV(vec2 uv, float amount) {\n\treturn floor(uv * amount) / amount;\n}\n\n#define colorBg vec3(1.0, 47.0, 113.0) / 255.0\n#define colorBlue vec3(8.0, 48.0, 170.0)/255.0\n#define colorGreen vec3(2.0, 87.0, 53.0)/255.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = pixelateUV(uv, 200.0);\n\n    float blueBubbles = bubbles(uv, 11512.11, 1.0);\n\tfloat blueOpacity = smoothstep(0.2, 0.6, noise((iTime + 11512.11) * 1.0));\n\tfloat blueCombined = clamp(blueBubbles * blueOpacity, 0.0, 1.0);\n\t\n    float greenBubbles = bubbles(uv, 82351.93, -1.0);\n\tfloat greenOpacity = smoothstep(0.2, 0.6, noise((iTime + 82351.93) * 1.0));\n\tfloat greenCombined = clamp(greenBubbles * greenOpacity, 0.0, 1.0);\n\t\n\tvec3 color = mix(\n\t\tmix(\n\t\t\tcolorBg, // a\n\t\t\tcolorBlue, // b\n\t\t\tblueCombined // alpha\n\t\t), // a\n\t\tcolorGreen, // b\n\t\tgreenCombined // alpha\n\t);\n\n\tfragColor = vec4(vec3(color), 1.0);\n}","name":"Image","description":"","type":"image"}]}