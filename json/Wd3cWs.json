{"ver":"0.1","info":{"id":"Wd3cWs","date":"1601947436","viewed":105,"name":"Inktober 2020 | 4 : Radio","username":"pjkarlik","description":"[url]https://inktober.com/rules[/url]","likes":3,"published":3,"flags":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R\t\t\tiResolution\n#define M\t\t\tiMouse\n#define T\t\t\tiTime\n#define PI          3.1415926\n#define PI2         6.2831853\n\n#define MINDIST     .001\n#define MAXDIST     75.\n\n#define r2(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define hash(a, b) fract(sin(a*1.2664745 + b*.9560333 + 3.) * 14958.5453)\n\n/**\n    \u25aa   \u2590 \u2584 \u2584 \u2022\u2584 \u2584\u2584\u2584\u2584\u2584      \u2584\u2584\u2584\u2584\u00b7 \u2584\u2584\u2584 .\u2584\u2584\u2584  \n    \u2588\u2588 \u2022\u2588\u258c\u2590\u2588\u2588\u258c\u2584\u258c\u25aa\u2022\u2588\u2588  \u25aa     \u2590\u2588 \u2580\u2588\u25aa\u2580\u2584.\u2580\u00b7\u2580\u2584 \u2588\u00b7\n    \u2590\u2588\u00b7\u2590\u2588\u2590\u2590\u258c\u2590\u2580\u2580\u2584\u00b7 \u2590\u2588.\u25aa \u2584\u2588\u2580\u2584 \u2590\u2588\u2580\u2580\u2588\u2584\u2590\u2580\u2580\u25aa\u2584\u2590\u2580\u2580\u2584 \n    \u2590\u2588\u258c\u2588\u2588\u2590\u2588\u258c\u2590\u2588.\u2588\u258c \u2590\u2588\u258c\u00b7\u2590\u2588\u258c.\u2590\u258c\u2588\u2588\u2584\u25aa\u2590\u2588\u2590\u2588\u2584\u2584\u258c\u2590\u2588\u2022\u2588\u258c\n    \u2580\u2580\u2580\u2580\u2580 \u2588\u25aa\u00b7\u2580  \u2580 \u2580\u2580\u2580  \u2580\u2588\u2584\u2580\u25aa\u00b7\u2580\u2580\u2580\u2580  \u2580\u2580\u2580 .\u2580  \u2580\n\n\t4 | Radio\n\n\tLimiting myself to one or so hour and mostly\n\tfrom scratch except for some #defines and \n\thelper functions. \n\n\n*/\n\nvec3 getMouse(vec3 ro) {\n    float x = M.xy == vec2(0) ? 0. : -(M.y/R.y * 1. - .5) * PI;\n    float y = M.xy == vec2(0) ? 0. : (M.x/R.x * 1. - .5) * PI;\n    ro.zy *=r2(x);\n    ro.xz *=r2(y);\n\treturn ro;   \n}\n// @iq \n// https://iquilezles.org/www/articles/palettes/palettes.htm\nvec3 getHue(float t){ \n    vec3 c = vec3(.15, .17, .8),\n         d = vec3(.675,.25, .5),\n         a = vec3(.45),\n         b = vec3(.25);\n    \n    return a + b*cos( PI2*(c*t+d) ); \n}\nfloat ga1,ga2,ga3,ga4,ga5,ga6,idz;\nmat2 rt;\n\nvec2 map(vec3 p) {\n\tvec2 res = vec2(100.,-1.);\n    \n    float d2 = p.y + 1.;\n    if(d2<res.x) res = vec2(d2,1.);\n    \n    vec3 q = p-vec3(0,0,-4.);\n   // pMod(q.z,3.);\n    q.xz*=rt;\n    float id = pModPolar(q.xz,10.);\n\tidz=id;\n    if(mod(id,2.)<1.){\n      q.y -= ga1+ga2+ga3;  \n    } else {\n      q.y -= ga4+ga5+ga3;  \n    }\n\n    q.x -= 6.25;\n    \n    float d = fBox(q,vec3(2.75,1.,.25));\n    d = max(d,-fBox(q-vec3(0,0,.25),vec3(.8,.6,.1)));\n    d = max(d,-fBox(q-vec3(0,.8,.25),vec3(.55,.1,.08)));\n    \n    q.x = abs(q.x);\n    d = max(d,-sdCap(q.xzy-vec3(2.5,.25,.8),.15,.11));\n    d = max(d,-sdCap(q.xzy-vec3(1.8,.25,0.),.8,.15));\n\tif(d<res.x) res = vec2(d,2.);\n    \n    //buttons\n    float bt = min(\n        fBox(q-vec3(.1,-.75,.2+(ga1*.1)),vec3(.075,.1,.1)),\n        fBox(q-vec3(.3,-.75,.2+(ga2*.1)),vec3(.075,.1,.1))\n    );\n\tfloat bd = min(\n    \tfBox(q-vec3(.5,-.75,.2+(ga3*.1)),vec3(.075,.1,.1)),\n    \tfBox(q-vec3(.7,-.75,.2+(ga4*.1)),vec3(.075,.1,.1))\n   \t);\n    bt=min(bd,bt);\n    //if(bt<res.x) res = vec2(bt,3.);\n    \n    //speakers\n\td = fCircle(q.xzy-vec3(1.8,.25,0.),.8)-.05;\n    d = min(fCircle(q.xzy-vec3(2.5,.25,.8),.15)-.03,d);\n    d = min(sdCap(q.xzy-vec3(.76,.2,.8),.12,.12),d);\n    d=min(bt,d);\n    if(d<res.x) res = vec2(d,1.);\n\n    return res;\n}\n\nvec2 marcher(vec3 ro, vec3 rd, int maxsteps) {\n\tfloat d = 0.;\n    float m = -1.;\n    for(int i=0;i<maxsteps;i++){\n    \tvec2 t = map(ro + rd * d);\n        if(abs(t.x)<.0001||d>100.) break;\n        d += t.x*.9;\n        m  = t.y;\n    }\n\treturn vec2(d,m);\n}\n\n// Tetrahedron technique @iq\n// https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 getNormal(vec3 p, float t){\n    float e = t*MINDIST;\n    vec2 h = vec2(1.,-1.)*.5773;\n    return normalize( h.xyy*map( p + h.xyy*e).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e).x );/**\n    t *= .0002;\n    vec2 e = vec2(t,0.);\n    vec3 n = vec3(\n        map(p+e.xyy).x-map(p-e.xyy).x,\n        map(p+e.yxy).x-map(p-e.yxy).x,\n        map(p+e.yyx).x-map(p-e.yyx).x\n    );\n    return normalize(n); */\n\n}\n\n//camera setup\nvec3 camera(vec3 lp, vec3 ro, vec2 uv) {\n    vec3 f=normalize(lp-ro),//camera forward\n         r=normalize(cross(vec3(0,1,0),f)),//camera right\n         u=normalize(cross(f,r)),//camera up\n         c=ro+f*.75,//zoom\n         i=c+uv.x*r+uv.y*u,//screen coords\n         rd=i-ro;//ray direction\n    return rd;\n}\n\nfloat getDiff(vec3 p, vec3 n, vec3 lpos) {\n    vec3 l = normalize(lpos-p);\n    float dif = clamp(dot(n,l),0. , 1.);\n    \n    float shadow = marcher(p + n * MINDIST * 2., l, 92).x;\n    if(shadow < length(p -  lpos)) dif *= .2;\n \n    return dif; \n}\n\n//@Shane low cost AO\nfloat calcAO(in vec3 p, in vec3 n){\n    float sca = 2., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n        float hr = float(i + 1)*.16/5.; \n        // map(pos/dont record hit point)\n        float d = map(p + n*hr).x;\n        occ += (hr - d)*sca;\n        sca *= .7;\n        // Deliberately redundant line \n        // that may or may not stop the \n        // compiler from unrolling.\n        if(sca>1e5) break;\n    }\n    return clamp(1. - occ, 0., 1.);\n}\n\nvec3 getStripes(vec2 uv){\n    uv.x+=T*1.5;\n\n    uv.y -= tan(radians(45.)) * uv.x;\n    float sd = mod(floor(uv.y * 2.5), 2.);\n    vec3 background = (sd<1.) ? vec3(.1) : vec3(.125);\n    return background;\n}\n\nvec3 getColor(float m) {\n    vec3 h = vec3(.75);\n   \tif(m != 1.) h = getHue(idz);\n    \n    return h;\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    rt = r2(T*.3);\n\t// time movments\n    float tf = mod(T, 14.);\n    // move x steps in rotation\n    float t1 = linearstep(0.0, 1.0, tf);\n    float t2 = linearstep(3.0, 4.0, tf);\n    float a1 = easeInCubic(t1);\n    float a2 = easeOutCubic(t2);\n    \n    float t3 = linearstep(5.0, 6.0, tf);\n    float t4 = linearstep(7.0, 8.0, tf);\n    float a3 = easeInCubic(t3);\n    float a4 = easeOutCubic(t4);\n    \n    float t5 = linearstep(10.0, 11.0, tf);\n    float t6 = linearstep(12.0, 13.0, tf);\n    float a5 = easeInCubic(t5);\n    float a6 = easeOutCubic(t6);\n    \n    ga1 = (a1-a2);\n    ga2 = (a2-a3);\n    ga3 = (a3-a4);\n    ga4 = (a4-a5);\n    ga5 = (a5-a6);\n    ga6 = (a6-a1);\n    \n    // pixel screen coordinates\n    vec2 uv = (F.xy - R.xy*0.5)/R.y;\n    vec3 C = vec3(0.);\n    vec3 FC = vec3(.02);\n\n    vec3 lp = vec3(0.,0.,0.);\n    vec3 ro = vec3(0.,4.0,7.5);\n\t//ro = getMouse(ro);\n   \t\n    vec3 rd = camera(lp,ro,uv);\n\n    vec2 t = marcher(ro,rd, 128);\n    float d = t.x;\n\n    if(d<MAXDIST){\n    \tvec3 p = ro + rd * d;\n        vec3 n = getNormal(p,d);\n\n        vec3 lpos  = vec3(-2.0,5., 5.3); \n \t\tvec3 lpos2  = vec3(2.5,6., -5.3); \n    \tfloat dif = getDiff(p,n,lpos);\n        \t  dif+= getDiff(p,n,lpos2);\n  \t\tfloat ao = calcAO(p, n);\n        vec3 h = getColor(t.y);\n        C += dif*h*ao;\n\n        vec3 rr=reflect(rd,n); \n        vec2 tr = marcher(p+n*.003,rr,128);\n  \n        if(tr.x<MAXDIST){\n            p += rr*tr.x;\n            n = getNormal(p,tr.x);\n            dif = getDiff(p,n,lpos);\n            dif+= getDiff(p,n,lpos2);\n            h = getColor(tr.y);\n            C += dif*h;\n        } \n    }\n  \n    C = mix( C, vec3(.3)*getStripes(uv*8.), 1.-exp(-0.0003*t.x*t.x*t.x));\n    O = vec4(pow(C, vec3(0.4545)),1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI          3.1415926\n#define r2(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n//http://mercury.sexy/hg_sdf/\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\treturn max(v.x, v.y);\t\t\t\t\t\t}\nfloat vmax(vec3 v) {\treturn max(max(v.x, v.y), v.z);\t\t\t\t}\n\n// Repeat space along one axis.\nfloat pMod(inout float p, float size) {\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;\n}\n// Repeat around the origin by a fixed angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = 2.*PI/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    float r = length(p);\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if (abs(c) >= (repetitions/2.)) c = abs(c);\n    return c;\n}\n\n// A circle line. Can also be used to make a torus by subtracting the smaller radius of the torus.\nfloat fCircle(vec3 p, float r) {\n\tfloat l = length(p.xz) - r;\n\treturn length(vec2(p.y, l));\n}\n//@iq\nfloat sdCap( vec3 p, float h, float r ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n// Book Of Shaders - timing functions\nfloat linearstep(float begin, float end, float t) {\n    return clamp((t - begin) / (end - begin), 0.0, 1.0);\n}\n\nfloat easeOutCubic(float t) {\n    return (t = t - 1.0) * t * t + 1.0;\n}\n\nfloat easeInCubic(float t) {\n    return t * t * t;\n}","name":"Common","description":"","type":"common"}]}