{"ver": "0.1", "info": {"id": "3dKcDw", "date": "1603059994", "viewed": 2079, "name": "Juicy Fruit Truchet", "username": "pjkarlik", "description": "Reversion after factoring out some things from my multi pass attempt - runs pretty smooth now - little update to the colors too!", "likes": 21, "published": 3, "flags": 0, "usePreview": 0, "tags": ["tile"], "requires": ["imagebuf"]}, "renderpass": [{"inputs": [], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "/**\n\tSingle Pass Truchet Pattern | @pjkarlik\n\n\tDoing a simple 2d Truchet tile pattern using\n\ta single pass map and some tricks for material\n\treflections. \n\n\tMy original version\n\thttps://www.shadertoy.com/view/3sycWm\n\t\n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n#define PI          3.1415926535\n#define PI2         6.2831853070\n\n#define MAX_DIST    20.\n#define MIN_DIST    .0002\n#define SCALE 1.15\n\n#define r2(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define hue(a) .45 + .45 * cos(PI2* a * vec3(1.,.15,.25));\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\nvoid getMouse( inout vec3 p ) {\n    float x = M.xy == vec2(0) ? 0. : -(M.y/R.y * .25 - .125) * PI;\n    float y = M.xy == vec2(0) ? 0. : (M.x/R.x * .25 - .125) * PI;\n    p.zy *=r2(x);\n    p.xz *=r2(y);   \n}\n\n//http://mercury.sexy/hg_sdf/\nfloat vmax(vec3 v) {    return max(max(v.x, v.y), v.z);     }\nfloat fBox(vec3 p, vec3 b, float r) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)))-r;\n}\n//@iq\nmat2 trs;// - with added precal\nfloat sdTorus( vec3 p, vec2 t, float a ) {\n  if(a>0.){p.xy *= trs;p.yz *= trs;}\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\n// globals\nvec3 shp,fhp;\nvec2 sip,bid;\nfloat thsh;\n\nconst float size = 1./SCALE;\nconst float hlf = size/2.;\n\nvec2 map(vec3 q3){\n    vec2 res = vec2(1000.,0.);\n\n    q3.x -= T*.35;\n\n    float d = 1e5, t = 1e5;\n    vec2 qid=floor((q3.xy+hlf)/size);\n\n    vec3 qm = vec3(\n        mod(q3.x+hlf,size)-hlf,\n        mod(q3.y+hlf,size)-hlf,\n        q3.z\n    );\n\n    q3.z+=size;\n    vec3 qb = vec3(\n        mod(q3.x+hlf,size)-hlf,\n        mod(q3.y+hlf,size)-hlf,\n        q3.z\n    );\n\n    float ht = hash21(qid); \n    vec3 bm = qm;\n    // build box parts\n    float f = length(bm)-(hlf*1.25);\n    float b = fBox(bm,vec3(hlf),.012);\n    float c = fBox(bm,vec3(hlf)*.93,.012);\n    float di = ht > .28 ? max(c,-b) : max(c,-f);\n\n    float c2 = fBox(qb,vec3(hlf)*.93,.012);\n\n    di=min(c2,di);\n    // box\n    if(di<d) {\n        d = di;\n        sip = qid;\n        fhp = bm;\n        thsh = ht;\n    }\n\n    // truchet build parts\n    float thx = (.115+.1*sin(q3.y*1.05) ) *size;\n    if(ht>.5) qm.x *= -1.;\n\n    float ti = min(\n      sdTorus(qm-vec3(hlf,hlf,0),vec2(hlf,thx),0.),\n      sdTorus(qm-vec3(-hlf,-hlf,0),vec2(hlf,thx),0.)\n    );\n\n    // truchet\n    if(ti<t) {\n        t = ti;\n        sip = qid;\n        shp = qm;\n        thsh = ht;\n    }\n\n    if(d<res.x) res = vec2(d,1.);\n    if(t<res.x) res = vec2(t,2.);\n    return res;\n}\n\n// Tetrahedron technique @iq\n// https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 getNormal(vec3 p, float t){\n    // method to prevent compiler inlining map\n    float h = t * MIN_DIST;\n    #define ZERO (min(iFrame,0))\n    vec3 n = vec3(0.0);\n    for(int i=ZERO; i<4; i++) {\n        vec3 e = 0.5773*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.);\n        n += e*map(p+e*h).x;\n    }\n    return normalize(n);\n    //original tetrahedron normal\n    //float e = t*MIN_DIST;\n    //vec2 h = vec2(1.,-1.)*.5773;\n    //return normalize( h.xyy*map( p + h.xyy*e).x + \n\t//\t\t\t\t  h.yyx*map( p + h.yyx*e).x + \n\t//\t\t\t\t  h.yxy*map( p + h.yxy*e).x + \n\t// \t\t\t\t  h.xxx*map( p + h.xxx*e).x );\n}\n\nvec2 marcher(vec3 ro, vec3 rd, int maxsteps) {\n    float d = 0.;\n    float m = -1.;\n    for(int i=0;i<maxsteps;i++){\n        vec2 t = map(ro + rd * d);\n        if(abs(t.x)<d*MIN_DIST||d>MAX_DIST) break;\n        d += t.x*.75;\n        m  = t.y;\n    }\n    return vec2(d,m);\n}\n\nfloat getDiff(vec3 p, vec3 n, vec3 lpos) {\n    vec3 l = normalize(lpos-p);\n    float dif = clamp(dot(n,l),.1 , 1.);\n    float shadow = marcher(p + n * .01, l, 84).x;\n    if(shadow < length(p -  lpos)) dif *= .25;\n    return dif;\n}\n\nvec3 camera(vec3 lp, vec3 ro, vec2 uv) {\n    vec3 cf = normalize(lp - ro),\n         cr = normalize(cross(vec3(0,1,0),cf)),\n         cu = normalize(cross(cf,cr)),\n         c  = ro + cf *.85,\n         i  = c + uv.x * cr + uv.y * cu,\n         rd = i - ro;\n    return rd;\n}\n\nvec3 thp,ghp;\nvec2 tip,fid;\nfloat hsh;\n\nvec3 getColor(float m, vec3 p, vec3 n) {\n    vec3 h = vec3(.5);      \n    if(m==1.) {\n        h = .6-vec3(hsh*.75);\n    }\n    if(m==2.) {    \n        // strip patterns..\n        thp/=1./SCALE;\n        float dir = mod(tip.x + tip.y,2.) * 2. - 1.;  \n\n        vec2 cUv = thp.xy-sign(thp.x+thp.y+.001)*.5;\n        float angle = atan(cUv.x, cUv.y);\n        float a = sin( dir * angle * 6. + iTime * 2.25);\n        a = abs(a)-.45;a = abs(a)-.35;\n        vec3 nz = hue((p.x+(T*.12))*.25);\n        h = mix(nz, vec3(1), smoothstep(.01, .02, a));  \n    }\n    \n    return h;\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    // precal\n    trs = r2(PI*4.5);\n    // Normalized coordinates (from -1 to 1)\n    vec2 uv = (2.*F.xy-iResolution.xy)/max(iResolution.x,iResolution.y);\n    vec3 C = vec3(0.);\n    vec3 FC = vec3(.3+(uv.y*.3));\n    vec3 lp = vec3(0.,0.,0.),\n         ro = vec3(0.,0.,2.75);\n         getMouse(ro);\n\n    vec3 rd = camera(lp,ro,uv);\n    vec2 t = marcher(ro,rd, 128);\n    // save all globals\n    thp = shp;\n    ghp = fhp;\n    tip = sip;\n    hsh = thsh;\n\n    if(t.x<MAX_DIST){\n        vec3 p = ro + rd * t.x;\n        vec3 n = getNormal(p, t.x);\n        vec3 lpos = vec3(0.,3.,6.);\n        float diff = getDiff(p, n, lpos);\n        vec3 h = getColor(t.y, p, n);\n        C+=diff * h;\n        \n        // reflection\n        // if material && hue not black \n        if(h.x<.9999 &&h.y<.9999 &&h.z<.9999){\n            vec3 rr=reflect(rd,n); \n            vec2 tr = marcher(p ,rr, 98);\n            thp = shp;\n            ghp = fhp;\n            tip = sip;\n            hsh = thsh;\n            \n            if(tr.x<MAX_DIST){\n                p += rr*tr.x;\n                n = getNormal(p,tr.x);\n                diff = getDiff(p,n,lpos);\n                h = getColor(tr.y, p, n);\n                C+=diff * h;\n                \n            } else {\n                C += FC;\n            }\n        } \n        \n    } \n    C = mix( C, FC, 1.-exp(-.0015*t.x*t.x*t.x));\n    // Output to screen\n    O = vec4(C,1.0);\n}", "name": "Image", "description": "", "type": "image"}]}