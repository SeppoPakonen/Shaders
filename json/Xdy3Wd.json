{"ver": "0.1", "info": {"id": "Xdy3Wd", "date": "1457044164", "viewed": 163, "name": "portal kinda", "username": "dine909", "description": "use Z && X to pop portals - need to fix gravity on player, but player and objects can currently pass portals... \n\nran out of time - if anyone wants to continue, feel free", "likes": 0, "published": 1, "flags": 48, "tags": ["portal"], "requires": ["texture", "texturebuf", "keyboardbuf", "imagebuf"]}, "renderpass": [{"inputs": [{"id": "4dXGR8", "filepath": "/media/previz/buffer00.png", "previewfilepath": "/media/previz/buffer00.png", "type": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "XsXGR8", "filepath": "/media/previz/buffer01.png", "previewfilepath": "/media/previz/buffer01.png", "type": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "4sXGR8", "filepath": "/media/previz/buffer02.png", "previewfilepath": "/media/previz/buffer02.png", "type": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "//Shit Portal by dine909\n#define IF_EQ(a_,b_) step(abs(a_-b_),0.)\n#define IF_NEQ(a_,b_) (1.-step(abs(a_-b_),0.))\n#define IF_LT(a_,b_) step(a_-b_,0.)\n#define IF_GT(a_,b_) step(b_-a_,0.)\n#define IS_VAL(_val) (isInside(fragCoord,_val)>0.)\nfloat antiAlias(float x) {return (x-(1.0-2.0/iResolution.y))*(iResolution.y/2.0);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy) / iResolution.xy;\n\tvec2 ar = vec2(iResolution.x/iResolution.y,1.);\n\tvec3 col=texture(iChannel1,uv).rgb;\n    col*=clamp((.7/inversesqrt(2.4-distance(vec2(0.5),uv))),0.,1.);\n\n    float d=1.018-distance(uv*ar,vec2(0.5)*ar);\n\td=min(1.02-distance(uv*ar,vec2(0.5)*ar),2.-d);\n    \n    float aares=clamp(antiAlias(d),0.,1.);    \n\n    \n    \tvec3 colDEBUG=texture(iChannel2,uv).rgb;\n\n    col=mix(col,vec3(1.),aares*0.3);\n //   col=mix(col,texture(iChannel0,uv/8.).rgb,step(uv.y,0.1));\n//    col=mix(col,texture(iChannel1,uv/8.).rgb,step(uv.y,0.1));\n    col+=colDEBUG;\n\tfragColor = vec4(col,1.);\n}", "name": "Image", "description": "", "type": "image"}, {"inputs": [{"id": "4dXGRr", "filepath": "/presets/tex00.jpg", "previewfilepath": "/presets/tex00.jpg", "type": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "4dXGR8", "filepath": "/media/previz/buffer00.png", "previewfilepath": "/media/previz/buffer00.png", "type": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "XsXGR8", "filepath": "/media/previz/buffer01.png", "previewfilepath": "/media/previz/buffer01.png", "type": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dXGR8", "channel": 0}], "code": "#define TIMEBASE iTimeDelta\n\n#define PI 3.14159265359\n#define BALLS 2\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nfloat isInside( vec2 p, vec4 c ) { vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y); }\n\nconst vec2 _vPos \t= vec2(0.,0.);\nconst vec2 _qRot \t= vec2(1.,0.);\nconst vec2 _vHed \t= vec2(2.,0.);\nconst vec2 _vMou \t= vec2(3.,0.);\nconst vec2 _vTim \t= vec2(4.,0.);\nconst vec2 _vP1 \t= vec2(5.,0.);\nconst vec2 _qP1 \t= vec2(6.,0.);\nconst vec2 _vP2 \t= vec2(7.,0.);\nconst vec2 _qP2 \t= vec2(8.,0.);\n\nconst vec2 _vHit \t= vec2(0.,0.);\nconst vec2 _vHitNor\t= vec2(1.,0.);\nconst vec2 _vHitMat\t= vec2(2.,0.);\n\nconst vec2 _bBody \t= vec2(20.,0.);\n\n\nconst float KEY_SPACE = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\nconst float KEY_R     = 82.5/256.0;\n\n#define IF_EQ(a_,b_) step(abs(a_-b_),0.)\n#define IF_NEQ(a_,b_) (1.-step(abs(a_-b_),0.))\n#define IF_LT(a_,b_) step(a_-b_,0.)\n#define IF_GT(a_,b_) step(b_-a_,0.)\n#define IS_VAL(_val) (isInside(fragCoord,_val)>0.)\n\n#define store(what,value) storeValue( what, value, \tfragColor, fragCoord )\n#define isinit IF_GT(float(iFrame),0.5)\n#define noinit IF_LT(float(iFrame),0.5)\n#define loadv(what) (loadValue(iChannel0,what*isinit))\n#define loadif(what,default) ((loadValue(iChannel0,what)*isinit)+(noinit*default))\n#define loadifb(what,default) ((loadValue(iChannel1,what)*isinit)+(noinit*default))\n#define load(what,value,default) vec4 value=(loadValue(iChannel0,what)*isinit )+(noinit*default)\n#define loadb(what,value,default)vec4 value=(loadValue(iChannel1,what)*isinit )+(noinit*default)\n\nvec4 loadValue(sampler2D tex, in vec2 re )\n{\n    return texture( tex, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\nconst float KEY_X     = 88.5/256.0;\nconst float KEY_Z     = 90.5/256.0;\n\nvec4 RotationBetweenVectors(vec3 start, vec3 dest){\n    start = normalize(start);\n    dest = normalize(dest);\n\n    float cosTheta = dot(start, dest);\n    vec3 rotationAxis;\n\n\n\n    rotationAxis = cross(start, dest);\n\n    float s = sqrt( (1.+cosTheta)*2. );\n    float invs = 1. / s;\n\n    return vec4(\n\n        rotationAxis.x * invs,\n        rotationAxis.y * invs,\n        rotationAxis.z * invs,\n        s * 0.5\n    );\n\n}\n\nfloat keyMom(float key)\n{\n    return IF_NEQ(texture( iChannel3, vec2(key, 0.0) ).x,0.) ;\n}\n\nvec4 multQuat(vec4 q1, vec4 q2)\n{\n    return vec4(\n        q1.w * q2.x + q1.x * q2.w + q1.z * q2.y - q1.y * q2.z,\n        q1.w * q2.y + q1.y * q2.w + q1.x * q2.z - q1.z * q2.x,\n        q1.w * q2.z + q1.z * q2.w + q1.y * q2.x - q1.x * q2.y,\n        q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z\n    );\n}\nvec4 QuatFromAxisAngle( vec3 vAxis, float fAngle )\n{\n    return vec4( normalize(vAxis) * sin(fAngle), cos(fAngle) );    \n}\nvec4 QuatFromVec3( vec3 vRot )\n{\n    float l = length( vRot );\n    if ( l <= 0.0 )\n    {\n        return vec4( 0.0, 0.0, 0.0, 1.0 );\n    }\n    return QuatFromAxisAngle( vRot, l );\n}\n\nvec3 QuatMul( vec3 v, vec4 q )\n{\n    // TODO Validate vs other quat code\n    vec3 t = 2.0 * cross(q.xyz, v);\n    return v + q.w * t + cross(q.xyz, t);\n}\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\nstruct Body\n{\n    // Persistent State\n    int id;\n    vec3 vPos;\n    vec4 qRot;\n    vec3 vMomentum;\n    vec3 vAngularMomentum;\n\n    // Derived\n    mat3 mRot;\n\n    // Constant\n    float fMass;\n    float fIT; // Hacky scalar for inertia tensor\n\n    // Per frame\n    vec3 vForce;\n    vec3 vTorque;\n    vec4 vCol;\n    vec4 vColMat;\n}T_Body;\n\nconst vec2 txBodyPos \t= vec2(0.,0.);\nconst vec2 txBodyRot \t= vec2(1.,0.);\nconst vec2 txBodyMom\t= vec2(2.,0.);\nconst vec2 txBodyAngMom\t= vec2(3.,0.);\nconst vec2 txBodyCol\t= vec2(4.,0.);\nconst vec2 txBodyColMat = vec2(5.,0.);\n\nvoid BodyLoadState(inout Body body,in float af )\n{\n    vec2 a=vec2(0.,af)+_bBody;\n    body.id=int(af);\n    {\n        vec4 bvp = \t\t\tloadif(txBodyPos+a\t,vec4(body.vPos,0.));\n        body.vPos=bvp.xyz;\n        body.fMass=bvp.w;\n    }\n    body.qRot = \t\t\tloadif(txBodyRot+a\t,body.qRot);\n    body.vMomentum =  \t\tloadif(txBodyMom+a\t,vec4(body.vMomentum,0.)).xyz;\n    body.vAngularMomentum = loadif(txBodyAngMom+a,vec4(body.vAngularMomentum,0.)).xyz;\n    body.vCol = \t\t\tloadifb(txBodyCol+a,body.vCol);\n    body.vColMat = \t\t\tloadifb(txBodyColMat+a,body.vCol);\n\n}\n\nvoid BodyStoreState(const in Body body,in float af, inout vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 a=vec2(0.,af)+_bBody;\n    storeValue( a+txBodyPos, \t\t\tvec4(body.vPos,body.fMass),   \t   \t\tfragColor, fragCoord );\n    storeValue( a+txBodyRot, \t\t\tbody.qRot,   \t   \t\t\t\tfragColor, fragCoord );\n    storeValue( a+txBodyMom, \t\t\tvec4(body.vMomentum,0.),   \t   \tfragColor, fragCoord );\n    storeValue( a+txBodyAngMom, \t\tvec4(body.vAngularMomentum,0.), fragColor, fragCoord );\n}\n#define loadBody(b_,a_) BodyLoadState(b_,a_)\n#define storeBody(b_,a_) BodyStoreState(b_,a_,fragColor,fragCoord)\n\nvoid BodyApplyGravity( inout Body body, float f )\n{\n    float fAccel_MpS = -9.81 * f;\n    body.vForce.y += body.fMass * fAccel_MpS;\n}\n\nvoid BodyIntegrate( inout Body body, float dT )\n{\n\n\n    body.vMomentum += body.vForce * dT;\n    body.vAngularMomentum += body.vTorque * dT;\n\n    vec3 vVel = body.vMomentum / body.fMass;\n    vec3 vAngVel = body.vAngularMomentum / body.fIT;\n\n    body.vPos += vVel * dT;\n    vec4 qAngDelta = QuatFromVec3( vAngVel * dT );\n    body.qRot = multQuat( qAngDelta, body.qRot );\n\n    body.qRot = normalize( body.qRot );\n}\n\nvoid BodyApplyForce( inout Body body, vec3 vPos, vec3 vForce )\n{    \n    body.vForce += vForce;\n    body.vTorque += cross(vPos - body.vPos, vForce);     \n\n}\nvoid BodyApplyForceM( inout Body body, vec3 vPos, vec3 vForce )\n{    \n    //  body.vForce += vForce;\n    body.vTorque += cross(vPos, vForce);\n\n}\n\nvoid BodyApplyImpulse( inout Body body, vec3 vPos, vec3 vImpulse )\n{    \n    body.vMomentum += vImpulse;\n    body.vAngularMomentum += cross(vPos - body.vPos, vImpulse);     \n}\nvoid BodyApplyAMom( inout Body body, vec3 vPos, vec3 vImpulse )\n{    \n    //  body.vMomentum += vImpulse;\n    body.vAngularMomentum += cross(vPos - body.vPos, vImpulse);     \n}\n\nvec3 BodyPointVelocity( const in Body body, vec3 vWorldPos )\n{\n    vec3 vVel = body.vMomentum / body.fMass;\n    vec3 vAngVel = body.vAngularMomentum / body.fIT;\n\n    return vVel + cross( vAngVel, vWorldPos - body.vPos );\n}\n#define PORTAL_ROTATION(this,other) multQuat(QuatFromVec3(mix(mix(vec3(0.,0.,PI*0.5),vec3(PI*0.5,0.,0.),IF_EQ(this.x+other.x,0.)),vec3(0.,PI*0.5,0.),IF_EQ(this.y+other.y,0.))),RotationBetweenVectors(this.xyz,other.xyz));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n\n    if(isInside(fragCoord,vec4(0.,0.,32.,1.))>0.)\n    {       \n        //  load(_vPos,\tvPos,\tvec4(0.,1.,10.2,0.));\n        //       load(_qRot,\tqRot,\tvec4(0.7,0.,0.,1.));\n        load(_vHed,\tvHed,\tvec4(0.,0.,.1,0.));\n        load(_vMou,\tvMou,\tvec4(0.,0.,.0,0.));\n        load(_vTim,\tvTim,\tvec4(0.));\n\n        load(_vP1,\tvP1,\tvec4(0.));\n        load(_vP2,\tvP2,\tvec4(0.));\n        load(_qP1,\tqP1,\tvec4(0.));\n        load(_qP2,\tqP2,\tvec4(0.));\n\n        loadb(_vHit,vHit,\tvec4(0.));\n        loadb(_vHitNor,vHitNor,\tvec4(0.));\n        loadb(_vHitMat,vHitMat,\tvec4(0.));\n\n        //        vP2.x=2.+(0.5+0.5*sin(iTime));\n        //        vP2.y=.6+(0.5+0.5*cos(iTime));\n\n        float fire=vTim.y*vHit.w;\n        vP1.xyz=mix(vP1.xyz,vHit.xyz,\tkeyMom(KEY_Z)*fire);\n        qP1=\tmix(qP1,\tvHitNor,\tkeyMom(KEY_Z)*fire);\n        vP1.w=\tmix(vP1.w,\tvHitMat.y,\tkeyMom(KEY_Z)*fire);\n\n        vP2.xyz=mix(vP2.xyz,vHit.xyz,\tkeyMom(KEY_X)*fire);\n        qP2=\tmix(qP2,\tvHitNor,\tkeyMom(KEY_X)*fire);\n        vP2.w=\tmix(vP2.w,\tvHitMat.y,\tkeyMom(KEY_X)*fire);\n\n\n        float dT=iTime-vTim.x;\n        dT=step(0.0001,dT)*1./60.;\n        //    qRot=vec4(0.,0.,0.,1.);\n\n        vHed.w+=keyMom(KEY_LEFT)*0.01;\n        vHed.w-=keyMom(KEY_RIGHT)*0.01;\n\n\n        vec2 cr=(vMou.xy-iMouse.xy)/iResolution.xy;\n        vec2 ca=(iMouse.xy)/iResolution.xy;\n        ca=mix(ca,vec2(0.5),IF_EQ(iMouse.w,0.));\n        vHed.w+=IF_GT(vMou.w,0.5) * IF_GT(iMouse.w,0.5) * cr.x*2.;\n\n        vHed.xz=vec2(0.,.1)*mm2(-(vHed.w)*2.);\n\n        //        vec3 mov=vPos.xyz;\n        //        mov.xz-=keyMom(KEY_UP)*vHed.xz;\n        //        mov.xz+=keyMom(KEY_DOWN)*vHed.xz;\n        //\n\n        //        vPos.y=1.;\n        //        //   vPos.y+=moving*sin(vPos.z*2.4)*0.07;\n        //        vPos.y+=(1.-moving)*sin(iTime*2.)*0.02;\n        //\n        //        vPos.xz=mov.xz;\n\n        //physics\n        Body ball[BALLS];\n        ball[0]=\n            ball[1]=\n            Body(0,\n                 vec3(0.,03.,-4.),\n                 vec4(0.,0.,0.,1.),\n                 vec3(0.,0.,0.),\n                 vec3(0.,0.,0.),\n                 mat3(1.),\n                 10.,\n                 1.,\n                 vec3(0.),\n                 vec3(0.),\n                 vec4(0.),\n                 vec4(0.));\n\n        ball[0].fMass=25.;\n        float moving=max(keyMom(KEY_DOWN),keyMom(KEY_UP));\n        float firing=1.-max(keyMom(KEY_Z),keyMom(KEY_X));\n        //        float ma=1.\n\n\n        if(keyMom(KEY_UP)>0.)\n        {\n            //  BodyApplyForce(ball[0],ball[0].vPos+vec3(0.,1000.,0.),-vHed.xyz*1000.);\n            ball[0].vMomentum=vec3(0.,clamp(1.-ball[0].vCol.w*4.,0.,1.)*140.2,0.)  -vHed.xyz*550.;\n        }\n        if(keyMom(KEY_DOWN)>0.)\n        {         \n            //  BodyApplyForce(ball[0],ball[0].vPos+vec3(0.,1000.,0.),-vHed.xyz*1000.);\n            ball[0].vMomentum=vec3(0.,clamp(1.-ball[0].vCol.w*4.,0.,1.)*140.2,0.)  +vHed.xyz*550.;\n        }\n\n        \n         loadBody(ball[0],float(0));\n       BodyIntegrate(ball[0],dT);\n        ball[0].qRot=QuatFromAxisAngle(vec3(0.,1.,0.),vHed.w);\n        ball[0].qRot=multQuat(QuatFromAxisAngle(vec3(1.,0.,0.),(ca.y-0.5)*2.),ball[0].qRot);\n\t\tstoreBody(ball[0],float(0));\n        for(int i=1;i<BALLS;i++)\n            //        const int i=0;\n        {\n            if(i==0){\n\n\n\n                // BodyIntegrate(ball[i],dT);\n                //   ball[0].qRot=QuatFromAxisAngle(vec3(0.,1.,0.),vHed.w);\n                //   ball[0].qRot=multQuat(QuatFromAxisAngle(vec3(1.,0.,0.),(ca.y-0.5)*2.),ball[0].qRot);\n\n            }\n            if(noinit+keyMom(KEY_R)==0.){\n\n                loadBody(ball[i],float(i));\n\n\n\n                if(ball[i].vCol.w<0. && ball[i].vColMat.w==0.) {\n                    ball[i].vMomentum=reflect(ball[i].vMomentum,normalize(ball[i].vCol.xyz));\n                    //    ball[i].vForce=reflect(ball[i].vForce,normalize(ball[i].vCol.xyz));\n                    ball[i].vMomentum*=mix(vec3(.7,0.0,.7),vec3(1.),IF_NEQ(float(i),0.));\n\n                    // BodyApplyImpulse(ball,ball.vPos,bvm*0.1);\n                }\n                else if(ball[i].vColMat.w<0.)\n                {\n\n                    vec4 qro=PORTAL_ROTATION(mix(qP1,qP2,IF_EQ(ball[i].vColMat.z,2.)),mix(qP2,qP1,IF_EQ(ball[i].vColMat.z,2.)));\n                    ball[i].vPos-=(mix(vP1.xyz,vP2.xyz,IF_EQ(ball[i].vColMat.z,2.)));\n                    ball[i].vPos=QuatMul(ball[i].vPos,qro);\n                    ball[i].vPos+=(mix(vP2.xyz,vP1.xyz,IF_EQ(ball[i].vColMat.z,2.)));\n                    ball[i].vMomentum=QuatMul(ball[i].vMomentum,qro);\n                    ball[i].vForce=QuatMul(ball[i].vForce,qro);;\n                        //  ball[i].qRot=multQuat(ball[i].qRot,qro);;\n\n                        }\n                else{\n                    ball[i].vMomentum*=0.999;\n\n                    BodyApplyGravity( ball[i], 1. );\n                }\n            }\n            else{\n                ball[i].vPos.z+=4.*float(i);\n                ball[i].id=i;\n                BodyApplyImpulse(ball[i],ball[i].vPos+vec3(0.,0.,0.),vec3(0.,0.,-50.));\n            }\n\n            BodyIntegrate(ball[i],dT);\n\n\n\n            storeBody(ball[i],float(i));\n        }\n\n        //     store(_vPos,vPos);\n        store(_vHed,vHed);\n        //        store(_qRot,qRot);\n        store(_vMou,iMouse);\n\n        store(_vTim,vec4(iTime,firing,0.,0.));\n\n        store(_vP1,\tvP1);\n        store(_vP2,\tvP2);\n        store(_qP1,\tqP1);\n        store(_qP2,\tqP2);\n\n    }\n    else discard;\n\n}\n\n", "name": "Buffer A", "description": "", "type": "buffer"}, {"inputs": [{"id": "XsfGRn", "filepath": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "type": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "4dXGRr", "filepath": "/presets/tex00.jpg", "previewfilepath": "/presets/tex00.jpg", "type": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "4dXGR8", "filepath": "/media/previz/buffer00.png", "previewfilepath": "/media/previz/buffer00.png", "type": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "XsXGR8", "filepath": "/media/previz/buffer01.png", "previewfilepath": "/media/previz/buffer01.png", "type": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "XsXGR8", "channel": 0}], "code": "#define BALLS 2\n\n\n\nfloat remap(float value, float low1,float high1, float low2,float high2,bool c){float r=low2 + (value - low1) * (high2 - low2) / (high1 - low1);return c?clamp(r,min(low2,high2),max(low2,high2)):r;}\nfloat remap(float value, float low2,float high2,bool c){return remap(value,0.,1.,low2,high2,c);}\nfloat antiAlias(float x) {return (x-(1.0-2.0/iResolution.y))*(iResolution.y/2.0);}\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nfloat isInside( vec2 p, vec4 c ) { vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y); }\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nconst vec2 _vHed \t= vec2(2.,0.);\nconst vec2 _vP1 \t= vec2(5.,0.);\nconst vec2 _qP1 \t= vec2(6.,0.);\nconst vec2 _vP2 \t= vec2(7.,0.);\nconst vec2 _qP2 \t= vec2(8.,0.);\nconst vec2 _bBody \t= \tvec2(20.,0.);\n\nconst vec2 _vHit\t= vec2(0.,0.);\nconst vec2 _vHitNor\t= vec2(1.,0.);\nconst vec2 _vHitMat\t= vec2(2.,0.);\n\n#define PI 3.14159265359\n#define MAX_DIST 70.\n#define MIN_DIST .0001\n#define precis 0.002\n//#define AUTO_MOUSE\n\n#define srat iResolution.x/iResolution.y\n\n#define IF_EQ(a_,b_) step(abs(a_-b_),0.)\n#define IF_NEQ(a_,b_) (1.-step(abs(a_-b_),0.))\n#define IF_LT(a_,b_) step(a_-b_,0.)\n#define IF_GT(a_,b_) step(b_-a_,0.)\n#define IS_VAL(_val) step(0.,isInside(fragCoord,_val))\n\n#define store(what,value) storeValue( what, value, \tfragColor, fragCoord )\n#define isinit IF_GT(float(iFrame),0.5)\n#define noinit IF_LT(float(iFrame),0.5)\n#define loadifb(what,default) ((loadValue(iChannel1,what)*isinit)+(noinit*default))\n#define loadif(what,default) ((loadValue(iChannel0,what)*isinit)+(noinit*default))\n#define load(what,value,default) vec4 value=(loadValue(iChannel0,what)*isinit)+(noinit*default)\n#define loadb(what,value,default)vec4 value=(loadValue(iChannel1,what)*isinit)+(noinit*default)\n\nconst vec2 txBodyPos \t= vec2(0.,0.);\nconst vec2 txBodyRot \t= vec2(1.,0.);\nconst vec2 txBodyCol\t= vec2(4.,0.);\nconst vec2 txBodyColMat = vec2(5.,0.);\n\nconst float KEY_R     = 82.5/256.0;\nfloat keyMom(float key)\n{\n    return IF_NEQ(texture( iChannel3, vec2(key, 0.0) ).x,0.) ;\n}\n\nvec4 loadValue(sampler2D tex, in vec2 re )\n{\n    return texture( tex, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\n\nstruct Body\n{\n    // Persistent State\n    int id;\n    vec3 vPos;\n    vec4 qRot;\n    vec4 vCol;\n    vec4 vColMat;\n    float fMass;\n}T_Body;\n\nBody ball[BALLS];\nvec3 p1,p2;\nvec4 q1,q2;\n\nvoid BodyLoadState( out Body body,in float af )\n{\n    vec2 a=vec2(0.,af)+_bBody;\n    body.id=int(af);\n    {\n        vec4 bvp = \t\t\tloadif(txBodyPos+a\t,vec4(body.vPos,0.));\n        body.vPos=bvp.xyz;\n        body.fMass=bvp.w;\n    }\n    body.qRot = \t\t\tloadif(txBodyRot+a,vec4(0.,0.,0.,1.));\n    body.vCol = \t\t\tloadifb(txBodyCol+a,body.vCol);\n}\n\nvoid BodyStoreState(const in Body body,in float af, inout vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 a=vec2(0.,af)+_bBody;\n    storeValue( a+txBodyCol, \t\t\tbody.vCol,   \t   \tfragColor, fragCoord );\n    storeValue( a+txBodyColMat,\t\t\tbody.vColMat,  \t   \tfragColor, fragCoord );\n}\n#define loadBody(b_,a_) BodyLoadState(b_,a_)\n#define storeBody(b_,a_) BodyStoreState(b_,a_,fragColor,fragCoord)\n\n\nstruct Ray{vec3 ro,rd;float tmin ,tmax;vec3 hit;vec3 nor;int i;}T_Ray;\nRay newRay(vec3 ro,vec3 rd){return Ray(ro,rd,MIN_DIST,MAX_DIST,vec3(0.),vec3(0.),-1);}\n\n#define REP(p,c) mod(p,c)-0.5*c\nfloat rand (in vec2 seed) {\n    seed = fract (seed * vec2 (5.3983, 5.4427));\n    seed += dot (seed.yx, seed.xy + vec2 (21.5351, 14.3137));\n    return fract (seed.x * seed.y * 95.4337);\n}\nfloat render(vec2 uv,float d)\n{\n    return clamp(antiAlias(d), 0.0, 1.0);\n\n}\nfloat opU( float d1, float d2 )\n{\n    return max(d1,d2);\n}\nfloat opS(float a,float b) { return min(-b,a); }\nfloat opI( float d1, float d2 ){    return max(d1,d2);}\nfloat box( in vec2 p, in vec2 a, in vec2 b )\n{\n\n    return  1.-max(-isInside(p,a),-isInside(-p,-b));\n}\nvoid RPY(in vec3 _v,inout vec3 _ro,inout vec3 _rd) {\n    mat2 mx = mm2(PI*_v.x);mat2 my = mm2(PI*_v.y);mat2 mz = mm2(PI*_v.z);_ro.xy *= mx;_rd.xy *= mx;_ro.zy *= my;_rd.zy *= my;_ro.zx *= mz;_rd.zx *= mz;\n}\nmat3 QuatToMat3( const in vec4 q )\n{\n    vec4 qSq = q * q;\n    float xy2 = q.x * q.y * 2.0;\n    float xz2 = q.x * q.z * 2.0;\n    float yz2 = q.y * q.z * 2.0;\n    float wx2 = q.w * q.x * 2.0;\n    float wy2 = q.w * q.y * 2.0;\n    float wz2 = q.w * q.z * 2.0;\n\n    return mat3 (\t\n        qSq.w + qSq.x - qSq.y - qSq.z, xy2 - wz2, xz2 + wy2,\n        xy2 + wz2, qSq.w - qSq.x + qSq.y - qSq.z, yz2 - wx2,\n        xz2 - wy2, yz2 + wx2, qSq.w - qSq.x - qSq.y + qSq.z );\n}\nvec4 mulQuat(vec4 q1, vec4 q2)\n{\n    return vec4(\n        q1.w * q2.x + q1.x * q2.w + q1.z * q2.y - q1.y * q2.z,\n        q1.w * q2.y + q1.y * q2.w + q1.x * q2.z - q1.z * q2.x,\n        q1.w * q2.z + q1.z * q2.w + q1.y * q2.x - q1.x * q2.y,\n        q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z\n    );\n}\nvec4 RotationBetweenVectors(vec3 start, vec3 dest){\n    start = normalize(start);\n    dest = normalize(dest);\n\n    float cosTheta = dot(start, dest);\n    vec3 rotationAxis;\n\n    rotationAxis = cross(start, dest);\n\n    float s = sqrt( (1.+cosTheta)*2. );\n    float invs = 1. / s;\n\n    return vec4(\n\n        rotationAxis.x * invs,\n        rotationAxis.y * invs,\n        rotationAxis.z * invs,\n        s * 0.5\n    );\n\n}\nvec4 QuatFromAxisAngle( vec3 vAxis, float fAngle )\n{\n    return vec4( normalize(vAxis) * sin(fAngle), cos(fAngle) );    \n}\nvec3 QuatMul( vec3 v, vec4 q )\n{\n    // TODO Validate vs other quat code\n    vec3 t = 2.0 * cross(q.xyz, v);\n    return v + q.w * t + cross(q.xyz, t);\n}\n\nvec3 sdMin(vec3 a,vec3 b)\n{\n    return mix(a,b,step(b.x,a.x));\n}\nvec3 sdSub(vec3 a,float b)\n{\n    b=-b;\n    //    a.yz=b.yz;\n    return vec3(mix(a.x,b,step(a.x,b)),a.yz);\n}\nvec3 sdSub(vec3 a,vec3 b)\n{\n    b.x=-b.x;\n    //    a.yz=b.yz;\n    return mix(a,b,step(a.x,b.x));\n}\nvec3 sdMin(vec3 a,vec3 b,int i)\n{\n    return mix(mix(a,b,step(b.x,a.x)),a,IF_EQ(float(b.y),float(i)));\n}\nvec3 sdI(vec3 a,vec3 b,int i)\n{\n    return mix(mix(a,b,step(-b.x,-a.x)),a,IF_EQ(float(b.y),float(i)));\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) +\n        length(max(d,0.0));\n}\nfloat sdCylinder( vec3 p, vec3 c )\n{\n    return length( p.xz - c.xy ) - c.z;\n}\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n    p.xyz=p.yzx;\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nmat3 NormalToRotation(vec3 normal) {\n    // Find a vector in the plane\n    vec3 tangent0 = cross(normal, vec3(1., 0., 0.));\n    if (dot(tangent0, tangent0) < 0.001)\n        tangent0 = cross(normal, vec3(0., 1., 0.));\n    tangent0 = normalize(tangent0);\n    // Find another vector in the plane\n    vec3 tangent1 = normalize(cross(normal, tangent0));\n    // Construct a 3x3 matrix by storing three vectors in the columns of the matrix\n    return mat3(tangent0, tangent1, normal);\n}\n\n\nvec4 QuatFromVec3( vec3 vRot )\n{\n    float l = length( vRot );\n    if ( l <= 0.0 )\n    {\n        return vec4( 0.0, 0.0, 0.0, 1.0 );\n    }\n    return QuatFromAxisAngle( vRot, l );\n}\nvec3 mapPortals(vec3 p,int i)\n{\n    vec3 res=vec3(MAX_DIST,-1.,-1.);\n    vec3 p1r=vec3(sdCappedCylinder(((p-p1)*NormalToRotation(q1.xyz))+vec3(0.,0.,0.),vec2(.8,.0001)),10.,1.);\n    vec3 p2r=vec3(sdCappedCylinder(((p-p2)*NormalToRotation(q2.xyz))+vec3(0.,0.,0.),vec2(.8,.0001)),10.,2.);\n\n    res=sdMin(res,p2r,int(IF_EQ(q2.w,0.)*10.));\n    res=sdMin(res,p1r,int(IF_EQ(q1.w,0.)*10.));\n\n    return res;\n}\n\nvec3 mapScene(vec3 p,int i)\n{\n    vec3 res=vec3(MIN_DIST,1.,0.);\n\n    float repRand=0.5+0.5*sin(floor(p.x*.10)/.10);\n    float rscale=0.1+rand((floor(p.xz/10.)*10.));\n\n\n    vec3 rp=REP(p-vec3(0.,10.*rscale,0.),vec3(010.,0.,010.));\n\n    #define ROOM_QUANT 2.5\n    #define ROOM_SIZE (ROOM_QUANT*8.)\n    //    vec3 pur=vec3(sdBox(rp-vec3(0.,3.,0.)*ROOM_QUANT,vec3(1.,1.,1.)),2.,0.);\n\n    res=sdSub(res,vec3(sdBox(p+(vec3(0.,-2,0.)*ROOM_QUANT),vec3(8.,4.,8.)*ROOM_QUANT),2.,0.));\n    res=sdSub(res,vec3(sdBox(p+(vec3(0.,-2,0.)*ROOM_QUANT),vec3(7.,5.,7.)*ROOM_QUANT),1.,0.));\n\n    res=sdSub(res,vec3(sdBox(p+(vec3(4.,4.,0.)*ROOM_QUANT),vec3(1.,6.,8.)*ROOM_QUANT),2.,0.));\n    res=sdSub(res,vec3(sdBox(p+(vec3(0.,-1.,0.)*ROOM_QUANT),vec3(16.,1.,1.)*ROOM_QUANT),1.,0.));\n\n    //    res=sdMin(res,pur);\n\n    for(int bi=0;bi<BALLS;bi++)\n    {\n        vec3 sdball=vec3(length(p-(ball[bi].vPos))-(ball[bi].fMass*0.02),20.+float(bi),0.);\n        res=sdMin(res,sdball,i+20);\n    }\n\n    return res;\n}\nvec3 map(vec3 p,int i)\n{\n    vec3 res=vec3(MAX_DIST,-1.,-1.);\n\n\n    res=sdMin(res,mapScene(p,i),i+20);\n    res=sdMin(res,mapPortals(p,i),i+20);\n\n    return res;\n}\nvec3 map(vec3 p)\n{\n    return map(p,-1);\n}\nvec3 map(Body p)\n{\n    return map(p.vPos,p.id);\n}\nvec2 sphproj(in vec3 p,vec2 rx)\n{\n    vec2 sph = vec2(acos(p.y/length(p)), atan(p.z,p.x));\n    vec2 tl=vec2(sph.yx*1.5915*vec2(0.4,0.2));\n    tl.x*=.25;\n    tl.x=mod(tl.x+rx.x,1.);\n    tl.y=mod(tl.y+rx.y,1.);\n\n    return tl;\n}\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3( 0.004, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    return normalize(nor);\n}\n\nvec3 castRay(inout Ray ray){\n    float t = ray.tmin;\n    vec3 res=vec3(0.);\n    ray.hit=vec3(0.);\n    for( int i=0; i<200; i++ )\n    {\n        ray.hit=ray.ro+ray.rd*t;\n        res = map( ray.hit,ray.i );\n        if( res.x<precis || t>ray.tmax ) break;\n        t += res.x*0.9;\n    }\n    res.x=res.z;\n    res.z=t;\n    return res*=step(t,ray.tmax);\n}\n\nRay getCamera(vec2 p,in vec3 pos,in vec4 rot)\n{\n    //camera\n    vec3 cam=vec3(0.,0.,0.);\n    vec3 ro = cam;\n    vec3 rd = normalize(vec3(p,-1.15));\n\n    vec2 cr=vec2(0.);\n    cr=iMouse.xy/iResolution.xy;\n    //    cr.x*=srat;\n    #ifdef AUTO_MOUSE\n    cr=mix(cr,vec2(-1.25-0.5*sin(-2.8+iTime*0.1),remap(cos(-1.18+iTime*0.2),-1.,1.,0.25,0.4,true)),step(iMouse.z,0.5));\n    #endif\n\n    mat3  m3r=QuatToMat3(normalize(rot));\n    //mat2 mz = mm2(PI*2.*(-cr.x*srat)-PI*0.5);\n    //mat2 my = mm2(PI*2.*cr.y-1.); \n    //   ro.zy *= my;rd.zy *= my;\n    //   ro.zx *= mz;rd.zx *= mz;\n    rd*=m3r;\n    ro*=m3r;\n\n    ro+=pos.xyz;\n\n    return newRay(ro,rd);\n\n}\n\n#define PORTAL_ROTATION(this,other) mulQuat(QuatFromVec3(mix(mix(vec3(0.,0.,PI*0.5),vec3(PI*0.5,0.,0.),IF_EQ(this.x+other.x,0.)),vec3(0.,PI*0.5,0.),IF_EQ(this.y+other.y,0.))),RotationBetweenVectors(this.xyz,other.xyz));\n\nvec3 doPortal(inout Ray ray,\n              vec3 ppos, //this portal pos\n              vec3 apos, // other portal pos\n              vec4 pq, // this normal\n              vec4 aq) // other normal\n{\n\n    vec3 res=vec3(0.);\n\n    vec4 qro=PORTAL_ROTATION(pq,aq);\n\n    ray.ro=ray.hit;\n\n    ray.ro-=ppos;\n\n    ray.ro=QuatMul(ray.ro,qro);\n    ray.rd=QuatMul(ray.rd,qro);\n\n    //    ray.ro.x*=-1.;\n    ray.ro+=apos;\n\n\n    ray.i=10;\n    ray.tmin*=400.;\n    res=castRay(ray);\n    ray.nor = calcNormal( ray.hit );\n    return res;\n}\nvec2 softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    vec2 res = vec2(1.,1.);\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n        vec3 hit=map( ro + rd*t );\n        float h = hit.x;\n        res.x = min( res.x, (32.0*h/t) );\n        t += clamp( h, 0.01, 0.99999 );\n        if( h<(0.001) || t>tmax ) break;\n    }\n    return clamp( res,1.2-res.y, 1.0 );\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //  load(_vPos,\tvPos,vec4(01.,3.,01.,0.));\n    //load(_qRot,\tqRot,vec4(0.,0.,0.,1.));\n    load(_vHed,\tvHed,vec4(0.));\n\n\n    load(_vP1,\tvP1,\tvec4(0.));\n    load(_vP2,\tvP2,\tvec4(0.));\n    load(_qP1,\tqP1,\tvec4(0.));\n    load(_qP2,\tqP2,\tvec4(0.));\n\n    p1=vP1.xyz;\n    p2=vP2.xyz;\n    q1=qP1;\n    q2=qP2;\n\n    //    vPos.xyz=ball[0].vPos+vec3(0.,1.,0.);\n\n    //   loadb(_vCol,\tvCol,vec4(0.));\n\n    for(int i=0;i<BALLS;i++)\n    {\n        loadBody(ball[i],float(i));\n    }\n\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float istest=max(IS_VAL(_vHit),max(IS_VAL(_vHitNor),IS_VAL(_vHitMat)));\n    uv=mix(uv,vec2(0.5),istest);\n\n    uv.x*=srat;\n    vec3 col=vec3(0.);\n\n    //initial view projection & sky\n    Ray ray=getCamera(uv-vec2(0.5*srat,0.5),ball[0].vPos,ball[0].qRot);\n    ray.i=0;\n    vec3 res=castRay(ray);\n    ray.nor = calcNormal( ray.hit );\n\n    #define BACKGROUND ((vec3(0.1, 0.7, .90)+ray.rd.y*-0.8)) *0.5   \n    vec3 bcol = BACKGROUND ;\n\n    //the portals:\n    #define P1POS vP1.xyz\n    #define P2POS vP2.xyz\n    float pdis=res.z;\n    float validHit=1.;\n    if((istest*100.)==0.)\n    {\n        if(1.==res.x )\n        {\t\n            //          res.y=10.;\n            //if(min(vP1.w,vP2.w)>0.)\n            {\n                //     ray.rd=QuatMul(ray.rd,(q2));\n                res=doPortal(ray,P1POS,P2POS,q1,q2);\n                pdis+=res.z;\n            }\n\n        }else if(2.==res.x )\n        {\n            //            res.y=10.;\n            //if(min(vP1.w,vP2.w)>0.)\n            {\n                //   ray.rd=QuatMul(ray.rd,(q1));\n                res=doPortal(ray,P2POS,P1POS,q2,q1);\n                pdis+=res.z;\n            }\n        }\n        //ray.hit.y=-ray.hit.y;\n    }else{\n        validHit=IF_EQ(res.y,1.);\n        //ray.hit\n    }\n    //materials\n    #define SQSIZE 5.\n    mat3 tro=NormalToRotation(ray.nor);\n    vec3 trv=ray.hit*tro;\n\n    //   vec2 tx=sphproj((ray.hit-ball.vPos)*QuatToMat3(ball.qRot),vec2(0.,0.));\n\n    float f = mod( floor((2./SQSIZE)*(trv.x)) + floor((2./SQSIZE)*(trv.y)), 2.);\n\n\n    col += IF_EQ(1.,res.y) * (vec3(.5) * 0.5 + 0.5*f*vec3(1.0));\n    col += IF_EQ(2.,res.y) * (vec3(1.1,0.8,0.7)*texture(iChannel2,trv.xy*.1).rgb*0.3);\n    col += IF_EQ(5.,res.y) * (vec3(.5,.5,1.25) );\n\n    col += IF_EQ(10.,res.y) * (vec3(1.,0.,0.) );\n\n    col += IF_EQ(20.,res.y) * (vec3(.5,1.,1.));// * 0.5 + 0.5*fs*vec3(1.0,0.5,0.));\n    col += IF_EQ(21.,res.y) * (vec3(1.5,0.,1.));// * 0.5 + 0.5*fs*vec3(1.0,0.5,0.));\n\n\n    //lighting\n    #define MDiffCol \tvec3(1.,1.,1.) *.5\n    #define MSpecCol \tvec3(1.,1.,1.) *.3\n    #define LCol \t\tvec3(1.,1.,1.)\n    #define LPower 300.\n    #define MAmbient\t \tvec3(1.) * 0.07\n\n    vec3 lcol=vec3(1.);\n\n    vec3 lig = normalize(vec3(1.2,01.,0.4));\n    vec3 ref = reflect( (lig), ray.nor );\n    float cosAlpha = clamp( dot( normalize(ray.rd),ref ), 0.,1. );\n    float dis=pow(distance(lig,(ray.hit)),2.);\n    lcol *= MAmbient + MDiffCol * LCol * LPower * clamp(dot( ray.nor,(lig) ),0.,1.) / dis;\n    lcol += MSpecCol * LCol * LPower * pow(cosAlpha,5.) / dis;\n\n//    lcol *=1.-step(res.y,0.);\n\n   vec2 difss=softshadow( ray.hit, lig, 0.02, 15.5 );\n\n    vec2 domss=softshadow( ray.hit, ref, 0.2, 12.5 );\n    lcol*=difss.x;           \n    lcol*=domss.x*2.4;           \n\n\n    float dither=rand(vec2(ray.hit.x,(ray.hit.y+ray.hit.z)*0.5));\n    float pthrob=1.+1.*cos(iTime*3.)+dither;\n\n    //col+=dither*0.05;\n\n\n    col = mix( col, vec3(0.8,0.9,1.0)*0.35, 1.-MAmbient*(0.9)-exp( -0.000605*pow(pdis,2.) ) );\n    col=pow(col*lcol, vec3(1./2.2));\n    \n    \n    col += vec3(1.,pthrob*0.2,0.) * \t\tclamp(2.4-(pow(distance(p1,ray.hit),3.2+pthrob)),0.,1.);\n    col += vec3(0.,(1.-pthrob)*0.2,1.) * \tclamp(2.4-pow(distance(p2,ray.hit),3.2+pthrob),0.,1.);\n\n    fragColor = vec4(mix(col,bcol,IF_EQ(0.,res.y)),1.0);\n\n    if(isInside(fragCoord,vec4(0.,0.,32.,1.))>0.)\n    {  \n        //collision detection\n        for(int i=0;i<BALLS;i++)\n        {\n            vec3 bp=mapScene(ball[i].vPos,ball[i].id);\n            vec3 pm=mapPortals(ball[i].vPos,ball[i].id);\n            pm.x-=ball[i].fMass*0.02;\n            bp.x-=ball[i].fMass*0.02;\n            {\n                vec3 eps = vec3( 0.04, 0.0, 0.0 );\n                vec3 nor = vec3(\n                    mapScene(ball[i].vPos+eps.xyy,ball[i].id).x - mapScene(ball[i].vPos-eps.xyy,ball[i].id).x,\n                    mapScene(ball[i].vPos+eps.yxy,ball[i].id).x - mapScene(ball[i].vPos-eps.yxy,ball[i].id).x,\n                    mapScene(ball[i].vPos+eps.yyx,ball[i].id).x - mapScene(ball[i].vPos-eps.yyx,ball[i].id).x );\n                ball[i].vCol=vec4(normalize(nor),bp.x);\n            }\n            //        calcColNormal(ball[i]);      \n            // float sv=clamp(dot(normalize(-bpn),ray.nor ),0.,1.);\n\n            ball[i].vColMat=vec4(bp,0.);\n            if(pm.x<=0.){\n                vec4 plane=(mix(q1,q2,IF_EQ(pm.z,2.)));\n                vec3 v1=(mix(p1,p2,IF_EQ(pm.z,2.)));\n                vec3 v2=ball[i].vPos;\n\n                plane[3] = -( plane[0]*v1[0] + plane[1]*v1[1] + plane[2]*v1[2] );\n                float sd = v2[0]*plane[0] + v2[1]*plane[1] + v2[2]*plane[2] + plane[3];\n\n                ball[i].vCol.w=pm.x;\n                ball[i].vColMat=vec4(pm,sd);\n            }\n            storeBody(ball[i],float(i));\n        }\n\n\n\n        store(_vHit,vec4(ray.hit,validHit*(1.-IF_EQ(res.y,10.))));\n        store(_vHitNor,vec4(ray.nor,PI/4.));\n        store(_vHitMat,vec4(res,0.));\n    }\n\n}", "name": "Buffer B", "description": "", "type": "buffer"}, {"inputs": [{"id": "4dXGR8", "filepath": "/media/previz/buffer00.png", "previewfilepath": "/media/previz/buffer00.png", "type": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "XsXGR8", "filepath": "/media/previz/buffer01.png", "previewfilepath": "/media/previz/buffer01.png", "type": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4sXGR8", "channel": 0}], "code": "#define DOWN_SCALE 1.0\n\n#define MAX_INT_DIGITS 4\n\n#define CHAR_SIZE vec2(8, 12)\n#define CHAR_SPACING vec2(8, 12)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\n#define NORMAL 0\n#define INVERT 1\n#define UNDERLINE 2\n\n\n\n\n\nint TEXT_MODE = NORMAL;\n\n/*\n--------\n-\u00e2\u2013\u02c6\u00e2\u2013\u02c6\u00e2\u2013\u02c6----\n\u00e2\u2013\u02c6\u00e2\u2013\u02c6-\u00e2\u2013\u02c6\u00e2\u2013\u02c6---\n\u00e2\u2013\u02c6\u00e2\u2013\u02c6-\u00e2\u2013\u02c6\u00e2\u2013\u02c6---\n-\u00e2\u2013\u02c6\u00e2\u2013\u02c6\u00e2\u2013\u02c6----\n\u00e2\u2013\u02c6\u00e2\u2013\u02c6\u00e2\u2013\u02c6\u00e2\u2013\u02c6\u00e2\u2013\u02c6-\u00e2\u2013\u02c6-\n\u00e2\u2013\u02c6\u00e2\u2013\u02c6-\u00e2\u2013\u02c6\u00e2\u2013\u02c6\u00e2\u2013\u02c6\u00e2\u2013\u02c6-\n\u00e2\u2013\u02c6\u00e2\u2013\u02c6--\u00e2\u2013\u02c6\u00e2\u2013\u02c6--\n\u00e2\u2013\u02c6\u00e2\u2013\u02c6-\u00e2\u2013\u02c6\u00e2\u2013\u02c6\u00e2\u2013\u02c6--\n-\u00e2\u2013\u02c6\u00e2\u2013\u02c6\u00e2\u2013\u02c6-\u00e2\u2013\u02c6\u00e2\u2013\u02c6-\n--------\n--------\n\n00000000\n01110000\n11011000\n11011000\n01110000\n11111010\n11011110\n11001100\n11011100\n01110110\n00000000\n00000000\n\n//Broken up into 4 8x3 (24 bit) chunks for each component of the vec4.\n//Hexadecimal is being used to reduce clutter in the code but decimal still works.\n\n00000000\n01110000 -> 00000000 01110000 11011000 -> 0x0070D8\n11011000\n\n11011000\n01110000 -> 11011000 01110000 11111010 -> 0xD870FA\n11111010\n\n11011110\n11001100 -> 11011110 11001100 11011100 -> 0xDECCDC\n11011100\n\n01110110\n00000000 -> 01110110 00000000 00000000 -> 0x760000\n00000000\n\nvec4(0x0070D8,0xD870FA,0xDECCDC,0x760000)\n*/\n\n//Automatically generated from the 8x12 font sheet here:\n//http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n\nvec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000);\nvec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000);\nvec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000);\nvec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000);\nvec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000);\nvec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000);\nvec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000);\nvec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000);\nvec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000);\nvec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000);\nvec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000);\nvec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000);\nvec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000);\nvec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000);\nvec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000);\nvec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000);\nvec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000);\nvec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000);\nvec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000);\nvec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000);\nvec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000);\nvec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000);\nvec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000);\nvec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000);\nvec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000);\nvec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000);\nvec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000);\nvec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000);\nvec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000);\nvec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000);\nvec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000);\nvec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000);\nvec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000);\nvec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000);\nvec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000);\nvec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000);\nvec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000);\nvec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000);\nvec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000);\nvec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000);\nvec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000);\nvec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000);\nvec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000);\nvec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000);\nvec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000);\nvec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000);\nvec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000);\nvec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000);\nvec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000);\nvec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00);\nvec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000);\nvec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000);\nvec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000);\nvec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000);\nvec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000);\nvec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000);\nvec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000);\nvec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000);\nvec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000);\nvec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000);\nvec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000);\nvec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000);\nvec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000);\nvec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00);\nvec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000);\nvec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000);\nvec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000);\nvec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000);\nvec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000);\nvec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000);\nvec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78);\nvec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000);\nvec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000);\nvec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78);\nvec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000);\nvec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000);\nvec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000);\nvec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000);\nvec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000);\nvec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0);\nvec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E);\nvec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000);\nvec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000);\nvec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000);\nvec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000);\nvec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000);\nvec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000);\nvec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000);\nvec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0);\nvec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000);\nvec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000);\nvec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000);\nvec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000);\nvec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000);\nvec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n\nvec2 res;\nvec2 print_pos = vec2(0);\n\n//Extracts bit b from the given number.\n//Shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).\nfloat extract_bit(float n, float b)\n{\n    b = clamp(b,-1.0,24.0);\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(vec4 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    \n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));\n    \n    float pixels = 0.0;\n    pixels += extract_bit(spr.x, bit - 72.0);\n    pixels += extract_bit(spr.y, bit - 48.0);\n    pixels += extract_bit(spr.z, bit - 24.0);\n    pixels += extract_bit(spr.w, bit - 00.0);\n    \n    return bounds ? pixels : 0.0;\n}\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat char(vec4 ch, vec2 uv)\n{\n    if( TEXT_MODE == INVERT )\n    {\n      //Inverts all of the bits in the character.\n      ch = pow(2.0,24.0)-1.0-ch;\n    }\n    if( TEXT_MODE == UNDERLINE )\n    {\n      //Makes the bottom 8 bits all 1.\n      //Shifts the bottom chunk right 8 bits to drop the lowest 8 bits,\n      //then shifts it left 8 bits and adds 255 (binary 11111111).\n      ch.w = floor(ch.w/256.0)*256.0 + 255.0;  \n    }\n\n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\n\n//Returns the digit sprite for the given number.\nvec4 get_digit(float d)\n{\n    d = floor(d);\n    \n    if(d == 0.0) return ch_0;\n    if(d == 1.0) return ch_1;\n    if(d == 2.0) return ch_2;\n    if(d == 3.0) return ch_3;\n    if(d == 4.0) return ch_4;\n    if(d == 5.0) return ch_5;\n    if(d == 6.0) return ch_6;\n    if(d == 7.0) return ch_7;\n    if(d == 8.0) return ch_8;\n    if(d == 9.0) return ch_9;\n    return vec4(0.0);\n}\n\n//Prints out the given number starting at pos.\nfloat print_number(float number, vec2 uv)\n{\n    float result = 0.0;\n    if(number<0.){\n         result += char(ch_dsh,uv);\n        number=-number;\n    }\n\tfor(int i = 3;i >= -1;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n        \n        if(i == -1) //Add a decimal point.\n        {\n            result += char(ch_per,uv);\n        }\n        \n        if(abs(number) > pow(10.0, float(i)) || i == 0) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\nfloat print_integer(float number, int zeros, vec2 uv)\n{\n    float result = 0.0;\n    \n\tfor(int i = MAX_INT_DIGITS;i >= 0;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n\n        if(abs(number) > pow(10.0, float(i)) || zeros > i  || i == 0) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\nconst vec2 _vPos \t= vec2(0.,0.);\nconst vec2 _qRot \t= vec2(1.,0.);\nconst vec2 _vHed \t= vec2(2.,0.);\nconst vec2 _vP1 \t= vec2(5.,0.);\nconst vec2 _qP1 \t= vec2(6.,0.);\nconst vec2 _vP2 \t= vec2(7.,0.);\nconst vec2 _qP2 \t= vec2(8.,0.);\n\n\nconst vec2 _bBody \t= vec2(20.,0.);\n\n\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nfloat isInside( vec2 p, vec4 c ) { vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y); }\n\nvec4 loadValue(sampler2D tex, in vec2 re )\n{\n    return texture( tex, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n#define IF_EQ(a_,b_) step(abs(a_-b_),0.)\n#define IF_NEQ(a_,b_) (1.-step(abs(a_-b_),0.))\n#define IF_LT(a_,b_) step(a_-b_,0.)\n#define IF_GT(a_,b_) step(b_-a_,0.)\n#define IS_VAL(_val) step(0.,isInside(fragCoord,_val))\n\n#define isinit IF_GT(float(iFrame),0.5)\n#define noinit IF_LT(float(iFrame),0.5)\n#define loadifb(what,default) ((loadValue(iChannel1,what)*isinit)+(noinit*default))\n#define loadif(what,default) ((loadValue(iChannel0,what)*isinit)+(noinit*default))\n#define load(what,value,default) vec4 value=(loadValue(iChannel0,what)*isinit)+(noinit*default)\n#define loadb(what,value,default)vec4 value=(loadValue(iChannel1,what)*isinit)+(noinit*default)\n\nconst vec2 txBodyPos \t= vec2(0.,0.);\nconst vec2 txBodyRot \t= vec2(1.,0.);\nconst vec2 txBodyMom\t= vec2(2.,0.);\nconst vec2 txBodyAngMom\t= vec2(3.,0.);\nconst vec2 txBodyCol\t= vec2(4.,0.);\nconst vec2 txBodyColMat = vec2(5.,0.);\n\nstruct Body\n{\n    // Persistent State\n    int id;\n    vec3 vPos;\n    vec4 qRot;\n    vec3 vMomentum;\n    vec3 vAngularMomentum;\n\n    // Derived\n    mat3 mRot;\n\n    // Constant\n    float fMass;\n    float fIT; // Hacky scalar for inertia tensor\n\n    // Per frame\n    vec3 vForce;\n    vec3 vTorque;\n    vec4 vCol;\n    vec4 vColMat;\n}T_Body;\n\nvoid BodyLoadState(inout Body body,in float af )\n{\n    vec2 a=vec2(0.,af)+_bBody;\n    body.id=int(af);\n    {\n        vec4 bvp = \t\t\tloadif(txBodyPos+a\t,vec4(body.vPos,0.));\n        body.vPos=bvp.xyz;\n        body.fMass=bvp.w;\n    }\n    body.qRot = \t\t\tloadif(txBodyRot+a\t,body.qRot);\n    body.vMomentum =  \t\tloadif(txBodyMom+a\t,vec4(body.vMomentum,0.)).xyz;\n    body.vAngularMomentum = loadif(txBodyAngMom+a,vec4(body.vAngularMomentum,0.)).xyz;\n    body.vCol = \t\t\tloadifb(txBodyCol+a,body.vCol);\n    body.vColMat = \t\t\tloadifb(txBodyColMat+a,body.vCol);\n\n}\n#define loadBody(b_,a_) BodyLoadState(b_,a_)\n\nvec4 RotationBetweenVectors(vec3 start, vec3 dest){\n    start = normalize(start);\n    dest = normalize(dest);\n\n    float cosTheta = dot(start, dest);\n    vec3 rotationAxis;\n\n   \n\n    rotationAxis = cross(start, dest);\n\n    float s = sqrt( (1.+cosTheta)*2. );\n    float invs = 1. / s;\n\n    return vec4(\n\n        rotationAxis.x * invs,\n        rotationAxis.y * invs,\n        rotationAxis.z * invs,\n        s * 0.5\n    );\n\n}\n\nfloat text(vec2 uv)\n{\n    float col = 0.0;\n    \n    vec2 center = res/2.0;\n    \n    float hour = floor(iDate.w/60.0/60.0);\n    float minute = floor(mod(iDate.w/60.0,60.0));\n    float second = floor(mod(iDate.w,60.0));\n    \n   \tload(_qP1,\tqP1,\tvec4(0.));\n    load(_qP2,\tqP2,\tvec4(0.));\n\n    qP1.xyz=normalize(-qP1.xyz);\n    //Date Text\n    \n    print_pos = vec2(2, 2.0 + STRHEIGHT(2.0));\n    \n    TEXT_MODE = INVERT;\n    col += char(ch_N,uv);\n    col += char(ch_o,uv);\n    col += char(ch_r,uv);\n    col += char(ch_m,uv);\n    \n    TEXT_MODE = NORMAL;\n    col += char(ch_col,uv);\n    \n    TEXT_MODE = UNDERLINE;\n    col += print_number(qP1.x,uv);\n    col += char(ch_lsl,uv);\n    col += print_number(qP1.y,uv);\n    col += char(ch_lsl,uv);\n    col += print_number(qP1.z,uv);\n    \n        TEXT_MODE = INVERT;\n    col += char(ch_D,uv);\n    col += char(ch_i,uv);\n    col += char(ch_f,uv);\n    col += char(ch_f,uv);\n\n    TEXT_MODE = NORMAL;\n    col += char(ch_col,uv);\n \n    vec4 dif=RotationBetweenVectors(qP1.xyz,qP2.xyz);\n    TEXT_MODE = UNDERLINE;\n    col += print_number(dif.x,uv);\n    col += char(ch_lsl,uv);\n    col += print_number(dif.y,uv);\n    col += char(ch_lsl,uv);\n    col += print_number(dif.z,uv);\n    col += char(ch_lsl,uv);\n    col += print_number(dif.w,uv);\n\n            TEXT_MODE = INVERT;\n  \n       Body ball=Body(0,\n                       vec3(0.,-.3,-4.),\n                       vec4(0.,0.,0.,1.),\n                       vec3(0.,0.,0.),\n                       vec3(0.,0.,0.),\n                       mat3(1.),\n                       10.,\n                       100.,\n                       vec3(0.),\n                       vec3(0.),\n                       vec4(0.),\n                       vec4(0.));\n\n            loadBody(ball,0.);\n     col += char(ch_C,uv);\n    col += char(ch_o,uv);\n    col += char(ch_l,uv);\n    col += char(ch_l,uv);\n\n    TEXT_MODE = NORMAL;\n    col += char(ch_col,uv);\n      \n    TEXT_MODE = UNDERLINE;\n    col += print_number(ball.vCol.x,uv);\n    col += char(ch_lsl,uv);\n    col += print_number(ball.vCol.y,uv);\n    col += char(ch_lsl,uv);\n    col += print_number(ball.vCol.z,uv);\n    col += char(ch_lsl,uv);\n    col += print_number(ball.vCol.w,uv);\n\n       col += char(ch_C,uv);\n    col += char(ch_m,uv);\n    col += char(ch_a,uv);\n    col += char(ch_t,uv);\n\n    TEXT_MODE = NORMAL;\n    col += char(ch_col,uv);\n      \n    TEXT_MODE = UNDERLINE;\n    col += print_number(ball.vColMat.x,uv);\n    col += char(ch_lsl,uv);\n    col += print_number(ball.vColMat.y,uv);\n    col += char(ch_lsl,uv);\n    col += print_number(ball.vColMat.z,uv);\n    col += char(ch_lsl,uv);\n    col += print_number(iMouse.w,uv);\n\n   \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   discard;\n    vec2 uv = fragCoord.xy / DOWN_SCALE;\n\tvec2 duv = floor(fragCoord.xy / DOWN_SCALE);\n \tres = iResolution.xy / DOWN_SCALE;   \n\tfloat pixel = text(duv);\n    \n    //Shading stuff\n    vec3 col = vec3(1);\n    col *= (1.-distance(mod(uv,vec2(1.0)),vec2(0.65)))*1.2;\n    col *= mix(vec3(0.),vec3(0,1,0),pixel);\n\n\tfragColor = vec4(vec3(col), 1.0);\n}", "name": "Buffer C", "description": "", "type": "buffer"}]}