{"ver":"0.1","info":{"id":"wlXyRj","date":"1592457451","viewed":8,"name":"path tracer implementation","username":"okdalto","description":"custom path tracer implementation","likes":0,"published":1,"flags":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n\n#define EP 0.001\n\nvoid rotX(inout vec3 z, float s, float c) {\n   z.yz = vec2(c*z.y + s*z.z, c*z.z - s*z.y);\n}\n\nvoid rotY(inout vec3 z, float s, float c) {\n   z.xz = vec2(c*z.x - s*z.z, c*z.z + s*z.x);\n}\n\nvoid rotZ(inout vec3 z, float s, float c) {\n   z.xy = vec2(c*z.x + s*z.y, c*z.y - s*z.x);\n}\n\nvoid rotX(inout vec3 z, float a) {\n   rotX(z, sin(a), cos(a));\n}\nvoid rotY(inout vec3 z, float a) {\n   rotY(z, sin(a), cos(a));\n}\n\nvoid rotZ(inout vec3 z, float a) {\n   rotZ(z, sin(a), cos(a));\n}\n\n\nfloat sdSphere(vec3 p){\n    return length(p) - 0.5;\n}\n\nfloat fractal(vec3 p){\n    rotX(p, iTime);\n    rotY(p, iTime);\n    rotZ(p, iTime);\n    for(int i = 0; i < 2; i++){\n        rotY(p, iTime);\n        if(p.x+p.y<0.0) p.xy = -p.yx; // fold 1\n        if(p.y+p.z<0.0) p.yz = -p.zy; // fold 2\n        if(p.z+p.x<0.0) p.zx = -p.xz; // fold 3   \n\n        p -= 0.5;\n    }\n    return length(p) - 0.85;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat opRep( in vec3 p, in vec3 c )\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return sdSphere( q );\n}\n\nfloat opRepLim( in vec3 p, in float c, in vec3 l )\n{\n    vec3 q = p-c*clamp(round(p/c),-l,l);\n    return sdSphere( q );\n}\n\n\nfloat sdf(vec3 p){\n    float sphere = fractal(p);\n    float plane = sdPlane(p, vec4(0,1,0, 2));\n    return min(sphere, plane);\n}\n\n\n\nvec3 getNormal(vec3 p){\n    vec2 ep = vec2(EP, 0);\n    return normalize(vec3(\n        sdf(p + ep.xyy) - sdf(p - ep.xyy),\n        sdf(p + ep.yxy) - sdf(p - ep.yxy),\n        sdf(p + ep.yyx) - sdf(p - ep.yyx)\n        ));\n}\n\nvec3 sampleRandomHemisphere(vec3 p, vec3 n){\n    vec3 randomVector = normalize(hash33(p * 10000.0 + iTime));\n\tfloat dotValue = dot(randomVector, n);\n    randomVector *= dotValue;\n    randomVector = normalize(randomVector);\n\n    return randomVector;\n}\n\nfloat shadow( in vec3 ro, in vec3 rd )\n{\n    float res = 0.0;\n    \n    float tmax = 12.0;\n    \n    float t = 0.001;\n    for(int i=0; i<80; i++ )\n    {\n        float h = sdf(ro+rd*t);\n        if( h<0.0001 || t>tmax) break;\n        t += h;\n    }\n\n    if( t>tmax ) res = 1.0;\n    \n    return res;\n}\n\n\nvec3 march(inout vec3 rayOrigin, inout vec3 rayDir, in vec3 lightPos, in int stage, inout int isOut){\n    vec3 col = vec3(0.0);\n    vec3 rayPos = rayOrigin;\n    float trvlDist = 0.1;\n    \n    for(int i = 0; i < 256; i++){\n        rayPos = rayOrigin + rayDir * trvlDist;\n        float dist = sdf(rayPos);\n        if(dist < EP){\n            vec3 norm = getNormal(rayPos);\n            vec3 lightDir = normalize(lightPos - rayPos);\n            //float diff = max(0.0, dot(norm, lightDir));\n            float fresnel = max(0.0, 1.0 - dot(-rayDir, norm));\n            fresnel = pow(fresnel, 0.2);\n            \n            //col = sampleRandomHemisphere(rayPos * float(i+1), norm);\n            //col = norm;\n            //col = texture(iChannel0, norm).xyz;\n            \n            rayOrigin = rayPos;\n            rayDir = mix(sampleRandomHemisphere(rayPos * float(stage+1), norm), reflect(rayDir, norm), fresnel);\n            //rayDir = mix(reflect(rayDir, norm), sampleRandomHemisphere(rayPos * float(stage+1), norm), fresnel);\n            rayDir = normalize(rayDir);\n            //rayDir = reflect(rayDir, norm);\n            \n            col = texture(iChannel0, rayDir).xyz * shadow(rayOrigin, rayDir);\n            \n            return col;\n        }\n        trvlDist += dist;\n        if(trvlDist > 16.0){\n            break;\n            isOut = 1;\n        }\n    }\n    return texture(iChannel0, rayDir).xyz;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv = (uv - 0.5) * 2.0;\n    \n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    \n    //vec3 cameraPos = vec3(0, 0, -5);\n    vec3 cameraPos = vec3(sin(iTime), 0.1, cos(iTime)) * 5.0;\n    //vec3 lightPos = vec3(sin(0.0), 0, cos(0.0)) * 10.0;\n    vec3 lightPos = vec3(-1) * 10.0;\n    \n    \n    vec3 up = vec3(0,1,0);\n    vec3 front = normalize(-cameraPos);\n    vec3 right = normalize(cross(up, front));\n    up = normalize(cross(front, right));\n    float iterJ = 32.0;\n    float iterI = 4.0;\n    \n    for(int j = 0; j < int(iterJ); j++){\n        vec3 rayPos = cameraPos;\n    \tvec3 rayDir = normalize(up * uv.y + front + right * uv.x);\n        float trvlDist = 0.0;\n\n        int isOut = 0;\n        int count = 0;\n        for(int i = 0; i < int(iterI); i++){\n            col += march(rayPos, rayDir, lightPos, j, isOut);\n            if(isOut == 1){\n                break;\n            }\n            count ++;\n        }\n        //\n    }\n    col /= iterJ * iterI;\n    \n    //col = pow(col, vec3(1.0/2.2));\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n    //fragColor = vec4(clamp(col/4096.0, 0.0, 1.0),1.0) + backPixels;\n\n}\n\n\n","name":"Image","description":"","type":"image"}]}