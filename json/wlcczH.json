{"ver":"0.1","info":{"id":"wlcczH","date":"1608518451","viewed":191,"name":"vesica()+mossEgg()=Pear() Joint","username":"ollj","description":"cci(radius,radius,distance.x) = circleCircleIntersection\ncci generates both, (bi)Vesica (up half) and MossEgg(low half) \nyou either add radius3 to both others or subtract it from both other radii.\nand if you do one on each half, you get a Pear/Joint/Smile","likes":4,"published":3,"flags":0,"usePreview":0,"tags":[]},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":" //#define FoldColors\n\n//very early version, only calculates correct circle positions\n//just s proof of concept\nvec4 circles4(vec2 u,vec2 m,vec2 n,float d//uv, 4 radii (red green blue yellow), distance (red to green)\n){u=fra(iR,u)\n ;vec4 r=vec4(m,n)//4 circle radii, (red,green,blue,blue)\n ;vec4 c=vec4(length(u)-r.x)//red circle\n ;c.y=length(u-vec2(d,0))-r.y//green circle\n ;vec2 ci=vec2(0)//2 circleCircleIntersections, for 2 blue circles\n ;ci.x=cci(r.x+r.z,r.y+r.z,d)//+r.z\n ;ci.y=cci(r.x-r.w,r.y-r.w,d)//-r.w\n ;vec2 cBlue=vec2(ci.x, pythagoras(vec2(r.x+r.z,ci.x)))//+(+r.z)\n ;vec2 cYell=vec2(ci.y, pythagoras(vec2(r.x-r.w,ci.y)))//-(-r.w)\n ;c.z=length(u-cBlue)-(r.z)//blue     circle\n ;c.w=length(u-cYell)-(r.w)//yellow.w circle\n ;c=abs(c)-.005 //4 rings of thichness\n ;c=ss(0.003,c) //4 smoothstep\n ;return c;}\n \n//first rather messy segmentation, still shows circles (ditheres)\n//is messy, overly explicit, and unoptimized, to debug or extend\nvec4 segments4(vec2 u,vec2 m,vec2 n,float d//uv, 4 radii (red green blue yellow), distance (red to green)\n){vec2 v=fra(iR,u)\n ;vec4 r=vec4(m,n)//4 circle radii, (red,green,blue,blue)\n ;vec2 cRed=vec2(0)//red circle center is always vec2(0)\n ;vec2 cGreen=vec2(d,0)\n ;vec2 ci=vec2(0)//2 circleCircleIntersections, for 2 blue circles\n ;//2 tangent-circle centers (ble and yellow)\n ;//.x = circleCircleIntersection\n ;ci.x=cci(r.x+r.z,r.y+r.z,d)//+r.z\n ;ci.y=cci(r.x-r.w,r.y-r.w,d)//-r.w\n ;//.y = pythagoras(radiusSums,.x)\n ;vec2 cBlue=vec2(ci.x,pythagoras(vec2(r.x+r.z,ci.x)))//+(+r.z)\n ;vec2 cYell=vec2(ci.y,pythagoras(vec2(r.x-r.w,ci.y)))//-(-r.w)\n ;//get distances to 4 points, minus 4 radii.\n ;vec4 c=vec4(0)\n ;c.x=length(v-cRed  )-r.x//red      circle/distance\n ;c.y=length(v-cGreen)-r.y//green    circle/distance\n ;c.z=length(v-cBlue )-r.z//blue     circle/distance\n ;c.w=length(v-cYell )-r.w//yellow.w circle/distance\n ;//segmentate\n ;//upper and lower SEGMENTATIONS behave differently\n ;vec2 e=vec2(0)\n ;if(v.y>0.\n ){e= vec2(sd2l(v,cRed  ,cBlue),sd2l(v,cBlue,cGreen))\n ;}else{     \n  ;e=-vec2(sd2l(v,cGreen,cYell),sd2l(v,cYell,cRed  ))\n ;}\n ;e=sign(e)\n ;//dither 2 views\n ;u=mod(u,2.)\n ;if(u.x==u.y\n ){c=abs(c)-.01 //4 rings of thichness\n  ;c=ss(0.003,c) //4 smoothstep\n ;}else{\n  ;//fold sections to 2 colors that are a piecewise DistanceField\n  ;if(e.x<0.&&e.y<0.//inner blue part\n  ){c.x=0.;c.y=0.;c.z=max(-c.z,c.w);c.w=0.\n  ;}else{//outer red part (can overlap in upper area, so its a miin)\n   ;c.z=0.;c.w=0.;c.x=min(c.x,c.y);c.y=0.\n  ;}\n  ;//c=fract(c*8.)\n  ;c.xz=mix(fract(c.xz*8.)*.5,fract(c.xz*8.)*.5+.5,sign(-c.xz)*.5+.5)\n              \n  ;//fold 2 segment to monochrome\n  //#define FoldColors\n  #ifdef FoldColors\n  ;c.x+=c.z\n  ;c.z=0.\n  #endif\n ;}\n ;return c;}\n \n//working version, retrns vec4, but only .xz matter\nvec4 pear(vec2 u,vec2 m,vec2 n,float d//uv, 4 radii (red green blue yellow), distance (red to green)\n){vec2 v=fra(iR,u)\n ;vec4 r=vec4(m,n)//4 circle radii, (red,green,blue,blue)\n ;vec2 cRed=vec2(0)//red circle center is always vec2(0)\n ;vec2 cGreen=vec2(d,0)\n ;vec2 ci=vec2(0)//2 circleCircleIntersections, for 2 blue circles\n ;//2 tangent-circle centers (ble and yellow)\n ;//.x = circleCircleIntersection\n ;ci.x=cci(r.x+r.z,r.y+r.z,d)//+r.z\n ;ci.y=cci(r.x-r.w,r.y-r.w,d)//-r.w\n ;//.y = pythagoras(radiusSums,.x)\n ;vec2 cBlue=vec2(ci.x,pythagoras(vec2(r.x+r.z,ci.x)))//+(+r.z)\n ;vec2 cYell=vec2(ci.y,pythagoras(vec2(r.x-r.w,ci.y)))//-(-r.w)\n ;\n ;//segmentate\n ;//upper and lower SEGMENTATIONS behave differently\n ;vec2 e=vec2(0)\n ;if(v.y>0.){e=vec2(sd2l(v,cRed  ,cBlue),sd2l(v,cBlue,cGreen))\n ;}else{     e=vec2(sd2l(v,cYell,cGreen),sd2l(v,cRed,cYell  ))\n ;}\n ;e=sign(e)\n ;//fold sections to 2 colors that are a piecewise DistanceField\n ;vec4 c=vec4(0)//return color\n ;if(e.x<0.&&e.y<0.//inner blue part\n ){c.z=max(-length(v-cBlue )+r.z,length(v-cYell )-r.w)\n ;}else{//outer red part (can overlap in upper area, so its a miin)\n  c.x=min(length(v-cRed  )-r.x,length(v-cGreen)-r.y)\n ;}\n ;//fold 2 segment to monochrome\n //#define FoldColors\n //#ifdef FoldColors\n  ;c.x+=c.z;c.z=0.\n //#endif\n ;return c;}\n \nvoid mainImage( out vec4 O, in vec2 u\n){vec2 m=iMouse.xy\n ;//u.x+=iR.y*.5\n ;vec2 n=abs(iMouse.zw)\n ;m=abs(fra(iR,m))\n ;n=abs(fra(iR,n))\n  ;\n ;float t=iTime*2.+15.\n ;\n ;//5 parameters (4 set by iMouse, or overwritten here\n ;float dist=1.//distance.x between red and green circle\n ;//m.x=  //left  end    circle radius (red)\n ;//m.y=  //right end    circle radius (green)\n ;//n.x=.3  //top  inner   circle radius (blue)\n ;//n.y=1.5 //bottom outer circle radius (yellow) (should be > m.x+m.y)\n ;if(iMouse.z>0.)n.y=5.*(cos(t*sqrt(7.)*.5+.5)*.5+.5)+m.x+m.y//lower outer radius\n ;//if(iMouse.z>0.)n.y=(dist-m.x-m.y)*mix(1.,5.,cos(iTime*.5)*.5+.5)\n ;\n ;if(iMouse.z<=0.//animate whime louse is up  must b1>=, or initiation if bad\n ){m.x=.7*(sin(t               )*.5+.5) //left radius\n  ;m.y=.7*(sin(t*sqrt(5.)*.5+.5)*.5+.5) //right radius\n  ;m.xy+=.02//minimum circle to emphasize roundness\n  ;n.x=1.*(cos(t*sqrt(2.)*.5+.5)*.5+.5) //upper inner radius\n  ;n.y=5.*(cos(t*sqrt(7.)*.5+.5)*.5+.5)+m.x+m.y//lower outer radius\n  ;dist=.5*mix(.3,2.\n           ,1.*(sin(t*sqrt(3.)*.5+.5)*.5+.5))+(m.x+m.y)*.5\n ;} \n ;\n ;//worksafing inputs\n ;float betterSafeThanNull=1./iR.x\n ;//blue circle is at least large enough to touch red AND green\n ;n.x=max(n.x,(dist-m.x-m.y)*.5+betterSafeThanNull)\n ;//yellow circle is at SMALL enough to contain green and blue\n ;n.y=max(n.y,(dist+m.x+m.y)*.5+betterSafeThanNull)\n ;\n ;vec4 c=vec4(0)//return value\n ;float a=1.; ;//chose one of 3 [stages of development];\n ;if(iMouse.z>0.)a=floor(mod(t+1.,7.))         //on mouse down\n ;else a=float(fra(iR,u).x>sin(iTime*.2)*2.)*6.+1.//on mouse up\n ;//3 [stages of development];\n ;     if(a<1.)c=circles4(u,m,n,dist) //draw only circles\n ;else if(a<5.)c=segments4(u,m,n,dist)//mix between above and below\n ;else        {c=pear(u,m,n,dist)\n              ;c.xz=mix(fract(c.xz*8.)*.5,fract(c.xz*8.)*.5+.5,sign(-c.xz)*.5+.5)\n              ;}\n ;//todo, more userfriendly MossEgg-like wrapper (nrormalize [dist] to 1)\n ;//todo, CSG sign swapping fun (as in my vesica shader)\n ;//todo, put in dragAndDrop Ui Canvas of \n ;//...   https://www.shadertoy.com/view/WdGfRw\n ;//todo, parametrization\n ;\n ;c.xy+=c.w//yellow\n ;O=vec4(c.xyz,1);}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define iR iResolution\n#define u2(a) (a)*2.-1.\n\n#define ss(a,b) smoothstep (a,-a,b)\n\n#define ViewZoom 2.\n#define fra(r,u) ((u-.5*r.xy)*ViewZoom/r.y)\n\nvec2 fra2(vec3 r,vec2 u\n){u=u/r.xy \n ;u.x*=r.x/r.y\n ;return u2(u);}\n\n//return circle-circle-intersection.x; r.x=circle.left.radius;r.y=circle.right.radius;r.z=circles.centers.distance\nfloat cci(vec3 r){float d=r.z*2.;r*=r;return(r.x-r.y+r.z)/d;}\nfloat cci(float a,float b,float c){return cci(vec3(a,b,c));}\n//does not check for non-intersecticn cases! \n//intersection.y can be calculated by pythagoras()   \n\n//pythagoran theorem: a.x=hypothenuse\nfloat pythagoras(vec2 a){a*=a;return sqrt(a.x-a.y);}\n//float su(vec2 a){return a.x-a.y;}\n//float su(vec3 b){return a.x-a.y-a.z;}\n//float su(vec4 b){return a.x-a.y-a.z-a.y;}\n//#define pythagoras(a) sqrt(-su(-(a*a)))\n\n //return SIGNED distance of u to line trough m.xy and m.zw\nfloat sd2l(vec2 u, vec4 m\n){//vec2 d=m.xy;vec2 e=m.zw;//2 points to define a line.\n ;//c.g=min(length(u-d),length(u-e))-.1;//draw 2 points\n ;vec2 f=m.zw-m.xy;f=vec2(-f.y,f.x)//calculate dorated differential\n ;//no need to normalize() f, because we only care for the sign \n ;return dot(u-m.xy,(f));}//signed distance to line \nfloat sd2l(vec2 u, vec2 a,vec2 b){return sd2l(u,vec4(a,b));}","name":"Common","description":"","type":"common"}]}