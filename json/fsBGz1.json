{"ver": "0.1", "info": {"id": "fsBGz1", "date": "1616914602", "viewed": 141, "name": "Atmosphere Scattering Shader", "username": "playbyan1453", "description": "Sky texture modified with rayleigh and mie scattering, this is forked shader. The original one was 2D version of this. This version just much more better cause you can control the sun in 3D space.", "likes": 1, "published": 1, "flags": 0, "usePreview": 0, "tags": [], "requires": ["imagebuf"]}, "renderpass": [{"inputs": [], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "/*-Code Witten By robobo1221\n  -Modified By playbyan1453\n  Now you can implement this shader on 3D space\n  all thanks to shadertoy and paper that I found*/\n#define rayleighCoeff vec3(0.5, 1.0, 1.8) * 1e-5\n#define mieCoeff vec3(1e-6)\n#define pi 3.14159265358979\n#define d0(x) abs(x) + 1e-8\n#define sunSize 0.9998\n\nvec3 totalCoeff = mieCoeff + rayleighCoeff;\n\nvec3 scatter(vec3 coeff, float depth) {\n    return coeff * depth;\n}\n\nvec3 absorb(vec3 coeff, float depth) {\n    return exp2(scatter(coeff, -depth));\n}\n\nfloat calcParticleThickness(float depth) {\n    depth = depth * 2.0;\n    depth = max(depth + 0.01, 0.01);\n    depth = 1.0 / depth;\n\n    return 1e5 * depth;\n}\n\nfloat rayleighPhase(vec3 p, vec3 lp) {\n    return 0.375 * (1.0 + pow(dot(p, lp), 2.0));\n}\n\nfloat miePhase(vec3 p, vec3 lp, float depth) {\n    float g = exp2(-1e-6 * depth);\n    float g2 = pow(g, 2.0);\n    return 0.25 * ((1.0 - g2) * pow(1.0 + g2 - 2.0*g*dot(p, lp), -1.5));\n}\n\nvec3 calcAtmosphericScatter(vec3 p, vec3 lp) {\n    const float ln2 = log(2.0);\n\n    float opticalDepth = calcParticleThickness(p.y);\n    float opticalDepthLight = calcParticleThickness(lp.y);\n\n    vec3 scatterView = scatter(totalCoeff, opticalDepth);\n    vec3 absorbView = absorb(totalCoeff, opticalDepth);\n\n    vec3 scatterLight = scatter(totalCoeff, opticalDepthLight);\n    vec3 absorbLight = absorb(totalCoeff, opticalDepthLight);\n\n    vec3 absorbSun = abs(absorbLight - absorbView) / d0((scatterLight - scatterView) * ln2);\n    vec3 rayleighScatter = scatter(rayleighCoeff, opticalDepth) * rayleighPhase(p, lp);\n    vec3 mieScatter = scatter(mieCoeff, opticalDepth) * miePhase(p, lp, opticalDepth);\n    vec3 scatterSun = rayleighScatter + mieScatter;\n\n    vec3 sunSpot = smoothstep(sunSize, sunSize+0.00002, dot(p, lp)) * absorbView * (pi * 2.0);// at confused out the real sizeabbi\n\n    return (scatterSun * absorbSun + sunSpot) * pi;\n}\n\nvec3 ACESFilm(vec3 x) {\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x + b)) / (x*(c*x + d) + e), 0.0f, 1.0f);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = (uv-.5) * vec2(2, 1) * acos(-1.0);\n    vec3 rd = vec3(cos(uv.x), tan(uv.y), sin(uv.x)) * cos(uv.y);\n    rd = normalize(rd);\n\n    vec3 col = vec3(0);\n    float epsilon = 1e-6;\n    float e = iTime*0.1;\n    vec3 l = normalize(vec3(0, sin(e), -cos(e)));\n    col = calcAtmosphericScatter(rd-epsilon*2.0, l+epsilon);\n    col = ACESFilm(col);\n\n    fragColor = vec4(col, 1.0);\n}", "name": "Image", "description": "", "type": "image"}]}