{"ver": "0.1", "info": {"id": "fdyXDR", "date": "1634534575", "viewed": 147, "name": "Octree Basic [Commented]", "username": "Yusef28", "description": "First Octree Shader\nHere is a lightly stylized version with comments on lighting and coloring\nhttps://www.shadertoy.com/view/NdGXWh", "likes": 11, "published": 3, "flags": 0, "usePreview": 0, "tags": [], "requires": ["imagebuf"]}, "renderpass": [{"inputs": [], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "//////////////////////////////////////////////////////\n// Octree Basic [Commented] By Yusef28\n// Purpose: Demonstrates A simplified Octree Shader Implentation\n// Well commented and fit for some educational purposes\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//And a lightly stylized version can be found here:\n//https://www.shadertoy.com/view/NdGXWh\n\n/* \n\nNotably, the first octree shaders I stumbled on were from abje\nalthough it seems they are using a different approach.\nHere is the main one: https://www.shadertoy.com/view/4sVfWw\nHere is one with lighting and shadow: https://www.shadertoy.com/view/XdyfRy\n\nMy version is \"stackless\" there is no bidiretional movement\nbetween levels of the tree. We always start at the top and\nwe get spit out somewhere along the way down. \n\nSo for each step in our traversal we have to jump into the tree\nfrom the top again and work down to get the next cell scale factor.\n\nWith a stack and with bidirectional movement I'm guessing\nyou don't have to leave the tree between steps, you just swing\nfrom vine to vine. Not completely sure yet though.\n\n***************************************************\nThe code for this 3D Octree is shorter than for\nthe 2D Quadtree it's based on! https://www.shadertoy.com/view/7dVSRh\nMainly because I draw lines and cirles in that one though and\nit could be more concise.\n\n*****************************************************\nIssues I ran into while writing this where I had to just\nuse intuition and play around with things until things worked out\n\nInitially:\nI found the ray origin needed to be shifter by epsilon\nto avoid really bad artifacts\n\nCurrently:\nI found the t value returned from tCalc() need to have epsilon\nadded to it to avoid really bad artifacts\n\nCurrently:\nthe value FAR needs to be atleast 100 or we get some\nweird cloud things that arn't clouds at all.\n\nFixed:\nI needed a way to create a hole where the camera would \nbe with out any octree cells being rendered and\n\n\n*/\n\n\n#define pi acos(-1.)\n#define eps 1./iResolution.y\n#define MAX_LEVEL 8.\n#define FAR 100.\n\n\n//Rotation matrix for the ray direction \nmat2 rot(float a){\n    float c = cos(a), s = sin(a); return mat2(c,-s,s,c);}\n    \n\n//  1 out, 3 in... from dave hoskins for the quad/octree\nfloat hash13(vec3 p3)\n{\n\tp3 = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n\n// SHORTER, NEATER, BRANCHLESS, UNIQUE, SINGULAR PURPOSE\n// This quad/octree map function returns the largest scaling factor \n//for a given posision\n// the inverse of that is the cell size\nfloat mapQ(vec3 p){\n  float s = 0.5;\n  for(float i = 1.; i < MAX_LEVEL; i++){\n    s *= 2.;\n    //if we don't pass the random check, add max to index so we break\n    i += step( hash13(floor(p * s)), 0.5 ) * MAX_LEVEL;\n  }\n  return s;\n}\n\n//This DDA algo is based on the lodev Raycasting tutorial\n// https://lodev.org/cgtutor/raycasting.html\n//and the modification is from my quadtree traversal\n//shader: https://www.shadertoy.com/view/7dVSRh\n//I explain the idea in the comments.\n//basically though we find the first axis the ray will \n//hit when traveling in the ray direction and return the \n//distance to that axis.\n//Firsst we get the \"scale factor\" from the qaudtree map so\n//we know what size box we are in. Then we find our distances\n//for each axis and return the smallest. More detail is given in\n//the link above.\nfloat calcT(vec3 p, vec3 rd, vec3 delta){\n    float s = mapQ(p);\n    vec3 t;\n    \n    t.x = rd.x < 0. ? ((p.x*s - floor(p.x*s))/s)*delta.x\n                    : ((ceil(p.x*s) - p.x*s)/s)*delta.x; \n                    \n    t.y = rd.y < 0. ? ((p.y*s - floor(p.y*s))/s)*delta.y\n                    : ((ceil(p.y*s) - p.y*s)/s)*delta.y; \n    \n    t.z = rd.z < 0. ? ((p.z*s - floor(p.z*s))/s)*delta.z\n                    : ((ceil(p.z*s) - p.z*s)/s)*delta.z; \n\n                    //+0.01 to get rid of a bunch of artifacts\n    return min(t.x,min(t.y,t.z))+0.001;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n    \n    \n    //This is the canonical orthonormal basis for a camera \n    //ray in the uv plane. \n    vec3 fwd = vec3(0.,0.,1.);\n    vec3 up = vec3(0.,1.,0.);\n    vec3 right = normalize(cross(up,fwd));\n    up = cross(fwd,right);\n    vec3 ro = vec3(0., iTime/6.,0.);\n    vec3 rd = right*uv.x + up*uv.y + fwd;\n    rd = normalize(rd);\n    \n    //rotating the raydirection to look around.\n    rd.xz *= rot(iTime/6.);\n    \n    //get the delta which is explained in the lodev tutorial\n    //on raycasting: https://lodev.org/cgtutor/raycasting.html\n\tvec3 delta = 1./max(abs(rd), eps);\n    float t = 0.;\n    \n    //It all comes together in this small iteration loop.\n    //We are updating t just like in raymarching.\n    //The only \"sdf\" we use though is the \"hole\" rect tunnel\n    //We only render a block if our hash returns < 0.4 AND\n    // the hit point of the block is outside of the sdf (hole > 0.001)\n    for(float i = 0.; i < FAR; i++){\n        vec3 pos = ro + rd * t;\n        float ss = mapQ(pos);\n\n        //create the hole / shield so blocks stop\n        //hitting me in the face\n        vec3 shi = abs(floor(pos-ro)) - 1.;\n        //the hole. Basically a vertical rectangular/square tunnel\n        float hole = max( shi.x, shi.z);\n        \n        //n = calcN(pos, rd, delta);\n        //check the hole AND check the random missing squares\n        //if we are out of the hole AND not hitting a missint square\n        //then break!\n        if(hole > 0.001 && hash13(floor((pos)*ss)) > .4) break;\n        \n        //updating t with the modified DDA algo.\n        t += calcT(pos, rd, delta);\n    }\n    \n    fragColor = vec4(pow(vec3(clamp(1.-t/7.,0.,1.))*1.3,vec3(4.)),1.);\n}", "name": "Image", "description": "", "type": "image"}]}