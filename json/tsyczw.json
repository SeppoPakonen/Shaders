{"ver": "0.1", "info": {"id": "tsyczw", "date": "1614001959", "viewed": 291, "name": "Just Cause 3 - A Tribute", "username": "Mathis", "description": "I love this game!\nPress or hold I to reinject the lights if the resolution is changed.\n\nClick on E to see Rico in action!", "likes": 9, "published": 1, "flags": 48, "usePreview": 1, "tags": [], "requires": ["library", "texturebuf", "keyboardbuf", "imagebuf", "texture"]}, "renderpass": [{"inputs": [{"id": "4dXGR8", "filepath": "/media/previz/buffer00.png", "previewfilepath": "/media/previz/buffer00.png", "type": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "4sXGR8", "filepath": "/media/previz/buffer02.png", "previewfilepath": "/media/previz/buffer02.png", "type": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "XdfGR8", "filepath": "/media/previz/buffer03.png", "previewfilepath": "/media/previz/buffer03.png", "type": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "XsBSR3", "filepath": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "type": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "/*\nA tribute to my favourite game.\n\n\n\n\nI used cubic-interpolated countours to render the terrain.\nSDF objects and lighs are sorted using a screen-space BVH.\nLightsources move using a gather approach, which is independent of the number of static and moving lights.\n\nIf you see possible improvements, don't hesitate to point them out!\n*/\n\nvec2 RandOffset(float t) {\n    //Returns random offsets in -1 to 1\n    float tf=floor(t*6.);\n    return mix(texture(iChannel1,vec2(tf+0.5,80.5)*I1024).xy,texture(iChannel1,vec2(tf+1.5,80.5)*I1024).xy,\n            fract(t*6.));\n}\n\nvec2 Bokeh_Sample(float theta) {\n    //Credit: http://www.adriancourreges.com/blog/2018/12/02/ue4-optimized-post-effects/\n    float r=cos(3.14159*0.2)/cos(mod(theta,2.*3.14159*0.2)-3.14159*0.2);\n    return vec2(sin(theta),cos(theta))*r;\n}\n\nvec3 SampleScene(vec2 uv) {\n    return Read(texture(iChannel3,uv).x).xyz;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //Sample stored vars\n    vec4 SV=texture(iChannel0,vec2(16.5,0.5)*IRES);\n    vec2 uv=fragCoord*IRES;\n    vec3 Dir=normalize(vec3((uv*2.-1.)*(ASPECT*CFOV),1.));\n    //Render terrain and lights\n    vec3 Color=vec3(0.);\n    if (SV.x<=0.5) {\n        //Samples light\n        Color=SampleScene(uv);\n    } else if (iTime-SV.y<10.) {\n        //Zoom, DOF, Rico, Jet, Lights\n        float rTime=iTime-SV.y; //Relative time\n        float Sine=pow(sin(rTime*0.1*3.14159),1.5);\n        //Zoom\n        vec2 target=vec2(1.05-0.3*rTime*0.1,0.6+0.005*rTime);\n        vec2 uvtarget=mix(target,vec2(0.75,0.62),exp(-rTime));\n        float InvZoom=1.-Sine;\n        uv=mix(uvtarget-0.02+uv*0.04,uv,InvZoom)+\n            mix(0.003,0.,InvZoom)*RandOffset(rTime);\n        //DOF\n        vec2 DOF_RAND=texture(iChannel1,floor(fragCoord)*I1024).xz;\n        float DOF_S=pow(Sine,0.5)*4.*(0.1+0.9*DOF_RAND.y);\n        float DOF_RAND_A=(0.05+0.9*DOF_RAND.x)*IDOF_A;\n        for (float i=0.; i<DOF_N; i++) {\n            Color+=SampleScene(uv+Bokeh_Sample(i*IDOF_A+DOF_RAND_A)*DOF_S*IRES);\n        }\n        Color*=IDOF_N;\n        //Render the lights on the jet\n        vec2 JetSize=vec2(10.)/(840.*CFOV)*0.5;\n        vec2 JetBurner=target-JetSize*0.5+vec2(JetSize.x*0.8,JetSize.y*0.1);\n        float BurnerT=max(-(Line2(uv,JetBurner,JetBurner+vec2(0.01,0.))/0.003-80.*(uv.x-JetBurner.x)),0.);\n        Color.xyz+=ITC(0.5+0.4*BurnerT)*(6.*BurnerT*max(0.,1.-1.8*(uv.x-JetBurner.x)/JetSize.x));\n        //Render Jet\n        if (Box2(uv-(target-JetSize*0.5),JetSize)<0. && 840.<texture(iChannel2,uv).w*Dir.z)\n            Color.xyz*=texture(iChannel0,vec2(0.5,0.)+0.5*(uv-(target-JetSize*0.5))/JetSize).x;\n        //Render Rico\n        vec2 RicoSize=vec2(7.2)/(840.*CFOV)*0.5;\n        vec2 ruv=uv-(target-RicoSize*0.5-vec2(0.,-0.00055));\n        if (rTime>5. && rTime<5.5) {\n            //Backflip\n            float tmpt=2.*(rTime-5.);\n            ruv-=vec2(tmpt*tmpt*0.005,0.0035*tmpt);\n        } else if (rTime>=5.5) {\n            //Parachute\n            float tmpt=2.*(rTime-5.5);\n            ruv=uv-(target-RicoSize*0.5-vec2(-0.005-0.005*tmpt-0.005*pow(tmpt,1.4),-0.0035));\n        }\n        if (Box2(ruv,RicoSize)<0. && 840.<texture(iChannel2,uv).w*Dir.z)\n            Color.xyz*=mix(texture(iChannel0,vec2(0.5,0.5)+0.5*ruv/RicoSize).x,1.,(rTime-5.5)/4.5);\n    } else if (iTime-SV.y>=10. && iTime-SV.y<=14.) {\n        //Shaking\n        float Sine=sin(clamp((iTime-SV.y-10.5)*0.3,0.,1.)*3.14159);\n        float InvZoom=1.-Sine;\n        uv=mix(0.01+uv*0.98,uv,InvZoom)+\n            mix(0.005*pow(Sine,2.),0.,InvZoom)*RandOffset((iTime-SV.y-10.)*3.);\n        //Explosion sampling, flying rico\n        Color=SampleScene(uv);\n        Color+=texture(iChannel0,uv*0.499+vec2(0.,0.5)).xyz;\n        //Explosion light\n        vec4 TerAttr=texture(iChannel2,uv);\n        vec3 PixelP=CAMERA_P+Dir*TerAttr.w;\n        vec3 PixelN=Read(TerAttr.y).xyz*2.-1.;\n        float lPTL=length(vec3(500.,260.,840.)-PixelP);\n        vec3 PTL=(vec3(500.,260.,840.)-PixelP)/lPTL;\n        Color+=vec3(1.,0.15,0.01)*max(0.,dot(PixelN,PTL))*(500./(1.+pow(lPTL,1.5)))* //PBR, what's that?\n            pow(max(0.,sin((iTime-SV.y-10.)*0.25*3.14159)),0.5);\n    } else {\n        Color=SampleScene(uv);\n    }\n    //Gamma correction\n    fragColor=vec4(pow(Color,vec3(0.45)),1.);\n}", "name": "Image", "description": "", "type": "image"}, {"inputs": [], "outputs": [], "code": "//SETTINGS\nconst float DOF_N=6.;\n\n//CONSTANTS\nstruct BVH_HIT { float D; vec3 N; vec3 C; };\nconst float IDOF_N=1./DOF_N; //User specified\nconst float IDOF_A=IDOF_N*3.141592653*2.;\nconst vec3 CAMERA_P=vec3(0.,40.,0.); //Camera\nconst float FOV=100.;\nconst float CFOV=atan(radians(FOV)*0.5);\nconst float RADIAN=2.*3.141592653;\nconst float IRADIAN=1./RADIAN;\nconst vec3 SkyColor=vec3(0.02,0.08,0.2); //Colors\nconst vec3 AmbientColor=vec3(0.2,0.5,0.75);\nconst vec3 GrassColor=vec3(0.1,0.2,0.06);\nconst vec3 IGrassColor=1./GrassColor;\nconst vec3 LightDir=normalize(vec3(1.,1.,-5.)); //Light direction\nconst vec3 WaveDir=normalize(vec3(-0.25,0.,1.)); //Water\nconst vec3 OWaveDir=cross(WaveDir,vec3(0.,1.,0.));\nconst float I1024=1./1024.; //Resolutions\nconst vec2 SDF_eps=vec2(0.01,0.); //SDF\nconst float f255=254./255.; //Read/Write\nconst float If255=1./f255;\nconst int NCONTOURS0=16; //Contours\nconst int NCONTOURS1=16;\nconst int NC016=NCONTOURS0*16;\nconst int NC116=NCONTOURS1*16;\nconst vec2 Offset3[8]=vec2[8](vec2(1.,0.),vec2(1.),vec2(0.,1.),vec2(-1.,1.),\n                              vec2(-1.,0.),vec2(-1.),vec2(0.,-1.),vec2(1.,-1.));\nconst float Contours0[NC016]=float[NC016](\n     -5. ,-8. ,-20. ,-10.,-10. ,-20. ,-20. ,-20. ,-20. ,-20. ,-20. ,-20. ,-20. ,-20. ,-20. ,-20. //4, first hill\n    ,20. ,13. ,4.  ,-5. ,-1. ,-9. ,-9. ,-7. ,0.1 ,0.2 ,0.3 ,0.2 ,0.1 ,-1. ,-4. ,-9.\n\t,28. ,28. ,24. ,17. ,19. ,22. ,24. ,7.  ,28. ,8.  ,6.  ,2.  ,-9. ,-4. ,-9. ,-9.\n    ,30. ,29. ,45. ,20. ,22. ,24. ,28. ,41. ,49. ,46. ,4.5 ,4.  ,2.  ,-1. ,-9. ,-9.\n    \n    ,125.,100.,50. ,65. ,-9. ,-9. ,-9. ,-9. ,-9. ,-9. ,-9. ,-9. ,-9. ,-9. ,-9. ,-9. //4, first bay\n    ,143.,120.,88. ,39. ,10. ,-9. ,-9. ,-9. ,-9. ,-9. ,-9. ,-9. ,-9. ,-9. ,-9. ,-9.\n    ,162.,124.,55. ,54. ,10. ,-9. ,-9. ,-9. ,-9. ,-9. ,-9. ,-9. ,-9. ,-9. ,-9. ,-9.\n    ,180.,164.,65. ,30. ,10. ,-1. ,-2. ,-1. ,-2. ,-2. ,-1. ,-3. ,-9. ,-9. ,-9. ,-9.\n    \n    ,100.,77. ,90. ,85. ,10. ,25. ,18. ,22. ,10. ,23. ,24. ,1.  ,-9. ,-9. ,-9. ,-9. //2, second smaller hill\n    ,100.,50. ,80. ,90. ,40. ,36. ,30. ,30. ,34. ,33. ,5. ,-9. ,-9. ,-9. ,-9. ,-9.\n    \n    ,50. ,50. ,90. ,90. ,70. ,10. ,-9. ,-9. ,-9. ,-9. ,-9. ,-3. ,-9. ,-9. ,-9. ,-9. //4, second bigger bay\n    ,140.,150.,150.,150.,30. ,10. ,-9. ,-9. ,-9. ,-9. ,-9. ,-3. ,-9. ,-9. ,-9. ,-9.\n    ,140.,150.,150.,150.,40. ,39. ,-9. ,-9. ,-9. ,-9. ,-9. ,-3. ,-9. ,-9. ,-9. ,-9.\n    ,140.,150.,150.,150.,62. ,-60.,-9. ,-9. ,60. ,70. ,60. ,20. ,1.  ,-9. ,-9. ,-9.\n    \n    ,140.,150.,150.,150.,82. ,79. ,73. ,100.,110.,115.,112.,-50.,-9. ,-9. ,-9. ,-9.   //2, base hill\n    ,140.,150.,150.,150.,100.,80. ,95. ,100.,110.,50. ,40. ,-9. ,-4. ,-9. ,-9. ,-9.\n\t);\nconst float Contours1[NC116]=float[NC116](\n     -9. ,-9. ,-9. ,-9. ,-9. ,-9. ,-9. ,-9. ,-9. ,-9. ,-9. ,-9. ,-60.,-60.,-70.,-80. //4, Till flygbasen\n    ,30. ,50. ,40. ,35. ,50. ,40. ,50. ,30. ,50. ,40. ,55. ,50. ,45. ,50. ,50. ,-400.\n    ,330.,330.,340.,350.,340.,300.,250.,210.,360.,370.,380.,300.,180.,230.,170.,-1000. //Klippa\n    ,370.,370.,370.,385.,370.,370.,360.,350.,360.,370.,380.,280.,100.,-9. ,-9. ,-9.\n    \n    ,400.,400.,420.,440.,460.,450.,470.,480.,450.,470.,450.,430.,400.,480.,500.,400. //3, kontur med v\u00e4g\n    ,400.,400.,400.,240.,560.,510.,500.,530.,500.,590.,600.,520.,500.,470.,400.,300.\n    ,400.,400.,400.,400.,400.,500.,520.,570.,900.,780.,660.,660.,530.,490.,400.,300.\n    \n    //6, A 800m depth difference between foreground and mountain \n    ,-9. ,-9. ,-9. ,-9. ,-9. ,-9. ,-9. ,-9. ,780.,720.,650.,580.,-9. ,-9. ,400.,300.\n    ,-9. ,-9. ,-9. ,-9. ,-9. ,-9. ,-9. ,300.,-9. ,-9. ,-9. ,-9. ,-9. ,-9. ,-9. ,-9.\n    ,-9. ,-9. ,-9. ,-9. ,-9. ,-9. ,-9. ,300.,-9. ,-9. ,-9. ,-9. ,-9. ,-9. ,-9. ,-9.\n    ,-9. ,300.,-9. ,400.,-9. ,500.,400.,600.,300.,-9. ,-9. ,-9. ,-9. ,-9. ,-9. ,-9.\n    ,-9. ,300.,500.,600.,500.,200.,700.,900.,900.,500.,800.,800.,800.,400.,100.,100.\n    \n    ,100. ,-900.,1200.,1400.,1400.,1400.,1700.,2000.,1000.,1400.,1200.,1000. ,600.,100.,100.,100. //4, Mountain\n    ,100. ,-700.,1000.,1500.,1500.,1500.,1800.,2100.,1100.,1500.,1100.,1100. ,600.,100.,100.,100.\n    ,100. ,100. ,-900.,1700.,1800.,2400.,2600.,2900.,2000.,1700.,1400.,1300.,1100.,800.,100.,100. //Stor bas cont.\n    ,100. ,100. ,100. ,-900.,1500.,1500. ,100.,3010.,2400.,1200.,1200.,100. ,100.,100.,100.,100. //Peak\n    );\n//DEFINES\n#define IRES (1./iResolution.xy)\n#define epsx 0.1*IRES.x\n#define ASPECT vec2(iResolution.x/iResolution.y,1.)\n\n//Decode/encode from cornusammonis: https://www.shadertoy.com/view/Xlfcz8\nuint Write0(vec4 x) {\n\tx = clamp(x,-1.0, 1.0) * 127.0;\n    uvec4 sig = uvec4(mix(vec4(0), vec4(1), greaterThanEqual(sign(x),vec4(0))));\n    uvec4 mag = uvec4(abs(x));\n    uvec4 r = sig << 7 | mag;\n    return r.x << 24 | r.y << 16 | r.z << 8 | r.w;\n}\nvec4 Read0(uint x) {\n\tuvec4 r = (uvec4(x) >> uvec4(24, 16, 8, 0)) & uvec4(0xFF);\n    uvec4 sig = r >> 7;\n    uvec4 mag = r & uvec4(0x7F);\n    vec4 fsig = mix(vec4(-1), vec4(1), greaterThanEqual(sig,uvec4(1)));\n    vec4 fmag = vec4(mag) / 127.0;\n    return fsig * fmag;\n}\nvec4 Read(float x) {\n    return (Read0(floatBitsToUint(x))*0.5+0.5)*If255;\n}\nfloat Write(vec4 x) {\n    return uintBitsToFloat(Write0(x*f255*2.-1.));\n}\n\nfloat Write2(vec2 a) {\n    //Lazy pack\n    return a.x*f255+floor(a.y*1000.);\n}\nvec2 Read2(float a) {\n    //Lazy unpack\n    float tmp_fl=floor(a);\n    return vec2((a-tmp_fl)*If255,tmp_fl*0.001);\n}\n\n//MATH\nvec3 RandSample(vec2 v) {\n    float theta=sqrt(v.x);\n    float phi=2.*3.14159*v.y;\n    float x=theta*cos(phi);\n    float z=theta*sin(phi);\n    return vec3(x,z,sqrt(max(0.,1.-v.x)));\n}\n\nmat3 TBN(vec3 N) {\n    vec3 Nb,Nt;\n    if (abs(N.y)>0.999) {\n        Nb=vec3(1.,0.,0.);\n        Nt=vec3(0.,0.,1.);\n    } else {\n    \tNb=normalize(cross(N,vec3(0.,1.,0.)));\n    \tNt=normalize(cross(Nb,N));\n    }\n    return mat3(Nb.x,Nt.x,N.x,Nb.y,Nt.y,N.y,Nb.z,Nt.z,N.z);\n}\n\n//Bounding boxes\nfloat boxfar(vec3 origin, vec3 dir, vec3 bmin, vec3 bmax) {\n    vec3 tMin=(bmin-origin)*dir;\n    vec3 tMax=(bmax-origin)*dir;\n    vec3 t2=max(tMin,tMax);\n    return min(min(t2.x,t2.y),t2.z);\n}\n\nbool BBox(vec3 origin, vec3 dir, vec3 bmin, vec3 bdim, out vec2 bb) {\n    vec3 tMin=(bmin-origin)*dir;\n    vec3 tMax=(bmin+bdim-origin)*dir;\n    vec3 t1=max(tMin,tMax);\n    vec3 t2=min(tMin,tMax);\n    bb=vec2(max(max(t2.x,t2.y),t2.z),min(min(t1.x,t1.y),t1.z));\n    return (bb.x>0. && bb.y>bb.x);\n}\n\n//SDF functions\nstruct SDF_HIT { float D; vec3 C; float Mat; };\n\nfloat Box(vec3 p, vec3 b) {\n    vec3 d=abs(p-b*0.5)-b*0.5;\n    return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\n}\n\nfloat BoxC(vec3 p, vec3 b) {\n    vec3 d=abs(p)-b;\n    return min(max(d.x,max(d.y,d.z)),0.)+length(max(d,0.));\n}\n\nfloat Box2(vec2 p, vec2 b) {\n    vec2 d=abs(p-b*0.5)-b*0.5;\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\nfloat BoxC2(vec2 p, vec2 b) {\n    vec2 d=abs(p)-b;\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\nfloat Plane(vec3 p, vec3 n, float offs) {\n\treturn dot(p,n)-offs;\n}\n\nfloat Line(vec3 p, vec3 a, vec3 b) {\n    vec3 ba=b-a;\n    float k=dot(p-a,ba)/dot(ba,ba);\n    return length((a+clamp(k,0.,1.)*(b-a))-p);\n}\n\nfloat Line2(vec2 p, vec2 a, vec2 b) {\n    vec2 ba=b-a;\n    float k=dot(p-a,ba)/dot(ba,ba);\n    return length((a+clamp(k,0.,1.)*(b-a))-p);\n}\n\nfloat CappedCylinder(vec3 p, float h, float r) {\n    vec2 d=abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\n\nfloat Pyramid(vec3 p, float h) {\n    float m2 = h*h + 0.25; \n    p.xz = abs(p.xz); p.xz = (p.z>p.x) ? p.zx : p.xz; p.xz -= 0.5;\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n    float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\nfloat Octahedron(vec3 p, float s) {\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nvec2 Rotate(vec2 p, float ang) {\n    float c=cos(ang), s=sin(ang);\n    return vec2(p.x*c-p.y*s,p.x*s+p.y*c);\n}\n\nvec2 Repeat(vec2 p, float n) {\n    float ang=2.*3.14159/n;\n    float sector=floor(atan(p.x,p.y)/ang+0.5);\n    p=Rotate(p,sector*ang);\n    return p;\n}\n\nfloat SMIN(float a, float b, float k) {\n    float h=clamp(0.5+0.5*(b-a)/k,0.,1.);\n    return mix(b,a,h)-k*h*(1.-h);\n}\n\nvoid MIN(inout vec4 df, vec4 a) {\n    if (a.w<=df.w) df=a;\n}\n\n//SDF objects (vec4(Color.xyz, Dist))\nvec4 SDF_Tunnel(vec3 p) { //10, 9, 80\n    vec4 ret=vec4(vec3(min(0.6,max(0.,1.-p.z*0.25)+max(0.,(length(p.xy-vec2(5.,0.))-4.5)*0.5))),\n                    Box(p,vec3(10.,9.,40.)));\n    ret.w=max(ret.w,-(Line(p,vec3(5.,1.,-30.),vec3(5.,1.,40.))-4.5));\n    ret.w=min(ret.w,Box(p-vec3(0.5,0.,4.),vec3(10.,9.,40.)));\n    return ret;\n}\n\nvoid TraceTunnel(vec3 p, vec3 d, float START, float FAR, inout BVH_HIT bvh_hit) {\n    vec4 dft; float t=0.;\n    for (int i=0; i<64; i++) {\n        if (t>FAR) break;\n        dft=SDF_Tunnel(p+d*t);\n        if (dft.w<SDF_eps.x) {\n            if (bvh_hit.D>START+t) {\n                vec3 sp=p+d*t;\n                vec3 Grad=normalize(vec3(SDF_Tunnel(sp+SDF_eps.xyy).w,SDF_Tunnel(sp+SDF_eps.yxy).w\n                                    ,SDF_Tunnel(sp+SDF_eps.yyx).w)-dft.w);\n                bvh_hit = BVH_HIT(START+t+dft.w,Grad,dft.xyz);\n            }\n            break;\n        }\n        t+=dft.w;\n    }\n}\n\nvec4 SDF_Balar(vec3 p) { //40, 30, 50\n    vec4 ret=vec4(1.,0.7,0.2,CappedCylinder((p-vec3(35.,18.8,35.)).xzy,1.3,1.));\n    ret.w=min(ret.w,CappedCylinder((p-vec3(30.,21.,30.)).xzy,1.3,1.));\n    ret.w=min(ret.w,CappedCylinder((p-vec3(25.,23.,35.)).xzy,1.3,1.));\n    return ret;\n}\n\nvoid TraceBalar(vec3 p, vec3 d, float START, float FAR, inout BVH_HIT bvh_hit) {\n    vec4 dft; float t=0.;\n    for (int i=0; i<64; i++) {\n        if (t>FAR) break;\n        dft=SDF_Balar(p+d*t);\n        if (dft.w<SDF_eps.x) {\n            if (bvh_hit.D>START+t) {\n                vec3 sp=p+d*t;\n                vec3 Grad=normalize(vec3(SDF_Balar(sp+SDF_eps.xyy).w,SDF_Balar(sp+SDF_eps.yxy).w\n                                    ,SDF_Balar(sp+SDF_eps.yyx).w)-dft.w);\n                if (abs(Grad.z)<max(abs(Grad.x),abs(Grad.y))) dft.xyz=vec3(0.3,0.2,0.04);\n                bvh_hit = BVH_HIT(START+t+dft.w,Grad,dft.xyz);\n            }\n            break;\n        }\n        t+=dft.w;\n    }\n}\n\nvec4 SDF_Church(vec3 p) { //40, 80, 40\n    vec4 ret=vec4(0.4,0.2,0.1,Box(p,vec3(40.,40.,40.)));\n    MIN(ret,vec4(0.25,0.15,0.05,Box(p-vec3(0.,0.,13.),vec3(7.,75.,7.)))); //Tower\n        MIN(ret,vec4(0.3,0.2,0.1,Octahedron((p-vec3(3.5,75.,16.5)),4.9)));\n    return ret;\n}\n\nvoid TraceChurch(vec3 p, vec3 d, float START, float FAR, inout BVH_HIT bvh_hit) {\n    vec4 dft; float t=0.;\n    for (int i=0; i<64; i++) {\n        if (t>FAR) break;\n        dft=SDF_Church(p+d*t);\n        if (dft.w<SDF_eps.x) {\n            if (bvh_hit.D>START+t) {\n                vec3 sp=p+d*t;\n                vec3 Grad=normalize(vec3(SDF_Church(sp+SDF_eps.xyy).w,SDF_Church(sp+SDF_eps.yxy).w\n                                    ,SDF_Church(sp+SDF_eps.yyx).w)-dft.w);\n                bvh_hit = BVH_HIT(START+t+dft.w,Grad,dft.xyz);\n            }\n            break;\n        }\n        t+=dft.w;\n    }\n}\n\nvec4 SDF_Bridge(vec3 p) { //20, 30, 280\n    vec4 ret=vec4(vec3(0.25),Box(p-vec3(0.,25.,0.),vec3(20.,5.,280.)));\n    //Bridge underlag \u00e4r symmetriskt i x-axeln\n    vec3 mp=vec3(abs(p.x-10.)+10.,p.yz);\n    MIN(ret,vec4(vec3(0.32),Box(mp-vec3(15.9,0.,100.),vec3(4.,28.,8.))));\n    MIN(ret,vec4(vec3(0.32),Box(mp-vec3(15.9,0.,190.),vec3(4.,28.,8.))));\n    return ret;\n}\n\nvoid TraceBridge(vec3 p, vec3 d, float START, float FAR, inout BVH_HIT bvh_hit) {\n    vec4 dft; float t=0.;\n    for (int i=0; i<64; i++) {\n        if (t>FAR) break;\n        dft=SDF_Bridge(p+d*t);\n        if (dft.w<SDF_eps.x) {\n            if (bvh_hit.D>START+t) {\n                vec3 sp=p+d*t;\n                vec3 Grad=normalize(vec3(SDF_Bridge(sp+SDF_eps.xyy).w,SDF_Bridge(sp+SDF_eps.yxy).w\n                                    ,SDF_Bridge(sp+SDF_eps.yyx).w)-dft.w);\n                bvh_hit = BVH_HIT(START+t+dft.w,Grad,dft.xyz);\n            }\n            break;\n        }\n        t+=dft.w;\n    }\n}\n\nvec4 SDF_VaktTorn(vec3 p) { //15, 30, 15\n    vec4 ret=vec4(0.45,0.45,0.45,Box(p-vec3(5.,0.,5.),vec3(5.,20.,5.)));\n    MIN(ret,vec4(vec3(0.3),max(CappedCylinder(p-vec3(7.5,20.,7.5),7.5,6.),-(p.y-20.))));\n    MIN(ret,vec4(vec3(0.3),Octahedron((p-vec3(7.5,20.,7.5)),7.5)));\n    return ret;\n}\n\nvoid TraceVaktTorn(vec3 p, vec3 d, float START, float FAR, inout BVH_HIT bvh_hit) {\n    vec4 dft; float t=0.;\n    for (int i=0; i<64; i++) {\n        if (t>FAR) break;\n        dft=SDF_VaktTorn(p+d*t);\n        if (dft.w<SDF_eps.x) {\n            if (bvh_hit.D>START+t) {\n                vec3 sp=p+d*t;\n                vec3 Grad=normalize(vec3(SDF_VaktTorn(sp+SDF_eps.xyy).w,SDF_VaktTorn(sp+SDF_eps.yxy).w\n                                    ,SDF_VaktTorn(sp+SDF_eps.yyx).w)-dft.w); \n                bvh_hit = BVH_HIT(START+t+dft.w,Grad,dft.xyz);\n            }\n            break;\n        }\n        t+=dft.w;\n    }\n}\n\nvec4 SDF_Torn(vec3 p) { //40, 230, 40\n    vec4 ret=vec4(vec3(0.25),Box(p-vec3(10.,0.,10.),vec3(20.,60.,20.))); //Gr\u00e5 grund\n    MIN(ret,vec4(vec3(0.8),Line(p,vec3(20.,30.,20.),vec3(20.,210.,20.))-3.)); //Vitt torn\n    vec3 syp=p-vec3(20.,200.,20.); float sdfa=atan(syp.x,syp.z); float sdfr=length(syp.xz);\n    syp=vec3(sdfr*sin(mod(sdfa,2.094)),syp.y,sdfr*cos(mod(sdfa,2.094)));\n        MIN(ret,vec4(1.,0.,0.,Box(syp-vec3(15.,0.,-3.),vec3(3.,30.,6.)))); //R\u00f6d antenn\n        MIN(ret,vec4(vec3(0.2),Box(syp-vec3(0.,15.,-2.5),vec3(15.,5.,5.)))); //Gr\u00e5 h\u00e5llare\n    MIN(ret,vec4(vec3(0.5),CappedCylinder(p-vec3(20.,180.,20.),7.5,1.)));\n        MIN(ret,vec4(vec3(0.5),CappedCylinder(p-vec3(20.,190.,20.),7.5,1.)));\n    MIN(ret,vec4(vec3(0.5),CappedCylinder(p-vec3(20.,80.,20.),15.,3.)));\n    return ret;\n}\n\nvoid TraceTorn(vec3 p, vec3 d, float START, float FAR, inout BVH_HIT bvh_hit) {\n    vec4 dft; float t=0.;\n    for (int i=0; i<64; i++) {\n        if (t>FAR) break;\n        dft=SDF_Torn(p+d*t);\n        if (dft.w<SDF_eps.x) {\n            if (bvh_hit.D>START+t) {\n                vec3 sp=p+d*t;\n                vec3 Grad=normalize(vec3(SDF_Torn(sp+SDF_eps.xyy).w,SDF_Torn(sp+SDF_eps.yxy).w\n                                    ,SDF_Torn(sp+SDF_eps.yyx).w)-dft.w); \n                bvh_hit = BVH_HIT(START+t+dft.w,Grad,dft.xyz);\n            }\n            break;\n        }\n        t+=dft.w;\n    }\n}\n\nvec4 SDF_TornDestr(vec3 p) { //40, 230, 40\n    vec4 ret=vec4(vec3(0.25),Box(p-vec3(10.,0.,10.),vec3(20.,60.,20.))); //Gr\u00e5 grund\n    MIN(ret,vec4(vec3(0.8),Line(p,vec3(20.,30.,20.),vec3(20.,140.,20.))-3.)); //Vitt torn\n    MIN(ret,vec4(vec3(0.5),CappedCylinder(p-vec3(20.,80.,20.),15.,3.)));\n    return ret;\n}\n\nvoid TraceTornDestr(vec3 p, vec3 d, float START, float FAR, inout BVH_HIT bvh_hit) {\n    vec4 dft; float t=0.;\n    for (int i=0; i<64; i++) {\n        if (t>FAR) break;\n        dft=SDF_TornDestr(p+d*t);\n        if (dft.w<SDF_eps.x) {\n            if (bvh_hit.D>START+t) {\n                vec3 sp=p+d*t;\n                vec3 Grad=normalize(vec3(SDF_TornDestr(sp+SDF_eps.xyy).w,SDF_TornDestr(sp+SDF_eps.yxy).w\n                                    ,SDF_TornDestr(sp+SDF_eps.yyx).w)-dft.w); \n                bvh_hit = BVH_HIT(START+t+dft.w,Grad,dft.xyz);\n            }\n            break;\n        }\n        t+=dft.w;\n    }\n}\n\nvec4 SDF_BeegDish(vec3 p) { //80, 250, 80\n    vec4 ret=vec4(vec3(0.25),Box(p-vec3(35.,0.,35.),vec3(30.,80.,30.))); //Gr\u00e5 grund\n    MIN(ret,vec4(vec3(0.15),Box(p-vec3(20.,80.,20.),vec3(50.,60.,40.))));\n    MIN(ret,vec4(vec3(0.2),Line(p,vec3(40.,110.,40.),vec3(40.,210.,40.))-10.));\n    vec3 syp=p-vec3(40.,190.,40.); float sdfa=atan(syp.x,syp.z); float sdfr=length(syp.xz);\n    syp=vec3(sdfr*sin(mod(sdfa,0.7854)),syp.y,sdfr*cos(mod(sdfa,0.7854)));\n        MIN(ret,vec4(vec3(0.3),CappedCylinder(p-vec3(40.,180.,40.),13.5,2.)));\n            MIN(ret,vec4(vec3(0.3),CappedCylinder(p-vec3(40.,160.,40.),13.5,2.)));\n        MIN(ret,vec4(vec3(0.12),Box(syp-vec3(-15.,0.,0.),vec3(40.,5.,30.)))); //Symmetrisk del\n    MIN(ret,vec4(vec3(0.8),max(length(p-vec3(40.,280.,40.))-60.,-length(p-vec3(40.,305.,40.))+80.))); //Dish\n    return ret;\n}\n\nvoid TraceBeegDish(vec3 p, vec3 d, float START, float FAR, inout BVH_HIT bvh_hit) {\n    vec4 dft; float t=0.;\n    for (int i=0; i<64; i++) {\n        if (t>FAR) break;\n        dft=SDF_BeegDish(p+d*t);\n        if (dft.w<SDF_eps.x) {\n            if (bvh_hit.D>START+t) {\n                vec3 sp=p+d*t;\n                vec3 Grad=normalize(vec3(SDF_BeegDish(sp+SDF_eps.xyy).w,SDF_BeegDish(sp+SDF_eps.yxy).w\n                                    ,SDF_BeegDish(sp+SDF_eps.yyx).w)-dft.w);\n                //SDF, om mindre \u00e4n 0 s\u00e5 f\u00e4rgar vi r\u00f6tt\n                float RedDF=-length(sp.xz-40.)+33.;\n                if (sp.y>220. && RedDF<0.) dft.xyz=vec3(1.,0.,0.);\n                bvh_hit = BVH_HIT(START+t+dft.w,Grad,dft.xyz);\n            }\n            break;\n        }\n        t+=dft.w;\n    }\n}\n\nvec4 SDF_BeegDishDestr(vec3 p) { //80, 250, 80\n    vec4 ret=vec4(vec3(0.25),Box(p-vec3(35.,0.,35.),vec3(30.,80.,30.))); //Gr\u00e5 grund\n    MIN(ret,vec4(vec3(0.15),Box(p-vec3(20.,80.,20.),vec3(50.,60.,40.))));\n    MIN(ret,vec4(vec3(0.2),Line(p,vec3(40.,110.,40.),vec3(40.,210.,40.))-10.));\n    vec3 syp=p-vec3(40.,190.,40.); float sdfa=atan(syp.x,syp.z); float sdfr=length(syp.xz);\n    syp=vec3(sdfr*sin(mod(sdfa,0.7854)),syp.y,sdfr*cos(mod(sdfa,0.7854)));\n        MIN(ret,vec4(vec3(0.3),CappedCylinder(p-vec3(40.,180.,40.),13.5,2.)));\n            MIN(ret,vec4(vec3(0.3),CappedCylinder(p-vec3(40.,160.,40.),13.5,2.)));\n        MIN(ret,vec4(vec3(0.12),Box(syp-vec3(-15.,0.,0.),vec3(30.,5.,30.)))); //Symmetrisk del\n    return ret;\n}\n\nvoid TraceBeegDishDestr(vec3 p, vec3 d, float START, float FAR, inout BVH_HIT bvh_hit) {\n    vec4 dft; float t=0.;\n    for (int i=0; i<64; i++) {\n        if (t>FAR) break;\n        dft=SDF_BeegDishDestr(p+d*t);\n        if (dft.w<SDF_eps.x) {\n            if (bvh_hit.D>START+t) {\n                vec3 sp=p+d*t;\n                vec3 Grad=normalize(vec3(SDF_BeegDishDestr(sp+SDF_eps.xyy).w,\n                                    SDF_BeegDishDestr(sp+SDF_eps.yxy).w\n                                    ,SDF_BeegDishDestr(sp+SDF_eps.yyx).w)-dft.w);\n                bvh_hit = BVH_HIT(START+t+dft.w,Grad,dft.xyz);\n            }\n            break;\n        }\n        t+=dft.w;\n    }\n}\n\nvec4 SDF_Maxime(vec3 p) { //140, 160, 140\n    vec4 ret=vec4(vec3(0.25),Box(p-vec3(50.,0.,50.),vec3(40.,160.,40.))); //Gr\u00e5 grund\n    ret.w=min(ret.w,Octahedron((p-vec3(70.,160.,70.)),120.));\n    return ret;\n}\n\nvoid TraceMaxime(vec3 p, vec3 d, float START, float FAR, inout BVH_HIT bvh_hit) {\n    vec4 dft; float t=0.;\n    for (int i=0; i<64; i++) {\n        if (t>FAR) break;\n        dft=SDF_Maxime(p+d*t);\n        if (dft.w<SDF_eps.x) {\n            if (bvh_hit.D>START+t) {\n                vec3 sp=p+d*t;\n                vec3 Grad=normalize(vec3(SDF_Maxime(sp+SDF_eps.xyy).w,SDF_Maxime(sp+SDF_eps.yxy).w\n                                    ,SDF_Maxime(sp+SDF_eps.yyx).w)-dft.w);\n                bvh_hit = BVH_HIT(START+t+dft.w,Grad,dft.xyz);\n            }\n            break;\n        }\n        t+=dft.w;\n    }\n}\n\n//Light rendering functions\nfloat TraceSphere(vec3 p, vec3 d, vec3 sp, float r) {\n\tvec3 lp=p-sp;\n\tfloat a=dot(lp,d);\n\tfloat b=dot(lp,lp)-r*r;\n\tfloat c=a*a-b;\n\treturn ((c<0.)?-1.:(-a-sqrt(c)));\n}\n\nvec3 BlueFog(vec3 Light, vec3 Pos, vec3 Dir, float Dist) {\n    //Blue fog: exp(-Int(density(p)*dt))\n    float FogIntegral=0.08*pow(Dist*Dir.z*0.06,1.3)\n                         +0.08*(exp(-Pos.y*0.005)-exp(-(Pos.y+Dir.y*Dist)*0.005))/(Dir.y*0.005)\n                         +0.08*pow(Dir.z,2.)*(exp(-Pos.y*0.01)-exp(-(Pos.y+Dir.y*Dist)*0.01))/(Dir.y*0.01);\n    return mix(vec3(0.01,0.06,0.15)*(0.5+0.5*(1.-Dir.y)),Light,clamp(exp(-FogIntegral*0.015),0.,1.));\n}\n\nconst vec3 SICol[6]=vec3[6](vec3(0.),vec3(1.),vec3(1.,1.,0.),vec3(1.,0.2,0.),vec3(1.,0.,0.),vec3(1.,0.,0.));\nvec3 ITC(float I) {\n    //Maps intensity to color (Black -> White -> Yellow -> Orange -> Red)\n    int tmp_i=int(floor(I*5.));\n    return mix(SICol[tmp_i],SICol[tmp_i+1],fract(I*5.));\n}", "name": "Common", "description": "", "type": "common"}, {"inputs": [{"id": "4dXGRr", "filepath": "/presets/tex00.jpg", "previewfilepath": "/presets/tex00.jpg", "type": "keyboard", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "4dXGR8", "filepath": "/media/previz/buffer00.png", "previewfilepath": "/media/previz/buffer00.png", "type": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "XsBSR3", "filepath": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "type": "texture", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dXGR8", "channel": 0}], "code": "/*\nTextures and explosion rendering\n*/\n\nvec3 ERandSample(float t, float n) {\n    float tf=floor(t*n)+0.5;\n    return mix(texture(iChannel3,vec2(tf,128.5)*I1024).xyz,\n                texture(iChannel3,vec2(mod(tf+1.,n),128.5)*I1024).xyz,fract(t*n));\n}\n\nfloat SilhouetteJet(vec2 uv) {\n    float t=100.;\n    vec2 luv=uv/ASPECT.x*vec2(10.,10.);\n    t=Box2(luv-vec2(2.,0.2),vec2(6.,1.));\n    t=min(t,max(Line2(luv,vec2(2.,0.7),vec2(0.3,0.5))-0.5*(1.+(luv.x-2.)*0.5) //Spets\n        ,luv.x-2.));\n    t=min(t,Line2(luv,vec2(2.,0.85),vec2(4.,1.1))-0.5*(1.-pow(luv.x-3.,2.)*0.2)); //Hytt\n        t=min(t,Line2(luv,vec2(2.,0.2),vec2(6.,0.2))-0.1*(1.-pow(luv.x-4.,2.)*0.2)); //Utbuckning under\n    t=SMIN(t,-SMIN(-Line2(luv,vec2(6.,1.2),vec2(9.,1.2))+0.5*(1.+(luv.x-9.)*0.25) //Bak\n        ,9.-luv.x,0.2),0.1);\n        t=SMIN(t,-SMIN(-Line2(luv,vec2(7.,1.2),vec2(8.5,1.9))+0.9*(1.+(luv.x-9.)*0.25) //Svans\n            ,8.5-luv.x,0.2),0.1);\n    t=min(t,max(Line2(luv,vec2(8.,0.6),vec2(9.5,0.6))-0.4*(1.-max(0.,luv.x-9.)*0.5),luv.x-9.5)); //Burner\n    return ((t<0.)?0.:1.);\n}\n\nfloat SilhouetteRico(vec2 uv, int Silhouette) {\n    //A black silhouette of rico\n    float t=100.; vec2 luv,suv0,suv1; float angle,fangle,hlen;\n    if (Silhouette==0) {\n        //Riding the jet\n            //https://i.ytimg.com/vi/lHe0Mi2m01M/maxresdefault.jpg\n        luv=(uv-vec2(0.5*ASPECT.x,0.))*3.6; //luv in metres\n        t=-SMIN(-(Line2(luv,vec2(0.,0.7),vec2(-0.15,1.2))-0.1*(1.+(luv.y-0.75)*2.)),-(luv.y-1.2),0.09); //Body\n        t=SMIN(t,Line2(luv,vec2(0.,0.7),vec2(-0.3,0.4))-0.08*(1.+(luv.y-0.4)*0.4),0.05); //Leg forward\n            t=SMIN(t,Line2(luv,vec2(-0.33,0.4),vec2(-0.3,0.05))-0.06,0.05);\n            t=SMIN(t,Line2(luv,vec2(-0.27,0.02),vec2(-0.45,0.))-0.02,0.05);\n        t=SMIN(t,Line2(luv,vec2(0.,0.7),vec2(0.2,0.38))-0.07*(1.+(luv.y-0.4)*0.4),0.05); //Leg back\n            t=SMIN(t,Line2(luv,vec2(0.2,0.38),vec2(0.16,0.05))-0.06,0.05);\n            t=SMIN(t,Line2(luv,vec2(0.25,0.),vec2(0.19,0.))-0.02,0.05);\n        t=SMIN(t,Line2(luv,vec2(-0.3,1.13),vec2(-0.29,0.87))-0.045,0.05); //Arm forward\n            t=SMIN(t,Line2(luv,vec2(-0.26,0.86),vec2(0.,0.8))-0.04,0.02);\n        t=SMIN(t,Line2(luv,vec2(0.02,1.15),vec2(0.25,0.97))-0.06,0.05); //Arm backwards\n            t=SMIN(t,Line2(luv,vec2(0.28,0.95),vec2(0.37,0.74))-0.045,0.02);\n            t=min(t,Line2(luv,vec2(0.36,0.71),vec2(0.37,0.71))-0.04);//Hand       \n        t=SMIN(t,Line2(luv,vec2(-0.13,1.15),vec2(-0.13,1.24))-0.05+pow(luv.y-1.15,2.)*1.4,0.05); //throat\n        //Head\n        t=SMIN(t,Line2(luv,vec2(-0.15,1.26),vec2(-0.16,1.3))-0.05\n                                                    -pow(clamp(luv.y-1.25,0.,1.)*1.1,1.4)*0.75,0.01);\n            t=SMIN(t,Line2(luv,vec2(-0.18,1.24),vec2(-0.19,1.26))-0.02,0.01); //Chin\n        //Hair\n        hlen=length(luv-vec2(-0.17,1.34));\n        angle=atan(-luv.y+1.34,-luv.x-0.17)/3.141592653+1.+hlen*2.5;\n        fangle=floor(angle*24.)/24.;\n            t=((angle-fangle<0.2-hlen*2.5 && (fangle<16./12. || fangle>23./12.))?-1.:t);\n        t=SMIN(t,Line2(luv,vec2(0.35,0.85),vec2(1.2,0.))-0.01,0.02); //Grapple\n    } else if (Silhouette==1) {\n        //Backflip\n        luv=(uv-vec2(0.5*ASPECT.x,0.))*3.6; //luv in metres\n        t=-SMIN(-(Line2(luv,vec2(0.,0.7),vec2(-0.15,1.2))-0.1*(1.+(luv.y-0.75)*1.3)),-(luv.y-1.2),0.09);//Body\n        t=SMIN(t,Line2(luv,vec2(0.,0.7),vec2(-0.3,0.65))-0.07*(1.+(luv.y-0.4)*0.4),0.05); //Leg forward\n            t=SMIN(t,Line2(luv,vec2(-0.33,0.67),vec2(-0.1,0.4))-0.06,0.02);\n            t=SMIN(t,Line2(luv,vec2(-0.07,0.37),vec2(-0.12,0.3))-0.02,0.05); //Skor\n        t=SMIN(t,Line2(luv,vec2(0.,0.7),vec2(-0.05,0.35))-0.05*(1.+(luv.y-0.3)*0.4),0.05); //Leg back\n                t=SMIN(t,Line2(luv,vec2(-0.07,0.37),vec2(-0.05,0.28))-0.02,0.05);\n        t=SMIN(t,Line2(luv,vec2(-0.2,1.15),vec2(-0.2,0.87))-0.045,0.05); //Arm forward\n            t=SMIN(t,Line2(luv,vec2(-0.2,0.86),vec2(-0.35,0.95))-0.04,0.02);\n            t=min(t,Line2(luv,vec2(-0.36,0.96),vec2(-0.35,0.94))-0.04);//Hand\n        t=SMIN(t,Line2(luv,vec2(0.,1.15),vec2(0.05,0.97))-0.05,0.05); //Arm backwards\n        t=SMIN(t,Line2(luv,vec2(-0.13,1.15),vec2(-0.13,1.24))-0.05+pow(luv.y-1.15,2.)*1.4,0.05); //throat\n        //Head\n        t=SMIN(t,Line2(luv,vec2(-0.15,1.26),vec2(-0.19,1.3))-0.05\n                                            -pow(clamp(luv.y-1.25,0.,1.)*1.05,1.4)*0.75,0.01);\n        //Hair\n        hlen=length(luv-vec2(-0.2,1.32));\n        angle=atan(-luv.y+1.32,-luv.x-0.2)/3.141592653+1.+hlen*2.5;\n        fangle=floor(angle*24.)/24.;\n            t=((angle-fangle<0.25-hlen*2.5 && (fangle<16./12. || fangle>23./12.))?-1.:t);\n    } else if (Silhouette==2) {\n        //Flying with parachute\n        luv=(uv-vec2(0.5*ASPECT.x,0.1))*3.6; //luv in metres\n        t=-SMIN(-(Line2(luv,vec2(0.,0.7),vec2(-0.05,1.2))-0.1*(1.+(luv.y-0.75)*1.4)),-(luv.y-1.2),0.09);//Body\n        t=SMIN(t,Line2(luv,vec2(0.,0.7),vec2(-0.15,0.4))-0.08*(1.+(luv.y-0.4)*0.4),0.05); //Leg forward\n            t=SMIN(t,Line2(luv,vec2(-0.16,0.4),vec2(-0.13,0.05))-0.06,0.05);\n            t=SMIN(t,Line2(luv,vec2(-0.13,-0.01),vec2(-0.25,-0.1))-0.025,0.05);\n        t=SMIN(t,Line2(luv,vec2(0.,0.7),vec2(0.2,0.38))-0.07*(1.+(luv.y-0.4)*0.4),0.05); //Leg back\n            t=SMIN(t,Line2(luv,vec2(0.2,0.38),vec2(0.1,0.15))-0.06,0.05);\n            t=SMIN(t,Line2(luv,vec2(0.1,0.1),vec2(0.24,0.07))-0.02,0.02);\n        t=SMIN(t,Line2(luv,vec2(-0.2,1.15),vec2(-0.3,1.))-0.045,0.05); //Arm l\n            t=SMIN(t,Line2(luv,vec2(-0.3,1.),vec2(-0.38,1.25))-0.04,0.02);\n        t=SMIN(t,Line2(luv,vec2(0.1,1.15),vec2(0.2,0.97))-0.05,0.05); //Arm r\n            t=SMIN(t,Line2(luv,vec2(0.2,0.97),vec2(0.3,1.2))-0.045,0.02);\n        t=SMIN(t,Line2(luv,vec2(-0.03,1.15),vec2(-0.03,1.24))-0.05+pow(luv.y-1.15,2.)*1.4,0.05); //throat\n        //Head\n        t=SMIN(t,Line2(luv,vec2(-0.05,1.26),vec2(-0.06,1.3))-0.05\n                                            -pow(clamp(luv.y-1.25,0.,1.),1.4)*0.75,0.01);\n            t=SMIN(t,Line2(luv,vec2(-0.08,1.24),vec2(-0.09,1.26))-0.02,0.01); //Chin\n        //Hair\n        hlen=length(luv-vec2(-0.07,1.34));\n        angle=atan(-luv.y+1.34,-luv.x-0.07)/3.141592653+1.+hlen*2.5;\n        fangle=floor(angle*24.)/24.;\n            t=((angle-fangle<0.2-hlen*2.5 && (fangle<16./12. || fangle>23./12.))?-1.:t);\n        //Parachute\n        angle=atan(luv.y-1.2,luv.x*0.8);\n        fangle=(floor(angle*6.)+0.5)/6.;\n        suv0=vec2(cos(fangle)*1.8,1.2+sin(fangle)*1.8);\n        suv1=vec2(cos(fangle)*1.6,1.2+sin(fangle)*1.6);\n        if (fangle>0.6 && fangle<2.5)\n        t=min(t,max(length(luv*vec2(0.8,1.)-suv0)-(0.25-abs(fangle-1.55)*0.08),\n            -(length(luv*vec2(0.8,1.)-suv1)-(0.25-abs(fangle-1.55)*0.08))));\n        //Ropes\n        t=SMIN(t,Line2(luv,vec2(0.25,1.6),vec2(-0.35,1.6))-0.03,0.02); //Center\n            t=SMIN(t,Line2(luv,vec2(0.3,1.2),vec2(0.25,1.6))-0.015,0.02); //Linor hand\n            t=SMIN(t,Line2(luv,vec2(-0.38,1.25),vec2(-0.35,1.6))-0.015,0.02);\n        t=SMIN(t,Line2(luv,vec2(0.,1.),vec2(0.25,1.6))-0.015,0.02); //Linor rygg\n            t=SMIN(t,Line2(luv,vec2(-0.1,1.),vec2(-0.35,1.6))-0.015,0.02);\n        t=SMIN(t,Line2(luv,vec2(0.25,1.6),vec2(1.8,2.35))-0.02,0.02); //H\u00f6ger linor\n            t=SMIN(t,Line2(luv,vec2(0.25,1.6),vec2(1.7,2.6))-0.02,0.02);\n            t=SMIN(t,Line2(luv,vec2(1.,2.13),vec2(1.2,2.65))-0.02,0.02);\n        t=SMIN(t,Line2(luv,vec2(-0.35,1.6),vec2(-1.8,2.3))-0.02,0.02); //V\u00e4nster linor\n            t=SMIN(t,Line2(luv,vec2(-0.35,1.6),vec2(-1.65,2.55))-0.02,0.02);\n            t=SMIN(t,Line2(luv,vec2(-1.,2.13),vec2(-1.24,2.65))-0.02,0.02);\n    }\n    return ((t<0.)?0.:1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Color=vec4(0.);\n    if (Box2(fragCoord,vec2(16.,NCONTOURS0+NCONTOURS1))<0.) {\n        //Storing the contours\n        vec2 fragFloor=floor(fragCoord);\n        if (fragCoord.y<float(NCONTOURS0)) {\n            Color.x=Contours0[int(fragFloor.x+fragFloor.y*16.)];\n        } else {\n            Color.x=Contours1[int(fragFloor.x+fragFloor.y*16.)-NCONTOURS0*16];\n        }\n    }\n    if (Box2(fragCoord-vec2(17.,0.),vec2(1.,1.))<0.) {\n        //Storing if \"i\" is pressed\n        Color=texture(iChannel0,vec2(73.5,0.5)/vec2(256.,3.));\n    }\n    if (Box2(fragCoord-vec2(16.,0.),vec2(1.,1.))<0.) {\n        //Storing boolean and time when \"e\" is pressed\n        vec4 LC=((iFrame==0)?vec4(0.):texture(iChannel1,fragCoord*IRES));\n        if (LC.x==0.) {\n            if (texture(iChannel0,vec2(69.5,0.5)/vec2(256.,3.)).x>0.) {\n                Color=vec4(1.,iTime,1.,0.);\n            }\n        } else {\n            Color=LC;\n            if (iTime-LC.y>10.) Color.z=0.;\n        }\n    } else if (Box2(fragCoord-vec2(iResolution.x*0.5,0.),iResolution.xy*0.5)<0.) {\n        //Silhouette jet\n        vec2 AAuv=floor(fragCoord-vec2(iResolution.x*0.5,0.))*2.;\n        Color.xyz=vec3(SilhouetteJet((AAuv+vec2(0.2,0.8))*IRES.yy)+\n                        SilhouetteJet((AAuv+vec2(0.8,0.2))*IRES.yy)+\n                        SilhouetteJet((AAuv+0.2)*IRES.yy)+\n                        SilhouetteJet((AAuv+0.8)*IRES.yy))*0.25;\n    } else if (Box2(fragCoord-vec2(0.,iResolution.y*0.5),iResolution.xy*0.5)<0.) {\n        //Rendering the explosion (vec4(Light,Transparency))\n        vec4 SV=texture(iChannel1,vec2(16.5,0.5)*IRES);\n        vec2 AAuv=(fragCoord*2.-vec2(0.,iResolution.y))*IRES;\n        vec2 ExpCenter=vec2(500./(840.*CFOV*ASPECT.x)*0.5+0.5,0.62); //R=0.09\n        if (SV.x>0.5 && iTime-SV.y>10.) {\n            float rTime=iTime-SV.y-10.;\n            //Explosion fractional radius\n            float ER=(1.2-exp(-rTime*2.5))*(1.+0.05*ERandSample(rTime*0.2,24.).x);\n            //Explosion boundary\n            float EAngle=atan(AAuv.y-ExpCenter.y,AAuv.x-ExpCenter.x)*0.5/3.14159+0.5;\n            vec3 ERand=ERandSample(EAngle,25.);\n            float uvLen=length(AAuv-ExpCenter); float uvR=(0.03+0.02*ERand.x)*pow(ER,2.);\n                Color+=((uvLen<uvR)?vec4(vec3(1.,0.2,0.01),1.)*clamp(1.-pow(uvLen/uvR,2.),0.,1.):vec4(0.));//Orange\n            uvLen=length(AAuv-ExpCenter-vec2(0.01,0.02)*ER); uvR=(0.04+0.02*ERand.y)*ER;\n                Color+=((uvLen<uvR)?vec4(vec3(0.5,0.35,0.2),1.)*clamp(1.-uvLen/uvR,0.,1.):vec4(0.)); //Dark orange\n            uvLen=length(AAuv-ExpCenter-vec2(0.01,0.03)*ER); uvR=(0.05+0.01*ERand.z)*ER;\n                Color+=((uvLen<uvR)?vec4(vec3(0.4,0.,0.),1.)*clamp(1.-uvLen/uvR,0.,1.):vec4(0.)); //Red\n                uvLen=length(AAuv-ExpCenter-vec2(0.02,0.01)*ER); uvR=(0.03+0.02*ERand.y)*ER;\n                    Color=mix(Color,vec4(vec3(0.),1.),clamp(1.3-uvLen/uvR,0.,1.)); //Black\n                uvLen=length(AAuv-ExpCenter-vec2(-0.03,-0.01)*ER); uvR=(0.04+0.01*ERand.z)*ER;\n                    Color=mix(Color,vec4(vec3(0.),1.),clamp(1.3-uvLen/uvR,0.,1.));\n            uvLen=length(AAuv-ExpCenter-vec2(0.01,0.015)*ER); uvR=(0.02+0.02*ERand.y)*pow(ER,0.35);\n                Color+=((uvLen<uvR)?vec4(vec3(1.,0.2,0.),1.)*clamp(1.3-uvLen/uvR,0.,1.):vec4(0.)); //White/Ye\n            \n            Color.xyz*=clamp(pow(max(4.-rTime,0.)*0.5,0.5),0.,1.);\n        } else\n            Color=vec4(0.);\n    } else if (Box2(fragCoord-iResolution.xy*0.5,iResolution.xy*0.5)<0.) {\n        //Silhouette of rico\n        vec4 SV=texture(iChannel1,vec2(16.5,0.5)*IRES);\n        if (SV.x>0.5) {\n            float rTime=iTime-SV.y;\n            int SIL=((rTime<5.)?0:((rTime<5.5)?1:2));\n            vec2 AAuv=floor(fragCoord-iResolution.xy*0.5)*2.;\n            if (SIL==1)\n                AAuv=iResolution.xy*vec2(0.5,0.25)+Rotate(AAuv-iResolution.xy*\n                                                vec2(0.5,0.25),(rTime-5.)*4.*3.14);\n            Color.xyz=vec3(SilhouetteRico((AAuv+vec2(0.2,0.8))*IRES.yy,SIL)+\n                            SilhouetteRico((AAuv+vec2(0.8,0.2))*IRES.yy,SIL)+\n                            SilhouetteRico((AAuv+0.2)*IRES.yy,SIL)+\n                            SilhouetteRico((AAuv+0.8)*IRES.yy,SIL))*0.25;\n        }\n    }\n    fragColor=Color;\n}", "name": "Buffer A", "description": "", "type": "buffer"}, {"inputs": [{"id": "4sfGRn", "filepath": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "type": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "Xsf3Rr", "filepath": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "type": "texture", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "4dXGR8", "filepath": "/media/previz/buffer00.png", "previewfilepath": "/media/previz/buffer00.png", "type": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "XsBSR3", "filepath": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "type": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "XsXGR8", "channel": 0}], "code": "/*\nTerrain rendering\n    Output: vec4(vec4(Albedo.xyz,0.)\n                ,vec4(Normal.xyz,0.)\n                ,BushHeight\n                ,Distance)\n    Qubic interpolator from https://www.paulinternet.nl/?page=bicubic\n*/\n    \nBVH_HIT TraceBVH(vec2 uv, vec3 P, vec3 D, vec3 ID, float CDist) {\n    BVH_HIT Hit=BVH_HIT(CDist,vec3(0.),vec3(0.)); vec2 bb; vec3 RP,RD,IRD;\n    if (uv.x<0.5) {\n        if (uv.y<0.5) {\n            if (BBox(P,ID,vec3(-225.,25.,190.),vec3(10.,9.,80.),bb)) { //Tunnel\n                TraceTunnel(P+D*bb.x-vec3(-225.,25.,190.),D,bb.x,bb.y-bb.x,Hit);\n            }\n            if (BBox(P,ID,vec3(-155.,0.,75.),vec3(40.,30.,50.),bb)) { //Haybale\n                TraceBalar(P+D*bb.x-vec3(-155.,0.,75.),D,bb.x,bb.y-bb.x,Hit);\n            }\n            RP=P-vec3(-220.,10.,350.); RD=D; RP.xz=Rotate(RP.xz,-0.4);\n                                             RD.xz=Rotate(RD.xz,-0.4); IRD=1./RD;\n            if (BBox(RP,IRD,vec3(-10.,-15.,-130.),vec3(20.,30.,280.),bb)) { //Bridge\n                TraceBridge(RP+RD*bb.x-vec3(-10.,-15.,-130.),RD,bb.x,bb.y-bb.x,Hit);\n            }\n        } else {\n            if (BBox(P,ID,vec3(-530.,135.,600.),vec3(40.,80.,40.),bb)) { //Church\n                TraceChurch(P+D*bb.x-vec3(-530.,135.,600.),D,bb.x,bb.y-bb.x,Hit);\n            }\n            if (BBox(P,ID,vec3(-3300.,1800.,4450.),vec3(600.,200.,200.),bb)) { //Flygbas berg\n                RP=P-vec3(-3300.,1800.,4450.);\n                if (BBox(RP,ID,vec3(0.,60.,50.),vec3(140.,160.,140.),bb)) { //Falco maxime torn\n                    TraceMaxime(RP+D*bb.x-vec3(0.,60.,50.),D,bb.x,bb.y-bb.x,Hit);\n                }\n                if (BBox(RP,ID,vec3(0.,80.,90.),vec3(400.,10.,40.),bb)) { //Flygbana uppe\n                    if (bb.x<Hit.D) { Hit.D=bb.x; Hit.C=vec3(0.3); } }\n                if (BBox(RP,ID,vec3(100.,40.,90.),vec3(400.,10.,100.),bb)) { //Flygbana uppe\n                    if (bb.x<Hit.D) { Hit.D=bb.x; Hit.C=vec3(0.3); } }\n            }\n        }\n    } else {\n        if (BBox(P,ID,vec3(350.,0.,730.),vec3(200.,250.,250.),bb)) { //Bas torn\n            RP=P-vec3(350.,0.,730.);\n            vec4 SV=texture(iChannel0,vec2(16.5,0.5)*IRES);\n            if (BBox(RP,ID,vec3(30.,0.,210.),vec3(40.,230.,40.),bb)) { //Torn 4\n                TraceTorn(RP+D*bb.x-vec3(30.,0.,210.),D,bb.x,bb.y-bb.x,Hit);\n            }\n            if (BBox(RP,ID,vec3(90.,0.,170.),vec3(40.,230.,40.),bb)) { //Torn 3\n                if (SV.x>0.5 && iTime-SV.y>10.)\n                    TraceTornDestr(RP+D*bb.x-vec3(90.,0.,170.),D,bb.x,bb.y-bb.x,Hit);\n                else TraceTorn(RP+D*bb.x-vec3(90.,0.,170.),D,bb.x,bb.y-bb.x,Hit);\n            }\n            if (BBox(RP,ID,vec3(100.,0.,110.),vec3(40.,230.,40.),bb)) { //Torn 2\n                if (SV.x>0.5 && iTime-SV.y>10.)\n                    TraceTornDestr(RP+D*bb.x-vec3(100.,0.,110.),D,bb.x,bb.y-bb.x,Hit);\n                else TraceTorn(RP+D*bb.x-vec3(100.,0.,110.),D,bb.x,bb.y-bb.x,Hit);\n            }\n            if (BBox(RP,ID,vec3(130.,0.,20.),vec3(40.,230.,40.),bb)) { //Torn 1\n                if (SV.x>0.5 && iTime-SV.y>10.)\n                    TraceTornDestr(RP+D*bb.x-vec3(130.,0.,20.),D,bb.x,bb.y-bb.x,Hit);\n                else TraceTorn(RP+D*bb.x-vec3(130.,0.,20.),D,bb.x,bb.y-bb.x,Hit);\n            }\n            if (BBox(RP,ID,vec3(110.,0.,60.),vec3(80.,250.,80.),bb)) { //Dish\n                if (SV.x>0.5 && iTime-SV.y>10.)\n                    TraceBeegDishDestr(RP+D*bb.x-vec3(110.,0.,60.),D,bb.x,bb.y-bb.x,Hit);\n                else TraceBeegDish(RP+D*bb.x-vec3(110.,0.,60.),D,bb.x,bb.y-bb.x,Hit);\n            }\n        }\n        if (BBox(P,ID,vec3(280.,0.,500.),vec3(15.,4.,15.),bb)) { //Hamn\n            if (bb.x<Hit.D) { Hit.D=bb.x; Hit.C=vec3(0.3); } }\n        if (BBox(P,ID,vec3(1200.,0.,1700.),vec3(400.,100.,200.),bb)) { //Stad\n            RP=P-vec3(1200.,0.,1700.);\n            if (BBox(RP,ID,vec3(140.,0.,50.),vec3(80.,70.,30.),bb)) { //Hus bakom\n                if (bb.x<Hit.D) { Hit.D=bb.x; Hit.C=vec3(0.4); } }\n            if (BBox(RP,ID,vec3(230.,0.,0.),vec3(30.,50.,80.),bb)) {\n                if (bb.x<Hit.D) { Hit.D=bb.x; Hit.C=vec3(0.45); } }\n            if (BBox(RP,ID,vec3(300.,0.,0.),vec3(30.,50.,80.),bb)) {\n                if (bb.x<Hit.D) { Hit.D=bb.x; Hit.C=vec3(0.45); } }\n        }\n    }\n    if (BBox(P,ID,vec3(-50.,105.,740.),vec3(350.,40.,100.),bb)) { //Bas kulle\n        RP=P-vec3(-50.,105.,740.);\n        if (BBox(RP,ID,vec3(250.,0.,10.),vec3(15.,30.,15.),bb)) { //Torn \u00e5t h\u00f6ger\n            TraceVaktTorn(RP+D*bb.x-vec3(250.,0.,10.),D,bb.x,bb.y-bb.x,Hit);\n        }\n        if (BBox(RP,ID,vec3(190.,0.,25.),vec3(15.,30.,15.),bb)) { //Torn\n            TraceVaktTorn(RP+D*bb.x-vec3(190.,0.,25.),D,bb.x,bb.y-bb.x,Hit);\n        }\n        if (BBox(RP,ID,vec3(104.,-10.,25.),vec3(15.,30.,15.),bb)) { //Torn \u00e5t v\u00e4nter\n            TraceVaktTorn(RP+D*bb.x-vec3(104.,-10.,25.),D,bb.x,bb.y-bb.x,Hit);\n        }\n        if (BBox(RP,ID,vec3(24.,-20.,25.),vec3(15.,30.,15.),bb)) { //Torn l\u00e4ngre bak\n            TraceVaktTorn(RP+D*bb.x-vec3(24.,-20.,25.),D,bb.x,bb.y-bb.x,Hit);\n        }\n        if (BBox(RP,ID,vec3(124.,0.,25.),vec3(20.,20.,30.),bb)) { //Hus\n            if (bb.x<Hit.D) { Hit.D=bb.x; Hit.C=vec3(0.2); }\n        }\n    }\n    if (BBox(P,ID,vec3(200.,240.,1800.),vec3(400.,35.,200.),bb)) { //Flygbas kust\n        if (bb.x<Hit.D) { Hit.D=bb.x; Hit.C=vec3(0.2); }\n    }\n    return Hit;\n}\n\nvec2 ContourHeight(float IndexOffset, float t) {\n    //Cubic Interpolation (Contour 1)\n    vec2 tIndex=floor(vec2(t*15.,(t+epsx)*15.));\n    vec2 tIMax=min(tIndex+2.,vec2(15.));\n    vec2 tIMin=max(tIndex-1.,vec2(0.));\n    vec2 CH0=vec2(texture(iChannel0,vec2(tIMin.x+0.5,IndexOffset+0.5)*IRES).x,\n                    texture(iChannel0,vec2(tIMin.y+0.5,IndexOffset+0.5)*IRES).x);\n    vec2 CH1=vec2(texture(iChannel0,vec2(tIndex.x+0.5,IndexOffset+0.5)*IRES).x,\n                    texture(iChannel0,vec2(tIndex.y+0.5,IndexOffset+0.5)*IRES).x);\n    vec2 CH2=vec2(texture(iChannel0,vec2(tIndex.x+1.5,IndexOffset+0.5)*IRES).x,\n                    texture(iChannel0,vec2(tIndex.y+1.5,IndexOffset+0.5)*IRES).x);\n    vec2 CH3=vec2(texture(iChannel0,vec2(tIMax.x+0.5,IndexOffset+0.5)*IRES).x,\n                    texture(iChannel0,vec2(tIMax.y+0.5,IndexOffset+0.5)*IRES).x);//*/\n    vec2 a=0.5*(CH3-CH0+3.*(CH1-CH2));\n    vec2 b=CH0-2.5*CH1+2.*CH2-0.5*CH3;\n    vec2 c=0.5*(CH2-CH0);\n    vec2 d=CH1;\n    vec2 x=fract(vec2(t,t+epsx)*15.);\n    return d+x*(c+x*(b+a*x));\n}\n\nvec4 GradZ(vec2 a, vec2 b, vec2 c, vec2 d, vec2 uv, float Interval) {\n    //Computing the interpolator parameter and gradient\n    float z,Offset,dydz,dzdy,dydx,dzdx; vec2 ih;\n    //The parameter z is computed using binary search: H(z)=uv.y -> H(x)-uv.y=0\n    z=0.5; Offset=0.25;\n    for (int j=0; j<32; j++) {\n        ih=d+z*(c+z*(b+a*z)); //Low level optimization\n        if (abs(ih.x-uv.y)<IRES.y*0.05) break;\n        z+=((ih.x<uv.y)?Offset:-Offset);\n        Offset=Offset*0.5;\n    }\n    //Computing the normal\n    dydz=(c.x+z*(2.*b.x+3.*a.x*z));\n    dydx=dot(d+z*(c+z*(b+a*z)),vec2(1.,-1.))/(epsx);\n    return vec4(normalize(vec3(dydx,1.,-dydz)),z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Color=vec4(0.);\n    //Camera + uv\n    //vec2 uv=(fragCoord+texture(iChannel2,vec2(mod(float(iFrame),8.)+0.5)*I1024).xy*0.8-0.4)*IRES;\n    vec2 uv=fragCoord*IRES;\n    vec3 Pos=CAMERA_P;\n    vec3 Dir=normalize(vec3((uv*2.-1.)*(ASPECT*CFOV),1.));\n    //Init variables\n    float Mat=-1.; float Dist=10000.; float BushHeight=0.; float Interval=50./Dir.z;\n    float CZ,CDist,TG0,TG1,DecD;\n    vec2 CH2,CH3,a,b,c,d,TFrag;\n    vec3 TSand,TStone,TGrass,TSnow,PixelPos,Normal; vec3 Albedo=vec3(0.);\n    //********************First contours********************\n    CZ=50.; CDist=CZ/Dir.z;\n    vec2 CH1=(ContourHeight(0.,uv.x)-Pos.y)/(CZ*CFOV)*0.5+0.5;\n    vec2 CH0=CH1;\n    for (float i=1.; i<float(NCONTOURS0); i++) {\n        CZ+=50.;\n    \tCH2=(ContourHeight(i,uv.x)-Pos.y)/(CZ*CFOV)*0.5+0.5;\n        if (CH1.x<uv.y && uv.y<CH2.x) {\n            CH3=(ContourHeight(i+1.,uv.x)-Pos.y)/((CZ+50.)*CFOV)*0.5+0.5;\n            //Creating the cubic interpolator H(z)=az^3+bz^2+cz+d, 0<z<1\n            a=0.5*(CH3-CH0+3.*(CH1-CH2));\n            b=CH0-2.5*CH1+2.*CH2-0.5*CH3;\n            c=0.5*(CH2-CH0);\n            d=CH1;\n            //Position, normal and material\n            vec4 gradz=GradZ(a,b,c,d,uv,Interval);\n            Normal=gradz.xyz;\n            Dist=CDist+gradz.w*Interval;\n            PixelPos=Pos+Dir*Dist;\n            Mat=0.;\n            //Computing the albedo\n            TFrag=uv*vec2(800.,450.);\n            TStone=pow(texture(iChannel3,(TFrag*0.9+vec2(1.,2.)*(Dist*0.5))*I1024).xyz,vec3(1.4));\n            TStone*=(1.-pow(texture(iChannel2,Rotate(PixelPos.xz*0.00008*vec2(0.8,1.)\n                            ,PixelPos.z*0.002)).z,2.5));\n            TGrass=GrassColor*(0.6+0.4*texture(iChannel2,PixelPos.xy*0.00025).z);\n            TSand=(0.1+0.9*TStone.x*TStone.y*TStone.z)*vec3(1.,0.9,0.1);\n            TG0=smoothstep(0.12,0.2,Normal.y*0.2); //Normal mix\n            TG0=mix(1.,TG0,smoothstep(0.1,0.2,texture(iChannel2,PixelPos.xz*0.000038).x*0.4)); //More grass\n            TG0=mix(TG0,0.,smoothstep(0.2,0.4,\n                    texture(iChannel2,PixelPos.xz*0.00018).x/max(1.,0.4+0.6*PixelPos.y))); //Stone (sea)\n            Albedo=mix(TStone,TGrass,TG0);\n            BushHeight=TG0;\n            //Decals (stone)\n            DecD=Line(PixelPos,vec3(-95.,0.,780.),vec3(270.,20.,770.))-110.;\n            if (DecD<0.) {\n                Albedo=mix(TStone,Albedo,clamp(1.+DecD*0.1,0.,1.));\n                BushHeight=mix(0.,BushHeight,clamp(1.+DecD*0.1,0.,1.));\n            }\n            //Decals (farmland)\n            DecD=BoxC(PixelPos-vec3(-135.,25.,100.),vec3(20.,25.,25.))-3.;\n            DecD=min(DecD,BoxC(PixelPos-vec3(-400.,0.,785.),vec3(70.,250.,50.))-3.);\n            if (DecD<=0.) {\n                Albedo=mix(vec3(0.99,0.33,0.03)*0.65\n                        *(0.5+0.25*texture(iChannel1,vec2(PixelPos.x*0.0095,0.5)).y)\n                        ,Albedo,clamp(1.+DecD*0.25,0.,1.));\n                BushHeight=mix(0.,BushHeight,clamp(1.+DecD*0.25,0.,1.));\n            }\n            break;\n        }\n        CH0=CH1;\n        CH1=CH2;\n        CDist=CZ/Dir.z;\n    }\n    \n    //********************Last contours********************\n    if (Mat!=0.) {\n        CZ=1600.; CDist=CZ/Dir.z; Interval=200./Dir.z;\n        vec2 CH1=(ContourHeight(16.,uv.x)-Pos.y)/(CZ*CFOV)*0.5+0.5;\n        vec2 CH0=CH1;\n        for (float i=1.; i<float(NCONTOURS1); i++) {\n            CZ+=200.;\n            CH2=(ContourHeight(i+16.,uv.x)-Pos.y)/(CZ*CFOV)*0.5+0.5;\n            if (CH1.x<uv.y && uv.y<CH2.x) {\n                CH3=(ContourHeight(i+17.,uv.x)-Pos.y)/((CZ+50.)*CFOV)*0.5+0.5;\n                //Creating the cubic interpolator H(z)=az^3+bz^2+cz+d, 0<z<1\n                a=0.5*(CH3-CH0+3.*(CH1-CH2));\n                b=CH0-2.5*CH1+2.*CH2-0.5*CH3;\n                c=0.5*(CH2-CH0);\n                d=CH1;\n                //Position, normal and material\n                vec4 gradz=GradZ(a,b,c,d,uv,Interval);\n                Normal=gradz.xyz;\n                Dist=CDist+gradz.w*Interval;\n                PixelPos=Pos+Dir*Dist;\n                Mat=1.;\n                //Computing the albedo\n                TFrag=uv*vec2(800.,450.);\n                TStone = texture(iChannel3,(TFrag*1.57+vec2(1.,1.5)*(Dist*0.5))*I1024).xyz;\n                TGrass=GrassColor;\n                BushHeight=smoothstep(0.88,0.98,Normal.y)*clamp((600.-PixelPos.y)*0.02,0.,1.);\n                Albedo = mix(TStone,TGrass,BushHeight);\n                //Snow\n                float InvConc=(2.*b.x+6.*a.x*gradz.w); //Concavity\n                float ConcF=((InvConc<0.)?1.-exp(InvConc):0.);\n                TG0=clamp((PixelPos.y-600.)*0.005,0.,1.)*max(ConcF,clamp(\n                    pow(texture(iChannel2,vec2((uv.x-0.47)/(3050.-PixelPos.y)*26.,0.5)).z*1.2,1.6)\n                    +pow(texture(iChannel2,uv*0.06).z,1.3),0.,1.));\n                Albedo=mix(Albedo,vec3(TStone.x*TStone.y*0.2+0.8),min(1.,pow(TG0,2.3)));\n                BushHeight=0.;\n                //Decals (Grass)\n                DecD=length(PixelPos.xz-vec2(-1000.,1900.))-400.;\n                DecD=min(DecD,Line(PixelPos,vec3(1500.,2000.,4600.),vec3(4000.,700.,4600.))-400.);\n                if (DecD<0.) {\n                    Albedo=mix(TGrass,Albedo,clamp(1.+DecD*0.125,0.,1.));\n                    BushHeight=mix(0.,BushHeight,clamp(1.+DecD*0.25,0.,1.));\n                }\n                //Decals (farmland)\n                DecD=BoxC(PixelPos-vec3(-700.,0.,2000.),vec3(270.,600.,70.))-33.;\n                vec3 Drp=PixelPos-vec3(-1220.,0.,1920.); Drp.xz=Rotate(Drp.xz,-0.3);\n                DecD=min(DecD,BoxC(Drp-vec3(0.,0.,40.),vec3(200.,600.,30.))-3.);\n                DecD=min(DecD,BoxC(Drp-vec3(0.,0.,-65.),vec3(200.,600.,50.))-3.);\n                if (DecD<0.) {\n                    Albedo=mix(vec3(0.99,0.65,0.03)*(TStone.y),Albedo,clamp(1.+DecD*0.125,0.,1.));\n                    BushHeight=0.;\n                }\n                break;\n            }\n            CH0=CH1;\n            CH1=CH2;\n            CDist=CZ/Dir.z;\n        }\n    }\n    \n    //********************BVH Objects********************\n    BVH_HIT SDFHit=TraceBVH(uv,Pos,Dir,1./Dir,Dist);\n    if (SDFHit.D<Dist) {\n        Dist=SDFHit.D;\n        Normal=SDFHit.N;\n        Albedo=SDFHit.C;\n        PixelPos=Pos+Dir*Dist;\n        BushHeight=0.;\n    }\n    \n    //Return\n    fragColor=vec4(Write(vec4(Albedo,0.))\n                  ,Write(vec4(Normal*0.5+0.5,0.))\n                  ,BushHeight\n                  ,Dist);\n}", "name": "Buffer B", "description": "", "type": "buffer"}, {"inputs": [{"id": "XsXGR8", "filepath": "/media/previz/buffer01.png", "previewfilepath": "/media/previz/buffer01.png", "type": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "4sXGR8", "filepath": "/media/previz/buffer02.png", "previewfilepath": "/media/previz/buffer02.png", "type": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "XsBSR3", "filepath": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "type": "texture", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4sXGR8", "channel": 0}], "code": "/*\nGrowing bushes (propagation pass)\n    Output: Same as Buffer B\n*/\n\nconst ivec2 ARR_StartEnd[2]=ivec2[2](ivec2(0,1),ivec2(1,3));\nconst vec2 ARR_SP[3]=vec2[3](vec2(0.,-1.),vec2(1.,-1.),vec2(-1.,-1.));\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 fragFloor=floor(fragCoord);\n    vec2 uv=fragCoord*IRES;\n    vec3 Dir=normalize(vec3((uv*2.-1.)*(ASPECT*CFOV),1.));\n    vec4 Color=texture(iChannel0,uv);\n    //********************Vegetation rendering********************\n    float Dist=Color.w;\n    vec3 PP=CAMERA_P+Dir*Dist;\n    vec3 Normal=Read(Color.y).xyz*2.-1.;\n    vec3 Albedo=Read(Color.x).xyz;\n    float BushHeight=0.;\n    float BH; vec2 suv,suvfloor,ChunkPos,BushPos; vec3 SP,SDir; vec4 GC;\n    ivec2 SE=ARR_StartEnd[int(texture(iChannel3,fragCoord*I1024).z*2.99)];\n    for (int i=SE.x; i<SE.y; i++) {\n        suvfloor=fragFloor+ARR_SP[i];\n        suv=suvfloor*IRES;\n        SDir=normalize(vec3((suv*2.-1.)*(ASPECT*CFOV),1.));\n        //Terrain\n        GC=texture(iChannel0,suv);\n        SP=CAMERA_P+SDir*GC.w;\n        ChunkPos=floor(SP.xz*0.1);\n        BushPos=ChunkPos*10.+1.+texture(iChannel3,(ChunkPos+0.5)*I1024).xz*8.;\n        BH=GC.z*step(0.,-length(SP.xz-BushPos)+1.)*mod(suvfloor.x+suvfloor.y,2.); //Bushes\n        if (GC.w<=min(Dist,1500.) && BH>0.) {\n            Albedo=Read(GC.x).xyz;\n            Normal=vec3(0.,0.,-1.);\n            BushHeight=BH;\n            Dist=GC.w;\n        }\n        //Propagation\n        GC=texture(iChannel1,suv);\n        BH=max(-1.,GC.z-0.18*(Dir.y-SDir.y)*GC.w); //BushHeight - Projected Height\n        if (GC.w<=Dist && BH>0.) {\n            Albedo=Read(GC.x).xyz;\n            Normal=vec3(0.,0.,-1.);\n            BushHeight=BH;\n            Dist=GC.w;\n        }\n    }\n    //Updating Buffer\n    Color.x=Write(vec4(Albedo,0.));\n    Color.y=Write(vec4(Normal*0.5+0.5,0.));\n    Color.z=BushHeight;\n    Color.w=Dist;\n    //Return\n    fragColor=Color;\n}", "name": "Buffer C", "description": "", "type": "buffer"}, {"inputs": [{"id": "4dXGR8", "filepath": "/media/previz/buffer00.png", "previewfilepath": "/media/previz/buffer00.png", "type": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "4sXGR8", "filepath": "/media/previz/buffer02.png", "previewfilepath": "/media/previz/buffer02.png", "type": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "XdfGR8", "filepath": "/media/previz/buffer03.png", "previewfilepath": "/media/previz/buffer03.png", "type": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "XsBSR3", "filepath": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "type": "texture", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "XdfGR8", "channel": 0}], "code": "/*\nSSAO, Water, Fog and Light rendering\n    Output: vec4(vec4(Accumulated_light.xyz,AnimFlag)\n                ,vec4(Pos.xy,Dir.xy)\n                ,vec2(Intensity,StaticIntensity)\n                ,DynamicDepth)\n*/\n\nvoid Simulate(vec2 FUV, vec3 Dir, inout vec2 P, inout vec2 D) {\n    //Simulating gravity and collisions\n    float LD=length(D);\n    if (LD>0.02) {\n        //Gravity (D in screen-space, pixels/s^2): 9.82/(840*CFOV)*0.5*(450 pixels)\n        //    450 -> 1080 in fullscreen, but smaller pixels and higher pixel-acceleration makes no\n        //    difference when only propagating once each frame\n        D.y-=3.6*iTimeDelta;\n        //Normalization\n        LD=length(D); D=((LD>1.)?D/(LD+0.005):D);\n        //Collision\n        vec4 CC=texture(iChannel0,(FUV+P)*IRES);\n        vec2 CN=normalize(Read(CC.y).xy);\n        if (CC.w*Dir.z<840.) {\n            D=reflect(D,CN);\n        }\n        P+=D;\n        //Water\n        if ((FUV.y+P.y)*IRES.y<0.47) P=vec2(6.);\n    }\n}\n\nvec3 SampleLight(vec2 uv) {\n    //Returns mapped intensity in point uv\n    vec2 tmp_v=Read2(texture(iChannel1,uv).z);\n    return ITC(tmp_v.x)+ITC(tmp_v.y);\n}\n\nvec3 LightLine(vec3 p0, vec3 p1, vec3 p, vec2 uv, float N, float R, float I, int Type) {\n    //N lights with size R (pixels) and intensity I on a line from p0 to p1\n    vec3 Int=vec3(0.); vec2 Intensity;\n    vec2 uv0=(p0.xy-p.xy)/(((p0.z-p.z)*CFOV)*ASPECT)*0.5+0.5;\n    vec2 uv1=(p1.xy-p.xy)/(((p1.z-p.z)*CFOV)*ASPECT)*0.5+0.5;\n    vec2 uv01=uv1-uv0;\n    float uvlensqr=dot(uv01,uv01);\n    if (uvlensqr==0.) {\n        //Projection: point\n    } else {\n        //Projection: line\n        float k=dot(uv-uv0,uv01)/uvlensqr;\n        k=clamp(floor(k*N),0.,N-2.)/(N-1.);\n        vec3 LightPos=p0+k*(p1-p0);\n        Intensity=((length((uv0+uv01*k-uv)*ASPECT)>R*IRES.y)?vec2(0.,10000.):vec2(I,LightPos.z-p.z));\n        k+=1./(N-1.);\n        LightPos=p0+k*(p1-p0);\n        Intensity=((length((uv0+uv01*k-uv)*ASPECT)>R*IRES.y)?Intensity:vec2(I,LightPos.z-p.z));\n        Int[Type]=Intensity.x; Int.z=Intensity.y;\n    }\n    return Int;\n}\n\nvec3 LightRing(vec3 cp, float r, vec3 p, vec3 dir, float N, float R, float I, int Type) {\n    //N lights with size R (pixels) and intensity I on a circle with normal e_y, radius r and center p\n    vec3 Int=vec3(0.); vec2 Intensity;\n    if (dir.y==0.) {\n        //Projection: line\n    } else {\n        //Projection: ellips\n        vec2 CircleCoord=(p-cp+dir*(-(p.y-cp.y)/dir.y)).xz;\n        float Angle=atan(CircleCoord.x,CircleCoord.y)+RADIAN*0.5;\n        float FAngle=floor(Angle*IRADIAN*N)*(RADIAN/N);\n        vec3 LightPos=cp+vec3(-r*sin(FAngle),0.,-r*cos(FAngle));\n        Intensity=((TraceSphere(p,dir,LightPos,R*IRES.y*(LightPos.z-p.z))<0.)?\n                                    vec2(0.,10000.):vec2(I,LightPos.z-p.z));\n        FAngle+=(RADIAN/N);\n        LightPos=cp+vec3(-r*sin(FAngle),0.,-r*cos(FAngle));\n        Intensity=((TraceSphere(p,dir,LightPos,R*IRES.y*(LightPos.z-p.z))<0.)?\n                                    Intensity:vec2(I,LightPos.z-p.z));\n        Int[Type]=Intensity.x; Int.z=Intensity.y;\n    }\n    return Int;\n}\n\nvec3 LightRing(vec3 cp, float r, float angle, vec3 p, vec3 dir, float N, float R, float I, int Type) {\n    //N lights with size R (pixels) and intensity I on a circle with normal e_y, radius r and center p\n    vec3 Int=vec3(0.); vec2 Intensity;\n    if (dir.y==0.) {\n        //Projection: line\n    } else {\n        //Projection: ellips\n        vec2 CircleCoord=(p-cp+dir*(-(p.y-cp.y)/dir.y)).xz;\n        float Angle=atan(CircleCoord.x,CircleCoord.y)+RADIAN*0.5;\n        float FAngle=floor(Angle*IRADIAN*N)*(RADIAN/N)-angle;\n        vec3 LightPos=cp+vec3(-r*sin(FAngle),0.,-r*cos(FAngle));\n        Intensity=((TraceSphere(p,dir,LightPos,R*IRES.y*(LightPos.z-p.z))<0.)?\n                                    vec2(0.,10000.):vec2(I,LightPos.z-p.z));\n        FAngle+=(RADIAN/N);\n        LightPos=cp+vec3(-r*sin(FAngle),0.,-r*cos(FAngle));\n        Intensity=((TraceSphere(p,dir,LightPos,R*IRES.y*(LightPos.z-p.z))<0.)?\n                                    Intensity:vec2(I,LightPos.z-p.z));\n        Int[Type]=Intensity.x; Int.z=Intensity.y;\n    }\n    return Int;\n}\n\nvoid RenderAnimatedLights(vec2 uv, inout vec2 I, inout float AFlag) {\n    //Animated lights\n    float uvlen=length((uv-vec2(0.25-pow(sin(iTime*0.1),2.)*0.04,0.78+0.055*(1.-exp(-iTime*0.15))))*ASPECT);\n        if (uvlen<IRES.y*2.) { I.y=0.4+0.2*(uvlen/(IRES.y*2.)); AFlag=1.; } //Helicopter\n}\n\nvec3 LightTower(vec3 RP, vec3 D, vec3 cRET) { //60, 230, 60\n    //Using the same light-positions and types for all 4 towers\n    vec3 RET=cRET; vec3 LRET;\n    LRET=LightRing(vec3(30.,200.,30.),7.,-0.75,RP,D,5.,1.,0.5,1); if (LRET.z<RET.z) RET=LRET; //\u00d6verst\n        LRET=LightRing(vec3(30.,190.,30.),9.,RP,D,8.,0.9,0.6,1); if (LRET.z<RET.z) RET=LRET;\n        LRET=LightRing(vec3(30.,180.,30.),9.,RP,D,8.,0.9,0.6,1); if (LRET.z<RET.z) RET=LRET;\n    LRET=LightRing(vec3(30.,80.,30.),18.,RP,D,16.,1.5,0.5,0); if (LRET.z<RET.z) RET=LRET; //Plattform\n            LRET=LightRing(vec3(30.,85.,30.),8.,RP,D,16.,2.,0.6,0); if (LRET.z<RET.z) RET=LRET;\n        LRET=LightRing(vec3(30.,50.,30.),17.,RP,D,11.,1.5,0.55,0); if (LRET.z<RET.z) RET=LRET;\n        LRET=LightRing(vec3(30.,30.,30.),17.,RP,D,11.,1.5,0.55,0); if (LRET.z<RET.z) RET=LRET;\n    return RET;\n}\n\nvec3 LightVaktTorn(vec3 RP, vec3 D, vec3 cRET) { //45, 40, 45\n    vec3 RET=cRET; vec3 LRET;\n    LRET=LightRing(vec3(22.5,27.,22.5),8.,RP,D,3.,2.,0.25,0); if (LRET.z<RET.z) RET=LRET; //\u00d6verst\n    return RET;\n}\n\nvec3 TraceBVH(vec2 uv, vec3 P, vec3 D, vec3 ID, float TerZ) {\n    //Tracing the light BVH: vec3(Stat Intensity, Dyn Intensity, Dist)\n    vec3 RET=vec3(0.,0.,TerZ); vec3 LRET,RP,RD,IRD; vec2 bb;\n    if (uv.x<0.5) {\n        if (uv.y<0.5) {\n            if (BBox(P,ID,vec3(-225.,25.,170.),vec3(100.,10.,100.),bb)) { //Tunnel\n                vec3 RP=P-vec3(-225.,25.,170.);\n                LRET=LightLine(vec3(-3.,4.,9.),vec3(-3.,4.,20.),RP,uv,3.,2.,0.3,0);\n                    if (LRET.z<RET.z) RET=LRET;\n            }\n            RP=P-vec3(-220.,10.,350.); RD=D; RP.xz=Rotate(RP.xz,-0.4);\n                                             RD.xz=Rotate(RD.xz,-0.4); IRD=1./RD;\n            if (BBox(RP,IRD,vec3(-10.,-15.,-130.),vec3(20.,40.,280.),bb)) { //Bridge\n                LRET=LightLine(vec3(-170.,30.,230.),vec3(-275.,30.,500.),P,uv,12.,2.,0.2,0);\n                    if (LRET.z<RET.z) RET=LRET;\n            }\n        } else {\n            if (BBox(P,ID,vec3(-530.,135.,600.),vec3(40.,80.,40.),bb)) { //Church\n                RP=P-vec3(-530.,135.,600.);\n                LRET=LightLine(vec3(4.,30.,-1.),vec3(36.,30.,-1.),RP,uv,4.,1.,0.55,0);\n                    if (LRET.z<RET.z) RET=LRET;\n                LRET=LightLine(vec3(41.,27.,2.),vec3(41.,27.,38.),RP,uv,6.,1.5,0.45,0);\n                    if (LRET.z<RET.z) RET=LRET;\n                LRET=LightRing(vec3(3.5,50.,16.5),4.5,RP,D,4.,1.5,0.4,0); if (LRET.z<RET.z) RET=LRET; //Torn\n                LRET=LightRing(vec3(3.5,60.,16.5),4.5,RP,D,4.,1.5,0.4,0); if (LRET.z<RET.z) RET=LRET;\n                LRET=LightRing(vec3(3.5,70.,16.5),5.5,RP,D,4.,1.5,0.55,0); if (LRET.z<RET.z) RET=LRET;\n            }\n            if (BBox(P,ID,vec3(-2350.,2000.,4450.),vec3(50.,50.,20.),bb)) { //Helikopter plattform\n                LRET=LightRing(vec3(25.,5.,25.),10.,P-vec3(-2350.,2000.,4450.),D,7.,1.5,0.5,0);\n                if (LRET.z<RET.z) RET=LRET;\n            }\n            if (BBox(P,ID,vec3(-3400.,1800.,4450.),vec3(700.,300.,200.),bb)) { //Flygbas berg\n                RP=P-vec3(-3300.,1800.,4450.);\n                if (BBox(RP,ID,vec3(-40.,60.,30.),vec3(250.,250.,180.),bb)) { //Falco maxime torn\n                LRET=LightRing(vec3(0.,240.,120.),7.,RP,D,8.,5.,0.4,0); if (LRET.z<RET.z) RET=LRET;\n                    LRET=LightRing(vec3(150.,240.,120.),7.,RP,D,8.,5.,0.4,0); if (LRET.z<RET.z) RET=LRET;\n                LRET=LightRing(vec3(70.,210.,120.),100.,RP,D,10.,2.,0.4,0); if (LRET.z<RET.z) RET=LRET;\n                        LRET=LightRing(vec3(70.,190.,120.),90.,RP,D,17.,1.5,0.6,0);\n                            if (LRET.z<RET.z) RET=LRET;\n                        LRET=LightRing(vec3(80.,170.,120.),70.,RP,D,17.,1.5,0.7,0);\n                            if (LRET.z<RET.z) RET=LRET;\n                    LRET=LightRing(vec3(80.,140.,120.),50.,RP,D,17.,0.75,0.3,0); if (LRET.z<RET.z) RET=LRET;\n                    LRET=LightRing(vec3(80.,80.,120.),50.,RP,D,17.,0.75,0.3,0); if (LRET.z<RET.z) RET=LRET;\n                }\n                if (BBox(RP,ID,vec3(100.,40.,90.),vec3(400.,500.,100.),bb)) { //Flygbanor\n                    RP=P-vec3(-3300.,1800.,4450.)-vec3(100.,40.,90.);\n                    LRET=LightLine(vec3(20.,60.,20.),vec3(300.,60.,20.),RP,uv,10.,0.65,0.5,0); //\u00d6vre bana\n                        if (LRET.z<RET.z) RET=LRET;\n                        LRET=LightLine(vec3(20.,50.,20.),vec3(300.,50.,20.),RP,uv,5.,0.85,0.6,0);\n                            if (LRET.z<RET.z) RET=LRET;\n                    LRET=LightLine(vec3(60.,30.,20.),vec3(120.,30.,20.),RP,uv,10.,3.,0.8,0); //Nedre bana\n                        if (LRET.z<RET.z) RET=LRET;\n                    LRET=LightLine(vec3(60.,10.,20.),vec3(400.,10.,20.),RP,uv,10.,1.5,0.6,0); //Nedre bana 2\n                        if (LRET.z<RET.z) RET=LRET;\n                    LRET=LightLine(vec3(280.,40.,20.),vec3(280.,220.,20.),RP,uv,5.,0.6,0.8,0); //Mast\n                        if (LRET.z<RET.z) RET=LRET;\n                    LRET=LightRing(vec3(240.,100.,10.),30.,RP,D,7.,0.75,0.35,0); if (LRET.z<RET.z) RET=LRET;\n                    LRET=LightLine(vec3(200.,170.,20.),vec3(380.,70.,20.),RP,uv,2.,0.6,0.75,0); //2 ljus\n                        if (LRET.z<RET.z) RET=LRET;\n                    LRET=LightLine(vec3(60.,2.,0.),vec3(380.,2.,0.),RP,uv,4.,1.2,0.8,0); //Under bana\n                        if (LRET.z<RET.z) RET=LRET;\n                }\n            }\n            if (BBox(P,ID,vec3(-1400.,200.,1700.),vec3(1400.,200.,200.),bb)) { //V\u00e4nstra delen av v\u00e4gg\n                //Sm\u00e5 ljus\n                LRET=LightLine(vec3(0.,360.,1600.),vec3(-300.,330.,1600.),P,uv,5.,1.,0.8,0);\n                    if (LRET.z<RET.z) RET=LRET;\n                LRET=LightLine(vec3(-500.,300.,1600.),vec3(-750.,310.,1600.),P,uv,5.,1.,0.8,0);\n                    if (LRET.z<RET.z) RET=LRET;\n                LRET=LightLine(vec3(-750.,300.,1600.),vec3(-1200.,280.,1600.),P,uv,7.,1.,0.8,0);\n                    if (LRET.z<RET.z) RET=LRET;\n                //Stora ljus\n                LRET=LightLine(vec3(0.,360.,1600.),vec3(-300.,330.,1600.),P,uv,3.,2.,0.7,0);\n                    if (LRET.z<RET.z) RET=LRET;\n                    LRET=LightLine(vec3(-290.,330.,1610.),vec3(-310.,330.,1610.),P,uv,3.,1.5,0.4,0);\n                        if (LRET.z<RET.z) RET=LRET;\n                LRET=LightLine(vec3(-500.,300.,1600.),vec3(-750.,310.,1600.),P,uv,3.,2.,0.7,0);\n                    if (LRET.z<RET.z) RET=LRET;\n                LRET=LightLine(vec3(-750.,300.,1600.),vec3(-1200.,280.,1600.),P,uv,4.,2.,0.7,0);\n                    if (LRET.z<RET.z) RET=LRET;\n                //Sm\u00e5ljus under v\u00e4ggen (typ byggnader)\n                LRET=LightLine(vec3(-200.,280.,1610.),vec3(-810.,220.,1610.),P,uv,2.,1.,0.75,0);\n                        if (LRET.z<RET.z) RET=LRET;\n            }\n            if (BBox(P,ID,vec3(-1900.,1100.,3500.),vec3(300.,100.,100.),bb)) { //Liten outpost vid gruva\n                RP=P-vec3(-1900.,1100.,3500.);\n                LRET=LightLine(vec3(10.,20.,0.),vec3(290.,20.,0.),RP,uv,5.,1.5,0.7,0);\n                    if (LRET.z<RET.z) RET=LRET;\n                LRET=LightLine(vec3(20.,20.,0.),vec3(220.,20.,0.),RP,uv,12.,1.,0.55,0);\n                    if (LRET.z<RET.z) RET=LRET;\n                    LRET=LightLine(vec3(60.,30.,0.),vec3(200.,30.,0.),RP,uv,3.,1.,0.4,0);\n                        if (LRET.z<RET.z) RET=LRET;\n                    LRET=LightLine(vec3(70.,20.,0.),vec3(70.,90.,0.),RP,uv,5.,0.7,0.8,0);\n                        if (LRET.z<RET.z) RET=LRET;\n            }\n            if (BBox(P,ID,vec3(-1800.,650.,3000.),vec3(200.,50.,100.),bb)) { //Liten v\u00e4g vid gruva\n                LRET=LightLine(vec3(20.,20.,0.),vec3(100.,30.,0.),P-vec3(-1800.,650.,3000.),uv,2.,1.,0.5,0);\n                    if (LRET.z<RET.z) RET=LRET;\n                LRET=LightLine(vec3(100.,30.,0.),vec3(180.,25.,0.),P-vec3(-1800.,650.,3000.),uv,2.,1.,0.5,0);\n                    if (LRET.z<RET.z) RET=LRET;\n            }\n        }\n    } else {\n        if (BBox(P,ID,vec3(350.,0.,730.),vec3(200.,250.,250.),bb)) { //Bas torn\n            RP=P-vec3(350.,0.,730.);\n            if (BBox(RP,ID,vec3(20.,0.,200.),vec3(60.,230.,60.),bb)) { //Torn 4\n                RET=LightTower(RP-vec3(20.,0.,200.),D,RET);\n            }\n            if (BBox(RP,ID,vec3(80.,0.,160.),vec3(60.,230.,60.),bb)) { //Torn 3\n                RET=LightTower(RP-vec3(80.,0.,160.),D,RET);\n            }\n            if (BBox(RP,ID,vec3(90.,0.,100.),vec3(60.,230.,60.),bb)) { //Torn 2\n                RET=LightTower(RP-vec3(90.,0.,100.),D,RET);\n            }\n            if (BBox(RP,ID,vec3(120.,0.,10.),vec3(60.,230.,60.),bb)) { //Torn 1\n                RET=LightTower(RP-vec3(120.,0.,10.),D,RET);\n            }\n            if (BBox(RP,ID,vec3(0.,0.,60.),vec3(200.,250.,80.),bb)) { //Dish + g\u00e5ngar och annat\n                RP=RP-vec3(110.,0.,60.);\n                LRET=LightLine(vec3(10.,90.,15.),vec3(65.,90.,15.),RP,uv,10.,0.5,0.45,1); //Stor kloss\n                    if (LRET.z<RET.z) RET=LRET;\n                    LRET=LightLine(vec3(15.,100.,15.),vec3(65.,100.,15.),RP,uv,10.,0.5,0.55,1);\n                        if (LRET.z<RET.z) RET=LRET;\n                    LRET=LightLine(vec3(5.,130.,15.),vec3(65.,130.,15.),RP,uv,10.,0.5,0.65,1);\n                        if (LRET.z<RET.z) RET=LRET;\n                LRET=LightRing(vec3(40.,155,40.),14.,RP,D,14.,1.,0.35,1); if (LRET.z<RET.z) RET=LRET;\n                    LRET=LightRing(vec3(40.,165,40.),14.,RP,D,14.,1.,0.35,1); if (LRET.z<RET.z) RET=LRET;\n                LRET=LightRing(vec3(40.,193,40.),35.,RP,D,12.,1.5,0.55,1); if (LRET.z<RET.z) RET=LRET;\n                //Kustens ljus\n                LRET=LightLine(vec3(10.,17.,-40.),vec3(40.,13.,-40.),RP,uv,2.,2.,0.45,0); //V\u00e4g till kust\n                    if (LRET.z<RET.z) RET=LRET;\n                    LRET=LightLine(vec3(-50.,34.,-35.),vec3(40.,18.,-35.),RP,uv,5.,1.,0.2,0); //Sm\u00e5 lampor\n                        if (LRET.z<RET.z) RET=LRET;\n                LRET=LightLine(vec3(65.,5.,-20.),vec3(65.,30.,-20.),RP,uv,5.,1.,0.55,0); //Torn\n                    if (LRET.z<RET.z) RET=LRET;\n                //G\u00e5ng mellan torn\n                LRET=LightLine(vec3(-75.,55.,0.),vec3(60.,55.,0.),RP,uv,12.,0.8,0.6,1);\n                    if (LRET.z<RET.z) RET=LRET;\n            }\n        }\n        if (BBox(P,ID,vec3(280.,0.,500.),vec3(30.,16.,15.),bb)) { //Hamn\n            LRET=LightLine(vec3(280.,4.,500.),vec3(295.,4.,500.),P,uv,3.,1.,0.45,0);\n                if (LRET.z<RET.z) RET=LRET;\n            LRET=LightLine(vec3(280.,4.,515.),vec3(295.,4.,515.),P,uv,3.,1.,0.45,0);\n                if (LRET.z<RET.z) RET=LRET;\n        }\n        if (BBox(P,ID,vec3(1100.,0.,1700.),vec3(600.,150.,200.),bb)) { //Stad\n            RP=P-vec3(1200.,0.,1700.);\n            LRET=LightLine(vec3(105.,25.,0.),vec3(185.,25.,0.),RP,uv,7.,1.,0.5,0); //Hus bakom\n                if (LRET.z<RET.z) RET=LRET;\n                LRET=LightLine(vec3(105.,35.,0.),vec3(185.,35.,0.),RP,uv,7.,1.,0.6,0);\n                    if (LRET.z<RET.z) RET=LRET;\n                LRET=LightLine(vec3(130.,45.,0.),vec3(200.,45.,0.),RP,uv,7.,1.,0.75,0);\n                    if (LRET.z<RET.z) RET=LRET;\n            LRET=LightLine(vec3(220.,25.,5.),vec3(220.,25.,75.),RP,uv,7.,1.,0.7,0); //1 hus\n                if (LRET.z<RET.z) RET=LRET;\n                LRET=LightLine(vec3(220.,35.,5.),vec3(220.,35.,75.),RP,uv,7.,1.,0.7,0);\n                    if (LRET.z<RET.z) RET=LRET;\n            LRET=LightLine(vec3(290.,25.,5.),vec3(290.,25.,75.),RP,uv,7.,1.,0.7,0); //2 hus\n                if (LRET.z<RET.z) RET=LRET;\n                LRET=LightLine(vec3(290.,35.,5.),vec3(290.,35.,75.),RP,uv,7.,1.,0.7,0);\n                    if (LRET.z<RET.z) RET=LRET;\n            LRET=LightLine(vec3(40.,10.,-5.),vec3(480.,10.,-5.),RP,uv,24.,0.7,0.75,0); //R\u00f6d stor linje\n                if (LRET.z<RET.z) RET=LRET;\n                LRET=LightLine(vec3(350.,27.,-5.),vec3(430.,27.,-5.),RP,uv,4.,1.,0.8,0);\n                    if (LRET.z<RET.z) RET=LRET;\n                LRET=LightLine(vec3(255.,35.,-5.),vec3(315.,35.,-5.),RP,uv,2.,1.5,0.05,0);\n                    if (LRET.z<RET.z) RET=LRET;\n            LRET=LightLine(vec3(-100.,15.,-4.),vec3(150.,20.,-4.),RP,uv,9.,0.7,0.45,0); //V\u00e4g\n                if (LRET.z<RET.z) RET=LRET;\n            LRET=LightLine(vec3(320.,125.,-4.),vec3(350.,120.,-4.),RP,uv,3.,0.6,0.1,0); //Hopp\n                if (LRET.z<RET.z) RET=LRET;\n                LRET=LightLine(vec3(160.,125.,0.),vec3(470.,135.,0.),RP,uv,7.,0.6,0.75,0); //Ljuslyktor\n                    if (LRET.z<RET.z) RET=LRET;\n                LRET=LightLine(vec3(0.,125.,0.),vec3(160.,125.,0.),RP,uv,4.,0.6,0.75,0); //Ljuslyktor\n                    if (LRET.z<RET.z) RET=LRET;\n        }\n        if (BBox(P,ID,vec3(0.,200.,1700.),vec3(1500.,300.,200.),bb)) { //H\u00f6gra delen av stor v\u00e4gg\n            LRET=LightLine(vec3(1200.,200.,1600.),vec3(1350.,200.,1600.),P,uv,7.,1.,0.5,0);\n                if (LRET.z<RET.z) RET=LRET;\n                LRET=LightLine(vec3(1230.,200.,1600.),vec3(1320.,200.,1600.),P,uv,3.,3.,0.7,0);\n                    if (LRET.z<RET.z) RET=LRET;\n                LRET=LightLine(vec3(1150.,200.,1550.),vec3(1150.,215.,1550.),P,uv,2.,0.8,0.2,0);\n                    if (LRET.z<RET.z) RET=LRET;\n                LRET=LightLine(vec3(1150.,220.,1600.),vec3(1250.,220.,1600.),P,uv,7.,2.,0.65,0);\n                    if (LRET.z<RET.z) RET=LRET;\n                LRET=LightLine(vec3(1200.,210.,1590.),vec3(1300.,210.,1590.),P,uv,3.,2.,0.75,0);\n                    if (LRET.z<RET.z) RET=LRET;\n            LRET=LightRing(vec3(1340.,230.,1590.),6.,P,D,4.,1.,0.3,0); if (LRET.z<RET.z) RET=LRET; //Torn\n                LRET=LightRing(vec3(1340.,245.,1590.),6.,P,D,4.,1.,0.3,0); if (LRET.z<RET.z) RET=LRET;\n                LRET=LightRing(vec3(1340.,265.,1590.),10.,P,D,4.,1.,0.5,0); if (LRET.z<RET.z) RET=LRET;\n            //Sm\u00e5 r\u00f6da ljus v\u00e4g\n            LRET=LightLine(vec3(1150.,220.,1600.),vec3(1000.,260.,1600.),P,uv,5.,1.,0.75,0);\n                if (LRET.z<RET.z) RET=LRET;\n            LRET=LightLine(vec3(1000.,260.,1600.),vec3(500.,350.,1600.),P,uv,7.,1.,0.75,0);\n                if (LRET.z<RET.z) RET=LRET;\n            LRET=LightLine(vec3(250.,330.,1600.),vec3(0.,360.,1600.),P,uv,5.,1.,0.8,0);\n                if (LRET.z<RET.z) RET=LRET;\n            //Stora torn p\u00e5 v\u00e4g\n            LRET=LightLine(vec3(1150.,220.,1600.),vec3(1000.,260.,1600.),P,uv,3.,2.,0.7,0);\n                if (LRET.z<RET.z) RET=LRET;\n            LRET=LightLine(vec3(1000.,260.,1600.),vec3(500.,350.,1600.),P,uv,3.,2.,0.7,0);\n                if (LRET.z<RET.z) RET=LRET;\n            LRET=LightLine(vec3(500.,350.,1600.),vec3(250.,330.,1600.),P,uv,3.,2.,0.7,0);\n                if (LRET.z<RET.z) RET=LRET;\n            LRET=LightLine(vec3(250.,330.,1600.),vec3(0.,360.,1600.),P,uv,3.,2.,0.7,0);\n                if (LRET.z<RET.z) RET=LRET;\n        }\n        if (BBox(P,ID,vec3(1200.,600.,2600.),vec3(100.,80.,100.),bb)) { //Liten outpost\n            RP=P-vec3(1200.,600.,2600.);\n            LRET=LightLine(vec3(5.,7.,0.),vec3(90.,7.,0.),RP,uv,3.,2.,0.35,0); //Str\u00e5lkastare\n                if (LRET.z<RET.z) RET=LRET;\n            LRET=LightLine(vec3(5.,5.,-1.),vec3(90.,5.,-1.),RP,uv,7.,1.5,0.7,0); //Str\u00e5lkastare\n                if (LRET.z<RET.z) RET=LRET;\n        }\n    }\n    if (BBox(P,ID,vec3(-50.,105.,740.),vec3(350.,40.,100.),bb)) { //Bas kulle\n        RP=P-vec3(-50.,105.,740.);\n        if (BBox(RP,ID,vec3(235.,0.,0.),vec3(45.,40.,45.),bb)) //Torn \u00e5t h\u00f6ger\n            RET=LightVaktTorn(RP-vec3(235.,0.,0.),D,RET);\n        if (BBox(RP,ID,vec3(175.,0.,10.),vec3(45.,40.,45.),bb)) //Torn\n            RET=LightVaktTorn(RP-vec3(175.,0.,10.),D,RET);\n        if (BBox(RP,ID,vec3(89.,-10.,10.),vec3(45.,40.,45.),bb)) //Torn \u00e5t v\u00e4nster\n            RET=LightVaktTorn(RP-vec3(89.,-10.,10.),D,RET);\n        if (BBox(RP,ID,vec3(9.,-20.,10.),vec3(45.,40.,45.),bb)) //Torn l\u00e4ngre bak\n            RET=LightVaktTorn(RP-vec3(9.,-20.,10.),D,RET);\n        if (BBox(RP,ID,vec3(124.,0.,25.),vec3(20.,20.,30.),bb)) { //Hus\n            LRET=LightLine(vec3(5.,14.,-1.),vec3(15.,14.,-1.),RP-vec3(124.,0.,25.),uv,4.,1.,0.4,0);\n                if (LRET.z<RET.z) RET=LRET;\n        }\n        //Objekt p\u00e5 kullen (dish, generator, ...)\n        LRET=LightLine(vec3(280.,25.,-1.),vec3(330.,15.,-1.),RP,uv,2.,3.,0.25,0); //Str\u00e5lkastare\n            if (LRET.z<RET.z) RET=LRET;\n        LRET=LightLine(vec3(300.,20.,0.),vec3(330.,20.,0.),RP,uv,4.,1.,0.7,0); //Generator\n            if (LRET.z<RET.z) RET=LRET;\n        LRET=LightRing(vec3(220.,12.,4.),8.,RP,D,5.,2.,0.4,0); if (LRET.z<RET.z) RET=LRET;\n    }\n    if (BBox(P,ID,vec3(200.,240.,1800.),vec3(500.,120.,200.),bb)) { //Flygbas kust\n        RP=P-vec3(200.,240.,1800.);\n        LRET=LightLine(vec3(150.,40.,0.),vec3(480.,40.,0.),RP,uv,13.,0.7,0.7,0); //Nedre bana\n            if (LRET.z<RET.z) RET=LRET;\n            LRET=LightLine(vec3(150.,30.,1.),vec3(420.,30.,1.),RP,uv,5.,1.7,0.5,0);\n                if (LRET.z<RET.z) RET=LRET;\n        LRET=LightLine(vec3(100.,60.,0.),vec3(350.,60.,0.),RP,uv,13.,0.9,0.6,0); //\u00d6vre bana\n            if (LRET.z<RET.z) RET=LRET;\n            LRET=LightLine(vec3(50.,60.,0.),vec3(120.,30.,0.),RP,uv,3.,1.5,0.5,0);\n                if (LRET.z<RET.z) RET=LRET;\n            LRET=LightLine(vec3(50.,40.,4.),vec3(120.,40.,4.),RP,uv,5.,1.,0.8,0);\n                if (LRET.z<RET.z) RET=LRET;\n        LRET=LightRing(vec3(200.,80.,50.),8.,RP,D,4.,1.,0.7,0); if (LRET.z<RET.z) RET=LRET; //Torn\n            LRET=LightRing(vec3(200.,95.,50.),8.,RP,D,4.,1.,0.7,0); if (LRET.z<RET.z) RET=LRET;\n            LRET=LightRing(vec3(200.,115.,50.),10.,RP,D,4.,1.,0.5,0); if (LRET.z<RET.z) RET=LRET;\n        LRET=LightRing(vec3(230.,75.,50.),10.,RP,D,3.,1.5,0.3,0); if (LRET.z<RET.z) RET=LRET; //Hus\n    }\n    if (BBox(P,ID,vec3(-500.,0.,640.),vec3(500.,100.,200.),bb)) { //V\u00e4gar vid basen vid kusten och mainland\n        LRET=LightLine(vec3(-250.,75.,600.),vec3(-100.,90.,600.),P,uv,7.,1.,0.5,0); //V\u00e4g till bas\n            if (LRET.z<RET.z) RET=LRET;\n            LRET=LightRing(vec3(-240.,73.,598.),6.,P,D,9.,1.,0.2,0); if (LRET.z<RET.z) RET=LRET; //Vakt\n        LRET=LightLine(vec3(-250.,75.,600.),vec3(-150.,20.,500.),P,uv,6.,0.7,0.6,0); //V\u00e4g ned\n            if (LRET.z<RET.z) RET=LRET;\n        LRET=LightLine(vec3(-370.,95.,590.),vec3(-400.,70.,520.),P,uv,8.,1.,0.5,0); //V\u00e4g kyrka\n            if (LRET.z<RET.z) RET=LRET;\n        LRET=LightLine(vec3(-298.,72.,590.),vec3(-300.,70.,570.),P,uv,3.,1.,0.65,0); //V\u00e4g wine\n            if (LRET.z<RET.z) RET=LRET;\n    }\n    //Ljus p\u00e5 kullen\n    LRET=LightLine(vec3(1830.,680.,2600.),vec3(1870.,680.,2600.),P,uv,7.,1.,0.5,0); //Str\u00e5lkastare\n        if (LRET.z<RET.z) RET=LRET;\n    LRET=LightLine(vec3(500.,1000.,2600.),vec3(520.,1000.,2600.),P,uv,2.,1.,0.7,0); //Str\u00e5lkastare\n        if (LRET.z<RET.z) RET=LRET;\n    //Star injection\n    if (TerZ>5000.) {\n        vec2 StarFloor=floor(uv*10.);\n        vec3 StarRand=texture(iChannel3,(StarFloor+56.5)*I1024).xyz;\n        if (length(uv-(StarFloor+StarRand.xy)*0.1)<IRES.y) RET.x=D.y*(0.02+0.02*StarRand.z);\n    }\n    //Return\n    return vec3(RET.xy,RET.z*ID.z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv=fragCoord*IRES;\n    vec2 fragFloor=floor(fragCoord);\n    vec4 Color=texture(iChannel0,uv);\n    //********************AO,Water,Fog*********************\n    vec3 Light=vec3(0.);\n    vec3 Albedo=Read(Color.x).xyz;\n    vec3 Pos=CAMERA_P;\n    vec3 Dir=normalize(vec3((uv*2.-1.)*(ASPECT*CFOV),1.));\n    float WaterDist=-Pos.y/Dir.y;\n    if (Color.w>9900.) {\n        //Sky\n        Light=SkyColor*(0.3+0.7*(1.-Dir.y));\n    } else {\n        if (Dir.y<0. && WaterDist<=Color.w) {\n            //Water (albedo and ambient light)\n            vec3 PPos=Pos+Dir*WaterDist;\n            vec2 WaterCoord=vec2(dot(OWaveDir,PPos),dot(WaveDir,PPos)-iTime);\n            vec2 FWC=floor(WaterCoord*0.025);\n            vec2 WavePos=FWC*40.+vec2(10.,4.)+texture(iChannel3,(FWC+512.5)*I1024).zy*vec2(20.,32.);\n            vec2 RandSize=vec2(0.1,0.25)*(0.75+texture(iChannel3,(WaterCoord*0.7+iTime*0.5+256.5)*I1024).xy);\n            float FoamFactor=0.05*clamp(1.-length((WavePos-WaterCoord)*RandSize),0.,1.);\n            FoamFactor+=clamp(1.-(Color.w-WaterDist)*RandSize.y*0.5,0.,1.)*0.1;\n            Albedo=vec3(FoamFactor);\n            Light=AmbientColor;\n            Color.w=WaterDist;\n        } else {\n            //Geometry (SSAO)\n            vec3 Pos=CAMERA_P;\n            float AO=1.;\n            if (Color.w<9900.) {\n                vec3 Dir=normalize(vec3((uv*2.-1.)*(ASPECT*CFOV),1.));\n                vec3 Normal=Read(Color.y).xyz*2.-1.;\n                mat3 NM=TBN(Normal);\n                vec3 PixelPos=Pos+Dir*Color.w;\n                float aoZ,aoDist; AO=0.; vec2 aoUV; vec3 aoPos,aoDir;\n                for (float j=0.; j<8.; j++) {\n                    aoDir=RandSample(texture(iChannel3,(fragCoord+j*32.)/1024.).xy)*NM;\n                    for (float i=0.; i<3.; i++) {\n                        aoDist=pow(3.,i+1.);\n                        aoPos=PixelPos+aoDir*aoDist;\n                        aoUV=(aoPos.xy-Pos.xy)/(aoPos.z*CFOV*ASPECT)*0.5+0.5;\n                        aoZ=texture(iChannel0,aoUV).w*Dir.z-aoPos.z;\n                        if (aoZ<0. && aoZ>-aoDist*6.) { AO=AO+1.; break; }\n                    }\n                }\n                //Ambient light\n                Light=((0.4+0.6*dot(Normal,LightDir))*(1.-AO*0.125))*AmbientColor;\n            }\n        }\n        Light=Albedo*Light;\n        Light=BlueFog(Light,Pos,Dir,Color.w);\n        \n    }\n    //********************Lightsources********************\n    float AnimFlag; vec2 Intensities,PDir,PPos;\n    if (iFrame==0 || texture(iChannel2,vec2(17.5,0.5)*IRES).x>0.) {\n        //Injection (static and dynamic lights)\n        Intensities=vec2(0.);\n        vec3 BVH_RET=TraceBVH(uv,Pos,Dir,1./Dir,Color.w*Dir.z);\n        Intensities=BVH_RET.xy;\n        AnimFlag=0.;\n        PPos=vec2(0.5);\n        PDir=vec2(0.);\n    } else {\n        Color=texture(iChannel1,uv);\n        AnimFlag=Read(Color.x).w;\n        Intensities=Read2(Color.z);\n        PPos=Read2(Color.y);\n        PDir=Read2(Color.w)*2.-1.;\n    }\n    vec4 SV=texture(iChannel2,vec2(16.5,0.5)*IRES);\n    bool PIXEL_EMPTY=false;\n    //Removing old animated lights\n    if (AnimFlag>0.5) {\n        Intensities.y=0.;\n        AnimFlag=0.;\n    }\n    //Simulation of falling and colliding lights\n    if (Intensities.y==0.) {\n        //Air or only a static lightsource\n        PIXEL_EMPTY=true;\n    } else {\n        //A dynamic lightsource (collision, explosion)\n        //Injection of shockwave\n        if (SV.x>0.) {\n            vec2 ExpCenter=vec2(500./(840.*CFOV*ASPECT.x)*0.5+0.5,0.64);\n            float uvlen=length((ExpCenter-uv)*ASPECT);\n            if (iTime-SV.y>10. && uvlen<0.09) {\n                PDir=0.5*(uv-ExpCenter)*ASPECT/uvlen;\n            }\n        }\n        //Movement\n        Simulate(fragFloor,Dir,PPos,PDir);\n        if (Box2(PPos.xy,vec2(1.))>0.) {\n            //Lightsource outside pixel\n            Intensities.y=0.;\n            PPos=vec2(0.);\n            PDir=vec2(0.);\n            PIXEL_EMPTY=true;\n        }\n    }\n    //Propagation and injection of animated lights\n    if (PIXEL_EMPTY) {\n        //Injection\n        RenderAnimatedLights(uv,Intensities,AnimFlag);\n        //Propagation (3x3 search)\n        vec2 OFF,FUV,SP,SD; vec4 SC;\n        for (int j=0; j<8; j++) {\n            OFF=Offset3[j];\n            FUV=fragFloor+OFF;\n            SC=texture(iChannel1,(FUV+0.5)*IRES);\n            if (Box2(FUV,iResolution.xy)>0. || Read2(SC.z).y==0.) continue;\n            SP=Read2(SC.y);\n            SD=Read2(SC.w)*2.-1.;\n            Simulate(FUV,Dir,SP,SD);\n            if (Box2(OFF+SP,vec2(1.))<0.) {\n                //Particle moves into this pixel\n                PPos=OFF+SP;\n                PDir=SD;\n                Intensities.y=Read2(SC.z).y;\n            }\n        }\n    }\n    //Sampling the lights\n    Light+=(ITC(Intensities.x)+ITC(Intensities.y))*0.5+\n            (SampleLight(uv+vec2(IRES.x,0.))+SampleLight(uv+vec2(-IRES.x,0.))+\n            SampleLight(uv+vec2(0.,IRES.y))+SampleLight(uv+vec2(0.,-IRES.y))+\n            SampleLight(uv+IRES)+SampleLight(uv-IRES)+\n            SampleLight(uv+vec2(-IRES.x,IRES.y))+SampleLight(uv+vec2(IRES.x,-IRES.y)))*0.0625;\n    Light=clamp(Light,vec3(0.),vec3(1.));\n    //Output\n    fragColor=vec4(Write(vec4(Light,AnimFlag))\n                  ,Write2(PPos)\n                  ,Write2(Intensities.xy)\n                  ,Write2(PDir*0.5+0.5));\n}", "name": "Buffer D", "description": "", "type": "buffer"}]}