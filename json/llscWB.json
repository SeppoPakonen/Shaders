{"ver": "0.1", "info": {"id": "llscWB", "date": "1506311142", "viewed": 124, "name": "draw an ellipse", "username": "tamwaiban", "description": "draw an ellipse", "likes": 0, "published": 1, "flags": 0, "tags": ["drawing"], "requires": ["imagebuf"]}, "renderpass": [{"inputs": [], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "float ellipse(vec2 p, vec2 c, float a, float b)\n{\n    p = p - c;\n    a = 1.0/a;\n    b = 1.0/b;\n    return (length( p*vec2(a,b) )-1.0)/(length(p*vec2(a*a,b*b)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float angle = iTime;\n    \n    vec2 centerPivot = iResolution.xy*0.5;\n    \n    //calculate the distance from current position to the center pivot\n    float dist = distance(fragCoord, centerPivot);\n    \n    //calculate the vector angle from center pivot to current position\n    float theta = atan(fragCoord.y - centerPivot.y, fragCoord.x - centerPivot.x);\n    \n    //calculate the vector angle from center pivot to the new position\n    theta -= angle;\n\n    //the final rotated position we should read from inTexture\n    vec2 rotated = centerPivot +  vec2(cos(theta) * dist, sin(theta) * dist);\n    \n    vec2 uv = rotated / iResolution.xy;\n    \n    vec2 center   = vec2(0.5, 0.5);\n    float rad_x   = 0.3;\n    float rad_y   = 0.2;\n    float falloff = 0.05;\n    \n    float fill  = ellipse( uv, center, rad_x, rad_y );\n\n    vec3 col = vec3(0.0,0.7,0.9);\n    col = mix( col, vec3(1.0,0.5,0.6), 1.0 - smoothstep( -falloff, falloff, fill   ) );\n\t\n    fragColor = vec4( col, 1.0 );\n}", "name": "Image", "description": "", "type": "image"}]}