{"ver": "0.1", "info": {"id": "3dlfWs", "date": "1589581525", "viewed": 427, "name": "STARRY NIGHT", "username": "alro", "description": "Use mouse to look around.", "likes": 39, "published": 1, "flags": 32, "tags": ["moon", "night"], "requires": ["texture", "texturebuf", "library", "imagebuf"]}, "renderpass": [{"inputs": [{"id": "4dXGR8", "filepath": "/media/previz/buffer00.png", "previewfilepath": "/media/previz/buffer00.png", "type": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "XsXGR8", "filepath": "/media/previz/buffer01.png", "previewfilepath": "/media/previz/buffer01.png", "type": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "XsBSR3", "filepath": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "type": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "//Starry night sky with moonlit clouds.\n//See https://www.shadertoy.com/view/3sffzj for clouds\n\n//Blue noise dithering based on:\n//https://blog.demofox.org/2020/05/10/ray-marching-fog-with-blue-noise/\n//https://www.shadertoy.com/view/WsfBDf\n\n//BufferA: \tTracking view direction and resolution change.\n//BufferB: \tRed & Green: Perlin-Worley atlas, \n//\t\t\tBlue: cloud map\n//\t\t\tAlpha: moon texture.\n\n//Comment to see banding that the blue noise hides.\n#define DITHERING\nconst float goldenRatio = 1.61803398875;\n\n//Size of cloud AABB.\n#define CLOUD_EXTENT 1000.0\n\n//Uncomment for fewer ray marching steps and better performance.\n//#define FAST\n\n#ifdef FAST\n\t#define STEPS_PRIMARY 32\t\n\t#define STEPS_LIGHT 10\n#else\n\t#define STEPS_PRIMARY 100\n\t#define STEPS_LIGHT 10\n#endif\n\n\n//Uncomment to animate moon azimuth.\n//#define ANIMATE_MOON\n\nconst float moonSpeed = 0.1;\nfloat moonDistance = 100.0;\nfloat moonSize = 8.0;\n\nfloat moonLocation = 4.5;\nfloat moonHeight = 0.25;\n\nconst vec3 lightColour = vec3(0.65, 0.8, 1.0);\n\nconst vec3 skyColour = 0.1 * vec3(0.32, 0.65, 1.0);\n\nconst float starCount = 6000.0;\nconst float flickerSpeed = 3.0;\n\nconst float shapeSpeed = -5.0;\nconst float detailSpeed = -10.0;\n\nconst float power = 15.0;\nconst float densityMultiplier = 0.075;\n\nconst float shapeSize = 0.05;\nconst float detailSize = 0.3;\n\nconst float shapeStrength = 0.7;\nconst float detailStrength = 0.2;\n\nconst float cloudStart = 0.0;\nconst float cloudEnd = CLOUD_EXTENT;\n\nconst vec3 minCorner = vec3(-CLOUD_EXTENT, cloudStart, -CLOUD_EXTENT);\nconst vec3 maxCorner = vec3(CLOUD_EXTENT, cloudEnd, CLOUD_EXTENT);\n\nvec3 rayDirection(float fieldOfView, vec2 fragCoord) {\n    vec2 xy = fragCoord - iResolution.xy / 2.0;\n    float z = (0.5 * iResolution.y) / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n//https://www.geertarien.com/blog/2017/07/30/breakdown-of-the-lookAt-function-in-OpenGL/\nmat3 lookAt(vec3 camera, vec3 targetDir, vec3 up){\n  vec3 zaxis = normalize(targetDir);    \n  vec3 xaxis = normalize(cross(zaxis, up));\n  vec3 yaxis = cross(xaxis, zaxis);\n\n  return mat3(xaxis, yaxis, -zaxis);\n}\n\nfloat getGlow(float dist, float radius, float intensity){\n    dist = max(dist, 1e-6);\n\treturn pow(radius/dist, intensity);\t\n}\n\n\n//Get Cartesian coordinates from spherical.\nvec3 getStarPosition(float theta, float phi){\n\treturn normalize(vec3(\tsin(theta)*cos(phi),\n               \t\t\t\tsin(theta)*sin(phi),\n               \t\t\t\tcos(theta)));\n}\n\n//https://www.shadertoy.com/view/4djSRW\nfloat rand(float p){\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);;\n}\n\nfloat getDistToStar(vec3 p, float theta, float phi){\n    vec3 starPos = getStarPosition(theta, phi);\n    return 0.5+0.5*dot(starPos, p);\n}\n\n//Get star colour from view direction.\n//The positions are based on spherical coordinates and clump at the poles.\nfloat getStars(vec3 rayDir){\n    \n    //acos returns a value in the range [0, PI].\n    //The theta of the original view ray.\n    float theta = acos(rayDir.z);\n\n    //Extent of each level.\n    float width = PI/starCount;\n    \n    //The level on which the view ray falls.\n    float level = floor((theta/PI)*starCount);\n    \n    //The theta of the level considered.\n    float theta_;\n    //Random angle of the star on the level.\n    float phi_;\n    \n    float stars = 0.0;\n    float dist;\n    \n    //Variable to keep track of neighbouring levels.\n    float level_;\n    \n    float rnd;\n    \n    //For a set number of layers above and below the view ray one,\n    //accumulate the star colour.\n    for(float l = -10.0; l <= 10.0; l++){\n        \n    \tlevel_ = min(starCount-1.0, max(0.0, level+l));\n        \n        theta_ = (level_+0.5)*width;\n        rnd = rand(PI+theta_);\n        phi_ = TWO_PI*rand(level_);\n        dist = getDistToStar(rayDir, theta_, phi_);\n        \n        stars += getGlow(1.0-dist, rnd*8e-7, 2.9 + (sin(rand(rnd)*flickerSpeed*iTime)));\n    }\n    \n    return stars;\n}\n\nvec3 getSkyColour(vec3 rayDir, float mu){\n    \n    float stars = 0.0;\n    \n    //Render stars only above the horizon.\n    if(rayDir.y > 0.0){\n        //Swap Y and Z axis to be consistent with notation.\n    \tvec3 dir = rayDir.xzy;\n    \tstars = getStars(dir);\n    }\n    \n    //Return stars plus a blue colour with a brighter haze around the moon. \n    return stars + mix(0.2*skyColour, 0.5*skyColour, pow(mu, 8.0));\n}\n\n//Return the near and far intersections of an infinite ray and a sphere. \n//Assumes sphere at origin. No intersection if result.x > result.y\nvec2 sphereIntersections(vec3 start, vec3 dir, float radius){\n\tfloat a = dot(dir, dir);\n\tfloat b = 2.0 * dot(dir, start);\n    float c = dot(start, start) - (radius * radius);\n\tfloat d = (b*b) - 4.0*a*c;\n\tif (d < 0.0){\n        return vec2(1e5, -1e5);\n\t}\n\treturn vec2((-b - sqrt(d))/(2.0*a), (-b + sqrt(d))/(2.0*a));\n}\n\n//https://gist.github.com/DomNomNom/46bb1ce47f68d255fd5d\n//Compute the near and far intersections using the slab method.\n//No intersection if tNear > tFar.\nvec2 intersectAABB(vec3 rayOrigin, vec3 rayDir, vec3 boxMin, vec3 boxMax) {\n    vec3 tMin = (boxMin - rayOrigin) / rayDir;\n    vec3 tMax = (boxMax - rayOrigin) / rayDir;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    return vec2(tNear, tFar);\n}\n\nbool insideAABB(vec3 p){\n    float eps = 1e-4;\n\treturn  (p.x > minCorner.x-eps) && (p.y > minCorner.y-eps) && (p.z > minCorner.z-eps) && \n\t\t\t(p.x < maxCorner.x+eps) && (p.y < maxCorner.y+eps) && (p.z < maxCorner.z+eps);\n}\n\nbool getCloudIntersection(vec3 org, vec3 dir, out float distToStart, out float totalDistance){\n\tvec2 intersections = intersectAABB(org, dir, minCorner, maxCorner);\n\t\n    if(insideAABB(org)){\n        intersections.x = 1e-4;\n    }\n    \n    distToStart = intersections.x;\n    totalDistance = intersections.y - intersections.x;\n    return intersections.x > 0.0 && (intersections.x < intersections.y);\n}\n\n\nfloat getPerlinWorleyNoise(vec3 pos){\n    //The cloud shape texture is an atlas of 6*6 tiles (36). \n    //Each tile is 32*32 with a 1 pixel wide boundary.\n    //Per tile:\t\t32 + 2 = 34.\n    //Atlas width:\t6 * 34 = 204.\n    //The rest of the texture is black.\n    //The 3D texture the atlas represents has dimensions 32 * 32 * 36.\n    //The green channel is the data of the red channel shifted by one tile.\n    //(tex.g is the data one level above tex.r). \n    //To get the necessary data only requires a single texture fetch.\n    const float dataWidth = 204.0;\n    const float tileRows = 6.0;\n    const vec3 atlasDimensions = vec3(32.0, 32.0, 36.0);\n\n    //Change from Y being height to Z being height.\n    vec3 p = pos.xzy;\n\n    //Pixel coordinates of point in the 3D data.\n    vec3 coord = vec3(mod(p, atlasDimensions));\n    float f = fract(coord.z);  \n    float level = floor(coord.z);\n    float tileY = floor(level/tileRows); \n    float tileX = level - tileY * tileRows;\n\n    //The data coordinates are offset by the x and y tile, the two boundary cells \n    //between each tile pair and the initial boundary cell on the first row/column.\n    vec2 offset = atlasDimensions.x * vec2(tileX, tileY) + 2.0 * vec2(tileX, tileY) + 1.0;\n    vec2 pixel = coord.xy + offset;\n    vec2 data = texture(iChannel1, mod(pixel, dataWidth)/iChannelResolution[1].xy).rg;\n    return mix(data.x, data.y, f);\n}\n\n//Read cloud map.\nfloat getCloudMap(vec3 p){\n    vec2 uv = 0.5+0.5*(p.xz/(2.0*CLOUD_EXTENT));\n    return texture(iChannel1, uv).b;\n}\n\nfloat clouds(vec3 p, out float cloudHeight, bool sampleDetail){\n    if(!insideAABB(p)){\n    \treturn 0.0;\n    }\n\n    cloudHeight = saturate((p.y - cloudStart)/(cloudEnd-cloudStart));\n    float cloud = getCloudMap(p);\n\n    //If there are no clouds, exit early.\n    if(cloud <= 0.0){\n      return 0.0;\n    }\n\n    //Sample texture which determines how high clouds reach.\n    float height = cloud;\n    \n    //Round the top of the cloud. From \"Real-time rendering of volumetric clouds\". \n    cloud *= saturate(remap(cloudHeight, 0.8*height, height, 1.0, 0.0));\n\n    //Animate main shape.\n    p += vec3(shapeSpeed*iTime);\n    \n    //Get main shape noise, invert and scale it.\n    float shape = 1.0-getPerlinWorleyNoise(shapeSize * p);\n    shape *= shapeStrength;\n\n    //Carve away density from cloud based on noise.\n    cloud = saturate(remap(cloud, shape, 1.0, 0.0, 1.0));\n\n    //Early exit from empty space\n    if(cloud <= 0.0){\n      return 0.0;    \n    }\n    \n    //Animate details.\n    p += vec3(detailSpeed*iTime, 0.0, 0.5*detailSpeed*iTime);\n    \n    float detail = getPerlinWorleyNoise(detailSize*p);\n    //Invert detail noise to subtract from the main shape.\n    //Leave the value at the bottom of the cloud to introduce wispy shapes there.\n\tdetail = mix(detail, 1.0-detail, saturate(cloudHeight * 10.0));\n\tdetail *= detailStrength;\n    \n\t//Carve away detail based on the noise\n\tcloud = saturate(remap(cloud, detail, 1.0, 0.0, 1.0));\n    return densityMultiplier * cloud;\n}\n\nfloat HenyeyGreenstein(float g, float costh){\n\treturn (1.0/(4.0 * 3.1415))  * ((1.0 - g * g) / pow(1.0 + g*g - 2.0*g*costh, 1.5));\n}\n\n//Get the amount of light that reaches a sample point.\nfloat lightRay(vec3 org, vec3 p, float phaseFunction, float mu, vec3 lightDirection){\n\n\tfloat lightRayDistance = CLOUD_EXTENT*1.5;\n    float distToStart = 0.0;\n    \n    getCloudIntersection(p, lightDirection, distToStart, lightRayDistance);\n        \n    float stepL = lightRayDistance/float(STEPS_LIGHT);\n\n\tfloat lightRayDensity = 0.0;\n    \n    float cloudHeight = 0.0;\n\n\t//Collect total density along light ray.\n\tfor(int j = 0; j < STEPS_LIGHT; j++){\n\t\n\t\tbool sampleDetail = true;\n\t\tif(lightRayDensity > 0.3){\n\t\t\tsampleDetail = false;\n\t\t}\n\t\t//Reduce density of clouds when looking towards the light for more luminous clouds.\n\t\tlightRayDensity += mix(1.0, 0.75, mu) * \n            clouds(p + lightDirection * float(j) * stepL, cloudHeight, sampleDetail);\n\t}\n\n    //Multiple scattering approximation from Nubis presentation credited to Wrenninge et al. \n    //Introduce another weaker Beer-Lambert function.\n\tfloat beersLaw = max(exp(-stepL * lightRayDensity), \n                         exp(-stepL * lightRayDensity * 0.2) * 0.75);\n\t\n    //Return product of Beer's law and powder effect depending on the \n    //view direction angle with the light direction.\n\treturn mix(beersLaw * 2.0 * (1.0-(exp(-stepL*lightRayDensity*2.0))), beersLaw, mu);\n}\n\n//Get the colour along the main view ray.\nvec3 mainRay(vec3 org, vec3 dir, vec3 lightDirection, \n             out float totalTransmittance, float mu, vec3 lightColour, float offset){\n    \n\t//Variable to track transmittance along view ray. \n    //Assume clear sky and attenuate light when encountering clouds.\n\ttotalTransmittance = 1.0;\n\n\t//Default to black.\n\tvec3 colour = vec3(0.0);\n    \n    //The distance at which to start ray marching.\n    float distToStart = 0.0;\n    \n    //The length of the intersection.\n    float totalDistance = 0.0;\n\n    //Determine if ray intersects bounding volume.\n\t//Set ray parameters in the cloud layer.\n\tbool renderClouds = getCloudIntersection(org, dir, distToStart, totalDistance);\n\n\tif(!renderClouds){\n\t\treturn colour;\n    }\n    \n    //Sampling step size.\n    float stepS = totalDistance / float(STEPS_PRIMARY); \n    \n    //Offset the starting point by blue noise.\n    distToStart += stepS * offset;\n    \n    //Track distance to sample point.\n    float dist = distToStart;\n\n    //Initialise sampling point.\n    vec3 p = org + dist * dir;\n    \n    vec3 moonLight = lightColour * power;\n\n   \t//Combine backward and forward scattering to have details in all directions.\n\tfloat phaseFunction = mix(HenyeyGreenstein(-0.3, mu), HenyeyGreenstein(0.3, mu), 0.7);\n\n\tfor(int i = 0; i < STEPS_PRIMARY; i++){\n\n        //Normalised height for shaping and ambient lighting weighting.\n        float cloudHeight;\n\n        //Get density and cloud height at sample point\n        float density = clouds(p, cloudHeight, true);\n\n        //Scattering and absorption coefficients.\n        float sigmaS = 1.0;\n        float sigmaA = 0.0;\n\n        //Extinction coefficient.\n        float sigmaE = sigmaS + sigmaA;\n\n        float sampleSigmaS = sigmaS * density;\n        float sampleSigmaE = sigmaE * density;\n\n        //If there is a cloud at the sample point.\n        if(density > 0.0 ){\n\n            //Constant lighting factor based on the height of the sample point.\n            vec3 ambient = lightColour * mix((0.0), (0.2), cloudHeight);\n\n            //Amount of sunlight that reaches the sample point through the cloud \n            //is the combination of ambient light and attenuated direct light.\n            vec3 luminance = ambient + moonLight * phaseFunction * \n                \t\t\t lightRay(org, p, phaseFunction, mu, lightDirection);\n\n            //Scale light contribution by density of the cloud.\n            luminance *= sampleSigmaS;\n\n            //Beer-Lambert.\n            float transmittance = exp(-sampleSigmaE * stepS);\n\n            //Better energy conserving integration\n            //\"From Physically based sky, atmosphere and cloud rendering in Frostbite\" 5.6\n            //by Sebastian Hillaire.\n            colour += \n                totalTransmittance * (luminance - luminance * transmittance) / sampleSigmaE; \n\n            //Attenuate the amount of light that reaches the camera.\n            totalTransmittance *= transmittance;  \n\n            //If ray combined transmittance is close to 0, nothing beyond this sample \n            //point is visible, so break early.\n            if(totalTransmittance <= 0.01){\n                totalTransmittance = 0.0;\n                break;\n            }\n        }\n\n        dist += stepS;\n\n\t\t//Step along ray.\n\t\tp = org + dir * dist;\n\t}\n\n\treturn colour;\n}\n\n//From Scratchpixel\n//Assume normalised vectors.\nbool getPlaneIntersection(vec3 org, vec3 ray, vec3 planePoint, vec3 normal, out float t){\n    float denom = dot(normal, ray); \n    if (denom > 1e-6) { \n        vec3 p0l0 = planePoint - org; \n        t = dot(p0l0, normal) / denom; \n        return (t >= 0.0); \n    } \n \n    return false; \n}\n\n//Get the moon texture.\nvec3 getMoon(vec3 cameraPos, vec3 rayDir, vec3 moonDirection, out bool covered){\n    \n    vec2 uv = vec2(0);\n    covered = false;\n    \n    //Get the texture cooridnates.\n    //The moon is a disk on a plane perpendicular to the moon direction vector. \n    //The texture coordinates of this plane are two perpendicular vectors u and v \n    //which are also perpendicular to the plane normal.\n    //As the moon is always facing the camera, we want u to be tangent to constant latitudes\n    //and v to be tangent to constant longitudes. We first find the point p0 that\n    //defines the plane. We then find a point p1 where a ray r1 offset in elevation \n    //from the moon direction r0 hits the moon plane. Vector v is then the normalised vector \n    //p1-p0 and u can be found by cross(r0, v).\n    \n    vec3 p0 = cameraPos + moonDirection * moonDistance;\n    vec3 offsetDir = normalize(vec3(cos(moonLocation), moonHeight+0.01, sin(moonLocation)));\n\n    float t = 0.0;\n    getPlaneIntersection(cameraPos, offsetDir, p0, moonDirection, t);\n    \n    vec3 p1 = cameraPos + offsetDir * t;\n    vec3 v = normalize(p1-p0);\n    vec3 u = normalize(cross(moonDirection, v));\n    \n    if(getPlaneIntersection(cameraPos, rayDir, p0, moonDirection, t)){\n    \t//Where view ray hits the plane.\n        vec3 p = cameraPos + rayDir * t;\n        \n        //Is point larger than the specified radius.\n        if(length(p - p0) > moonSize){\n        \treturn vec3(0);\n        }\n        \n        uv = vec2(dot(p, u), dot(p, v));\n        uv /= (2.0*moonSize);\n        \n        covered = true;\n    \treturn texture(iChannel1, uv+0.5).aaa;\n    }\n   \n\treturn vec3(0);\n}\n\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x){\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    //Get the default direction of the ray (along the negative Z direction)\n    vec3 rayDir = rayDirection(45.0, fragCoord);\n   \n    //----------------- Define a camera -----------------\n    \n    vec3 cameraPos = vec3(-CLOUD_EXTENT*0.4, cloudEnd * 0.7, CLOUD_EXTENT*0.4);\n    vec3 targetDir = texelFetch(iChannel0, ivec2(0.5, 1.5), 0).xyz;\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    //Get the view matrix from the camera orientation\n    mat3 viewMatrix = lookAt(cameraPos, targetDir, up);\n    \n    //Transform the ray to point in the correct direction\n    rayDir = normalize(viewMatrix * rayDir);\n    \n    //---------------------------------------------------\n    \n\t#ifdef ANIMATE_MOON\n    \tmoonLocation = moonLocation + moonSpeed * iTime;\n\t#endif\n    \n    vec3 lightDirection = normalize(vec3(cos(moonLocation), moonHeight, sin(moonLocation)));\n    \n    //Alignment of view and light directions.\n    float mu = 0.5+0.5*dot(rayDir, lightDirection);\n    \n  \tfloat offset = 0.0;\n    \n    #ifdef DITHERING\n    //Sometimes the blue noise texture is not immediately loaded into iChannel2\n    //leading to jitters.\n    if(iChannelResolution[2].xy == vec2(1024)){\n        //From https://blog.demofox.org/2020/05/10/ray-marching-fog-with-blue-noise/\n        //Get blue noise for the fragment.\n        float blueNoise = texture(iChannel2, fragCoord / 1024.0).r;\n\n    \t//Blue noise texture is blue in space but animating it leads to white noise in time.\n        //Adding golden ratio to a number yields a low discrepancy sequence (apparently),\n    \t//making the offset of each pixel more blue in time (use fract() for modulo 1).\n        //https://blog.demofox.org/2017/10/31/animating-noise-for-integration-over-time/\n        offset = fract(blueNoise + float(iFrame%32) * goldenRatio);\n    }\n    #endif\n    \n    //Get sky colour and stars. \n    //Offset mu with blue noise to get rid of bands in the haze gradient.\n    vec3 background = getSkyColour(rayDir, 0.05*offset+mu);\n\n    if(mu > 0.85){\n        bool covered = false;\n        vec3 moonColour = getMoon(vec3(0), rayDir, lightDirection, covered);\n        if(covered){\n        \tbackground = moonColour;\n        }\n    }\n    \n    //Get the glow around the moon (without offsetting with blue noise).\n    background += lightColour * \n        saturate((getGlow(1.0-mu, 0.5*(1.0-cos(atan(moonSize/moonDistance))), 2.0)));\n    \n    \n\tfloat totalTransmittance = 1.0;\n\n    float exposure = 0.5;\n    vec3 colour = exposure * mainRay(cameraPos, rayDir, lightDirection, \n                                     totalTransmittance, mu, lightColour, offset); \n\n    colour += background * totalTransmittance;\n   \n    //Tonemapping\n    colour = ACESFilm(colour);\n\n    //Gamma correction 1.0/2.2 = 0.4545...\n    colour = pow(colour, vec3(0.4545));\n   \n    //Output to screen\n    fragColor = vec4(colour, 1.0);\n}", "name": "Image", "description": "", "type": "image"}, {"inputs": [{"id": "4dXGR8", "filepath": "/media/previz/buffer00.png", "previewfilepath": "/media/previz/buffer00.png", "type": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dXGR8", "channel": 0}], "code": "//Track mouse movement and resolution change between frames and set view direction.\n\n#define EPS 1e-4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    //Work with just the first four pixels\n    if((fragCoord.x == 0.5) && (fragCoord.y < 4.0)){\n        \n        vec4 oldMouse = texelFetch(iChannel0, ivec2(0.5), 0).xyzw;\n        vec4 mouse = (iMouse / iResolution.xyxy); \n        vec4 newMouse = vec4(0);\n\n        float mouseDownLastFrame = texelFetch(iChannel0, ivec2(0.5, 3.5), 0).x;\n        \n        //If mouse button is down and was down last frame\n        if(iMouse.z > 0.0 && mouseDownLastFrame > 0.0){\n            \n            //Difference between mouse position last frame and now\n            vec2 mouseMove = mouse.xy-oldMouse.zw;\n            if((length(mouseMove) > EPS)){\n                newMouse = vec4(oldMouse.xy+vec2(0.1, 0.05)*normalize(mouseMove), mouse.xy);\n            }else{\n                newMouse = vec4(oldMouse.xy, mouse.xy);\n            }\n        }else{\n            newMouse = vec4(oldMouse.xy, mouse.xy);\n        }\n        newMouse.x = mod(newMouse.x, 2.0*PI);\n        newMouse.y = max(-0.999, min(0.999, newMouse.y));\n\n        //Store mouse data in the first pixel of Buffer C\n        if(fragCoord == vec2(0.5, 0.5)){\n            //Set value at first frame\n            if(iFrame < 1){\n                newMouse = vec4(0.1, 0.07, 0.0, 0.0);\n                \n            }\n            fragColor = vec4(newMouse);\n        }\n\n        //Store view direction in the second pixel of Buffer A\n        if(fragCoord == vec2(0.5, 1.5)){\n            //Set camera position from mouse information\n            vec3 targetDir = vec3(sin(newMouse.x), newMouse.y, -cos(newMouse.x));\n            fragColor = vec4(targetDir, 1.0);\n        }\n        \n        //Store resolution change data in the third pixel of Buffer A\n        if(fragCoord == vec2(0.5, 2.5)){\n            \n            float resolutionChangeFlag = 0.0;\n            \n            //The resolution last frame\n            vec2 oldResolution = texelFetch(iChannel0, ivec2(0.5, 2.5), 0).yz;\n            \n            if(iResolution.xy != oldResolution){\n            \tresolutionChangeFlag = 1.0;\n            }\n            \n        \tfragColor = vec4(resolutionChangeFlag, iResolution.xy, 1.0);\n        }\n        \n        //Store whether the mouse button is down in the fourth pixel of Buffer A\n        if(fragCoord == vec2(0.5, 3.5)){\n            if(iMouse.z > 0.0){\n            \tfragColor = vec4(vec3(1.0), 1.0);\n            }else{\n            \tfragColor = vec4(vec3(0.0), 1.0);\n            }\n        }\n        \n    }\n}", "name": "Buffer A", "description": "", "type": "buffer"}, {"inputs": [{"id": "4dXGR8", "filepath": "/media/previz/buffer00.png", "previewfilepath": "/media/previz/buffer00.png", "type": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "XsXGR8", "filepath": "/media/previz/buffer01.png", "previewfilepath": "/media/previz/buffer01.png", "type": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "XsXGR8", "channel": 0}], "code": "//Create a Perlin-Worley texture atlas for cloud shape carving.\n//Runs only once in the first frame.\n//Based on https://github.com/sebh/TileableVolumeNoise/blob/master/main.cpp\n\n//The atlas is a 6*6 grid of 32*32 tiles with a single layer of halo cells around each tile. \n\n//TODO: Assumes a size of at least 204*204. Make it work with any reasonable resolution.\n\n#define TILES 1.0\n#define NUM_CELLS 2.0\n\n#define PERLIN_WORLEY 0\n#define WORLEY 1\n\nvec4 taylorInvSqrt(vec4 r){\n\treturn 1.79284291400159-0.85373472095314*r;\n}\n\nvec4 mod289(vec4 x){\n    return x-floor(x*(1.0/289.0))*289.0;\n}\n\nvec4 permute(vec4 x){\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 fade(vec4 t){\n\treturn (t * t * t) * (t * (t * vec4(6) - vec4(15)) + vec4(10));\n}\n\n//From https://github.com/g-truc/glm/blob/master/glm/gtc/noise.inl\n//Classic Perlin noise, periodic version\nfloat glmPerlin(vec4 Position, vec4 rep){\n  vec4 Pi0 = mod(floor(Position), rep); // Integer part modulo rep\n  vec4 Pi1 = mod(Pi0 + float(1), rep); // Integer part + 1 mod rep\n  vec4 Pf0 = fract(Position); // Fractional part for interpolation\n  vec4 Pf1 = Pf0 - float(1); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.y, Pi0.y, Pi1.y, Pi1.y);\n  vec4 iz0 = vec4(Pi0.z);\n  vec4 iz1 = vec4(Pi1.z);\n  vec4 iw0 = vec4(Pi0.w);\n  vec4 iw1 = vec4(Pi1.w);\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n  vec4 ixy00 = permute(ixy0 + iw0);\n  vec4 ixy01 = permute(ixy0 + iw1);\n  vec4 ixy10 = permute(ixy1 + iw0);\n  vec4 ixy11 = permute(ixy1 + iw1);\n\n  vec4 gx00 = ixy00 / float(7);\n  vec4 gy00 = floor(gx00) / float(7);\n  vec4 gz00 = floor(gy00) / float(6);\n  gx00 = fract(gx00) - float(0.5);\n  gy00 = fract(gy00) - float(0.5);\n  gz00 = fract(gz00) - float(0.5);\n  vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n  vec4 sw00 = step(gw00, vec4(0));\n  gx00 -= sw00 * (step(float(0), gx00) - float(0.5));\n  gy00 -= sw00 * (step(float(0), gy00) - float(0.5));\n\n  vec4 gx01 = ixy01 / float(7);\n  vec4 gy01 = floor(gx01) / float(7);\n  vec4 gz01 = floor(gy01) / float(6);\n  gx01 = fract(gx01) - float(0.5);\n  gy01 = fract(gy01) - float(0.5);\n  gz01 = fract(gz01) - float(0.5);\n  vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n  vec4 sw01 = step(gw01, vec4(0.0));\n  gx01 -= sw01 * (step(float(0), gx01) - float(0.5));\n  gy01 -= sw01 * (step(float(0), gy01) - float(0.5));\n\n  vec4 gx10 = ixy10 / float(7);\n  vec4 gy10 = floor(gx10) / float(7);\n  vec4 gz10 = floor(gy10) / float(6);\n  gx10 = fract(gx10) - float(0.5);\n  gy10 = fract(gy10) - float(0.5);\n  gz10 = fract(gz10) - float(0.5);\n  vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n  vec4 sw10 = step(gw10, vec4(0.0));\n  gx10 -= sw10 * (step(float(0), gx10) - float(0.5));\n  gy10 -= sw10 * (step(float(0), gy10) - float(0.5));\n\n  vec4 gx11 = ixy11 / float(7);\n  vec4 gy11 = floor(gx11) / float(7);\n  vec4 gz11 = floor(gy11) / float(6);\n  gx11 = fract(gx11) - float(0.5);\n  gy11 = fract(gy11) - float(0.5);\n  gz11 = fract(gz11) - float(0.5);\n  vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n  vec4 sw11 = step(gw11, vec4(float(0)));\n  gx11 -= sw11 * (step(float(0), gx11) - float(0.5));\n  gy11 -= sw11 * (step(float(0), gy11) - float(0.5));\n\n  vec4 g0000 = vec4(gx00.x, gy00.x, gz00.x, gw00.x);\n  vec4 g1000 = vec4(gx00.y, gy00.y, gz00.y, gw00.y);\n  vec4 g0100 = vec4(gx00.z, gy00.z, gz00.z, gw00.z);\n  vec4 g1100 = vec4(gx00.w, gy00.w, gz00.w, gw00.w);\n  vec4 g0010 = vec4(gx10.x, gy10.x, gz10.x, gw10.x);\n  vec4 g1010 = vec4(gx10.y, gy10.y, gz10.y, gw10.y);\n  vec4 g0110 = vec4(gx10.z, gy10.z, gz10.z, gw10.z);\n  vec4 g1110 = vec4(gx10.w, gy10.w, gz10.w, gw10.w);\n  vec4 g0001 = vec4(gx01.x, gy01.x, gz01.x, gw01.x);\n  vec4 g1001 = vec4(gx01.y, gy01.y, gz01.y, gw01.y);\n  vec4 g0101 = vec4(gx01.z, gy01.z, gz01.z, gw01.z);\n  vec4 g1101 = vec4(gx01.w, gy01.w, gz01.w, gw01.w);\n  vec4 g0011 = vec4(gx11.x, gy11.x, gz11.x, gw11.x);\n  vec4 g1011 = vec4(gx11.y, gy11.y, gz11.y, gw11.y);\n  vec4 g0111 = vec4(gx11.z, gy11.z, gz11.z, gw11.z);\n  vec4 g1111 = vec4(gx11.w, gy11.w, gz11.w, gw11.w);\n\n  vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), \n                                   dot(g1100, g1100)));\n  g0000 *= norm00.x;\n  g0100 *= norm00.y;\n  g1000 *= norm00.z;\n  g1100 *= norm00.w;\n\n  vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), \n                                   dot(g1101, g1101)));\n  g0001 *= norm01.x;\n  g0101 *= norm01.y;\n  g1001 *= norm01.z;\n  g1101 *= norm01.w;\n\n  vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), \n                                   dot(g1110, g1110)));\n  g0010 *= norm10.x;\n  g0110 *= norm10.y;\n  g1010 *= norm10.z;\n  g1110 *= norm10.w;\n\n  vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), \n                                   dot(g1111, g1111)));\n  g0011 *= norm11.x;\n  g0111 *= norm11.y;\n  g1011 *= norm11.z;\n  g1111 *= norm11.w;\n\n  float n0000 = dot(g0000, Pf0);\n  float n1000 = dot(g1000, vec4(Pf1.x, Pf0.y, Pf0.z, Pf0.w));\n  float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.z, Pf0.w));\n  float n1100 = dot(g1100, vec4(Pf1.x, Pf1.y, Pf0.z, Pf0.w));\n  float n0010 = dot(g0010, vec4(Pf0.x, Pf0.y, Pf1.z, Pf0.w));\n  float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n  float n0110 = dot(g0110, vec4(Pf0.x, Pf1.y, Pf1.z, Pf0.w));\n  float n1110 = dot(g1110, vec4(Pf1.x, Pf1.y, Pf1.z, Pf0.w));\n  float n0001 = dot(g0001, vec4(Pf0.x, Pf0.y, Pf0.z, Pf1.w));\n  float n1001 = dot(g1001, vec4(Pf1.x, Pf0.y, Pf0.z, Pf1.w));\n  float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n  float n1101 = dot(g1101, vec4(Pf1.x, Pf1.y, Pf0.z, Pf1.w));\n  float n0011 = dot(g0011, vec4(Pf0.x, Pf0.y, Pf1.z, Pf1.w));\n  float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.z, Pf1.w));\n  float n0111 = dot(g0111, vec4(Pf0.x, Pf1.y, Pf1.z, Pf1.w));\n  float n1111 = dot(g1111, Pf1);\n\n  vec4 fade_xyzw = fade(Pf0);\n  vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), \n                  vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n  vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), \n                  vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n  vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n  vec2 n_yzw = mix(vec2(n_zw.x, n_zw.y), vec2(n_zw.z, n_zw.w), fade_xyzw.y);\n  float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n  return float(2.2) * n_xyzw;\n}\n\nfloat getPerlinNoise(vec3 pos, float frequency){\n\t//Noise frequency factor between octave.\n\tconst float octaveFrequencyFactor = 2.0;\n\n\t//Compute the sum for each octave.\n\tfloat sum = 0.0;\n\tfloat weightSum = 0.0;\n\tfloat weight = 1.0;\n\tfor(int oct = 0; oct < 3; oct++){\n\n        vec3 p = pos * frequency;\n        //Hillaire says that the 3D version of tileable perlin noise in GLM is broken.\n        //Use 4D noise with w component set to 0 as in example code.\n        float val = 0.5 + 0.5 * glmPerlin(vec4(p, 0.0), vec4(frequency));\n        sum += val * weight;\n        weightSum += weight;\n\n        weight *= 0.5;\n        frequency *= octaveFrequencyFactor;\n\t}\n\n    float noise = (sum / weightSum);\n\tnoise = saturate(noise);\n\treturn noise;\n}\n\nfloat hash(float n){\n\treturn fract(sin(n) * 43758.5453);\n}\n\n//From Shadertoy somewhere but not sure where originally.\nfloat noise(in vec3 x){\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\n\tf = f*f*(3.0 - 2.0 * f);\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\treturn mix(\n\tmix(\n       \tmix(hash(n + 0.0), hash(n + 1.0), f.x),\n\t\tmix(hash(n + 57.0), hash(n + 58.0), f.x),\n\t\tf.y),\n\tmix(\n\t\tmix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\tmix(hash(n + 170.0), hash(n + 171.0), f.x),\n\t\tf.y),\n\tf.z);\n}\n\n\nfloat worley(vec3 pos, float numCells){\n\tvec3 p = pos * numCells;\n\tfloat d = 1.0e10;\n\tfor (int x = -1; x <= 1; x++){\n\t\tfor (int y = -1; y <= 1; y++){\n\t\t\tfor (int z = -1; z <= 1; z++){\n                vec3 tp = floor(p) + vec3(x, y, z);\n                tp = p - tp - noise(mod(tp, numCells / TILES));\n                d = min(d, dot(tp, tp));\n            }\n        }\n    }\n\treturn 1.0 - clamp(d, 0.0, 1.0);\n}\n\n//Return the 3D coordinate corresponding to the 2D atlas uv coordinate.\nvec3 get3Dfrom2D(vec2 uv, float tileRows){\n    vec2 tile = floor(uv);\n    float z = floor(tileRows * tile.y + tile.x);\n    return vec3(fract(uv), z);\n}\n\nfloat getTextureForPoint(vec3 p, int type){\n\tfloat res;\n    if(type == PERLIN_WORLEY){\n        \n        //Perlin-Worley.\n        const float frequency = 8.0;\n        float perlinNoise = getPerlinNoise(p, frequency);\n        res = perlinNoise;\n\n        //Special weights from example code.\n        float worley0 = worley(p, NUM_CELLS*2.0);\n        float worley1 = worley(p, NUM_CELLS*8.0);\n        float worley2 = worley(p, NUM_CELLS*14.0);\n\n        float worleyFBM = worley0 * 0.625 + worley1 * 0.25 + worley2 * 0.125;\n        res = remap(perlinNoise, 0.0, 1.0, worleyFBM, 1.0);\n        \n\t}else{\n\n        //Worley\n        float worley0 = worley(p, NUM_CELLS);\n        float worley1 = worley(p, NUM_CELLS*2.0);\n        float worley2 = worley(p, NUM_CELLS*4.0);\n        float worley3 = worley(p, NUM_CELLS*8.0);\n\n        float FBM0 = worley0 * 0.625 + worley1 * 0.25 + worley2 * 0.125;\n\t\tfloat FBM1 = worley1 * 0.625 + worley2 * 0.25 + worley3 * 0.125;\n\t\tfloat FBM2 = worley2 * 0.75 + worley3 * 0.25;\n\n        res = FBM0 * 0.625 + FBM1 * 0.25 + FBM2 * 0.125;\n\t}\n    \n\treturn res;\n}\n\nvoid setMoonTexture(vec2 fragCoord, inout vec4 col){\n    //Write moon texture to alpha channel.\n    vec2 uv_ = fragCoord/iResolution.xy;\n    vec2 uv = uv_;\n    vec3 p = vec3(uv, 0.0);\n    \n    //Mix some noises together for a blotchy texture.\n    float base = getPerlinNoise(p, 2.6);\n\tfloat worley = worley(p, 2.0);\n    col.a = saturate(remap(base, 0.45*worley, 1.0, 0.0, 1.0));;\n}\n\nvoid setCloudMap(vec2 fragCoord, inout vec4 col){\n    //Write cloud map in the blue channel.\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n\n    //A constant height centre with raised edges like a shallow bowl.\n    float dist = 0.72;\n    uv *= 3.5;\n    dist = max(dist, smoothstep(0.0, 1.0, length(uv)));\n\n    col.b = dist;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    bool resolutionChanged = (texelFetch(iChannel0, ivec2(0.5, 2.5), 0).x == 1.0);\n    \n    if(iFrame < 1){\n       \tvec4 col = vec4(0);\n        \n        //32 with 1 pixel on either side.\n        float tileSize = 34.0;\n        float padWidth = 1.0;\n        float coreSize = tileSize - 2.0 * padWidth;\n        float tileRows = 6.0;\n        float tileCount = tileRows * tileRows;\n        vec2 tile = floor((fragCoord.xy - 0.5) / tileSize);\n\n        bool padCell = false;\n        if(mod(fragCoord.x, tileSize) == 0.5 || mod(fragCoord.x, tileSize) == tileSize - 0.5){\n            padCell = true;\n        }\n        if(mod(fragCoord.y, tileSize) == 0.5 || mod(fragCoord.y, tileSize) == tileSize - 0.5){\n            padCell = true;\n        }\n\n        bool startPadX = false;\n        bool endPadX = false;\n        bool startPadY = false;\n        bool endPadY = false;\n        if(fragCoord.x == tile.x * tileSize + 0.5){\n            startPadX = true;\n        }\n        if(fragCoord.y == tile.y * tileSize + 0.5){\n            startPadY = true;\n        }\n        if(fragCoord.x == (tile.x + 1.0) * tileSize - 0.5){\n            endPadX = true;\n        }\n        if(fragCoord.y == (tile.y + 1.0) * tileSize - 0.5){\n            endPadY = true;\n        }\n        vec2 padding = vec2(2.0 * padWidth) * tile;\n        vec2 pixel;\n        vec2 uv;\n        \n        if(!padCell){\n            pixel = fragCoord.xy - padWidth - padding;\n            uv = vec2(pixel.xy/coreSize);\n        }else{\n            pixel = fragCoord.xy - padWidth - padding;\n            if(startPadX){\n                pixel.x += coreSize;\t\n            }\n            if(startPadY){\n                pixel.y += coreSize;\t\n            }\n            if(endPadX){\n                pixel.x -= coreSize;\t\n            }\n            if(endPadY){\n                pixel.y -= coreSize;\t\n            }\n            uv = vec2(pixel.xy/coreSize);\n        }\n        \n        vec3 p_ = get3Dfrom2D(uv, tileRows);\n        vec3 p = p_;\n        p.z /= (tileRows*tileRows);\n\n        //Get Perlin-Worley noise for level l\n        float worleyPerlinNoise = getTextureForPoint(p, PERLIN_WORLEY);\n\n        //Get Worley noise for level l\n        float worleyNoise = getTextureForPoint(p, WORLEY);\n        col.r = saturate(remap(worleyPerlinNoise, worleyNoise, 1.0, 0.0, 1.0));\n\n        p_ = mod(p_ + 1.0, tileRows * tileRows);\n        p = p_;\n        p.z /= (tileRows*tileRows);\n\n        //Get Perlin-Worley noise for level l+1\n        worleyPerlinNoise = getTextureForPoint(p, PERLIN_WORLEY);\n\n        //Get Worley noise for level l+1\n        worleyNoise = getTextureForPoint(p, WORLEY);\n        col.g = saturate(remap(worleyPerlinNoise, worleyNoise, 1.0, 0.0, 1.0));\n\n        //Unused cells\n        if(gl_FragCoord.x > tileRows * tileSize || gl_FragCoord.y > tileRows * tileSize){\n            col = vec4(0);\n        }\n\n        setCloudMap(fragCoord, col);\n        setMoonTexture(fragCoord, col);\n\n    \tfragColor = col;\n        \n    }else{\n        \n        vec4 oldData = texelFetch(iChannel1, ivec2(fragCoord - 0.5), 0).rgba;\n        \n        if(resolutionChanged){\n            setCloudMap(fragCoord, oldData);\n        \tsetMoonTexture(fragCoord, oldData);\n        }\n    \t\n        fragColor = oldData;\n        \n        \n    }\n\n}", "name": "Buffer B", "description": "", "type": "buffer"}, {"inputs": [], "outputs": [], "code": "#define PI 3.14159\n#define TWO_PI 2.0*PI\n\nfloat saturate(float x){\n\treturn clamp(x, 0.0, 1.0);\n}\n\nfloat remap(float x, float low1, float high1, float low2, float high2){\n\treturn low2 + (x - low1) * (high2 - low2) / (high1 - low1);\n}\n", "name": "Common", "description": "", "type": "common"}]}