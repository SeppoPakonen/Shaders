{"ver":"0.1","info":{"id":"lsf3zr","date":"1362908515","viewed":23442,"name":"Catacombs","username":"iq","description":"Porting my old Slisesix procedural image, and improving it. ","likes":160,"published":3,"flags":1,"tags":[]},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define AA 1\n\n#define SC 15.0\n\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat udBox( in vec3 p, in vec3 abc )\n{\n\treturn length(max(abs(p)-abc,0.0));\n}\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( in vec3 p, in vec3 b ) \n{\n    vec3 q = abs(p) - b;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0));\n}\n\nfloat sdSqSegmentX( vec3 p, float l )\n{\n\tfloat h = clamp( p.x/l, 0.0, 1.0 );\n    p.x -= l*clamp( p.x/l, 0.0, 1.0 );\n\treturn dot(p,p);\n}\n\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\nfloat roundcube( vec3 p, vec3 n )\n{\n    n = abs(n);\n\tfloat x = texture( iChannel0, p.yz ).x;\n\tfloat y = texture( iChannel0, p.zx ).x;\n\tfloat z = texture( iChannel0, p.xy ).x;\n\treturn (x*n.x + y*n.y + z*n.z)/(n.x+n.y+n.z);\n}\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------\n\nvec3 column( in float x, in float y, in float z )\n{\n    float y2=y-0.25;\n    float y3=y-0.25;\n    float y4=y-1.0;\n\n    float dsp = abs( min(cos(1.5*0.75*6.283185*x/0.085), cos(1.5*0.75*6.283185*z/0.085)));\n    dsp *= 1.0-smoothstep(0.8,0.9,abs(x/0.085)*abs(z/0.085));\n    float di1=sdBox( vec3(x,mod(y+0.08,0.16)-0.08,z), vec3(0.10*0.85+dsp*0.03*0.25,0.079,0.10*0.85+dsp*0.03*0.25)-0.008 )-0.008;\n    float di2=sdBox( vec3(x,y,z), vec3(0.12,0.29,0.12)-0.007 )-0.007;\n    float di3=sdBox( vec3(x,y4,z), vec3(0.14,0.02,0.14)-0.006 )-0.006;\n    float nx = max( abs(x), abs(z) );\n    float nz = min( abs(x), abs(z) );\t\n    float di4=sdBox( vec3(nx, y, nz), vec3(0.14,0.3,0.05)-0.004 )-0.004;\n\tfloat di5=smax(-(y-0.291),sdBox( vec3(nx, (y2+nz)*0.7071, (nz-y2)*0.7071), vec3(0.12, 0.16*0.7071, 0.16*0.7071)-0.004)-0.004,0.007 + 0.0001);\n    float di6=sdBox( vec3(nx, (y3+nz)*0.7071, (nz-y3)*0.7071), vec3(0.14, 0.10*0.7071, 0.10*0.7071)-0.004)-0.004;\n\n    float dm1 = min(min(di5,di3),di2);\n    float dm2 = min(di6,di4);\n\tvec3 res = vec3( dm1, 3.0, 1.0 );\n\tif( di1<res.x ) res = vec3( di1, 2.0, dsp );\n    if( dm2<res.x ) res = vec3( dm2, 5.0, 1.0 );\n    \n\treturn res;\n}\n\nfloat wave( in float x, in float y )\n{\n    return sin(x)*sin(y);\n}\n\nfloat monster( in vec3 pos )\n{\n    pos -= vec3(0.64,0.5,1.5);\n\n    float r2 = dot(pos,pos);\n\n\tfloat sa = smoothstep(0.0,0.5,r2);\n\tfloat fax = 0.75 + 0.25*sa;\n\tfloat fay = 0.80 + 0.20*sa;\n    pos *= vec3( fax, fay, fax );\n    \n    r2 = dot(pos,pos);\n\n\tfloat r = sqrt(r2);\n\n    {\n        float a1 = 0.60;\n        a1 += 0.1*sin(iTime);\n        a1 *= 1.0-smoothstep( 0.0, 0.75, r );\n        float si1 = sin(a1);\n        float co1 = cos(a1);\n        pos.xy = mat2(co1,si1,-si1,co1)*pos.xy;\n\t}\n\n\n\t//#define TENTACURA 0.04f\n\t#define TENTACURA 0.045\n\tfloat mindist2 = 1000000.0;\n\n\tfloat rr = 0.05+length(pos.xz);\n    rr += 0.05;\n    float ca = (0.5-TENTACURA*0.75) -6.0*rr*exp2(-9.0*rr);\n    for( int j=1; j<7; j++ )\n\t{\n\t\tfloat an = (6.283185/7.0) * float(j);\n        float aa = an + 0.3*rr*wave(6.0*rr,float(j)+4.95) + 0.29;\n\t\tfloat rc = cos(aa);\n        float rs = sin(aa);\n\t\tvec3 q = vec3( pos.x*rc-pos.z*rs, pos.y+ca, \n                       pos.x*rs+pos.z*rc );\n        mindist2 = min(mindist2,sdSqSegmentX(q,1.5));\n\t}\n\n\n\tfloat c = sqrt(mindist2) - TENTACURA;\n    float br = 0.5+0.5*sin(2.0*iTime);\n\tfloat d = r-0.30 - 0.02*br*br;\n\t\n    return 0.65*smin(c,d+0.17,0.3);\n}\n\nvec3 map( vec3 pos )\n{\npos /= SC;\n\n    // floor\n    vec2 id = floor((pos.xz+0.1)/0.2 );\n    float h = 0.012 + 0.008*sin(id.x*2313.12+id.y*3231.219);\n    vec3 ros = vec3( mod(pos.x+0.1,0.2)-0.1, pos.y, mod(pos.z+0.1,0.2)-0.1 );\n    vec3 res = vec3( udBox( ros, vec3(0.096,h,0.096)-0.005 )-0.005, 0.0, 0.0 );\n\n    // ceilin\n\tfloat x = fract( pos.x+128.0 ) - 0.5;\n\tfloat z = fract( pos.z+128.0 ) - 0.5;\n    float y = (1.0 - pos.y)*0.6;// + 0.1;\n    float dis = 0.4 - smin(sqrt(y*y+x*x),sqrt(y*y+z*z),0.01);\n    float dsp = abs(sin(31.416*pos.y)*sin(31.416*pos.x)*sin(31.416*pos.z));\n    dis -= 0.02*dsp;\n\n\tdis = max( dis, y );\n    if( dis<res.x )\n    {\n        res = vec3(dis,1.0,dsp);\n    }\n\n    // columns\n\tvec2 fc = fract( pos.xz+128.5 ) - 0.5;\n\tvec3 dis2 = column( fc.x, pos.y, fc.y );\n    if( dis2.x<res.x )\n    {\n        res = dis2;\n    }\n    \n    fc = fract( pos.xz+128.5 )-0.5;\n    dis = length(vec3(fc.x,pos.y,fc.y)-vec3(0.0,-0.565,0.0))-0.6;\n    dis -= texture(iChannel0,1.5*pos.xz).x*0.02;\n    if( dis<res.x ) res=vec3(dis,4.0,1.0);\n    \n    \n    #if 1\n    dis = monster( pos );\n    if( dis<res.x )\n    {   \n        res=vec3(dis,7.0,1.0);\n    }\n    #endif\n    \n\tres.x*=SC;\n    return res;\n}\n\nvec4 calcColor( in vec3 pos, in vec3 nor, in float sid, out float ke )\n{\n\tvec3 col = vec3( 1.0 );\n\tfloat ks = 1.0;\n    ke = 0.0;\n\n    float kk = 0.2+0.8*roundcube( 1.0*pos, nor );\n\t\n    if( sid<0.5 )\n\t{\n        col = texture( iChannel1, 6.0*pos.xz ).xyz;\n\t\tvec2 id = floor((pos.xz+0.1)/0.2 );\n    \tcol *= 1.0 + 0.5*sin(id.y*2313.12+id.x*3231.219);\n\t}\n    else if( sid>0.5 && sid<1.5 )\n\t{\n\t\tfloat fx = fract( pos.x+128.0 ); \n\t    float fz = fract( pos.z+128.0 ); \n\t\tcol = vec3(0.7,0.6,0.5)*1.3;\n\t\tfloat p = 1.0;\n\t\tp *= smoothstep( 0.02, 0.03, abs(fx-0.1) );\n\t\tp *= smoothstep( 0.02, 0.03, abs(fx-0.9) );\n\t\tp *= smoothstep( 0.02, 0.03, abs(fz-0.1) );\n\t\tp *= smoothstep( 0.02, 0.03, abs(fz-0.9) );\n\t\tcol = mix( vec3(0.6,0.2,0.1), col, p );\n\t}\n    else if( sid>1.5 && sid<2.5 )\n\t{\n        float id = floor((pos.y+0.08)/0.16);\n        col = vec3(0.7,0.6,0.5);\n        col *= 1.0 + 0.2*cos(id*312.0 + floor(pos.x+0.5)*33.1 + floor(pos.z+0.5)*13.7);\n\t}\n    else if( sid>2.5 && sid<3.5 )\n\t{\n        col = vec3(0.7,0.6,0.5);\n        col *= 0.25 + 0.75*smoothstep(0.0,0.1,pos.y);\n\t}\n    else if( sid>3.5 && sid<4.5 )\n\t{\n        col = vec3(0.2,0.15,0.1)*1.5;\n        ks = 0.05;\n    }\n    else if( sid>4.5 && sid<5.5 )\n\t{\n        col = vec3(0.6,0.2,0.1);\n        col *= 0.25 + 0.75*smoothstep(0.0,0.1,pos.y);\n        ks = 1.0;\n\t}\n    else if( sid>6.5 && sid<7.5 )\n\t{\n        //col = vec3(0.3,0.15,0.1)*0.3;\n        col = vec3(0.25,0.13,0.1)*0.25;\n        ks = 1.0*2.0;\n        ke = 1.0;\n\t}\n\t\n    return vec4(col * 1.2 * kk,ks);\n}\n\nvec3 castRay( in vec3 ro, in vec3 rd, in float precis, in float maxd )\n{\n    float t = 0.001;\n    float dsp = 0.0;\n    float sid = -1.0;\n    for( int i=0; i<128; i++ )\n    {\n\t    vec3 res = map( ro+rd*t );\n        if( abs(res.x)<(precis*t)||t>maxd ) break;\n\t    sid = res.y;\n\t\tdsp = res.z;\n        t += res.x;\n    }\n\n    if( t>maxd ) sid=-1.0;\n    return vec3( t, sid, dsp );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<64; i++ )\n    {\n        float h = map( ro + rd*t ).x;\n        res = min( res, k*h/t );\n        t += clamp(h,0.01,0.5);\n\t\tif( res<0.001 || t>maxt ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n#if 0    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+e*0.001).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nvec3 doBumpMap( in vec3 pos, in vec3 nor )\n{\n    const float e = 0.001;\n    const float b = 0.005;\n    \n\tfloat ref = roundcube( 7.0*pos, nor );\n    vec3 gra = -b*vec3( roundcube(7.0*vec3(pos.x+e, pos.y, pos.z),nor)-ref,\n                        roundcube(7.0*vec3(pos.x, pos.y+e, pos.z),nor)-ref,\n                        roundcube(7.0*vec3(pos.x, pos.y, pos.z+e),nor)-ref )/e;\n\t\n\tvec3 tgrad = gra - nor*dot(nor,gra);\n    \n    return normalize( nor-tgrad );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float ao = 0.0;\n    float sca = 15.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = SC*(0.01 + 0.015*float(i*i));\n        float dd = map( pos + hr*nor ).x;\n        ao += (hr-dd)*sca/SC;\n        sca *= 0.5;\n    }\n    return 1.0 - clamp( ao, 0.0, 1.0 );\n}\n\nvec3 getLightPos( in int i )\n{\n    vec3 lpos;\n    \n    float la = 1.0;\n    lpos.x = 0.5 + 2.2*cos(0.22+0.1*iTime + 17.0*float(i) );\n    lpos.y = 0.25;\n    lpos.z = 1.5 + 2.2*cos(2.24+0.1*iTime + 13.0*float(i) );\n\n    // make the lights avoid the columns\n    vec2 ilpos = floor( lpos.xz );\n    vec2 flpos = lpos.xz - ilpos;\n    flpos = flpos - 0.5;\n    if( length(flpos)<0.2 ) flpos = 0.2*normalize(flpos);\n    lpos.xz = ilpos + flpos;\n\n    return lpos*SC;\n}\n\nvec4 getLightCol( in int i )\n{\n    float li = sqrt(0.5 + 0.5*sin(2.0*iTime+ 23.1*float(i)));\n    float h = float(i)/8.0;\n    vec3 c = mix( vec3(1.0,0.8,0.6), vec3(1.0,0.3,0.05), 0.5+0.5*sin(40.0*h) );\n    return vec4( c, li );\n}\n\nconst int kNumLights = 9;\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.0);\n    vec3 res = castRay(ro,rd,0.00001*SC,10.0*SC);\n    float t = res.x;\n    if( res.y>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n\n        float ao = calcAO( pos, nor );\n        ao *= 0.7 + 0.6*res.z;\n\n        pos /= SC;\n\t\tt /= SC;\n        \n        float ke = 0.0;\n        vec4 mate = calcColor( pos, nor, res.y, ke );\n        col = mate.xyz;\n        float ks = mate.w;\n\n        nor = doBumpMap( pos, nor );\n\n        \n        // lighting\n        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n        vec3 lin = 0.03*ao*vec3(0.25,0.20,0.20)*(0.5+0.5*nor.y);\n\t\tvec3 spe = vec3(0.0);\n        for( int i=0; i<kNumLights; i++ )\n        {\n            vec3 lpos = getLightPos(i);\n            vec4 lcol = getLightCol(i);\n            \n            vec3 lig = lpos/SC - pos;\n            float llig = dot( lig, lig);\n            float im = inversesqrt( llig );\n            lig = lig * im;\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n\t\t\tfloat at = 2.0*exp2( -2.3*llig )*lcol.w;\n            dif *= at;\n            float at2 = exp2( -0.35*llig );\n\n\t\t\tfloat sh = 0.0;\n\t\t\tif( dif>0.001 ) { sh = softshadow( pos*SC, lig, 0.02*SC, sqrt(llig)*SC, 32.0 ); dif *= sh; }\n\n            float dif2 = clamp( dot(nor,normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 );\n            lin += 0.20*dif2*vec3(0.35,0.20,0.10)*at2*ao;\n            lin += 2.50*dif*lcol.xyz;\n\t\t\t\n            lin += (0.7*fre*fre*fre*col+\n                    0.3*fre*(0.5+col)\n                   )*ao*(0.5+dif*0.5)*ke*0.2;\n            \n            \n            vec3 hal = normalize(lig-rd);\n            float pp = clamp( dot(nor,hal), 0.0, 1.0 );\n            pp = pow(pp,1.0+ke*3.0);\n            spe += ks*(5.0)*lcol.xyz*at*sh*dif*(0.04+0.96*pow(1.0-clamp(dot(hal,-rd),0.0,1.0),5.0))*(pow(pp,16.0) + 0.5*pow(pp,4.0));\n            \n        }\n    \n        col = col*lin + 2.0*spe + 1.0*ke*fre*fre*col*col*ao;\n    }\n\telse\n    {\n\t\tt /= SC;\n    }\n    \n\tcol *= exp( -0.055*t*t );\n\n    //col = col*1.6/(1.0+col);\n    col = col*1.2/(1.0+col);\n\n    \n    // lights\n\tfor( int i=0; i<kNumLights; i++ )\n\t{\n        vec3 lpos = getLightPos(i);\n        vec4 lcol = getLightCol(i);\n        \n        vec3 lv = (lpos - ro)/SC;\n        float ll = length( lv );\n        if( ll<t )\n        {\n            float dle = clamp( dot( rd, lv/ll ), 0.0, 1.0 );\n\t\t\tdle = 1.0-smoothstep( 0.0, 0.2*(0.7+0.3*lcol.w), acos(dle)*ll );\n            col += dle*dle*6.0*lcol.w*lcol.xyz*exp( -0.07*ll*ll );\n        }\n    }\n\n    \n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\n    vec3 tot = vec3(0.0);\n\n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif        \n        float time = iTime;\n\n        // camera\t\n        vec3 ce = vec3( 0.5, 0.25, 1.5 );\n        vec3 ro = ce + vec3( 1.3*cos(0.11*time + 6.0*mo.x), 0.65*(1.0-mo.y)- 0.4, 1.3*sin(0.11*time + 6.0*mo.x) );\n        vec3 ta = ce + vec3( 0.95*cos(1.2+.08*time), 0.4*0.25+0.75*ro.y- 0.2, 0.95*sin(2.0+0.07*time) );\n        ro *= SC;\n        ta *= SC;\n        float roll = -0.15*sin(0.1*time);\n\n        // camera tx\n        vec3 cw = normalize( ta-ro );\n        vec3 cp = vec3( sin(roll), cos(roll),0.0 );\n        vec3 cu = normalize( cross(cw,cp) );\n        vec3 cv = normalize( cross(cu,cw) );\n        vec3 rd = normalize( p.x*cu + p.y*cv + 1.5*cw );\n\n        vec3 col = render( ro, rd );\n\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    // vigneting\n    {\n \tvec2 q = fragCoord.xy/iResolution.xy;\n    tot *= 0.25+0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.15 );\n    }\n    \n    fragColor=vec4( tot, 1.0 );\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec3 ro = fragRayOri + vec3( 0.5*SC, 1.8, 1.5*SC );\n    vec3 rd = fragRayDir;\n    \n    vec3 col = render( ro, rd );\n\n  \tcol = pow( col, vec3(0.4545) );\n\n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}