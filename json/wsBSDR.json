{"ver":"0.1","info":{"id":"wsBSDR","date":"1553505797","viewed":167,"name":"2.5D Renderer Prototype 1","username":"kubamaruszczyk1604","description":"2.5D Maze Renderer Prototype. \nShader uses similar 2D ray-casting technique to that of Wolfenstein 3D engine.  \nMouse Y - Move the camera forward/back\nMouse X - Look around","likes":1,"published":1,"flags":16,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n2.5D Maze Renderer Prototype 1. \nShader uses similar 2D ray-casting technique to that of Wolfenstein3D engine.  \nIdea inspired by the video from OneLoneCoder (javidx9):\nhttps://www.youtube.com/watch?v=xW8skO7MFYw\n\nInteraction:\nMouse Y - Move the camera forward/back\nMouse X - Look around\n\n\nFeatures (version 1):\n- Calculating intersection with wall segments defined in array \"cMap\"\n\n\n\nby kubamaruszczyk1604 \n\n*/\n\n#define AA\n#define RED_SCREEN_BORDERS\n\nconst int cMap[100] = int[]\n    (\n        1,1,1,1,1,1,1,1,1,1,\n        1,0,0,0,0,0,0,0,0,1,\n        1,0,0,0,0,0,0,0,0,1,\n        1,0,1,0,0,0,0,0,0,1,\n        1,0,0,0,0,2,0,0,0,1,\n        1,0,1,0,0,0,0,1,0,1,\n        1,0,0,0,0,0,0,1,0,1,\n        1,0,1,0,0,0,1,0,0,1,\n        1,0,0,0,1,0,0,0,0,1,\n        1,1,1,1,1,1,1,1,1,1\n    );\n\nconst vec2 cMapSize = vec2(10.0,10.0); \nconst float cDepth = 10.0;\n\n\nstruct Player\n{\n    vec2 Pos;\n    vec2 Dir;\n};\n\nint GetCoord(int x, int y)\n{\n   return (int(cMapSize.y)*y)+x;\n}\n\nint GetCell(vec2 p)\n{\n    int x = int(p.x);\n    int y = int(p.y);\n    if(x > int(cMapSize.x-1.0)) return 0;\n    if(y > int(cMapSize.y-1.0)) return 0;\n    \n    return cMap[GetCoord(x,y)];\n}\n\nvec2 Rotate(vec2 v, float theta)\n{\n    float s = sin(theta);\n    float c = cos(theta);\n    \n   return vec2(v.x * c - v.y * s, v.x * s + v.y * c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratioX = iResolution.x/iResolution.y;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 2.0*uv -1.0;\n    uv.x *= ratioX;\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n    mouse = 2.0*mouse-1.0;\n    mouse.x *= ratioX;\n   \n    float yRotation = 0.0;\n    if(mouse.x != -(ratioX)) yRotation = mouse.x;\n    \n    Player player;\n    player.Pos = vec2(5.0+sin(iTime*0.2)*3.8,4.0+mouse.y*3.0);\n    player.Dir = normalize(Rotate(vec2(0.0,1.0),yRotation));\n    \n   \n    vec2 rayDir = normalize(Rotate(player.Dir, 0.2*uv.x));\n    \n    float t = 0.0;\n    const float stp = 0.05;\n    bool hit = false;\n    while(t < cDepth && !hit)\n    {\n      vec2 ray = player.Pos + rayDir*t;\n      int cell =  GetCell(ray); \n      t +=stp; \n      if(cell == 1) hit = true; \n    }\n    \n    float ceiling = 1.0/t;\n    float floorp = -1.0/t;\n    float normInvDist = 0.9-t/cDepth;\n    vec3 col = vec3(normInvDist*normInvDist);\n    \n    #ifdef AA \n    float sp = smoothstep(ceiling - 0.01, ceiling +0.01,uv.y); \n    col = mix(col,vec3(0.0),sp);\n    sp = smoothstep(floorp + 0.01, floorp -0.01,uv.y); \n    col = mix(col,vec3(0.0,0.0,normInvDist*0.4),sp);\n    #else\n    if(uv.y > ceiling) col = vec3(0);\n    if(uv.y < floorp) col = vec3(0.0,0.0,normInvDist*0.4);\n    #endif\n    \n    \n    #ifdef RED_SCREEN_BORDERS\n    col = mix(col,vec3(0.4,0.0,0.0),abs(pow(uv.y,6.0)));\n    #endif\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}