{"ver":"0.1","info":{"id":"WtlXzM","date":"1562631554","viewed":4969,"name":"Patience 2","username":"Yusef28","description":"better menger Design\nbump mapping, triplanar, and all the lighting specific stuff comes mostly from user: \"Shane\"...Shane tho!\nMusic is mine tho!\nLet me know if the music is too loud tho!","likes":42,"published":1,"flags":0,"tags":[]},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358979323846\n\n//This first part is all stuff related to creating the checker pattern\n\n\n\n//basic rotation matrix\nmat2 prot (float a)\n{\n \n    mat2 m = mat2(cos(a), -sin(a), sin(a), cos(a) );\n    return m;\n}\n\n//creaes the golden frame, well just it's shape \nfloat stripes(vec2 p, float s, float e)\n{\n    p = fract(p*s);   \n    return min(smoothstep(0.95, 0.97, p.x)+smoothstep(0.95, 0.97, p.y),1.0);\n\t//return smoothstep(0.92, 0.95, p.x)-step(0.95,p.x)/5.;\n}\n\nfloat chess (vec2 p, float s)\n{\n    vec2 c = floor(p*s);\n    return mod(c.x +c.y, 2.0);    \n}\n\nvec3 pattern3(vec2 uv)\n{\n   // uv*=2.;\n    float wobble = (sin(iTime*4.-0.79)/3.);//fract(-iTime)/400.;//*0.05*sin(20.*iTime);\n    float smoothT = iTime/1. ;//+ sin(iTime)/16.;\n    \n    vec2 st = uv; ;//for vig later\n        uv*=1.25;\n     uv.x+=0.75;\n    uv.y+=0.75;   \n\n    vec2 sv =uv;//prot(PI*floor(uv.x))*uv;\n    \n    //adding teh bumpy pebble texture for the red squares\n    vec3 col = vec3(pow(texture(iChannel2, sv).x, 3.))*1.;\n\t\t\t\t\t\t\t\t\t\t\t //-sin(iTime/1.)/50. //add this to uv/2. of ichannel0 for movement\n    \n    //adding the moldy wood? texture for the black squares\n    col = mix(col, vec3(1.0, 0.0, .0)*texture(iChannel0,sv/2.+vec2(0., smoothT+wobble)).x, vec3(chess(uv, 2.0))  );\n    \n    //adding the frame, this one required a lot of hacking\n    \n    col = mix(col, vec3(texture(iChannel1, uv*0.01+0.75)/1.2+0.1)\n              //the sin portion is for the light movement\n              +abs(sin(uv.x*3.)),  \n              //this calles the stripes function\n              vec3(stripes(uv, 2., 1.)) )\n\n        -step(0.98, fract(2.*uv.x))/3.-step(0.98, fract(2.*uv.y))/3.;\n    \n    \n    //This is for vignetting\n     st *=  1.0 - st.yx;\n    float vig = st.x*st.y*15.;\n    vig = pow(vig, 0.09);\n    \n return clamp(col, 0., 1.);\n    \n}\n\n//and now the other stuff\n\n\n\n\nvec2 rot(vec2 uv,float a){\n\treturn vec2(uv.x*cos(a)-uv.y*sin(a),uv.y*cos(a)+uv.x*sin(a));\n}\n\nmat2 rot(float a)\n{\n    \n float si = sin(a);\n    float cs = cos(a);\n    \n    mat2 mat= mat2(cs, -si, si, cs);\n    return mat;\n}\n\n\nfloat getGrey(vec3 p)\n{\n    return p.x*0.299 + p.y*0.587 + p.z*0.114;\n       }\n\n\nvec3 triPlanar(sampler2D tex, vec3 p, vec3 n)\n{\n    \n    ///old comments\n    //this thing gets the normal, abs because we only need positive values, \n    //negative ones are going into the surface so not needed?\n    //we get max I guess because I guess if the normal is 0 or too small it's not helpful lol\n    //we get the sum and use it to get the percentage each component contributes to the whole.\n vec3 norm = max(abs(n), 0.0001);\t//I'll keep it simple with just this\n float sum = norm.x+norm.y+norm.z;\n norm = norm/sum;//so now the normal is a weighting factor, each component is  weight out of 100 percent\n   // p/=10.;\n    //I kinda get this. it's doing the scaling here, but it's still hard to visualize \n    //that adding texures of the yz, xz, and xy planes would result it a crisp image.\n    //for example, if the texture was a chess board pattern...hmmm maybe.\n    return vec3(pattern3(p.yz*8.)*norm.x + \n                pattern3(p.xz*8.)*norm.y +\n                pattern3(p.xy*8.)*norm.z ) ;\n    \n}\n\n\nvec3 bumpMap(sampler2D tex, in vec3 p, in vec3 n, float bumpfactor)\n{\n    \n   \n    const vec3 eps = vec3(0.001, 0., 0.);//I use swizzling here, x is eps\n    float ref = getGrey(triPlanar(tex, p, n));//reference value \n    \n    vec3 grad = vec3(getGrey(triPlanar(tex, p - eps, n)) - ref,\n                     //eps.yxz means 0.,0.001, 0. \"swizzling\n                     getGrey(triPlanar(tex, p - eps.yxz, n)) - ref,\n                     getGrey(triPlanar(tex, p - eps.yzx, n)) - ref)/eps.xxx;\n    \n    //so grad is the normal...then he does:\n    grad -= n*dot(grad, n);//takes the dot of the surface normal \n\n    return normalize(n + grad*bumpfactor);\n}\n\n\n\nfloat rect(vec3 p, vec3 b)\n{\n    p = abs(p)-b;\n return max(p.x, max(p.y, p.z));\n}\n\nfloat infRect(vec3 p, vec3 b)\n{\n    p = abs(p)-b;\n    float f = max(p.x, p.y);\n return f;   \n}\n\nfloat cylCross(vec3 p, float r)\n{\n p = abs(p);\n    vec3 f = vec3(max(p.x, p.y), max(p.y, p.z), max(p.z,p.x));\n    return min(length(p.xy), min(length(p.yz), length(p.xz)))-r;\n}\n\nfloat rCross(vec3 p)\n{float wobble = (sin(iTime*4.-0.79)/3.);\n    p = abs(p);\n    vec3 f = vec3(max(p.x, p.y), max(p.y, p.z), max(p.z,p.x));\n    float k = min(f.x, min(f.y, f.z) ) - 1./3.;\n    \n return k;   \n}\n\nfloat repCross(vec3 p)\n{\n    \n    vec3 q = mod(p+1., 2.)-1.;\n    float f = rCross(q);\n\n    \nq = abs(q)-0.5;\n\n   q = abs(q)-0.2;q = abs(q)-0.95;q = abs(q)-0.5;q = abs(q)-0.5;\n    q=abs(q)-0.005;\n    f = min(f, cylCross(q,0.101));\n    \n\n return f;   \n}\n\nfloat repCylCross(vec3 p)\n{\n    vec3 q = mod(p+1., 2.)-1.;\n    float f =  cylCross(q, 0.05) ;\n return f;   \n}\n\nfloat rcScale(vec3 p, float s)\n{\n    \n return repCross(p*s)/s;\n}\n\nfloat map(vec3 p)\n   {\n       //p = fract(p);\n     p.y+=sin(p.z*2.+iTime)/200.;\n      p.x+=sin(p.y*2.+iTime)/200.;\n    float re = 0.0;\n       float scale = 1.;\n       \n       for(int i=0; i<2 ;i++)\n       {\n        \n        scale*=3.;\n        re = max(re, -rcScale(p, scale)  );\n\n       }\n        \n    return re;//rect(p, vec3(2.5));\n    }\n\nfloat trace(vec3 ro, vec3 rd)\n{\n    float eps = 0.001;\n    float dist;\n    float t = 0.0;\n    for(int i = 0;i<96;i++)\n    {\n        dist = map(ro+rd*t);\n    if(dist<eps || t > 120.)\n        break;\n    \n    t +=dist*0.95;\n    }\n    \n    return t;\n\t    \n}\n//based on shanes reflection tutorial\nfloat rtrace(vec3 ro, vec3 rd)\n{\n    float eps = 0.0001;\n    float dist;\n   \tfloat t = 0.0;\n    \n    for(int i=0; i<48; i++)\n    {\n     dist = map(ro + rd*t);\n        if(dist<eps || t > 120.)\n            break;\n        \n      t += dist;\n        \n    }\n    \n    \n return t;   \n}\nvec2 path(vec3 p)\n{\n    \n float a = sin(p.z*1.)/3. ;\n     float b = cos(p.z)/3.;\n    return vec2(a, b);\n}\n\n\n\nvec3 normal(vec3 sp)\n{///had to adjust the normal cause I was getting these weird lines on edges.\n    vec3 eps = vec3(.0014, 0.0, 0.0);\n    \n    vec3 normal = normalize (vec3( map(sp+eps) - map(sp-eps)\n                       ,map(sp+eps.yxz) - map(sp-eps.yxz)\n                       ,map(sp+eps.yzx) - map(sp-eps.yzx) ));\n    \n    \n return normal;   \n}\n\n//guess who this is from...shane\n// \"I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\"\nfloat calculateAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ ){\n    \n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n//based on shanes lighting function but i added reflections using a cubemap\nvec3 lighting(vec3 sp, vec3 sn, vec3 lp, vec3 rd)\n{\nvec3 color;\n    \n\n    sn = bumpMap(iChannel0, sp, sn, 0.0015);\n    vec3 lv = lp - sp;\n    float ldist = max(length(lv), 0.01);\n    vec3 ldir = lv/ldist;\n    \n    float atte = 1.0/(1.0 + 0.002*ldist*ldist );\n    \n    float diff = dot(ldir, sn);\n    float spec = pow(max(dot(reflect(-ldir, sn), -rd), 0.0), 10.);\n    float fres = pow(max(dot(rd, sn) + 1., 0.0), 1.);\n\tfloat ao = calculateAO(sp, sn);\n    \n    vec3 refl = reflect(rd, sn);\n    vec3 refr = refract(rd, sn, 0.7);\n    \n   vec3 color2 = vec3(0.2, 0.5, 0.9);\n    vec3 color3 = vec3(0.0);\n\n    vec3 coolSpec = vec3(.3, 0.5, 0.9);\n    vec3 hotSpec = vec3(0.9,0.5, 0.2);\n   color2 = triPlanar(iChannel0, sp, sn);\n    \n    //apply color options and add refl/refr options\n    color = (diff*color2*8. +  spec*coolSpec*9.  )*atte;\n\t\n    \n    //apply ambient occlusion and return.\n return color*ao;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv=uv*2.0-1.0;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    float wobble=sin(12.*iTime+0.7);\n    \n    wobble *= (smoothstep(0.6,0.9,sin(-iTime*4.))/60.);//fract(-iTime)/400.;//*0.05*sin(20.*iTime);\n    float smoothT = iTime/1. ;\n    \n    //(fract(.1*(iTime-1.))>=0.5)?:0.;\n    vec3 lk = vec3(0.,0. +wobble , 0.+iTime/16.);\n    \n    //lk.xy+=vec2(2.34,.34);//path(lk/4.);//lk.xz*=rot(lk.z);//;\n    vec3 ro = lk + vec3(0., 0., -1.0);\n    vec3 lp = ro + vec3(0, 0., 0.);//lp is ro so no area is too dark\n   \tfloat FOV = .57;\n    \n    vec3 fwd = normalize(lk - ro);\n    vec3 up = vec3(0., -1., 0.0);\n    vec3 rr = normalize(cross(up, fwd));\n    vec3 uu = normalize(cross(rr, fwd));\n    \n    vec3 rd = normalize(vec3(rr*FOV*uv.x + uu*FOV*uv.y + fwd));\n    \n   rd.yz*=rot(iTime/5.);\n    //rd.xz*=rot(iTime/10.);\n    rd.xz*=rot(sin(iTime/8.)/1.);\n    float t = trace(ro, rd);\n    \n     vec3 sp = ro + rd*t;\n    vec3 sn = normal(sp);\n   \t\n    float far = smoothstep(0.0, 1.0, t/4.);\n    \n    //get cube color from cubemap again this time to apply to the sky,\n    //really just so that the reflections on the ground make sense\n    \n  //  vec4 cubeColor = texture(iChannel1, rd);\n    vec3 color = lighting(sp, sn, lp, rd);//mix(stripes(ro+rd*t),vec3(t), far);\n     //reflection trace based on shanes reflection tutorial\n    vec3 refRay = reflect(rd, sn);\n    float rt = rtrace(sp+refRay*0.01, refRay);\n    vec3 rsp = sp + refRay*rt;\n    vec3 rsn = normal(rsp);\n\n    color = mix(color, vec3(2., 2.5, 3.) ,far);//\n\n\tfragColor = vec4(color+rsn.x*0.03,1.0);\n\n}","name":"Image","description":"","type":"image"}]}