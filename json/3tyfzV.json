{"ver": "0.1", "info": {"id": "3tyfzV", "date": "1614651089", "viewed": 168, "name": "Trilinear Isosurface Explorer", "username": "oneshade", "description": "Messing around with my trilinear surface intersector and decided to try making a simple UI to allow me to interact with it.", "likes": 15, "published": 1, "flags": 32, "usePreview": 1, "tags": ["explore"], "requires": ["texture", "imagebuf", "library", "texturebuf"]}, "renderpass": [{"inputs": [{"id": "4dXGzr", "filepath": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "type": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "4dXGR8", "filepath": "/media/previz/buffer00.png", "previewfilepath": "/media/previz/buffer00.png", "type": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "#define TAU 6.28318530718\n\n// Line drawing utility\nvoid drawLine(inout vec3 color, in vec3 lineColor, in vec2 p, in vec2 a, in vec2 b) {\n     float unit = 2.0 / iResolution.y;\n \n     vec2 pa = p - a, ba = b - a;\n     float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n     float d = length(pa - ba * h);\n \n     color = mix(color, lineColor, smoothstep(unit, 0.0, d));\n}\n\n// Modified version of font loader from https://www.shadertoy.com/view/ltcXzs\nvoid drawChar(inout vec3 color, in vec3 charColor, in vec2 p, in vec2 pos, in vec2 size, in int char) {\n    p = (p - pos) / size + 0.5;\n    if (all(lessThan(abs(p - 0.5), vec2(0.5)))) {\n        float val = textureGrad(iChannel1, p / 16.0 + fract(vec2(char, 15 - char / 16) / 16.0), dFdx(p / 16.0), dFdy(p / 16.0)).r;\n        color = mix(color, charColor, val);\n    }\n}\n\n// Quick slider drawing function, not super customizable\nvoid drawSlider(inout vec3 color, in vec2 p, in vec2 pos, in float len, in float rmin, in float rmax, in float val) {\n    p -= pos;\n\n    float hlen = 0.5 * len;\n    float unit = 2.0 / iResolution.y;\n\n    float d = length(vec2(max(0.0, abs(p.x) - hlen), p.y)) - 0.01;\n    color = mix(color, vec3(0.5), smoothstep(unit, 0.0, d));\n\n    d = length(p - vec2(mix(-hlen, hlen, (val - rmin) / (rmax - rmin)), 0.0)) - 0.02;\n    color = mix(color, vec3(1.0), smoothstep(unit, 0.0, d));\n}\n\n// A cubic solver I wrote a while ago, its still a bit buggy\nvec4 solveCubic(in float a, in float b, in float c, in float d) {\n    float denom = 3.0 * a * a;\n    float inflection = -b / (3.0 * a);\n\n    float p = c / a - b * b / denom, p3 = p * p * p;\n    float q = 2.0 * b * b * b / (27.0 * a * a * a) - b * c / denom + d / a, q2 = q * q;\n\n    vec4 roots;\n    if (q2 / 4.0 + p3 / 27.0 > 0.0) {\n        if (4.0 * p3 > -27.0 * q2 && p < 0.0) {\n            roots[0] = -2.0 * sign(q) * sqrt(-p / 3.0) * cosh(acosh(-1.5 * abs(q) / p * sqrt(-3.0 / p)) / 3.0) + inflection;\n        }\n\n        if (p > 0.0) {\n            roots[0] = -2.0 * sqrt(p / 3.0) * sinh(asinh(1.5 * q / p * sqrt(3.0 / p)) / 3.0) + inflection;\n        }\n\n        roots[3] = 1.0;\n    }\n\n    else {\n        float foo = 2.0 * sqrt(-p / 3.0);\n        float bar = acos(1.5 * q / p * sqrt(-3.0 / p));\n        roots = vec4(foo * cos((bar - vec3(0.0, TAU, 2.0 * TAU)) / 3.0) + inflection, 3.0);\n    }\n\n    return roots;\n}\n\nvec4 solveCubic2(in float a, in float b, in float c, in float d) {\n    vec4 roots = solveCubic(d, c, b, a);\n    roots[0] = 1.0 / roots[0];\n    if (roots[3] > 1.0) roots.yz = 1.0 / roots.yz;\n    return roots;\n}\n\n// Trilinear surface intersection and normal\nvec4 IntersectTrilinearSurf(in vec3 ro, in vec3 rd, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {\n    float x = ro.x, y = ro.y, z = ro.z;\n    float u = rd.x, v = rd.y, w = rd.z;\n\n    float ba = b - a, ca = c - a, ea = e - a;\n    float q = ba + c - d + e - f - g + h;\n    float dbac = d - ba - c, fbae = f - ba - e, gcae = g - ca - e;\n    float xy = x * y, uv1 = u * v;\n    float xvuy = x * v + u * y;\n\n    float coeff1 = q * uv1 * w;\n    float coeff2 = dbac * uv1 + (fbae * u + gcae * v) * w + (xvuy * w + uv1 * z) * q;\n    float coeff3 = ba * u + ca * v + ea * w + xvuy * dbac + (x * w + u * z) * fbae + (y * w + v * z) * gcae + (xy * w + xvuy * z) * q;\n    float coeff4 = a + ba * x + ca * y + ea * z + dbac * xy + (fbae * x + gcae * y) * z + q * xy * z;\n\n    return solveCubic2(coeff1, coeff2, coeff3, coeff4);\n}\n\nvec3 getTrilinearSurfNormal(in vec3 p, in float a, in float b, in float c, in float d, in float e, in float f, in float g, in float h) {\n    float x = p.x, y = p.y, z = p.z;\n\n    float ba = b - a, ca = c - a;\n    float q = ba + c - d + e - f - g + h, qx = q * x;\n    float dbac = d - ba - c, fbae = f - ba - e, gcae = g - ca - e;\n\n    float dx = ba + dbac * y + (fbae + q * y) * z;\n    float dy = ca + dbac * x + (gcae + qx) * z;\n    float dz = e - a + fbae * x + (gcae + qx) * y;\n\n    return normalize(vec3(dx, dy, dz));\n}\n\nbool intersectIsValid(in vec3 p, in float t) {\n    return t > 0.0 && all(lessThan(abs(p - 0.5), vec3(0.5)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = 0.5 * iResolution.xy;\n\n    vec2 mouse = ((iMouse.xy - center) / iResolution.y - renderOffs) * 3.14;\n    if (ivec2(iMouse.xy) == ivec2(0)) mouse = vec2(0.0);\n    if (mouse.x < -1.5) mouse = vec2(0.0);\n\n    vec2 uv1 = (fragCoord - center) / iResolution.y, uv2 = uv1 - renderOffs;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    vec3 ro = vec3(0.0, 0.0, 3.0);\n    vec3 rd = normalize(vec3(uv2, -1.0));\n\n    // Rotate with mouse\n    float cy = cos(mouse.x), sy = sin(mouse.x);\n    float cp = cos(mouse.y), sp = sin(mouse.y);\n\n    ro.yz *= mat2(cp, -sp, sp, cp);\n    ro.xz *= mat2(cy, -sy, sy, cy);\n    rd.yz *= mat2(cp, -sp, sp, cp);\n    rd.xz *= mat2(cy, -sy, sy, cy);\n\n    // Center (the surface goes from (0, 0, 0) to (1, 1, 1))\n    ro += 0.5;\n\n    // Isovalues\n    float a = texelFetch(iChannel0, ivec2(0, 0), 0).x;\n    float b = texelFetch(iChannel0, ivec2(1, 0), 0).x;\n    float c = texelFetch(iChannel0, ivec2(2, 0), 0).x;\n    float d = texelFetch(iChannel0, ivec2(3, 0), 0).x;\n    float e = texelFetch(iChannel0, ivec2(4, 0), 0).x;\n    float f = texelFetch(iChannel0, ivec2(5, 0), 0).x;\n    float g = texelFetch(iChannel0, ivec2(6, 0), 0).x;\n    float h = texelFetch(iChannel0, ivec2(7, 0), 0).x;\n\n    vec4 intersect = IntersectTrilinearSurf(ro, rd, a, b, c, d, e, f, g, h);\n    int numIntersects = int(intersect[3]);\n\n    // Find closest valid intersection\n    vec3 hitPos;\n    float tMin = 1000000.0;\n    bool intersecting = false;\n    for (int i=0; i < numIntersects; i++) {\n        vec3 posCandid = ro + rd * intersect[i];\n        float tCandid = intersect[i];\n        if (intersectIsValid(posCandid, tCandid) && tCandid < tMin) {\n            hitPos = posCandid;\n            tMin = tCandid;\n            intersecting = true;\n        }\n    }\n\n    // Render the surface\n    if (intersecting) {\n        vec3 n = getTrilinearSurfNormal(hitPos, a, b, c, d, e, f, g, h);\n        fragColor = vec4(abs(n), 1.0);\n    }\n\n    // Bounding box geometry\n    vec3[] bboxVerts = vec3[8](vec3(-0.5, -0.5, -0.5), vec3( 0.5, -0.5, -0.5),\n                               vec3(-0.5,  0.5, -0.5), vec3( 0.5,  0.5, -0.5),\n                               vec3(-0.5, -0.5,  0.5), vec3( 0.5, -0.5,  0.5),\n                               vec3(-0.5,  0.5,  0.5), vec3( 0.5,  0.5,  0.5));\n\n    ivec2[] bboxEdges = ivec2[12](ivec2(0, 1), ivec2(1, 3), ivec2(3, 2), ivec2(2, 0),\n                                  ivec2(0, 4), ivec2(1, 5), ivec2(2, 6), ivec2(3, 7),\n                                  ivec2(4, 5), ivec2(5, 7), ivec2(7, 6), ivec2(6, 4));\n\n    // Transform bounding box vertices\n    for (int v=0; v < 8; v++) {\n        vec3 vert = bboxVerts[v];\n        vert.xz *= mat2(cy, sy, -sy, cy);\n        vert.yz *= mat2(cp, sp, -sp, cp);\n        vert.z -= 3.0;\n        bboxVerts[v] = vert;\n    }\n\n    // Render bounding box\n    for (int e=0; e < 12; e++) {\n        ivec2 edge = bboxEdges[e];\n        vec3 a1 = bboxVerts[edge[0]];\n        vec3 b1 = bboxVerts[edge[1]];\n        if (max(-a1.z, -b1.z) < tMin) {\n            vec2 a2 = -a1.xy / a1.z;\n            vec2 b2 = -b1.xy / b1.z;\n            drawLine(fragColor.rgb, vec3(0.0, 1.0, 0.0), uv2, a2, b2);\n        }\n    }\n\n    // Draw sliders\n    float hlen = 0.5 * sliderLen;\n    float[] isovalues = float[8](a, b, c, d, e, f, g, h);\n    int[] chars = int[8](65, 66, 67, 68, 69, 70, 71, 72); // A, B, C, D, E, F, G, H\n    for (int i=0; i < 8; i++) {\n        drawSlider(fragColor.rgb, uv1, sliders[i], sliderLen, sliderMin, sliderMax, isovalues[i]);\n        drawChar(fragColor.rgb, vec3(1.0), uv1, vec2(sliders[i].x + hlen + 0.075, sliders[i].y), vec2(0.065), chars[i]);\n\n        // Label the corner\n        vec3 corner = bboxVerts[i];\n        if (-corner.z < tMin) {\n            corner.xy += normalize(corner.xy) * 0.1;\n            vec2 charPos = -corner.xy / corner.z;\n            drawChar(fragColor.rgb, vec3(1.0), uv2, charPos, vec2(0.065), chars[i]);\n        }\n    }\n\n    // -\n    drawChar(fragColor.rgb, vec3(1.0), uv1, vec2(sliders[0].x - hlen, sliders[0].y + 0.085), vec2(0.065), 45);\n\n    // 5\n    drawChar(fragColor.rgb, vec3(1.0), uv1, vec2(sliders[0].x - hlen + 0.025, sliders[0].y + 0.085), vec2(0.065), 53);\n\n    // 0\n    drawChar(fragColor.rgb, vec3(1.0), uv1, vec2(sliders[0].x, sliders[0].y + 0.085), vec2(0.065), 48);\n\n    // 5\n    drawChar(fragColor.rgb, vec3(1.0), uv1, vec2(sliders[0].x + hlen - 0.025, sliders[0].y + 0.085), vec2(0.065), 53);\n}", "name": "Image", "description": "", "type": "image"}, {"inputs": [{"id": "4dXGR8", "filepath": "/media/previz/buffer00.png", "previewfilepath": "/media/previz/buffer00.png", "type": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dXGR8", "channel": 0}], "code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    ivec2 iFragCoord = ivec2(fragCoord);\n    if (iFrame == 0) {\n        if (iFragCoord.x == 0) fragColor.x = 0.0;\n        if (iFragCoord.x == 1) fragColor.x = -5.0;\n        if (iFragCoord.x == 2) fragColor.x = 5.0;\n        if (iFragCoord.x == 3) fragColor.x = 0.1; // For the sake of my poor cubic solver :(\n        if (iFragCoord.x == 4) fragColor.x = -5.0;\n        if (iFragCoord.x == 5) fragColor.x = 0.0;\n        if (iFragCoord.x == 6) fragColor.x = 0.0;\n        if (iFragCoord.x == 7) fragColor.x = 5.0;\n    }\n\n    if (iFrame > 0 && iFragCoord.y == 0 && iFragCoord.x < 8) {\n        fragColor = texelFetch(iChannel0, iFragCoord, 0);\n        vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n        // Slider state\n        vec2 slider = sliders[iFragCoord.x];\n        vec2 sliderEnds = slider.x + vec2(-0.5, 0.5) * sliderLen;\n        vec2 curPos = vec2(mix(sliderEnds.x, sliderEnds.y, (fragColor.x - sliderMin) / (sliderMax - sliderMin)), slider.y);\n\n        // Update the slider if it is within the selection radius\n        if (iMouse.z > 0.0 && length(mouse - curPos) < selectRadius) {\n            fragColor.x = mix(sliderMin, sliderMax, clamp((mouse.x - sliderEnds.x) / sliderLen, 0.0, 1.0));\n        }\n    }\n}", "name": "Buffer A", "description": "", "type": "buffer"}, {"inputs": [], "outputs": [], "code": "// Offset of the 3D render\n#define renderOffs vec2(0.3, 0.0)\n\n// Mouse selection radius\n#define selectRadius 0.05\n\n// Slider range\n#define sliderMin -5.0\n#define sliderMax 5.0\n\n// Slider length\n#define sliderLen 0.5\n\n// Slider positions (top to bottom)\nconst vec2[] sliders = vec2[8](vec2(-0.55,  0.35),\n                               vec2(-0.55,  0.25),\n                               vec2(-0.55,  0.15),\n                               vec2(-0.55,  0.05),\n                               vec2(-0.55, -0.05),\n                               vec2(-0.55, -0.15),\n                               vec2(-0.55, -0.25),\n                               vec2(-0.55, -0.35));", "name": "Common", "description": "", "type": "common"}]}