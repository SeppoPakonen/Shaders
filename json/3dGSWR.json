{"ver":"0.1","info":{"id":"3dGSWR","date":"1574034405","viewed":2195,"name":"Sphere FBM Terrain Experiment","username":"iq","description":"This is an experiment on creating a terrain using only sphere SDFs, without using noise. In theory, this is a pretty good SDF and doesn't suffer from marching artifacts. It also allows for concave geometry, which is nice.","likes":45,"published":3,"flags":32,"tags":[]},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by inigo quilez - iq/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n\n    vec3 col = textureLod( iChannel0, p, 0.0 ).xyz;\n\n    // vignette\n    col *= 0.5 + 0.5*pow( 16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y), 0.05 );\n         \n    // cheap dithering\n    col += sin(fragCoord.x*114.0)*sin(fragCoord.y*211.1)/512.0;\n    \n    fragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// The MIT License\n// Copyright \u00a9 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// This is an experiment on creating a terrain using only sphere\n// SDFs, without using noise, displacement or heightmaps. Instead\n// the terrain is a true volumetric SDF, no approximations and no\n// reduced marching steps needed, even for concave areas.\n//\n// The main function is noiseSDF() in line 66, which computes the\n// SDF of a grid of spheres with random sizes, smoothly blended\n// together. From there on I evaluate a few octaves of such\n// infinte sphere distane field and do a smooth-min combination\n// of the all.\n//\n// I feel this is a superior way to produce noise and fbm shapes\n// for SDFs compared to displacement, because it produces a trus\n// SDF without artifcats.\n//\n// I'm still learning to control it though - growing the trees\n// on its surface wasn't difficult but also not elegant. So there's\n// that.\n    \n\n// replace this by something better\nfloat hash(vec2 p) { p  = 17.0*fract( p*0.3183099+vec2(.11,.17) ); return fract( p.x*p.y*(p.x+p.y) ); }\n// replace this by something better\nfloat hash(vec3 p)  { p  = 17.0*fract( p*0.3183099+vec3(.11,.17,.13) ); return fract( p.x*p.y*p.z*(p.x+p.y+p.z) ); }\n// replace this by something better\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n// replace this by something better\nvec3 hash3( vec2 p ) \n{\n    return textureLod(iChannel1,(p+0.5)/256.0,0.0).xyz;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n//---------------------------------------------------------------\n//\n// A smooth but random SDF. For each cell, it places a sphere of\n// random size in each corner and computer the smooth minimum.\n//\n//---------------------------------------------------------------\n\nfloat noiseSDF( in vec3 p )\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n    const float G1 = 0.2;\n    const float G2 = 0.7;\n    \n\t#define RAD(r) ((r)*(r)*G2)\n    #define SPH(i,f,c) length(f-c)-RAD(hash(i+c))\n    \n    return smin(smin(smin(SPH(i,f,vec3(0,0,0)),\n                          SPH(i,f,vec3(0,0,1)),G1),\n                     smin(SPH(i,f,vec3(0,1,0)),\n                          SPH(i,f,vec3(0,1,1)),G1),G1),\n                smin(smin(SPH(i,f,vec3(1,0,0)),\n                          SPH(i,f,vec3(1,0,1)),G1),\n                     smin(SPH(i,f,vec3(1,1,0)),\n                          SPH(i,f,vec3(1,1,1)),G1),G1),G1);\n}\n\n// rotation matrix\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat treeDensity( in vec3 p, in float treeL )\n{\n    return sin(p.x*18.0)*sin(p.z*18.0) + 0.2 +  7.0*p.y - treeL;\n}\n\nvec3 map( in vec3 p, in float dis, in float tre )\n{\n    // ground\n    float d = length(p-vec3(0.0,-250.0,0.0))-250.0;\n    \n\tfloat l = 1.0;\n    // fbm\n    vec3 q = p;\n    float t = 0.0;\n\tfloat s = 1.0;\n    int ioct = int(clamp(11.0 - log2(dis),1.0,12.0));\n    //const int ioct = 11;\n    for( int i=0; i<ioct; i++ )\n    {\n        float n = noiseSDF(q)*s;\n        n = smax(n,d-0.1*s,0.3*s);\n        d = smin(d,n,0.3*s );\n        t += d;\n        //q = 2.0*m*q; // next octave\n        q = m*(q*2.0+vec3(0.0,0.0,-t*2.0*s)*(1.0-float(i)/12.0));\n        //s = 0.4*s*(1.0+0.015*float(i));\n        s = 0.4*s*(1.0+0.0035*float(i*i));\n    }\n    \n#if 1\n    const float SC = 80.0;\n    float ss = SC/120.0;\n    if( t<0.2 )\n    {\n        vec3 w = p*SC;\n        vec2 n = floor( w.xz );\n        vec2 f = fract( w.xz );\n        float d2 = 1.0;\n        for( int j=0; j<=1; j++ )\n        for( int i=0; i<=1; i++ )\n        {\n            vec2  g = vec2( float(i), float(j) ) - step(f,vec2(0.5));\n            vec3  o = hash3( n + g );\n            vec3  r = vec3(g.x-f.x+o.x,d*SC,g.y-f.y+o.y);\n            if( treeDensity(vec3((n.x+g.x)/SC,p.y,(n.y+g.y)/SC),tre)<0.0 )\n            {\n                float k = sdEllipsoid(r,vec3(0.2,0.15+0.05*o.z,0.2));\n                d2 = min(d2,k);\n            }\n        }\n        d2 /= SC;\n\n        float d3 = noiseSDF(ss*400.0*p*vec3(1.0,1.0,1.0))/(ss*400.0);\n        d2 = smin(d2,smax(d3,d2-0.003,0.003),0.003);\n        d3 = noiseSDF(d3*ss*400.0+ss*1700.0*p*vec3(1.0,2.0,1.0))/(ss*1700.0);\n        d2 = smax(d2-0.0003,-d3,0.001);\n\n        if( d2<d ) {d=d2; l=2.0; }\n    }\n#endif\n        \n    return vec3(d,t,l);\n}\n\nconst float precis = 0.0007;\n\nvec3 interesect( in vec3 ro, in vec3 rd, in float px, in float tre )\n{\n\tvec3 res = vec3(-1.0);\n\n    float tmax = 20.0;\n\n    // raymarch\n    float t = 0.0;\n\tfor( int i=0; i<512; i++ )\n\t{\n        vec3 pos = ro + t*rd;\n\t\tvec3 h = map( pos, t, tre );\n        res.x = t;\n        res.yz = h.yz;\n        if( h.x<(precis*px*t) || t>tmax ) break;\n\t\tt += h.x;\n\t}\n\n\tif( t>tmax ) res = vec3(-1.0);\n\treturn res;\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos, in float t, float px, in float tre )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*precis*t*px;\n    return normalize( e.xyy*map( pos + e.xyy, t, tre ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx, t, tre ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy, t, tre ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx, t, tre ).x );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftShadow(vec3 ro, vec3 rd, float tmin, float tmax, float w, in float tre)\n{\n    // bounding volume    \n    #if 1\n    float tp = (0.5-ro.y)/rd.y;\n    if( tp>0.0 )\n    {\n        if( ro.y<0.5 ) tmax = min(tmax,tp);\n        else tmin = max(tmin,tp);\n\t}\n    #endif\n    \n    float t = tmin;\n    float res = 1.0;\n    for( int i=0; i<256; i++ )\n    {\n     \tfloat h = map(ro + t*rd, 1.0, tre).x;\n        res = min( res, h/(w*t) );\n    \tt += clamp(h, 0.002, 0.50);\n        if( res<-1.0 || t>1.0 ) break;\n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res);\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, cos(cr),sin(cr));\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nvoid sceneSetup( out vec3 ro, out vec3 ta, out float cr, out float fl,\n                 out vec3 lig, out float tre, out float rtime,\n                 in float time )\n{\n    if( time<10.0 )\n    {\n        rtime = time - 0.0;\n        float an = 0.4-0.005*rtime;\n        ta = vec3( an, 0.0-0.1, 0.0 );\n        ro = ta + vec3( 1.0, 0.22+0.1, 0.0 );\n        ta.y -= 0.05;\n        fl = 2.5;\n        cr = -0.05*sin(rtime*0.15);\n        lig = normalize(vec3(-0.6,0.125,1.0));\n        tre = 0.7;\n    }\n    else if( time<25.0 )\n    {\n        rtime = time - 10.0;\n        float an = -0.23-0.003*rtime;\n        ta = vec3( an, 0.0-0.1, 0.0 );\n        ro = ta + vec3( 1.0, 0.22+0.1, 0.0 );\n        ta.y -= 0.05;\n        fl = 2.5;\n        cr = -0.1*sin(rtime*0.1);\n        lig = normalize(vec3(-0.6,0.125,1.0));\n        tre = 0.0;\n    }\n    else if( time<35.0 )\n    {\n        rtime = time - 25.0;\n        float an = -0.001*rtime+2.0;\n        ro = 2.4*vec3( cos(an), 0.09, sin(an) );\n        ta = vec3( 0.0, -0.3, 0.0 );\n        fl = 3.5;\n        cr = 0.0;\n        lig = normalize(vec3(2.00,0.3,-0.26));        \n        tre = 0.2;\n    }\n    else if( time<55.0 )\n    {\n        rtime = time - 35.0;\n        float an = 0.01*rtime;\n        ro = vec3( 3.0+cos(an), 0.22, 0.0+sin(an) );\n        ta = vec3( 3.0, -0.05, 0.0 );\n        ro.x -= 0.2;\n        ta.x -= 0.2;\n        ta.y += 0.1;\n        ro.y += 0.1;\n        ro.z -= 0.2;\n        ta.z -= 0.2;\n        fl = 6.0;\n        cr = 0.0;\n        lig = normalize(vec3(-0.7,0.125,-1.0));        \n        tre = 0.1;\n    }\n    else if( time<65.0 )\n    {\n        rtime = time - 55.0;\n    \tfloat an = -0.002-0.0025*time;\n    \tta = vec3( 1.5+an, -0.015,1.0 );\n    \tro = ta + vec3( 1.0, 0.19, 0.0 );\n    \tfl = 4.0;\n        cr = 0.02;\n        lig = normalize(vec3(-0.4,0.15,0.8));\n        tre = 0.35;\n    }\n    else\n    {\n    \trtime = time - 65.0;\n        float an = -0.005*rtime;\n        ro = 1.4*vec3( cos(an), 0.3, sin(an) );\n        ta = vec3( 0.0, -0.2, ro.z );\n        fl = 2.5;\n        cr = 0.0;\n        lig = normalize(vec3(1.0,0.1,-0.6));        \n        tre = -1.0;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 o = hash2( float(iFrame) ) - 0.5;\n    \n    vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/ iResolution.y;\n\n    float d = 0.5*sin(fragCoord.x*147.0)*sin(fragCoord.y*131.0);\n    float time = iTime;// - d*0.5*(1.0/24.0);\n    \n\t// scene setup\n    vec3 ro, ta, lig;\n    float cr, fl, tre, fad;\n\tsceneSetup( ro, ta, cr, fl, lig, tre, fad, time );\n\t\n    // camera matrix\t\n    mat3 ca = setCamera( ro, ta, cr );\n    vec3 rd = ca * normalize( vec3(p.xy,fl));\n\n    // render\n    vec3 col = vec3(0.5,0.6,0.7) - max(0.0,rd.y);\n    \n    vec3 tm = interesect( ro, rd, 2.0/fl, tre );\n    float t = tm.x;\n    if( t>0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t,2.0/fl, tre );\n\n        nor.xz += 0.4*(-1.0+2.0*texture(iChannel1,28.0*pos.xz).xz);\n        nor = normalize(nor);            \n        tm.y = smoothstep(0.0,0.16,tm.y);\n        float td = treeDensity(pos,tre);\n        float occ = 0.3 + 0.7*tm.y;\n\n        float fre = clamp(1.0+dot(nor,rd),0.0,1.0);\n\n        // fake occlusion from trees ot terrain\n        if( tm.z<1.5 && td<0.0 )\n        {\n            const float SC = 80.0;\n            vec3 w = pos*SC;\n            vec2 n = floor( w.xz );\n            vec2 f = fract( w.xz );\n            float d2 = 1.0;\n            for( int j=0; j<=1; j++ )\n                for( int i=0; i<=1; i++ )\n                {\n                    vec2  g = vec2( float(i), float(j) ) - step(f,vec2(0.5));\n                    vec3  o = hash3( n + g );\n                    vec2  r = vec2(g-f+o.xy);\n                    float k = length(r);\n                    d2 = min(d2,k);\n                }\n            d2 /= SC;\n            occ *= smoothstep(0.001,0.006,d2);\n        \tocc *= 0.2+0.8*clamp(1.0+td*5.0,0.0,1.0);\n        }\n\n        // material\n        vec3 mate = mix( 0.5*vec3(0.6,0.25,0.07), vec3(0.45,0.35,0.25), tm.y );\n        float ks = 0.2+0.8*tm.y;\n        float ke = 0.0;\n\n        // grass\n        float grass =smoothstep(0.6,0.65,1.0-tm.y)*smoothstep(0.9,0.98,nor.y);\n        mate = mix( mate, vec3(0.15,0.04,0.01)*3.0, grass);\n        ks *= 1.0-0.8*grass;\n        ke = grass;\n\n        // texture\n        mate *= pow(texture(iChannel2,4.0*pos.xz).xyz,vec3(1.5))*3.0;\n\n        // trees\n        if( tm.z>1.5 )\n        {\n            const float SC = 120.0;\n            vec2 n = floor( SC*pos.xz );\n            mate = vec3(1.3,0.1,0.01);\n            mate += vec3(0.1,0.2,0.01)*hash(n);\n            mate *= 0.3;\n            ks = 0.7;\n            ke = 1.0;\n        }\n\n        // lighting\n        float ww = 0.0;// + ke*0.5;\n        float dif = clamp(ww+(1.0-ww)*dot(lig,nor),0.0,1.0);\n        dif *= calcSoftShadow(pos+nor*0.0001,lig,0.001,1.0,0.003, tre);\n\n        vec3 hal = normalize(lig-rd);\n        float spe = clamp(dot(hal,nor),0.0,1.0);\n        spe = pow(spe,4.0)*dif*(0.04+0.96*pow(max(1.0-dot(hal,lig),0.0),5.0));\n\n        col = vec3(0.0);\n        col += mate*4.0*vec3(1.5,1.1,0.95)*dif;\n        col +=      ks*7.0*spe;\n        col += mate*0.3*vec3(0.40,0.5,1.2)*(occ)*clamp(0.4+0.6*nor.y,0.0,1.0);\n        col += (0.5+0.5*ke)*mate*vec3(0.05)*occ*clamp(dot(nor,vec3(-lig.x,0.0,-lig.z)),0.0,1.0);\n        col += ke*fre*fre*fre*mate*dif*0.8;\n\n        col = mix( col, 1.5*vec3(0.35,0.4,0.55), 1.0-exp(-(t*t+t)*0.02*2.0/fl) );\n    }\n\telse\n    {\n        t = 1000.0;\n    }\n\n    // compressor\n    col *= 3.0/(3.0+dot(col,vec3(0.333)));\n\n    // gamma\n    col = pow(col,vec3(0.4545));\n\n\n    //------------------------------------------\n\t// reproject from previous frame and average\n    //------------------------------------------\n\n    mat4 oldCam = mat4( textureLod(iChannel0,vec2(0.5,0.5)/iResolution.xy, 0.0),\n                        textureLod(iChannel0,vec2(1.5,0.5)/iResolution.xy, 0.0),\n                        textureLod(iChannel0,vec2(2.5,0.5)/iResolution.xy, 0.0),\n                        0.0, 0.0, 0.0, 1.0 );\n    \n    // world space\n    vec4 wpos = vec4(ro + rd*t,1.0);\n    // camera space\n    vec3 cpos = (wpos*oldCam).xyz; // note inverse multiply\n    // ndc space\n    vec2 npos = fl * cpos.xy / cpos.z;\n    // screen space\n    vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y/iResolution.x,1.0);\n    // undo dither\n    spos -= o/iResolution.xy;\n\t// raster space\n    vec2 rpos = spos * iResolution.xy;\n    \n    if( rpos.y<1.0 && rpos.x<3.0 )\n    {\n    }\n\telse\n    {\n        vec3 ocol = textureLod( iChannel0, spos, 0.0 ).xyz;\n    \tif( iFrame==0 ) ocol = col;\n        col = mix( ocol, col, 0.2 );\n    }\n\n    //----------------------------------\n                           \n\tif( fragCoord.y<1.0 && fragCoord.x<3.0 )\n    {\n        if( abs(fragCoord.x-2.5)<0.5 ) fragColor = vec4( ca[2], -dot(ca[2],ro) );\n        if( abs(fragCoord.x-1.5)<0.5 ) fragColor = vec4( ca[1], -dot(ca[1],ro) );\n        if( abs(fragCoord.x-0.5)<0.5 ) fragColor = vec4( ca[0], -dot(ca[0],ro) );\n    }\n    else\n    {\n    \tcol *= smoothstep(0.0,1.0,fad);\n        fragColor = vec4( col, 1.0 );\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}