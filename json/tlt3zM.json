{"ver":"0.1","info":{"id":"tlt3zM","date":"1576144914","viewed":223,"name":"FlowMapEditor","username":"sapporo_dynamite","description":"Easy Flow Map Editor\n[control]\nviewChange[paint mode or preview]: key 1 \nerase: key 2 + mouse drag \nreset:  key 3","likes":8,"published":1,"flags":48,"tags":[]},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tFlow Map Editor\n\n\tImplements Easy Flow Map Editor\n\n\tHow Flow Map Editor works\n\t1. Buffer A: Create a texture that records vector values of movement\n\t2. Buffer B: Depress the texture of Buffer A with gaussian blur\n\n\tauthor:\n\tsapporo_dynamite/2019 \n\n\tLicense :\n\tCreative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\u3000\u3000URL\uff1a\n    naochang blog\n    Shader\u3067Image\u3092\u304b\u304d\u6df7\u305c\u308b\n\thttp://naochang.me/?p=873#more-873\n\n    LIGHT11\n\t\u3010Unity\u3011\u3010\u30b7\u30a7\u30fc\u30c0\u3011\u30d5\u30ed\u30fc\u30de\u30c3\u30d7\u3067\u6c34\u6d41\u3092\u4f5c\u308b\n\thttp://light11.hatenadiary.com/entry/2018/03/15/000311\n*/\n\n/*\n2019/12/12\n  0.0.0 \u2192 1.0.0\n    \u30fb1st release   \n\n2019/12/11\n  0.0.0 \u2192 0.0.0\n    \u30fbstart\n*/\n\nbool keyPress(int ascii){\n    return (texture(iChannel2,vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n}\nbool keyToggle(int ascii) {\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\n\n// draw line\nfloat Line (vec2 p1, vec2 p2, vec2 uv, float a)\n{\n    vec2 p1uv =  (p1.xy + 0.5) / vec2(iResolution.xy);\n    vec2 p2uv =  (p2.xy + 0.5) / vec2(iResolution.xy);\n    \n    float r = 0.;\n    float one_px = 1. / iResolution.x; //not really one px\n    \n    // get dist between points\n    float d = distance(p1uv, p2uv);\n    \n    // get dist between current pixel and p1\n    float duv = distance(p1uv, uv);\n\n    //if point is on line, according to dist, it should match current uv \n    r = 1.-floor(1.-(a*one_px)+distance (mix(p1uv, p2uv, clamp(duv/d, 0., 1.)),  uv));\n        \n    return r;\n}\n\n// draw circle\nfloat circle(vec2 r, vec2 center, float radius) \n{\n\treturn (1.0 - smoothstep( radius-0.5, radius+0.5, length(r-center))) - (1.0 - smoothstep( radius * 0.99 -0.5, radius * 0.99 +0.5, length(r-center)));\n}\n\nvec4 getBuffer( in vec2 fragCoord)\n{\n    if (fragCoord.x >= 0. && fragCoord.x < float(iResolution.x) && fragCoord.y >= 0. && fragCoord.y < float(iResolution.y))\n    {\n     \tvec2 uv =  (fragCoord.xy + 0.5) / vec2(iResolution.xy);\n     \treturn texture(iChannel1, uv, -100.0);\n    }\n    return vec4(0.); \n} \n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //------------------------------------------------------------\n    // Flow Map Editor \u306e\u4ed5\u7d44\u307f\n\t// 1. Buffer A: \u79fb\u52d5\u91cf\u306e\u30d9\u30af\u30c8\u30eb\u5024\u3092\u8a18\u9332\u3059\u308b\u30c6\u30af\u30b9\u30c1\u30e3\u306e\u4f5c\u6210\n\t// 2. Buffer B: Buffer A \u306e\u30c6\u30af\u30b9\u30c1\u30e3\u3092 gaussian blur \u3067\u6688\u3059\n    //------------------------------------------------------------\n\t\n    // Implement FlowMap\n    vec2 uv = fragCoord/iResolution.xy;\n    const float timescale = .174;\n\tvec2 flowDir =  (texture(iChannel1, uv).xy - 0.5) * vec2(-1,1);\n\tfloat time = (iTime ) * timescale; \n\tfloat flow_t0 = fract(time);\n\tfloat flow_t1 = fract(time + .5);\n\tfloat lerp = abs((0.5 - flow_t0) / 0.5); \n\tvec4 samp0 = texture(iChannel3, uv + flowDir * flow_t0); \n\tvec4 samp1 = texture(iChannel3, uv + flowDir * flow_t1);\n\n\tfragColor = mix(samp0, samp1, lerp);\n \n    // key 1 \u3067 \u8868\u793a\u5207\u66ff( \u30da\u30a4\u30f3\u30c8\u30e2\u30fc\u30c9 \u3068 \u30d7\u30ec\u30d3\u30e5\u30fc)\n    // key 1 chage view [paint mode or preview]\n    if(!keyToggle(49)){\n        fragColor = getBuffer(fragCoord);\n    }\n    // \u30da\u30a4\u30f3\u30c8\u3059\u308b\u7bc4\u56f2\u306e\u8868\u793a\n    // debug circle (guide brush)\n    if( iMouse.z * circle(iMouse.xy, fragCoord.xy, 18.) > 0.0) { \n    \tfragColor += vec4(1.);\n    }\n    // \u30da\u30a4\u30f3\u30c8\u306e\u5411\u304d\u306e\u8868\u793a\n    // debug line (guide draw direction)\n    if(iMouse.z > 0.0 && !keyPress(50)){\n        if ( Line(iMouse.xy, iMouse.zw, uv, 1.) > 0.0 ){\n            fragColor = vec4(1);\n        }\n    }\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 getBuffer( in vec2 fragCoord)\n{\n    if (fragCoord.x >= 0. && fragCoord.x < float(iResolution.x) && fragCoord.y >= 0. && fragCoord.y < float(iResolution.y))\n    {\n     \tvec2 uv =  (fragCoord.xy + 0.5) / vec2(iResolution.xy);\n     \treturn texture(iChannel0, uv, -100.0);\n    }\n    return vec4(0.);\n}\n\nbool keyPress(int ascii){\n    return (texture(iChannel1,vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n}\n\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 1.0 - smoothstep( radius-0.5, radius+0.5, length(r-center));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 cell = floor(fragCoord);\n    \n    if(iFrame == 0) {\n    \tfragColor = vec4(0.5,0.5,0.0,1.0);\n    }\n    else {\n        vec4 col = getBuffer(cell);\n        fragColor = col;\n        float size = 16.0;\n        \n        // \u65b9\u5411\u306f \u73fe\u5728\u306e\u30de\u30a6\u30b9\u4f4d\u7f6e \u3068 \u30de\u30a6\u30b9\u30af\u30ea\u30c3\u30af\u3057\u305f\u4f4d\u7f6e \u304b\u3089\u6c42\u3081\u308b\n        // direction\u3000= current mouse pos - mouse click pos \n        vec2 v = vec2(iMouse.xy) - vec2(iMouse.zw);\n        \n        if(length(v) > 0.01){\n        \tv = normalize(v);\n            v = v * 0.5 + 0.5;\n            if( iMouse.z * disk(iMouse.xy, cell.xy, size) > 0.0) { \n                fragColor = vec4(v.x, 1.0 - v.y, 0, 1.0);\n            }\n        }\n        // key 2 erase\n        if( iMouse.z * disk(iMouse.xy, cell.xy, size) > 0.0) { \n        \tif( keyPress(50) ) fragColor = vec4(0.5,0.5,0,1);\n        }\n        // key 3 reset \n        if( keyPress(51) ) fragColor = vec4(0.5,0.5,0,1);\n        \n         if(iTime<=3.14){\n              if(0.7<0.9*smoothstep(1.0,0.0,length(fragCoord.xy-iResolution.xy*0.5+vec2(sin(iTime*2.0)*100.0, cos(iTime*2.0)*100.0 ))*0.026)){\n               \t  vec4 color = vec4(-sin(iTime*2.0), cos(iTime*2.0), 0, 0);\n                  color = color * 0.5 + 0.5;\n                  fragColor = vec4(color.x, color.y, 0, 1);\n              }\n          }  \n    }    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Shader From\n// FabriceNeyret2 \n// Single-pass gaussian blur - fast \n// https://www.shadertoy.com/view/ltScRG\n\n// Thanks very useful!!\n\nconst int samples = 35,\n          LOD = 2,         // gaussian done on MIPmap at scale LOD\n          sLOD = 4; // tile size = 2^LOD\nconst float sigma = float(samples) * .25;\n\nfloat gaussian(vec2 i) {\n    return exp( -.5* dot(i/=sigma,i) ) / ( 6.28 * sigma*sigma );\n}\n\nvec4 blur(sampler2D sp, vec2 U, vec2 scale) {\n    vec4 O = vec4(0);  \n    const int s = samples/sLOD;\n    \n    for ( int i = 0; i < s*s; i++ ) {\n        vec2 d = vec2(mod(float(i),float(s)), i/s)*float(sLOD) - float(samples)/2.;\n        O += gaussian(d) * texture( sp, U + scale * d , -100. );\n    }\n    \n    return O / O.a;\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    O = blur( iChannel1, U/iResolution.xy, 1./iChannelResolution[0].xy );\n}","name":"Buffer B","description":"","type":"buffer"}]}