{"ver": "0.1", "info": {"id": "ss3SzH", "date": "1633111811", "viewed": 173, "name": "i21/01 Crystal", "username": "byt3_m3chanic", "description": "day 01 - [crystal]", "likes": 10, "published": 3, "flags": 32, "usePreview": 0, "tags": [], "requires": ["texture", "texturebuf", "imagebuf"]}, "renderpass": [{"inputs": [{"id": "4dXGR8", "filepath": "/media/previz/buffer00.png", "previewfilepath": "/media/previz/buffer00.png", "type": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": "XsXGR8", "filepath": "/media/previz/buffer01.png", "previewfilepath": "/media/previz/buffer01.png", "type": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Inktober 2021 @byt3_m3chanic \n    10/01/21 Crystal \n    \n    Isometric and angles / some pattern illusions.\n    using the bag of tricks refration/reflection.\n\n    Buffer A / Theme Shader\n    Buffer B / Shadetober Overlay\n\n    Inktober 2021 found here\n    https://inktober.com/rules\n    \n*/\n\n#define R iResolution\n\nvoid mainImage( out vec4 O, in vec2 F )\n{  \n\tvec2 uv = F.xy/R.xy;\n\n    vec3 A = texture(iChannel0, uv).rgb;\n    vec4 B = texture(iChannel1, uv);\n    vec3 C = mix(A,vec3(B.rgb),B.w);\n    \n    // output\n    C=pow(C, vec3(.4545));\n    O = vec4(C,1.);\n}\n\n/** other shaders\n\n    10/01/21 Crystal             https://www.shadertoy.com/view/ss3SzH\n    10/04/21 Knot                https://www.shadertoy.com/view/NstXDM \n    10/06/21 Spirit              https://www.shadertoy.com/view/7dtSz2\n    \n*/", "name": "Image", "description": "", "type": "image"}, {"inputs": [], "outputs": [{"id": "4dXGR8", "channel": 0}], "code": "#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define MAX_DIST    30.00\n#define MIN_DIST    0.0001\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21( vec2 p ) { return fract(sin(dot(p,vec2(23.43,84.21))) *4832.3234); }\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), 0.0, 1.0); }\nfloat eoc(float t) { return (t = t - 1.0) * t * t + 1.0; }\n\n//@iq sdf's!\nfloat sdframe( vec3 p, vec3 b, float e ) {\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n//@gaz crystal shape via twitter\nfloat zag(vec3 p, float s) {\n    p = abs(p)-s;\n    if (p.x < p.z) p.xz = p.zx;\n    if (p.y < p.z) p.yz = p.zy;\n    if (p.x < p.y) p.xy = p.yx;\n    return dot(p,normalize(vec3(s*.42,s,0)));\n}\n\nfloat tmod=0.,ga1=0.,ga2=0.,ga3=0.,ga4=0.,ga5=0.;\nmat2 r45,ry,rx;\n\n#define SCALE .25\nconst float scale = 1./SCALE;\nconst vec2 l = vec2(scale);\nconst vec2 s = l*2.;\nconst float sl = l.x*4.;\nconst vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5),   vec2(.5, -.5), vec2(-.5));\n\nvec2 map(vec3 p) {\n    vec2 res =vec2(1e5,0.);\n\n    p.z+=ga5*sl;\n    \n    mat2 rz = rot(ga4*PI);\n    p.xz*=rz;\n    vec2 r,ip,ct = vec2(0);\n\n    //@Shane - multi tap grid\n    for(int i =0; i<4; i++){\n        ct = ps4[i]/2.;              // Block center.\n        r = p.xz - ct*s;             // Local coordinates. \n        ip = floor(r/s) + .5;        // Local tile ID. \n        r -= (ip)*s;                 // New local position.   \n        vec2 idi = (ip*s) + ct;\n \n        vec3 q = vec3(r.x,p.y,r.y);\n        float chx = mod(idi.x,2.) * 2. - 1.;\n        float chy = mod(idi.y,2.) * 2. - 1.;\n        float chk = (chy<1. ^^ chx<1.) ? .6 : .4;\n        \n        if(chk>.5) { \n            q.xy*=rz; \n            q.xz*=rot(ga1*PI); \n        } else { q.zy*=rot(ga3*PI);\n            q.yz*=rz; \n            q.yz*=rot(-ga5*PI);\n        }\n\n        float ms = l.x*.15;\n        float mf = l.x*.27;\n\n        float frame2 = sdframe(q,vec3(mf),.0725);\n        if(frame2<res.x) res = vec2(frame2,4.);\n  \n        float mainbox = zag(q,ms);\n        q.yz*=r45;\n        q.zx*=r45;\n        mainbox=max(mainbox,-zag(q,ms*.425));\n    \n        if(mainbox<res.x) res = vec2(mainbox,1.);\n\n    }\n\n    return res;\n}\n\n//Tetrahedron technique\n//https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 normal(vec3 p, float t) {\n    float e = t;\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n                      h.yyx*map( p + h.yyx*e ).x + \n                      h.yxy*map( p + h.yxy*e ).x + \n                      h.xxx*map( p + h.xxx*e ).x );\n}\n\nvec3 render(vec3 p, vec3 rd, vec3 ro, float d, float m, inout vec3 n, inout float fresnel) {\n    n = normal(p,d);\n    vec3 lpos =  vec3(8,10,8);\n    vec3 l = normalize(lpos-p);\n    float diff = clamp(dot(n,l),0.,1.);\n    \n    fresnel = pow(clamp(1.+dot(rd, n), 0., 1.), 9.);\n    fresnel = mix(.0, .9, fresnel);\n\n    vec3 h = vec3(.3);\n    if(m==1.) h=mix(vec3(.5),vec3(0.322,0.831,1.000),clamp((p.z+8.)*.075,0.,1.));\n    if(m==4.) h=mix(vec3(.9),vec3(.5),1.-clamp((p.z+8.)*.075,0.,1.));\n    h = mix(h,vec3(0.322,0.831,1.000),fresnel);\n    \n    return diff*h;\n}\n\nconst float zoom = 8.;\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    // precal\n    float time = T;\n    r45 = rot(.78539816);\n    \n    tmod = mod(time, 16.);\n    float t1 = lsp(2.0, 4.0, tmod);\n    float t2 = lsp(6.0, 8.0, tmod);\n    \n    float t5 = lsp(4.0, 6.0, tmod);\n    float t6 = lsp(8.0, 10.0, tmod);\n    \n    float t7 = lsp(0.0, 2.0, tmod);\n    float t8 = lsp(8.0, 10.0, tmod);\n    \n    float t9 = lsp(10.0, 16.0, tmod);\n    \n    ga1 = eoc(t1-t2);\n    ga1 = ga1*ga1*ga1;\n\n    ga3 = eoc(t5-t6);\n    ga3 = ga3*ga3*ga3;\n    \n    ga4 = eoc(t7-t8);\n    ga4 = ga4*ga4*ga4;\n    \n    t9 = eoc(t9);\n    t9 = t9*t9*t9;  \n    ga5 = (t9);\n    //\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n\n    //orthographic camera\n    vec3 ro = vec3(uv*zoom,-zoom-15.);\n    vec3 rd = vec3(0,0,1.);\n\n    rx = rot(.615);\n    ry = rot(-.7853981);\n    \n    ro.zy*=rx;rd.zy*=rx;\n    ro.xz*=ry;rd.xz*=ry;\n\n    vec3 C = vec3(.0075);\n    vec3  p = ro + rd;\n    float atten = .95;\n    float k = 1.;\n    float d = 0.;\n    for(int i=0;i<100;i++)\n    {\n        vec2 ray = map(p);\n        vec3 n=vec3(0);\n        float m = ray.y;\n\n        d = i<32 ? ray.x*.2 : ray.x;\n        p += rd * d *k;\n        \n        if (d*d < 1e-7) {\n  \n            float fresnel=0.;\n            C+=render(p,rd,ro,d,ray.y,n,fresnel)*atten;\n  \n            atten *= .525;\n            p += rd*.025;\n            k = sign(map(p).x);\n\n            vec3 rr = vec3(0);\n\n            if(m== 4.) {\n                rd=reflect(-rd,n);\n                p+=n*.05;\n            } else {\n                rr = refract(rd,n,.55);\n                rd=mix(rr,rd,.5-fresnel);\n            }\n\n        } \n       \n        if(distance(p,rd)>35.) { break; }\n    }\n\n    if(C.r<.008&&C.g<.008&&C.b<.008) C = hash21(uv)>.85 ? C+.015 : C;\n    //C = pow(C, vec3(.4545));\n    O = vec4(C*vec3(0.494,0.655,0.827),1.0);\n}", "name": "Buffer A", "description": "", "type": "buffer"}, {"inputs": [{"id": "4dXGzr", "filepath": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "type": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "outputs": [{"id": "XsXGR8", "channel": 0}], "code": "/** \n    inktober 2021 @byt3_m3chanic \n    10/21 Overlay Template\n\n*/\n\n#define R          iResolution\n#define M          iMouse\n#define T          iTime\n#define PI         3.14159265359\n#define PI2        6.28318530718\n\nfloat time,tmod,ga1,ga2,ga3,ca1,ca2,ca3;\nfloat lsp(float begin, float end, float t) { return clamp((t - begin) / (end - begin), 0.0, 1.0); }\nfloat eoc(float t) { return (t = t - 1.0) * t * t + 1.0; }\n\n////////////////////////////////////////////////////////\n// Fabrice Neyret https://www.shadertoy.com/view/llySRh\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.44;\n#define C(c) spc O+= char(U,64+CAPS+c);\nvec4 char(vec2 p, int c) {\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n// webGL2 variant with dynamic size\nvec4 pInt(vec2 p, float n) {\n    vec4 v = vec4(0);\n    for (int i = int(n); i>0; i/=10, p.x += .5 )\n        v += char(p, 48+ i%10 );\n    return v;\n}\nvec4 pFloat(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) v += char(p - vec2(-.5,0), 45 ), n = -n;\n    v += pInt(p,floor(n)); p.x -= .5;\n    v += char(p, 46);      p.x -= .95;\n    v += pInt(p,fract(n)*1e2);\n    return v;\n}\n////////////////////////////////////////////////////////\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 p) { return fract(sin(dot(p,vec2(23.86,48.32)))*4374.432); }\n\nfloat box( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec4 getHeader(vec2 uv, float px) {\n    vec3 C = vec3(0);\n    vec4 O = vec4(0);\n    float FontSize = .5;\n    vec2 U = ( (uv*8.)+vec2(1.85,+.5) )/.5;\n\n    //inktober\n     low C(9);C(14);C(11);C(20);C(15);C(2);C(5);C(18);\n\n    float shadetext = O.x;\n    shadetext = smoothstep(px,.95-px,shadetext);\n\n    float ofs = ca3*.25;\n    float tapeline=box(uv+vec2(.235-ofs,.03),vec2(ofs ,.0425));\n    tapeline=smoothstep(px,.001-px,tapeline);\n\n    return ca3>.0?vec4(vec3(C),clamp(tapeline-shadetext,0.,1.)):vec4(0.);\n}\n\nvec4 getDate(vec2 uv, float px) {\n    vec3 C = vec3(0);\n    vec4 O = vec4(0);\n    float FontSize = .35;\n    vec2 U = ( (uv*8.)+vec2(1.725,.5) )/.35;\n\n    C(3);C(18);C(25);C(19);C(20);C(1);C(12); spc spc spc \n    \n    O+=pInt(U,10.);C(-49);spc \n    O+=pInt(U,01.);C(-49);spc spc\n    O+=pInt(U,21.);\n    \n    float shadetext = O.x;\n    shadetext = smoothstep(px,.95-px,shadetext);\n\n    float ofs = ca2*.25;\n    float tapeline=box(uv+vec2(.235-ofs,.04),vec2(ofs ,.025));\n    tapeline=smoothstep(px,.001-px,tapeline);\n    \n    return ca2>.0? vec4(vec3(C),clamp(tapeline-shadetext,0.,1.)):vec4(0.);\n}\n\nfloat getHatch(vec2 p, float res) {\n    p *= res;\n    vec2 f = fract(p*.5);\n    f.y -= tan(radians(45.)) * f.x;\n    float hatch = mod(floor(f.y * 2.), 2.)<1.? .8 : .3;\n    return hatch;\n}\n\nvec4 getFrame(vec2 uv, float px) {\n    vec2 fv = uv;\n    float frame=box(fv-vec2(.7,-.605),vec2(.25,.25));\n    frame=smoothstep(px,-px,frame);\n    vec3 C=mix(vec3(0.059,0.737,0.961),vec3(0.145,0.153,0.153),1.-clamp((uv.y+.625)*2.5,0.,1.));\n    float hatch = getHatch(uv,100.);\n    vec3 h2=mix(vec3(0.141,0.141,0.141),vec3(0.839,0.937,1.000),1.-clamp((uv.y+.625)*2.5,0.,1.));\n    C = mix(C,h2,hatch);\n    return vec4(C,frame);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{  \n\n    time = T+40.;\n\n    float msw = mod(time,16.);\n    float m1 = lsp(0.0, 2.0, msw);\n    float m2 = lsp(8.0, 10.0, msw);\n    \n    ca1 = eoc(m1-m2);\n    ca1 = ca1*ca1*ca1;\n    \n    float m3 = lsp(10.0, 11.0, msw);\n    float m4 = lsp(15.0, 16.0, msw);\n    \n    ca2 = eoc(m3-m4);\n    ca2 = ca2*ca2*ca2;\n    \n    float m5 = lsp(09.5, 10.5, msw);\n    float m6 = lsp(14.5, 15.5, msw);\n    \n    ca3 = eoc(m5-m6);\n    ca3 = ca3*ca3*ca3;\n    \n    vec2 vuv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    float px = fwidth(vuv.x);\n    vec3 C = vec3(0,0,0);\n\n    vec4 frame = getFrame(vuv+vec2(0,ca1), px);\n    C = mix(C,frame.rgb,frame.w);\n  \n    vec4 logo = getHeader(vuv-vec2(.65,-(.4+ca1)), px);\n    C = mix(C,logo.rgb,logo.w);\n    \n    vec4 date = getDate(vuv-vec2(.65,-(.475+ca1)), px);\n    C = mix(C,date.rgb,date.w);\n    \n    float alpha = clamp(frame.w+logo.w+date.w,0.,1.);\n    O = vec4(C,alpha);\n}\n\n", "name": "Buffer B", "description": "", "type": "buffer"}]}