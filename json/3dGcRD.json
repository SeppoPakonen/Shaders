{"ver": "0.1", "info": {"id": "3dGcRD", "date": "1602531397", "viewed": 2224, "name": "Columns Sorting Fractal", "username": "pjkarlik", "description": "Saw something @FMS_Cat did in the Shader Royal that inspired me - so trying to replicate that effect from scratch. This is my interpretation of it.. [url]https://www.shadertoy.com/view/wsccWj[/url] - his is way better by far!", "likes": 22, "published": 3, "flags": 0, "usePreview": 0, "tags": ["box"], "requires": ["library", "imagebuf"]}, "renderpass": [{"inputs": [], "outputs": [{"id": "4dfGRr", "channel": 0}], "code": "#define R\t\t\tiResolution\n#define M\t\t\tiMouse\n#define T\t\t\tiTime\n#define PI  \t\t3.1415926\n#define PI2 \t\t6.2831853\n\n#define MINDIST     .001\n#define MAXDIST     175.\n\n/**\n\tColumn Sorting Fractals | pjkarlik\n\t\n\tInterpretation or stuff seen online and mostly from @FMS_Cats\n\tShader Royale 2020 work (https://www.shadertoy.com/view/wsccWj)\n\tSimple mod domain rep / with moving based on hash - linear timing\n\tfunctions which give it that spin.\n\n*/\n\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\nvoid getMouse(inout vec3 ro) {\n    float x = M.xy == vec2(0) ? 0. : -(M.y/R.y * 1. - .5) * PI;\n    float y = M.xy == vec2(0) ? 0. : (M.x/R.x * 1. - .5) * PI;\n    ro.zy *=r2(x);\n    ro.xz *=r2(y);  \n}\n\n// globals and stuff\nfloat ga1,ga2,ga3,ga4,ga5,ga6;\n\nfloat gragtail(vec3 pos, float z, int lps) {\n    float scale = 2.85;\n\n \tvec3 cxz =vec3(\n        3.45,\n        3.25,\n        3.\n    );\n\n    float r = length(pos);\n    float t = 0.0;\n    float ss= .99;\n    pos.z = abs(pos.z)-3.;\n    for (int i = 0;i<lps;i++) {\n        pos=abs(pos);\n\n        if ( pos.x- pos.y<0.) pos.yx = pos.xy;\n        if ( pos.z- pos.x<0.) pos.zx = pos.xz;\n        if ( pos.y- pos.z<0.) pos.zy = pos.yz;\n\t\t\n        pos.x=scale * pos.x-cxz.x*(scale-1.);\n        pos.y=scale * pos.y-cxz.y*(scale-.5);\n        pos.z=scale * pos.z;\n\n        if (pos.z>.0) pos.z-=cxz.z*(scale-1.5);\n\n        r =  fBox2(abs(pos.xy)-vec2(25.,10.),vec2(10., 20.));\n\t\tr = min(fBox2((pos.yz)-vec2(12.,8.),vec2(5., 3. )),r);\n        \n        ss*=1./scale;\n\n    }\n    return r*ss;\n}\n\nvec2 map (in vec3 pos, float sg) {\n\n \tvec2 res = vec2(1000.,-1.);\n\tpos.xy*=r2(T*.2);\n    \n    float k = 8.0/dot(pos,pos); \n    pos *= k;\n\n    pos.xz+= 12.5;\n    pos.z+=T*12.5;\n    float hght = 20.;\n    float size = 26.;\n    vec3 id =floor((pos + size*0.5)/size);\n    float hs = hash21(id.xz)+.1;\n\tfloat ff = (hght*hs);\n   \n    if (hs>.7) {\n        ff += ga1;\n    } else if(hs>.6) {\n        ff += ga2;\n    } else if(hs>.5) {\n        ff += ga3;\n    } else if(hs>.4){\n        ff += ga4;\n    } else if(hs>.3){\n        ff += ga5;\n    } else if(hs>.2){\n        ff += ga6;\n    } else if(hs>.1){\n    \tff += ga4-ga3;\n    } else {\n        ff += ga2-ga1;\n    } \n\n    \n    float zid = hs>.6?T*ff:-(T*ff);\n    vec3 q = pos-vec3(0.,zid, 0. );\n\n\tpMod(q,vec3(size,hght,size));\n    pModPolar(q.xz,4.);\n\tpMirrorOctant(q.zy, vec2(2.15, 3.), ff);\n\n    float d1 = gragtail(q,zid,3);\n    if(d1<res.x )  res = vec2(d1,3.);\n\n    float mul = 1.0/k;\n    res.x *=  mul / 1.36;\n \treturn res;\n}\n\nvec2 marcher(vec3 ro, vec3 rd, float sg,  int maxstep){\n\tfloat d =  .0,\n     \t  m =  -1.;\n    \tint i = 0;\n        for(i=0;i<maxstep;i++){\n        \tvec3 p = ro + rd * d;\n            vec2 t = map(p, sg);\n            if(abs(t.x)<d*MINDIST||d>MAXDIST)break;\n            d += t.x*.95;\n            m  = t.y;\n        }\n    return vec2(d,m);\n}\n\n// https://www.iquilezles.org/www/articles/normalsSDF\nvec3 getNormal(vec3 p, float t){\n    float e = t*MINDIST;\n    vec2 h = vec2(1.,-1.)*.5773;\n    return normalize( h.xyy*map( p + h.xyy*e, 0.).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e, 0.).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e, 0.).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e, 0.).x );\n}\n\n//camera setup\nvec3 camera(vec3 lp, vec3 ro, vec2 uv) {\n    vec3 f=normalize(lp-ro),\n         r=normalize(cross(vec3(0,1,0),f)),\n         u=normalize(cross(f,r)),\n         c=ro+f*.65,\n         i=c+uv.x*r+uv.y*u,\n         rd=i-ro;\n    return rd;\n}\n\n//@Shane AO\nfloat calcAO(in vec3 p, in vec3 n){\n    float sca = 2., occ = 0.;\n    for( int i = 0; i<4; i++ ){\n        float hr = float(i + 1)*.25/5.; \n        float d = map(p + n*hr, 0.).x;\n        occ += (hr - d)*sca;\n        sca *= .9;\n        if(sca>1e5) break;\n    }\n    return clamp(1. - occ, 0., 1.);\n}\n\nvec3 gethue(float a){ return .65 + .45*cos((PI2*a) + vec3(3.75,1.45, .75)); }\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n\n    // pixel screen coordinates\n    vec2 uv = (F.xy - R.xy*0.5)/R.y;\n    vec3 C = vec3(0.);\n    vec3 FC = vec3(.05);\n    \n\t// timing functions\n    float tf = mod(T*2.5,13.);\n    // move x steps in rotation\n    float t1 = linearstep(0.0, 2.0, tf);\n    float t2 = linearstep(2.0, 4.0, tf);\n    float a1 = easeInCubic(t1);\n    float a2 = easeOutCubic(t2);\n    \n    float t3 = linearstep(3.0, 5.0, tf);\n    float t4 = linearstep(5.0, 6.0, tf);\n    float a3 = easeInCubic(t3);\n    float a4 = easeOutCubic(t4);\n    \n    float t5 = linearstep(6.0, 7.0, tf);\n    float t6 = linearstep(9.0, 11.0, tf);\n    float a5 = easeInCubic(t5);\n    float a6 = easeOutCubic(t6);\n\n    float t7 = linearstep(11.0, 12.0, tf);\n    float a7 = easeInCubic(t7);\n    \n    ga1 = (a1-a3);\n    ga2 = (a2-a4);\n    ga3 = (a3-a5);\n    ga4 = (a4-a6);\n    ga5 = (a5-a7);\n    ga6 = (a6+a2);\n\n    // render scene\n    vec3 lp = vec3(0.,0.,0.);\n    vec3 ro = vec3(0.,0.,.11);\n\t//getMouse(ro);\n    vec3 rd = camera(lp,ro,uv);\n    vec2 t = marcher(ro,rd, 1., 192);\n    \n    float d = t.x,\n          m = t.y;\n    vec3 h = gethue(d*10.01);//25.\n\t// if visible \n    if(d<MAXDIST){\n    \tvec3 p = ro + rd * d;\n        vec3 nor = getNormal(p,d);\n        vec3 li =  normalize(vec3(0,1,1));\n        vec3 col = vec3(.07,.09,.08)*.1;\n        \n        //@gaz https://www.shadertoy.com/view/WsKcR1\n        col *= pow(1.-d*.1,2.); \n        col *= clamp(dot(nor,li),.3,.8);\n        col *= max(1.5+.75*nor.y,0.);\n        float rimd = pow(clamp(1.-dot(reflect(-li,nor),-rd),.0,1.),2.5);\n        col += pow(clamp(dot(reflect(normalize(p-ro),nor),li),0.,1.),1.);\n\t\t//\n        \n        float ao = calcAO(p,nor);\n        C += col * h * ao;\n        \n    } else {\n     \tC =  vec3(.6);\n    }\n\tC = mix( C, FC, 1.-exp(-100.*d*d));\n    //C = mix( C, FC, 1.-exp(-.00025*d*d));\n    O = vec4(pow(C, vec3(0.4545)),1.0);\n}\n", "name": "Image", "description": "", "type": "image"}, {"inputs": [], "outputs": [], "code": "#define PI          3.1415926\n#define r2(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n//Functions used modified from http://mercury.sexy/hg_sdf/\n\nfloat vmax(vec2 v) {  return max(v.x, v.y);  }\nfloat vmax(vec3 v) {  return max(max(v.x, v.y), v.z);  }\nfloat sgn(float x) {  return (x<0.)?-1.:1.;  }\nvec2 sgn(vec2 v)   {  return vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);  }\n\nvec3 pMod(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = 2.*PI/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*length(p);\n    if (abs(c) >= (repetitions/2.)) c = abs(c);\n    return c;\n}\nfloat pMirror (inout float p, float dist) {\n    p = abs(p)-dist;\n    return sgn(p);\n}\nvec2 pMirrorOctant (inout vec2 p, vec2 dist, float r) {\n    pMirror(p.x, dist.x);\n    pMirror(p.y, dist.y);\n    p*=r2(r);\n    if (p.y > p.x) p.xy = p.yx;\n    return sgn(p);\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\nfloat linearstep(float begin, float end, float t) {  return clamp((t - begin) / (end - begin), 0.0, 1.0);  }\nfloat easeOutCubic(float t) {  return (t = t - 1.0) * t * t + 1.0;  }\nfloat easeInCubic(float t) {  return t * t * t;  }", "name": "Common", "description": "", "type": "common"}]}